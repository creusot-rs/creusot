module M_union_find__implementation__qyi17232405883558456141__eq [#"union_find.rs" 18 8 18 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find = "union_find.rs" 17 18 17 69
  let%span sunion_find'0 = "union_find.rs" 24 8 24 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 109 22 109 66
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  let rec addr_eq (p:Opaque.ptr) (q:Opaque.ptr) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sptr] result = (addr_logic p = addr_logic q)} (! return' {result}) ]
  
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'0] addr_logic self.t_Element__0
  
  function deep_model'0 (self: t_Element) : UInt64.t =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  let rec eq[#"union_find.rs" 18 8 18 42] (self:t_Element) (other:t_Element) (return'  (x:bool))= (! bb0
    [ bb0 = s0
      [ s0 = addr_eq {self'0.t_Element__0} {other'0.t_Element__0} (fun (_ret:bool) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self'0: t_Element = self | & other'0: t_Element = other ] 
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#sunion_find] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi15934775324707434347__addr [#"union_find.rs" 33 8 33 40] (* implementation::Element<T> *)
  let%span sunion_find = "union_find.rs" 34 12 34 40
  let%span sunion_find'0 = "union_find.rs" 32 18 32 46
  let%span sunion_find'1 = "union_find.rs" 24 8 24 16
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'1] addr_logic self.t_Element__0
  
  meta "compute_max_steps" 1000000
  
  let rec addr[#"union_find.rs" 33 8 33 40] (self:t_Element) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sunion_find] deep_model self'0 ] s1 | s1 = bb1 ]  | bb1 = return''0 {_0} ]
    ) [ & _0: UInt64.t = Any.any_l () | & self'0: t_Element = self ] 
    [ return''0 (result:UInt64.t)-> {[@expl:addr ensures] [%#sunion_find'0] result = deep_model self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi10464084137166016688__clone [#"union_find.rs" 46 8 46 31] (* <implementation::Element<T> as creusot_contracts::Clone> *)
  let%span sunion_find = "union_find.rs" 44 18 44 33
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  let rec clone'[#"union_find.rs" 46 8 46 31] (self:t_Element) (return'  (x:t_Element))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- { t_Element__0 = self'0.t_Element__0 } ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0: t_Element = Any.any_l () | & self'0: t_Element = self ] 
    [ return''0 (result:t_Element)-> {[@expl:clone ensures] [%#sunion_find] self = result} (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__new [#"union_find.rs" 107 8 107 28] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 109 24 109 46
  let%span sunion_find'0 = "union_find.rs" 111 24 111 54
  let%span sunion_find'1 = "union_find.rs" 112 26 112 56
  let%span sunion_find'2 = "union_find.rs" 113 25 113 55
  let%span sunion_find'3 = "union_find.rs" 114 27 114 39
  let%span sunion_find'4 = "union_find.rs" 107 24 107 28
  let%span sunion_find'5 = "union_find.rs" 106 8 106 44
  let%span sunion_find'6 = "union_find.rs" 74 8 74 20
  let%span sunion_find'7 = "union_find.rs" 24 8 24 16
  let%span sunion_find'8 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 297 4 297 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 295 14 295 31
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 174 8 174 34
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 249 14 249 38
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 250 14 250 83
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 252 8 252 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sutil = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span sutil'1 = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'2 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use set.Fset
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_T
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'8] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'7] Map.get (view self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap'10] get_unsized self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant' (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''0 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant' x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'2 val'
    end)
  
  predicate invariant''1 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''1 x
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil'1] op <> C_None)  -> ([%#sutil'2] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'14] unwrap (get_unsized self k)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'13] forall k: UInt64.t. contains self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''3 x
  
  function ext_eq (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'4] view self = view other
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'2] ext_eq self other  -> self = other)
  && ([%#sfmap'3] (forall k: UInt64.t. get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'9] len self >= 0
  
  constant empty  : t_FMap
  
  axiom empty_spec: ([%#sfmap'5] len empty = 0) && ([%#sfmap'6] view empty = Const.const (C_None))
  
  function is_empty (self: t_FMap) : bool =
    [%#sfmap'1] ext_eq self empty
  
  let rec new (return'  (x: t_FMap))= any
    [ return''0 (result: t_FMap)-> {[%#sfmap] inv'6 result} {[%#sfmap'0] is_empty result} (! return' {result}) ]
  
  
  function index_logic (self: Map.map (Map.map t_Element t_T) bool) (a: Map.map t_Element t_T) : bool =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map (Map.map t_Element t_T) bool) : Map.map t_Element t_T
  
  axiom such_that_spec: forall p: Map.map (Map.map t_Element t_T) bool. ([%#sutil] exists x: Map.map t_Element t_T. index_logic p x)
   -> ([%#sutil'0] index_logic p (such_that p))
  
  function index_logic'0 (self: Map.map (Map.map t_Element int) bool) (a: Map.map t_Element int) : bool =
    [%#smapping] Map.get self a
  
  function such_that'0 (p: Map.map (Map.map t_Element int) bool) : Map.map t_Element int
  
  axiom such_that_spec'0: forall p: Map.map (Map.map t_Element int) bool. ([%#sutil] exists x: Map.map t_Element int. index_logic'0 p x)
   -> ([%#sutil'0] index_logic'0 p (such_that'0 p))
  
  function index_logic'1 (self: Map.map (Map.map t_Element t_Element) bool) (a: Map.map t_Element t_Element) : bool =
    [%#smapping] Map.get self a
  
  function such_that'1 (p: Map.map (Map.map t_Element t_Element) bool) : Map.map t_Element t_Element
  
  axiom such_that_spec'1: forall p: Map.map (Map.map t_Element t_Element) bool. ([%#sutil] exists x: Map.map t_Element t_Element. index_logic'1 p x)
   -> ([%#sutil'0] index_logic'1 p (such_that'1 p))
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'7] addr_logic self.t_Element__0
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'12] lookup_unsized self k
  
  function index_logic'2 [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'11] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'8] index_logic'2 self.t_UnionFind__map (deep_model e)
  
  function index_logic'3 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'4 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'5 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant''4 [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'6] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains'0 domain e  -> contains self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains'0 domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'3 self.t_UnionFind__values e
    = index_logic'3 self.t_UnionFind__values (index_logic'4 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'4 self.t_UnionFind__root_of (index_logic'4 self.t_UnionFind__root_of e)
    = index_logic'4 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains'0 domain e  -> contains'0 domain (index_logic'4 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains'0 domain e2 /\ index_logic'4 self.t_UnionFind__root_of e = index_logic'4 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'3 self.t_UnionFind__values e = v /\ index_logic'4 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'5 self.t_UnionFind__distance e < index_logic'5 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains'0 domain e
     -> 0 <= index_logic'5 self.t_UnionFind__distance e
    /\ index_logic'5 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self (index_logic'4 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant''4 x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec new'0[#"union_find.rs" 107 8 107 28] (return'  (x:t_UnionFind))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_2 <- [%#sunion_find] Fset.empty: Fset.fset t_Element ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 = new (fun (_ret: t_FMap) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_5 <- [%#sunion_find'0] such_that (fun (__0: Map.map t_Element t_T) -> true) ] s1 | s1 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &_7 <- [%#sunion_find'1] such_that'0 (fun (__0: Map.map t_Element int) -> true) ] s1 | s1 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &_9 <- [%#sunion_find'2] such_that'1 (fun (__0: Map.map t_Element t_Element) -> true) ] s1 | s1 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &_11 <- [%#sunion_find'3] 0 ] s1 | s1 = bb6 ] 
    | bb6 = s0
      [ s0 = 
        [ &_0 <- { t_UnionFind__domain = _2;
                   t_UnionFind__map = _4;
                   t_UnionFind__values = _5;
                   t_UnionFind__distance = _7;
                   t_UnionFind__root_of = _9;
                   t_UnionFind__max_depth = _11 } ]
        
        s1
      | s1 = return''0 {_0} ]
     ]
    )
    [ & _0: t_UnionFind = Any.any_l ()
    | & _2: Fset.fset t_Element = Any.any_l ()
    | & _4:  t_FMap = Any.any_l ()
    | & _5: Map.map t_Element t_T = Any.any_l ()
    | & _7: Map.map t_Element int = Any.any_l ()
    | & _9: Map.map t_Element t_Element = Any.any_l ()
    | & _11: int = Any.any_l () ]
    
    [ return''0 (result:t_UnionFind)-> {[@expl:new result type invariant] [%#sunion_find'4] inv'7 result}
      {[@expl:new ensures] [%#sunion_find'5] Fset.is_empty result.t_UnionFind__domain}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__domain [#"union_find.rs" 127 8 127 47] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 125 19 125 28
  let%span sunion_find'0 = "union_find.rs" 126 18 126 150
  let%span sunion_find'1 = "union_find.rs" 124 8 124 16
  let%span sunion_find'2 = "union_find.rs" 24 8 24 16
  let%span sunion_find'3 = "union_find.rs" 74 8 74 20
  let%span sunion_find'4 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'2] addr_logic self.t_Element__0
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'0] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'4] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'4] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'3] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'5] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  constant self  : t_UnionFind
  
  function domain [#"union_find.rs" 127 8 127 47] (self'0: t_UnionFind) : Fset.fset t_Element
  
  goal vc_domain: ([%#sunion_find] inv'7 self)
   -> (let result = self.t_UnionFind__domain in [%#sunion_find'0] forall e1: t_Element, e2: t_Element. contains result e1
  /\ contains result e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
end
module M_union_find__implementation__qyi1944850640244667852__root_of [#"union_find.rs" 138 8 138 63] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 136 19 136 28
  let%span sunion_find'0 = "union_find.rs" 137 18 137 98
  let%span sunion_find'1 = "union_find.rs" 135 8 135 16
  let%span sunion_find'2 = "union_find.rs" 74 8 74 20
  let%span sunion_find'3 = "union_find.rs" 24 8 24 16
  let%span sunion_find'4 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'3] addr_logic self.t_Element__0
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'0] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'4] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'4] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'2] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'5] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  constant self  : t_UnionFind
  
  function root_of [#"union_find.rs" 138 8 138 63] (self'0: t_UnionFind) : Map.map t_Element t_Element
  
  goal vc_root_of: ([%#sunion_find] inv'7 self)
   -> (let result = self.t_UnionFind__root_of in [%#sunion_find'0] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'1 result e = index_logic'1 result (index_logic'1 result e))
end
module M_union_find__implementation__qyi1944850640244667852__values [#"union_find.rs" 146 8 146 53] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 144 19 144 28
  let%span sunion_find'0 = "union_find.rs" 145 18 145 106
  let%span sunion_find'1 = "union_find.rs" 143 8 143 16
  let%span sunion_find'2 = "union_find.rs" 136 19 136 28
  let%span sunion_find'3 = "union_find.rs" 137 18 137 98
  let%span sunion_find'4 = "union_find.rs" 135 8 135 16
  let%span sunion_find'5 = "union_find.rs" 74 8 74 20
  let%span sunion_find'6 = "union_find.rs" 24 8 24 16
  let%span sunion_find'7 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'6] addr_logic self.t_Element__0
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'0] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'4] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'7] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'5] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'5] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'4] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'2] inv'7 self)
   -> ([%#sunion_find'3] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  constant self  : t_UnionFind
  
  function values [#"union_find.rs" 146 8 146 53] (self'0: t_UnionFind) : Map.map t_Element t_T
  
  goal vc_values: ([%#sunion_find] inv'7 self)
   -> (let result = self.t_UnionFind__values in [%#sunion_find'0] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'0 result e = index_logic'0 result (index_logic'1 (root_of self) e))
end
module M_union_find__implementation__qyi1944850640244667852__make [#"union_find.rs" 165 8 165 54] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 166 29 166 45
  let%span sunion_find'0 = "union_find.rs" 176 30 176 68
  let%span sunion_find'1 = "union_find.rs" 177 30 177 78
  let%span sunion_find'2 = "union_find.rs" 178 32 178 72
  let%span sunion_find'3 = "union_find.rs" 179 31 179 76
  let%span sunion_find'4 = "union_find.rs" 165 25 165 29
  let%span sunion_find'5 = "union_find.rs" 165 31 165 36
  let%span sunion_find'6 = "union_find.rs" 161 18 161 52
  let%span sunion_find'7 = "union_find.rs" 162 18 162 69
  let%span sunion_find'8 = "union_find.rs" 163 18 163 76
  let%span sunion_find'9 = "union_find.rs" 164 18 164 73
  let%span sunion_find'10 = "union_find.rs" 32 18 32 46
  let%span sunion_find'11 = "union_find.rs" 125 19 125 28
  let%span sunion_find'12 = "union_find.rs" 126 18 126 150
  let%span sunion_find'13 = "union_find.rs" 124 8 124 16
  let%span sunion_find'14 = "union_find.rs" 136 19 136 28
  let%span sunion_find'15 = "union_find.rs" 137 18 137 98
  let%span sunion_find'16 = "union_find.rs" 135 8 135 16
  let%span sunion_find'17 = "union_find.rs" 144 19 144 28
  let%span sunion_find'18 = "union_find.rs" 145 18 145 106
  let%span sunion_find'19 = "union_find.rs" 143 8 143 16
  let%span sunion_find'20 = "union_find.rs" 24 8 24 16
  let%span sunion_find'21 = "union_find.rs" 74 8 74 20
  let%span sunion_find'22 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 406 30 406 34
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 406 4 406 62
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 394 14 403 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 404 14 404 89
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 405 14 405 44
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 471 29 471 33
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 471 43 471 48
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 471 4 473 17
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 469 14 469 49
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 470 14 470 40
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 67 14 67 71
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 61
  let%span sfmap'15 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 66
  let%span sfmap'16 = "../../creusot-contracts/src/logic/fmap.rs" 127 8 130 9
  let%span sfmap'17 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sfmap'18 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'19 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'20 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span sutil'1 = "../../creusot-contracts/src/util.rs" 21 14 21 30
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 183 22 183 26
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 183 4 183 32
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 181 14 181 29
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 79 22 79 26
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 79 4 79 48
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 78 14 78 31
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 57 15 57 16
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 57 4 57 53
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 56 14 56 64
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 141 26 141 30
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 141 48 141 52
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 138 14 138 64
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 139 14 139 28
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span speano = "../../creusot-contracts/src/peano.rs" 47 14 47 26
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use map.Map
  use set.Fset
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  function view (self: t_PeanoInt) : int
  
  let rec new (return'  (x:t_PeanoInt))= any
    [ return''0 (result:t_PeanoInt)-> {[%#speano] view result = 0} (! return' {result}) ]
  
  
  type t_T
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type tuple  =
    { _p0: Opaque.ptr; _p1:  t_PtrOwn }
  
  predicate inv (_0: t_T)
  
  predicate inv'0 (_0: t_Content)
  
  axiom inv_axiom [@rewrite]: forall x: t_Content [inv'0 x]. inv'0 x
  = match x with
    | C_Root rank value -> inv value
    | C_Link a_0 -> true
    end
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant' (self: t_PtrOwn) =
    [%#sptr_own'6] not is_null_logic (ptr self)
  
  predicate invariant''0 (self: t_Content) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x = invariant''0 x
  
  predicate inv'2 (_0: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'2 x]. inv'2 x
  = (invariant' x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'1 val'
    end)
  
  predicate invariant''1 (self:  t_PtrOwn) =
    [%#sghost'7] inv'2 self
  
  predicate inv'3 (_0:  t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x:  t_PtrOwn [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate inv'4 (_0: tuple)
  
  axiom inv_axiom'3 [@rewrite]: forall x: tuple [inv'4 x]. inv'4 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'3 x1)
  
  function val' (self: t_PtrOwn) : t_Content
  
  let rec new'0 (v:t_Content) (return'  (x:tuple))= {[@expl:new 'v' type invariant] [%#sptr_own] inv'0 v}
    any
    [ return''0 (result:tuple)-> {[%#sptr_own'0] inv'4 result}
      {[%#sptr_own'1] ptr result._p1 = result._p0 /\ val' result._p1 = v}
      (! return' {result}) ]
  
  
  let rec into_inner (self: t_PtrOwn) (return'  (x:t_PtrOwn))= {[@expl:into_inner 'self' type invariant] [%#sghost] inv'3 self}
    any [ return''0 (result:t_PtrOwn)-> {[%#sghost'0] inv'2 result} {[%#sghost'1] result = self} (! return' {result}) ] 
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view'0 (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'18] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'0 m1 <> view'0 m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'11] Map.get (view'0 self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap'9] get_unsized self k <> C_None
  
  predicate inv'5 (_0: UInt64.t)
  
  axiom inv_axiom'4 [@rewrite]: forall x: UInt64.t [inv'5 x]. inv'5 x = true
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'2 self
  
  predicate inv'6 (_0: t_PtrOwn)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_PtrOwn [inv'6 x]. inv'6 x = invariant''2 x
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'10] unwrap (get_unsized self k)
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'17] forall k: UInt64.t. contains self k  -> inv'5 k /\ inv'6 (lookup_unsized self k)
  
  predicate inv'7 (_0: t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_FMap [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost'7] inv'7 self
  
  predicate inv'8 (_0:  t_FMap)
  
  axiom inv_axiom'7 [@rewrite]: forall x:  t_FMap [inv'8 x]. inv'8 x = invariant''4 x
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate invariant''5 (self: MutBorrow.t ( t_FMap)) =
    [%#sinvariant] inv'8 self.current /\ inv'8 self.final
  
  predicate inv'9 (_0: MutBorrow.t ( t_FMap))
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t ( t_FMap) [inv'9 x]. inv'9 x = invariant''5 x
  
  predicate invariant''6 (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'10 x]. inv'10 x = invariant''6 x
  
  let rec deref_mut (self:MutBorrow.t ( t_FMap)) (return'  (x:MutBorrow.t t_FMap))= {[@expl:deref_mut 'self' type invariant] [%#sghost'2] inv'9 self}
    any
    [ return''0 (result:MutBorrow.t t_FMap)-> {[%#sghost'3] inv'10 result}
      {[%#sghost'4] result.current = self.current}
      {[%#sghost'5] result.final = self.final}
      (! return' {result}) ]
  
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'20] addr_logic self.t_Element__0
  
  let rec addr (self:t_Element) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sunion_find'10] result = deep_model self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''7 (self: MutBorrow.t t_PtrOwn) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'11 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'11 x]. inv'11 x = invariant''7 x
  
  predicate inv'12 (_0: t_Option'0)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'0 [inv'12 x]. inv'12 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'11 a_0
    end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'12] len self >= 0
  
  let rec get_mut_ghost (self:MutBorrow.t t_FMap) (key:UInt64.t) (return'  (x:t_Option'0))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap] inv'10 self}
    any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'0] inv'12 result}
      {[%#sfmap'1] if contains self.current key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> contains self.final key
          /\ lookup_unsized self.current key = r.current /\ lookup_unsized self.final key = r.final
          end
      else
        result = C_None'0 /\ self.current = self.final
      }
      {[%#sfmap'2] forall k: UInt64.t. k <> key  -> get_unsized self.current k = get_unsized self.final k}
      {[%#sfmap'3] len self.current = len self.final}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option'0) (ret  (field_0:MutBorrow.t t_PtrOwn))= any
    [ good (field_0:MutBorrow.t t_PtrOwn)-> {C_Some'0 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t t_PtrOwn [C_Some'0 field_0: t_Option'0]. C_Some'0 field_0 <> input}
      (! {false}
      any) ]
  
  
  predicate invariant''8 (self: t_PtrOwn) =
    [%#sinvariant'0] inv'2 self
  
  predicate inv'13 (_0: t_PtrOwn)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_PtrOwn [inv'13 x]. inv'13 x = invariant''8 x
  
  let rec disjoint_lemma (own1:MutBorrow.t t_PtrOwn) (own2:t_PtrOwn) (return'  (x:()))= {[@expl:disjoint_lemma 'own1' type invariant] [%#sptr_own'2] inv'11 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] [%#sptr_own'3] inv'13 own2}
    any
    [ return''0 (result:())-> {[%#sptr_own'4] addr_logic (ptr own1.current) <> addr_logic (ptr own2)}
      {[%#sptr_own'5] own1.current = own1.final}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_PtrOwn) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_PtrOwn) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_FMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_FMap) =
    resolve'1 _0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_PtrOwn
  
  predicate inv'14 (_0: t_Option'1)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Option'1 [inv'14 x]. inv'14 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'2 a_0
    end
  
  function make_sized (self: t_PtrOwn) : t_PtrOwn
  
  axiom make_sized_spec: forall self: t_PtrOwn. [%#sutil'1] make_sized self = self
  
  function insert (self: t_FMap) (k: UInt64.t) (v: t_PtrOwn) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: UInt64.t, v: t_PtrOwn. ([%#sfmap'13] view'0 (insert self k v)
  = Map.set (view'0 self) k (C_Some (make_sized v)))
  && ([%#sfmap'14] contains self k  -> len (insert self k v) = len self)
  && ([%#sfmap'15] not contains self k  -> len (insert self k v) = len self + 1)
  
  function get [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option'1 =
    [%#sfmap'16] match get_unsized self k with
      | C_None -> C_None'1
      | C_Some x -> C_Some'1 x
      end
  
  let rec insert_ghost (self:MutBorrow.t t_FMap) (key:UInt64.t) (value:t_PtrOwn) (return'  (x:t_Option'1))= {[@expl:insert_ghost 'self' type invariant] [%#sfmap'4] inv'10 self}
    {[@expl:insert_ghost 'value' type invariant] [%#sfmap'5] inv'2 value}
    any
    [ return''0 (result:t_Option'1)-> {[%#sfmap'6] inv'14 result}
      {[%#sfmap'7] self.final = insert self.current key value}
      {[%#sfmap'8] result = get self.current key}
      (! return' {result}) ]
  
  
  predicate resolve'3 (_0: t_PtrOwn) =
    true
  
  predicate resolve'4 (self: t_Option'1) =
    [%#sresolve'0] match self with
      | C_Some'1 x -> resolve'3 x
      | C_None'1 -> true
      end
  
  predicate resolve'5 (_0: t_Option'1) =
    resolve'4 _0
  
  function insert'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element =
    [%#sfset] Fset.add e self
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset'0] Fset.mem e self
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'20] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'19] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'22] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant''9 [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'21] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains'0 domain e  -> contains self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains'0 domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains'0 domain e  -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains'0 domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv'15 (_0: t_UnionFind)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_UnionFind [inv'15 x]. inv'15 x
  = (invariant''9 x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'8 map
    end)
  
  predicate invariant''10 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'15 self.current /\ inv'15 self.final
  
  predicate inv'16 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'16 x]. inv'16 x = invariant''10 x
  
  predicate resolve'6 (self: MutBorrow.t t_UnionFind) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_UnionFind) =
    resolve'6 _0
  
  let rec new'1 (x:()) (return'  (x'0: ()))= any
    [ return''0 (result: ())-> {[%#sghost'6] result = x} (! return' {result}) ]
  
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'13] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'11] inv'15 self)
   -> ([%#sunion_find'12] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
  /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'16] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'14] inv'15 self)
   -> ([%#sunion_find'15] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'19] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'17] inv'15 self)
   -> ([%#sunion_find'18] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec make[#"union_find.rs" 165 8 165 54] (self:MutBorrow.t t_UnionFind) (value:t_T) (return'  (x:t_Element))= {[@expl:make 'self' type invariant] [%#sunion_find'4] inv'16 self}
    {[@expl:make 'value' type invariant] [%#sunion_find'5] inv value}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &value_snap <- [%#sunion_find] value'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = new (fun (_ret:t_PeanoInt) ->  [ &_13 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &_12 <- C_Root _13 value'0 ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new'0 {_12} (fun (_ret:tuple) ->  [ &_11 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &ptr'0 <- _11._p0 ] s1
      | s1 =  [ &perm <- _11._p1 ] s2
      | s2 =  [ &element <- { t_Element__0 = ptr'0 } ] s3
      | s3 = into_inner {perm} (fun (_ret:t_PtrOwn) ->  [ &perm'0 <- _ret ] s4)
      | s4 = bb6 ]
    
    | bb6 = s0
      [ s0 = {inv'8 (self'0.current).t_UnionFind__map}
        MutBorrow.borrow_mut < t_FMap> {(self'0.current).t_UnionFind__map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->
             [ &_25 <- _ret ] 
            -{inv'8 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__map = _ret.final } } ] 
            s1)
      | s1 = deref_mut {_25} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_24 <- _ret ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0 [ s0 = addr {element} (fun (_ret:UInt64.t) ->  [ &_28 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 =  [ &_27 <- _28 ] s1
      | s1 = {inv'7 _24.current}
        MutBorrow.borrow_final <t_FMap> {_24.current} {MutBorrow.get_id _24}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_23 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_24 <- { _24 with current = _ret.final } ] 
            s2)
      | s2 = get_mut_ghost {_23} {_27} (fun (_ret:t_Option'0) ->  [ &_22 <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = any [ br0 -> {_22 = C_None'0} (! bb11) | br1 (x0:MutBorrow.t t_PtrOwn)-> {_22 = C_Some'0 x0} (! bb12) ] 
    | bb12 = s0
      [ s0 = v_Some {_22} (fun (r0:MutBorrow.t t_PtrOwn) ->  [ &other_perm <- r0 ] s1)
      | s1 =  [ &_34 <- perm'0 ] s2
      | s2 = {inv'2 other_perm.current}
        MutBorrow.borrow_final <t_PtrOwn> {other_perm.current} {MutBorrow.get_id other_perm}
          (fun (_ret:MutBorrow.t t_PtrOwn) ->
             [ &_32 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &other_perm <- { other_perm with current = _ret.final } ] 
            s3)
      | s3 = disjoint_lemma {_32} {_34} (fun (_ret:()) ->  [ &_21 <- _ret ] s4)
      | s4 = bb14 ]
    
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv'11 other_perm} s1
      | s1 = -{resolve'0 other_perm}- s2
      | s2 = {[@expl:type invariant] inv'10 _24} s3
      | s3 = -{resolve'2 _24}- s4
      | s4 = bb15 ]
    
    | bb11 = bb13
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'10 _24} s1 | s1 = -{resolve'2 _24}- s2 | s2 = bb15 ] 
    | bb15 = s0
      [ s0 = {inv'8 (self'0.current).t_UnionFind__map}
        MutBorrow.borrow_final
          < t_FMap>
          {(self'0.current).t_UnionFind__map}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->
             [ &_38 <- _ret ] 
            -{inv'8 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__map = _ret.final } } ] 
            s1)
      | s1 = deref_mut {_38} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_37 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = addr {element} (fun (_ret:UInt64.t) ->  [ &_39 <- _ret ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 = {inv'7 _37.current}
        MutBorrow.borrow_final <t_FMap> {_37.current} {MutBorrow.get_id _37}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_36 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &_37 <- { _37 with current = _ret.final } ] 
            s1)
      | s1 = insert_ghost {_36} {_39} {perm'0} (fun (_ret:t_Option'1) ->  [ &_35 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv'14 _35} s3
      | s3 = -{resolve'5 _35}- s4
      | s4 = bb18 ]
    
    | bb18 = s0 [ s0 = {[@expl:type invariant] inv'10 _37} s1 | s1 = -{resolve'2 _37}- s2 | s2 = bb19 ] 
    | bb19 = s0
      [ s0 =  [ &_42 <- [%#sunion_find'0] insert'0 (self'0.current).t_UnionFind__domain element ] s1 | s1 = bb20 ]
    
    | bb20 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__domain = _42 } } ] s1
      | s1 =  [ &_44 <- [%#sunion_find'1] Map.set (self'0.current).t_UnionFind__values element value_snap ] s2
      | s2 = bb21 ]
    
    | bb21 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__values = _44 } } ] s1
      | s1 =  [ &_46 <- [%#sunion_find'2] Map.set (self'0.current).t_UnionFind__distance element 0 ] s2
      | s2 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__distance = _46 } } ] s1
      | s1 =  [ &_48 <- [%#sunion_find'3] Map.set (self'0.current).t_UnionFind__root_of element element ] s2
      | s2 = bb23 ]
    
    | bb23 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__root_of = _48 } } ] s1
      | s1 = {[@expl:type invariant] inv'16 self'0} s2
      | s2 = -{resolve'7 self'0}- s3
      | s3 = bb24 ]
    
    | bb24 = s0 [ s0 = new'1 {_18} (fun (_ret: ()) ->  [ &_17 <- _ret ] s1) | s1 = bb25 ] 
    | bb25 = s0 [ s0 =  [ &_0 <- element ] s1 | s1 = bb26 ] 
    | bb26 = return''0 {_0} ]
    )
    [ & _0: t_Element = Any.any_l ()
    | & self'0: MutBorrow.t t_UnionFind = self
    | & value'0: t_T = value
    | & value_snap: t_T = Any.any_l ()
    | & ptr'0: Opaque.ptr = Any.any_l ()
    | & perm:  t_PtrOwn = Any.any_l ()
    | & _11: tuple = Any.any_l ()
    | & _12: t_Content = Any.any_l ()
    | & _13: t_PeanoInt = Any.any_l ()
    | & element: t_Element = Any.any_l ()
    | & _17:  () = Any.any_l ()
    | & _18: () = Any.any_l ()
    | & perm'0: t_PtrOwn = Any.any_l ()
    | & _21: () = Any.any_l ()
    | & _22: t_Option'0 = Any.any_l ()
    | & _23: MutBorrow.t t_FMap = Any.any_l ()
    | & _24: MutBorrow.t t_FMap = Any.any_l ()
    | & _25: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _27: UInt64.t = Any.any_l ()
    | & _28: UInt64.t = Any.any_l ()
    | & other_perm: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _32: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _34: t_PtrOwn = Any.any_l ()
    | & _35: t_Option'1 = Any.any_l ()
    | & _36: MutBorrow.t t_FMap = Any.any_l ()
    | & _37: MutBorrow.t t_FMap = Any.any_l ()
    | & _38: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _39: UInt64.t = Any.any_l ()
    | & _42: Fset.fset t_Element = Any.any_l ()
    | & _44: Map.map t_Element t_T = Any.any_l ()
    | & _46: Map.map t_Element int = Any.any_l ()
    | & _48: Map.map t_Element t_Element = Any.any_l () ]
    
    [ return''0 (result:t_Element)-> {[@expl:make ensures #0] [%#sunion_find'6] not contains'0 (domain self.current) result}
      {[@expl:make ensures #1] [%#sunion_find'7] domain self.final = insert'0 (domain self.current) result}
      {[@expl:make ensures #2] [%#sunion_find'8] root_of self.final = Map.set (root_of self.current) result result}
      {[@expl:make ensures #3] [%#sunion_find'9] values self.final = Map.set (values self.current) result value}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find_inner [#"union_find.rs" 191 8 191 64] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 191 27 191 31
  let%span sunion_find'0 = "union_find.rs" 185 19 185 47
  let%span sunion_find'1 = "union_find.rs" 186 18 186 48
  let%span sunion_find'2 = "union_find.rs" 187 18 187 34
  let%span sunion_find'3 = "union_find.rs" 189 18 189 54
  let%span sunion_find'4 = "union_find.rs" 190 18 190 62
  let%span sunion_find'5 = "union_find.rs" 32 18 32 46
  let%span sunion_find'6 = "union_find.rs" 125 19 125 28
  let%span sunion_find'7 = "union_find.rs" 126 18 126 150
  let%span sunion_find'8 = "union_find.rs" 124 8 124 16
  let%span sunion_find'9 = "union_find.rs" 136 19 136 28
  let%span sunion_find'10 = "union_find.rs" 137 18 137 98
  let%span sunion_find'11 = "union_find.rs" 135 8 135 16
  let%span sunion_find'12 = "union_find.rs" 155 16 157 52
  let%span sunion_find'13 = "union_find.rs" 24 8 24 16
  let%span sunion_find'14 = "union_find.rs" 144 19 144 28
  let%span sunion_find'15 = "union_find.rs" 145 18 145 106
  let%span sunion_find'16 = "union_find.rs" 143 8 143 16
  let%span sunion_find'17 = "union_find.rs" 74 8 74 20
  let%span sunion_find'18 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 372 22 372 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 372 4 372 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 364 14 371 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 406 30 406 34
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 406 4 406 62
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 394 14 403 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 404 14 404 89
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 405 14 405 44
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 68 14 68 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 68 4 68 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 67 14 67 43
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 79 22 79 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 79 4 79 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 78 14 78 31
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 83 41 83 44
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 80 15 80 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 83 4 83 70
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 81 14 81 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 102 41 102 44
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 97 15 97 31
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 102 4 102 78
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 98 14 98 35
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 100 14 100 53
  let%span sptr_own'8 = "../../creusot-contracts/src/ptr_own.rs" 101 14 101 52
  let%span sptr_own'9 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 150 16 150 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 151 27 151 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 152 26 152 46
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'12] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'9] Map.get (view self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap'7] get_unsized self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant' (self: t_PtrOwn) =
    [%#sptr_own'9] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''0 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant' x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'2 val'
    end)
  
  predicate invariant''1 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''1 x
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'8] unwrap (get_unsized self k)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'11] forall k: UInt64.t. contains self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 (self:  t_FMap) =
    [%#sghost'9] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sinvariant'0] inv'6 self
  
  predicate inv'7 (_0:  t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x:  t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_FMap) =
    [%#sinvariant'0] inv'5 self
  
  predicate inv'8 (_0: t_FMap)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_FMap [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec deref (self: t_FMap) (return'  (x:t_FMap))= {[@expl:deref 'self' type invariant] [%#sghost] inv'7 self}
    any [ return''0 (result:t_FMap)-> {[%#sghost'0] inv'8 result} {[%#sghost'1] self = result} (! return' {result}) ] 
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'13] addr_logic self.t_Element__0
  
  let rec addr (self:t_Element) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sunion_find'5] result = deep_model self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn
  
  predicate invariant''6 (self: t_PtrOwn) =
    [%#sinvariant'0] inv'3 self
  
  predicate inv'9 (_0: t_PtrOwn)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PtrOwn [inv'9 x]. inv'9 x = invariant''6 x
  
  predicate inv'10 (_0: t_Option'0)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Option'0 [inv'10 x]. inv'10 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'9 a_0
    end
  
  let rec get_ghost (self:t_FMap) (key:UInt64.t) (return'  (x:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'8 self}
    any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'0] inv'10 result}
      {[%#sfmap'1] if contains self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self_:t_Option'0) (return'  (x:t_PtrOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'10 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result:t_PtrOwn)-> {inv'9 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ] 
  
  predicate invariant''7 (self:  t_PtrOwn) =
    [%#sghost'9] inv'9 self
  
  predicate inv'11 (_0:  t_PtrOwn)
  
  axiom inv_axiom'10 [@rewrite]: forall x:  t_PtrOwn [inv'11 x]. inv'11 x = invariant''7 x
  
  let rec new (x:t_PtrOwn) (return'  (x'0: t_PtrOwn))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'9 x}
    any [ return''0 (result: t_PtrOwn)-> {[%#sghost'3] inv'11 result} {[%#sghost'4] result = x} (! return' {result}) ] 
  
  predicate invariant''8 (self: t_Content) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'12 (_0: t_Content)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Content [inv'12 x]. inv'12 x = invariant''8 x
  
  function val' (self: t_PtrOwn) : t_Content
  
  let rec as_ref (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:t_Content))= {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'11 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result:t_Content)-> {[%#sptr_own'1] inv'12 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  
  let rec v_Link (input:t_Content) (ret  (field_0:t_Element))= any
    [ good (field_0:t_Element)-> {C_Link field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Element [C_Link field_0: t_Content]. C_Link field_0 <> input} (! {false} any) ]
  
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'14] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'13] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'18] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant''9 [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'17] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains'0 domain e  -> contains self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains'0 domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains'0 domain e  -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains'0 domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv'13 (_0: t_UnionFind)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_UnionFind [inv'13 x]. inv'13 x
  = (invariant''9 x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''10 (self: MutBorrow.t ( t_FMap)) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'14 (_0: MutBorrow.t ( t_FMap))
  
  axiom inv_axiom'13 [@rewrite]: forall x: MutBorrow.t ( t_FMap) [inv'14 x]. inv'14 x = invariant''10 x
  
  predicate invariant''11 (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'15 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'15 x]. inv'15 x = invariant''11 x
  
  let rec deref_mut (self:MutBorrow.t ( t_FMap)) (return'  (x:MutBorrow.t t_FMap))= {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'14 self}
    any
    [ return''0 (result:MutBorrow.t t_FMap)-> {[%#sghost'6] inv'15 result}
      {[%#sghost'7] result.current = self.current}
      {[%#sghost'8] result.final = self.final}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''12 (self: MutBorrow.t t_PtrOwn) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'16 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'16 x]. inv'16 x = invariant''12 x
  
  predicate inv'17 (_0: t_Option'1)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Option'1 [inv'17 x]. inv'17 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'16 a_0
    end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'10] len self >= 0
  
  let rec get_mut_ghost (self:MutBorrow.t t_FMap) (key:UInt64.t) (return'  (x:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'2] inv'15 self}
    any
    [ return''0 (result:t_Option'1)-> {[%#sfmap'3] inv'17 result}
      {[%#sfmap'4] if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ lookup_unsized self.current key = r.current /\ lookup_unsized self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'5] forall k: UInt64.t. k <> key  -> get_unsized self.current k = get_unsized self.final k}
      {[%#sfmap'6] len self.current = len self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self_:t_Option'1) (return'  (x:MutBorrow.t t_PtrOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'17 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result:MutBorrow.t t_PtrOwn)-> {inv'16 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  
  predicate invariant''13 (self:  (MutBorrow.t t_PtrOwn)) =
    [%#sghost'9] inv'16 self
  
  predicate inv'18 (_0:  (MutBorrow.t t_PtrOwn))
  
  axiom inv_axiom'17 [@rewrite]: forall x:  (MutBorrow.t t_PtrOwn) [inv'18 x]. inv'18 x = invariant''13 x
  
  let rec new'0 (x:MutBorrow.t t_PtrOwn) (return'  (x'0: (MutBorrow.t t_PtrOwn)))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'16 x}
    any
    [ return''0 (result: (MutBorrow.t t_PtrOwn))-> {[%#sghost'3] inv'18 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_FMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_FMap) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_PtrOwn) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_PtrOwn) =
    resolve'1 _0
  
  predicate invariant''14 (self: MutBorrow.t t_Content) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'19 (_0: MutBorrow.t t_Content)
  
  axiom inv_axiom'18 [@rewrite]: forall x: MutBorrow.t t_Content [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec as_mut (ptr'0:Opaque.ptr) (own: (MutBorrow.t t_PtrOwn)) (return'  (x:MutBorrow.t t_Content))= {[@expl:as_mut 'own' type invariant] [%#sptr_own'3] inv'18 own}
    {[@expl:as_mut requires] [%#sptr_own'4] ptr'0 = ptr own.current}
    any
    [ return''0 (result:MutBorrow.t t_Content)-> {[%#sptr_own'5] inv'19 result}
      {[%#sptr_own'6] result.current = val' own.current}
      {[%#sptr_own'7] ptr own.final = ptr own.current}
      {[%#sptr_own'8] val' own.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self: MutBorrow.t t_Content) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Content) =
    resolve'3 _0
  
  predicate invariant''15 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'13 self.current /\ inv'13 self.final
  
  predicate inv'20 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'20 x]. inv'20 x = invariant''15 x
  
  predicate resolve'5 (self: MutBorrow.t t_UnionFind) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_UnionFind) =
    resolve'5 _0
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'8] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'6] inv'13 self)
   -> ([%#sunion_find'7] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
  /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'11] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'9] inv'13 self)
   -> ([%#sunion_find'10] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'16] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'14] inv'13 self)
   -> ([%#sunion_find'15] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  predicate unchanged [#"union_find.rs" 153 8 153 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'12] domain self.current = domain self.final
    /\ root_of self.current = root_of self.final /\ values self.current = values self.final
  
  meta "compute_max_steps" 1000000
  
  let rec find_inner[#"union_find.rs" 191 8 191 64] (self:MutBorrow.t t_UnionFind) (elem:t_Element) (return'  (x:t_Element))= {[@expl:find_inner 'self' type invariant] [%#sunion_find] inv'20 self}
    {[@expl:find_inner requires] [%#sunion_find'0] contains'0 (domain self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = deref {(self'0.current).t_UnionFind__map} (fun (_ret:t_FMap) ->  [ &_12 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = addr {elem'0} (fun (_ret:UInt64.t) ->  [ &_16 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_15 <- _16 ] s1
      | s1 = get_ghost {_12} {_15} (fun (_ret:t_Option'0) ->  [ &_10 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_10} (fun (_ret:t_PtrOwn) ->  [ &_9 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new {_9} (fun (_ret: t_PtrOwn) ->  [ &perm <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = as_ref {elem'0.t_Element__0} {perm} (fun (_ret:t_Content) ->  [ &value <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any
      [ br0 (x0:t_PeanoInt) (x1:t_T)-> {value = C_Root x0 x1} (! bb8)
      | br1 (x0:t_Element)-> {value = C_Link x0} (! bb9) ]
    
    | bb9 = s0
      [ s0 = v_Link {value} (fun (r0:t_Element) ->  [ &e <- r0 ] s1)
      | s1 = {inv'13 self'0.current}
        MutBorrow.borrow_mut <t_UnionFind> {self'0.current}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_24 <- _ret ] 
            -{inv'13 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = find_inner {_24} {e} (fun (_ret:t_Element) ->  [ &root <- _ret ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {inv'6 (self'0.current).t_UnionFind__map}
        MutBorrow.borrow_final
          < t_FMap>
          {(self'0.current).t_UnionFind__map}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->
             [ &_32 <- _ret ] 
            -{inv'6 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__map = _ret.final } } ] 
            s1)
      | s1 = deref_mut {_32} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_31 <- _ret ] s2)
      | s2 = bb12 ]
    
    | bb12 = s0 [ s0 = addr {elem'0} (fun (_ret:UInt64.t) ->  [ &_35 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_34 <- _35 ] s1
      | s1 = {inv'5 _31.current}
        MutBorrow.borrow_final <t_FMap> {_31.current} {MutBorrow.get_id _31}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_30 <- _ret ] 
            -{inv'5 _ret.final}-
             [ &_31 <- { _31 with current = _ret.final } ] 
            s2)
      | s2 = get_mut_ghost {_30} {_34} (fun (_ret:t_Option'1) ->  [ &_29 <- _ret ] s3)
      | s3 = bb14 ]
    
    | bb14 = s0 [ s0 = unwrap'1 {_29} (fun (_ret:MutBorrow.t t_PtrOwn) ->  [ &_28 <- _ret ] s1) | s1 = bb15 ] 
    | bb15 = s0
      [ s0 = {inv'3 _28.current}
        MutBorrow.borrow_final <t_PtrOwn> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret:MutBorrow.t t_PtrOwn) ->
             [ &_27 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_28 <- { _28 with current = _ret.final } ] 
            s1)
      | s1 = new'0 {_27} (fun (_ret: (MutBorrow.t t_PtrOwn)) ->  [ &mut_perm <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'15 _31} s1
      | s1 = -{resolve'0 _31}- s2
      | s2 = {[@expl:type invariant] inv'16 _28} s3
      | s3 = -{resolve'2 _28}- s4
      | s4 =  [ &_38 <- C_Link root ] s5
      | s5 = as_mut {elem'0.t_Element__0} {mut_perm} (fun (_ret:MutBorrow.t t_Content) ->  [ &_40 <- _ret ] s6)
      | s6 = bb17 ]
    
    | bb17 = bb18
    | bb18 = s0
      [ s0 = {[@expl:type invariant] match _40 with
          | {current = x} -> inv'1 x
          | _ -> true
          end}
        s1
      | s1 =  [ &_40 <- { _40 with current = _38 } ] s2
      | s2 = {[@expl:type invariant] inv'19 _40} s3
      | s3 = -{resolve'4 _40}- s4
      | s4 = {[@expl:type invariant] inv'20 self'0} s5
      | s5 = -{resolve'6 self'0}- s6
      | s6 = bb20 ]
    
    | bb20 = s0 [ s0 =  [ &_0 <- root ] s1 | s1 = bb21 ] 
    | bb8 = bb10
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'20 self'0} s1
      | s1 = -{resolve'6 self'0}- s2
      | s2 =  [ &_0 <- elem'0 ] s3
      | s3 = bb21 ]
    
    | bb21 = return''0 {_0} ]
    )
    [ & _0: t_Element = Any.any_l ()
    | & self'0: MutBorrow.t t_UnionFind = self
    | & elem'0: t_Element = elem
    | & perm:  t_PtrOwn = Any.any_l ()
    | & _9: t_PtrOwn = Any.any_l ()
    | & _10: t_Option'0 = Any.any_l ()
    | & _12: t_FMap = Any.any_l ()
    | & _15: UInt64.t = Any.any_l ()
    | & _16: UInt64.t = Any.any_l ()
    | & value: t_Content = Any.any_l ()
    | & e: t_Element = Any.any_l ()
    | & root: t_Element = Any.any_l ()
    | & _24: MutBorrow.t t_UnionFind = Any.any_l ()
    | & mut_perm:  (MutBorrow.t t_PtrOwn) = Any.any_l ()
    | & _27: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _28: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _29: t_Option'1 = Any.any_l ()
    | & _30: MutBorrow.t t_FMap = Any.any_l ()
    | & _31: MutBorrow.t t_FMap = Any.any_l ()
    | & _32: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _34: UInt64.t = Any.any_l ()
    | & _35: UInt64.t = Any.any_l ()
    | & _38: t_Content = Any.any_l ()
    | & _40: MutBorrow.t t_Content = Any.any_l () ]
    
    [ return''0 (result:t_Element)-> {[@expl:find_inner ensures #0] [%#sunion_find'1] result
      = index_logic'1 (root_of self.current) elem}
      {[@expl:find_inner ensures #1] [%#sunion_find'2] unchanged self}
      {[@expl:find_inner ensures #2] [%#sunion_find'3] (self.final).t_UnionFind__distance
      = (self.current).t_UnionFind__distance}
      {[@expl:find_inner ensures #3] [%#sunion_find'4] index_logic'2 (self.current).t_UnionFind__distance result
      >= index_logic'2 (self.current).t_UnionFind__distance elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__find [#"union_find.rs" 210 8 210 62] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 210 25 210 29
  let%span sunion_find'0 = "union_find.rs" 207 19 207 47
  let%span sunion_find'1 = "union_find.rs" 208 18 208 48
  let%span sunion_find'2 = "union_find.rs" 209 18 209 34
  let%span sunion_find'3 = "union_find.rs" 191 27 191 31
  let%span sunion_find'4 = "union_find.rs" 185 19 185 47
  let%span sunion_find'5 = "union_find.rs" 186 18 186 48
  let%span sunion_find'6 = "union_find.rs" 187 18 187 34
  let%span sunion_find'7 = "union_find.rs" 189 18 189 54
  let%span sunion_find'8 = "union_find.rs" 190 18 190 62
  let%span sunion_find'9 = "union_find.rs" 125 19 125 28
  let%span sunion_find'10 = "union_find.rs" 126 18 126 150
  let%span sunion_find'11 = "union_find.rs" 124 8 124 16
  let%span sunion_find'12 = "union_find.rs" 136 19 136 28
  let%span sunion_find'13 = "union_find.rs" 137 18 137 98
  let%span sunion_find'14 = "union_find.rs" 135 8 135 16
  let%span sunion_find'15 = "union_find.rs" 155 16 157 52
  let%span sunion_find'16 = "union_find.rs" 24 8 24 16
  let%span sunion_find'17 = "union_find.rs" 144 19 144 28
  let%span sunion_find'18 = "union_find.rs" 145 18 145 106
  let%span sunion_find'19 = "union_find.rs" 143 8 143 16
  let%span sunion_find'20 = "union_find.rs" 74 8 74 20
  let%span sunion_find'21 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'16] addr_logic self.t_Element__0
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'0] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'4] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'21] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'20] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'5] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'11] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'9] inv'7 self)
   -> ([%#sunion_find'10] forall e1: t_Element, e2: t_Element. contains (domain self) e1
  /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'14] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'12] inv'7 self)
   -> ([%#sunion_find'13] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'19] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'17] inv'7 self)
   -> ([%#sunion_find'18] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  predicate unchanged [#"union_find.rs" 153 8 153 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'15] domain self.current = domain self.final
    /\ root_of self.current = root_of self.final /\ values self.current = values self.final
  
  let rec find_inner (self:MutBorrow.t t_UnionFind) (elem:t_Element) (return'  (x:t_Element))= {[@expl:find_inner 'self' type invariant] [%#sunion_find'3] inv'8 self}
    {[@expl:find_inner requires] [%#sunion_find'4] contains (domain self.current) elem}
    any
    [ return''0 (result:t_Element)-> {[%#sunion_find'5] result = index_logic'1 (root_of self.current) elem}
      {[%#sunion_find'6] unchanged self}
      {[%#sunion_find'7] (self.final).t_UnionFind__distance = (self.current).t_UnionFind__distance}
      {[%#sunion_find'8] index_logic'2 (self.current).t_UnionFind__distance result
      >= index_logic'2 (self.current).t_UnionFind__distance elem}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_UnionFind) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_UnionFind) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec find[#"union_find.rs" 210 8 210 62] (self:MutBorrow.t t_UnionFind) (elem:t_Element) (return'  (x:t_Element))= {[@expl:find 'self' type invariant] [%#sunion_find] inv'8 self}
    {[@expl:find requires] [%#sunion_find'0] contains (domain self.current) elem}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'7 self'0.current}
        MutBorrow.borrow_final <t_UnionFind> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_6 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = find_inner {_6} {elem'0} (fun (_ret:t_Element) ->  [ &_0 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'8 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: t_Element = Any.any_l ()
    | & self'0: MutBorrow.t t_UnionFind = self
    | & elem'0: t_Element = elem
    | & _6: MutBorrow.t t_UnionFind = Any.any_l () ]
    
    [ return''0 (result:t_Element)-> {[@expl:find ensures #0] [%#sunion_find'1] result
      = index_logic'1 (root_of self.current) elem}
      {[@expl:find ensures #1] [%#sunion_find'2] unchanged self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__get [#"union_find.rs" 220 8 220 49] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 220 20 220 24
  let%span sunion_find'0 = "union_find.rs" 217 19 217 47
  let%span sunion_find'1 = "union_find.rs" 218 19 218 47
  let%span sunion_find'2 = "union_find.rs" 220 47 220 49
  let%span sunion_find'3 = "union_find.rs" 219 18 219 48
  let%span sunion_find'4 = "union_find.rs" 32 18 32 46
  let%span sunion_find'5 = "union_find.rs" 125 19 125 28
  let%span sunion_find'6 = "union_find.rs" 126 18 126 150
  let%span sunion_find'7 = "union_find.rs" 124 8 124 16
  let%span sunion_find'8 = "union_find.rs" 136 19 136 28
  let%span sunion_find'9 = "union_find.rs" 137 18 137 98
  let%span sunion_find'10 = "union_find.rs" 135 8 135 16
  let%span sunion_find'11 = "union_find.rs" 144 19 144 28
  let%span sunion_find'12 = "union_find.rs" 145 18 145 106
  let%span sunion_find'13 = "union_find.rs" 143 8 143 16
  let%span sunion_find'14 = "union_find.rs" 24 8 24 16
  let%span sunion_find'15 = "union_find.rs" 74 8 74 20
  let%span sunion_find'16 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 372 22 372 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 372 4 372 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 364 14 371 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 68 14 68 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 68 4 68 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 67 14 67 43
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 83 41 83 44
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 80 15 80 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 83 4 83 70
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 81 14 81 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 150 16 150 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 151 27 151 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 152 26 152 46
  
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'5] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'4] Map.get (view self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap'2] get_unsized self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant' (self: t_PtrOwn) =
    [%#sptr_own'3] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''0 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant' x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'2 val'
    end)
  
  predicate invariant''1 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''1 x
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] unwrap (get_unsized self k)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap'7] forall k: UInt64.t. contains self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''2 x
  
  predicate invariant''3 (self:  t_FMap) =
    [%#sghost'5] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sinvariant] inv'6 self
  
  predicate inv'7 (_0:  t_FMap)
  
  axiom inv_axiom'6 [@rewrite]: forall x:  t_FMap [inv'7 x]. inv'7 x = invariant''4 x
  
  predicate invariant''5 (self: t_FMap) =
    [%#sinvariant] inv'5 self
  
  predicate inv'8 (_0: t_FMap)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_FMap [inv'8 x]. inv'8 x = invariant''5 x
  
  let rec deref (self: t_FMap) (return'  (x:t_FMap))= {[@expl:deref 'self' type invariant] [%#sghost] inv'7 self}
    any [ return''0 (result:t_FMap)-> {[%#sghost'0] inv'8 result} {[%#sghost'1] self = result} (! return' {result}) ] 
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'14] addr_logic self.t_Element__0
  
  let rec addr (self:t_Element) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sunion_find'4] result = deep_model self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn
  
  predicate invariant''6 (self: t_PtrOwn) =
    [%#sinvariant] inv'3 self
  
  predicate inv'9 (_0: t_PtrOwn)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_PtrOwn [inv'9 x]. inv'9 x = invariant''6 x
  
  predicate inv'10 (_0: t_Option'0)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Option'0 [inv'10 x]. inv'10 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'9 a_0
    end
  
  let rec get_ghost (self:t_FMap) (key:UInt64.t) (return'  (x:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'8 self}
    any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'0] inv'10 result}
      {[%#sfmap'1] if contains self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self_:t_Option'0) (return'  (x:t_PtrOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'10 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result:t_PtrOwn)-> {inv'9 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ] 
  
  predicate invariant''7 (self:  t_PtrOwn) =
    [%#sghost'5] inv'9 self
  
  predicate inv'11 (_0:  t_PtrOwn)
  
  axiom inv_axiom'10 [@rewrite]: forall x:  t_PtrOwn [inv'11 x]. inv'11 x = invariant''7 x
  
  let rec new (x:t_PtrOwn) (return'  (x'0: t_PtrOwn))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'9 x}
    any [ return''0 (result: t_PtrOwn)-> {[%#sghost'3] inv'11 result} {[%#sghost'4] result = x} (! return' {result}) ] 
  
  predicate invariant''8 (self: t_Content) =
    [%#sinvariant] inv'1 self
  
  predicate inv'12 (_0: t_Content)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Content [inv'12 x]. inv'12 x = invariant''8 x
  
  function val' (self: t_PtrOwn) : t_Content
  
  let rec as_ref (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:t_Content))= {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'11 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result:t_Content)-> {[%#sptr_own'1] inv'12 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  
  let rec v_Root (input:t_Content) (ret  (rank:t_PeanoInt) (value:t_T))= any
    [ good (rank:t_PeanoInt) (value:t_T)-> {C_Root rank value = input} (! ret {rank} {value})
    | bad -> {forall rank: t_PeanoInt, value: t_T [C_Root rank value: t_Content]. C_Root rank value <> input}
      (! {false}
      any) ]
  
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'8] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'6] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'16] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant''9 [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'15] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains'0 domain e1
    /\ contains'0 domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains'0 domain e  -> contains self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains'0 domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains'0 domain e  -> contains'0 domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains'0 domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains'0 domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains'0 domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv'13 (_0: t_UnionFind)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_UnionFind [inv'13 x]. inv'13 x
  = (invariant''9 x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''10 (self: t_UnionFind) =
    [%#sinvariant] inv'13 self
  
  predicate inv'14 (_0: t_UnionFind)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_UnionFind [inv'14 x]. inv'14 x = invariant''10 x
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'7] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'5] inv'13 self)
   -> ([%#sunion_find'6] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
  /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'10] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'8] inv'13 self)
   -> ([%#sunion_find'9] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  predicate invariant''11 (self: t_T) =
    [%#sinvariant] inv'0 self
  
  predicate inv'15 (_0: t_T)
  
  axiom inv_axiom'14 [@rewrite]: forall x: t_T [inv'15 x]. inv'15 x = invariant''11 x
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'13] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'11] inv'13 self)
   -> ([%#sunion_find'12] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec get[#"union_find.rs" 220 8 220 49] (self:t_UnionFind) (elem:t_Element) (return'  (x:t_T))= {[@expl:get 'self' type invariant] [%#sunion_find] inv'14 self}
    {[@expl:get requires #0] [%#sunion_find'0] contains'0 (domain self) elem}
    {[@expl:get requires #1] [%#sunion_find'1] index_logic'1 (root_of self) elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref {self'0.t_UnionFind__map} (fun (_ret:t_FMap) ->  [ &_10 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = addr {elem'0} (fun (_ret:UInt64.t) ->  [ &_14 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_13 <- _14 ] s1
      | s1 = get_ghost {_10} {_13} (fun (_ret:t_Option'0) ->  [ &_8 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap'0 {_8} (fun (_ret:t_PtrOwn) ->  [ &_7 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new {_7} (fun (_ret: t_PtrOwn) ->  [ &perm <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = as_ref {elem'0.t_Element__0} {perm} (fun (_ret:t_Content) ->  [ &_16 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any
      [ br0 (x0:t_PeanoInt) (x1:t_T)-> {_16 = C_Root x0 x1} (! bb8) | br1 (x0:t_Element)-> {_16 = C_Link x0} (! bb7) ]
    
    | bb7 = bb10
    | bb10 = bb10'0 [ bb10'0 = (! bb11) [ bb11 = bb10'0 ]  ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = v_Root {_16} (fun (rrank:t_PeanoInt) (rvalue:t_T) ->  [ &value <- rvalue ] s1)
      | s1 =  [ &_0 <- value ] s2
      | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: t_T = Any.any_l ()
    | & self'0: t_UnionFind = self
    | & elem'0: t_Element = elem
    | & perm:  t_PtrOwn = Any.any_l ()
    | & _7: t_PtrOwn = Any.any_l ()
    | & _8: t_Option'0 = Any.any_l ()
    | & _10: t_FMap = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & _16: t_Content = Any.any_l ()
    | & value: t_T = Any.any_l () ]
    
    [ return''0 (result:t_T)-> {[@expl:get result type invariant] [%#sunion_find'2] inv'15 result}
      {[@expl:get ensures] [%#sunion_find'3] result = index_logic'0 (values self) elem}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__equiv [#"union_find.rs" 233 8 233 71] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 233 26 233 30
  let%span sunion_find'0 = "union_find.rs" 229 19 229 48
  let%span sunion_find'1 = "union_find.rs" 230 19 230 48
  let%span sunion_find'2 = "union_find.rs" 231 18 231 70
  let%span sunion_find'3 = "union_find.rs" 232 18 232 34
  let%span sunion_find'4 = "union_find.rs" 210 25 210 29
  let%span sunion_find'5 = "union_find.rs" 207 19 207 47
  let%span sunion_find'6 = "union_find.rs" 208 18 208 48
  let%span sunion_find'7 = "union_find.rs" 209 18 209 34
  let%span sunion_find'8 = "union_find.rs" 125 19 125 28
  let%span sunion_find'9 = "union_find.rs" 126 18 126 150
  let%span sunion_find'10 = "union_find.rs" 124 8 124 16
  let%span sunion_find'11 = "union_find.rs" 136 19 136 28
  let%span sunion_find'12 = "union_find.rs" 137 18 137 98
  let%span sunion_find'13 = "union_find.rs" 135 8 135 16
  let%span sunion_find'14 = "union_find.rs" 155 16 157 52
  let%span sunion_find'15 = "union_find.rs" 24 8 24 16
  let%span sunion_find'16 = "union_find.rs" 144 19 144 28
  let%span sunion_find'17 = "union_find.rs" 145 18 145 106
  let%span sunion_find'18 = "union_find.rs" 143 8 143 16
  let%span sunion_find'19 = "union_find.rs" 74 8 74 20
  let%span sunion_find'20 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 109 22 109 66
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'1 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'15] addr_logic self.t_Element__0
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'0] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'4] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'20] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'19] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'1] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr'0] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'5] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'10] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'8] inv'7 self)
   -> ([%#sunion_find'9] forall e1: t_Element, e2: t_Element. contains (domain self) e1
  /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'13] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'11] inv'7 self)
   -> ([%#sunion_find'12] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'18] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'16] inv'7 self)
   -> ([%#sunion_find'17] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  predicate unchanged [#"union_find.rs" 153 8 153 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'14] domain self.current = domain self.final
    /\ root_of self.current = root_of self.final /\ values self.current = values self.final
  
  let rec find (self:MutBorrow.t t_UnionFind) (elem:t_Element) (return'  (x:t_Element))= {[@expl:find 'self' type invariant] [%#sunion_find'4] inv'8 self}
    {[@expl:find requires] [%#sunion_find'5] contains (domain self.current) elem}
    any
    [ return''0 (result:t_Element)-> {[%#sunion_find'6] result = index_logic'1 (root_of self.current) elem}
      {[%#sunion_find'7] unchanged self}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_UnionFind) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_UnionFind) =
    resolve _0
  
  let rec addr_eq (p:Opaque.ptr) (q:Opaque.ptr) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sptr] result = (addr_logic p = addr_logic q)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec equiv[#"union_find.rs" 233 8 233 71] (self:MutBorrow.t t_UnionFind) (e1:t_Element) (e2:t_Element) (return'  (x:bool))= {[@expl:equiv 'self' type invariant] [%#sunion_find] inv'8 self}
    {[@expl:equiv requires #0] [%#sunion_find'0] contains (domain self.current) e1}
    {[@expl:equiv requires #1] [%#sunion_find'1] contains (domain self.current) e2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'7 self'0.current}
        MutBorrow.borrow_mut <t_UnionFind> {self'0.current}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_9 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = find {_9} {e1'0} (fun (_ret:t_Element) ->  [ &r1 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'7 self'0.current}
        MutBorrow.borrow_final <t_UnionFind> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_12 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = find {_12} {e2'0} (fun (_ret:t_Element) ->  [ &r2 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'8 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 = addr_eq {r1.t_Element__0} {r2.t_Element__0} (fun (_ret:bool) ->  [ &_0 <- _ret ] s3)
      | s3 = bb3 ]
    
    | bb3 = return''0 {_0} ]
    )
    [ & _0: bool = Any.any_l ()
    | & self'0: MutBorrow.t t_UnionFind = self
    | & e1'0: t_Element = e1
    | & e2'0: t_Element = e2
    | & r1: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l ()
    | & r2: t_Element = Any.any_l ()
    | & _12: MutBorrow.t t_UnionFind = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:equiv ensures #0] [%#sunion_find'2] result
      = (index_logic'1 (root_of self.current) e1 = index_logic'1 (root_of self.current) e2)}
      {[@expl:equiv ensures #1] [%#sunion_find'3] unchanged self}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__link [#"union_find.rs" 270 8 270 70] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 288 20 288 93
  let%span sunion_find'0 = "union_find.rs" 290 20 290 94
  let%span sunion_find'1 = "union_find.rs" 291 33 291 63
  let%span sunion_find'2 = "union_find.rs" 293 20 293 95
  let%span sunion_find'3 = "union_find.rs" 306 20 306 93
  let%span sunion_find'4 = "union_find.rs" 308 20 308 94
  let%span sunion_find'5 = "union_find.rs" 309 33 309 63
  let%span sunion_find'6 = "union_find.rs" 311 20 311 95
  let%span sunion_find'7 = "union_find.rs" 270 21 270 25
  let%span sunion_find'8 = "union_find.rs" 249 19 249 44
  let%span sunion_find'9 = "union_find.rs" 250 19 250 41
  let%span sunion_find'10 = "union_find.rs" 251 19 251 44
  let%span sunion_find'11 = "union_find.rs" 252 19 252 41
  let%span sunion_find'12 = "union_find.rs" 253 18 253 54
  let%span sunion_find'13 = "union_find.rs" 254 18 254 82
  let%span sunion_find'14 = "union_find.rs" 255 18 255 53
  let%span sunion_find'15 = "union_find.rs" 256 18 261 13
  let%span sunion_find'16 = "union_find.rs" 263 18 268 13
  let%span sunion_find'17 = "union_find.rs" 17 18 17 69
  let%span sunion_find'18 = "union_find.rs" 32 18 32 46
  let%span sunion_find'19 = "union_find.rs" 125 19 125 28
  let%span sunion_find'20 = "union_find.rs" 126 18 126 150
  let%span sunion_find'21 = "union_find.rs" 124 8 124 16
  let%span sunion_find'22 = "union_find.rs" 136 19 136 28
  let%span sunion_find'23 = "union_find.rs" 137 18 137 98
  let%span sunion_find'24 = "union_find.rs" 135 8 135 16
  let%span sunion_find'25 = "union_find.rs" 245 12 245 50
  let%span sunion_find'26 = "union_find.rs" 144 19 144 28
  let%span sunion_find'27 = "union_find.rs" 145 18 145 106
  let%span sunion_find'28 = "union_find.rs" 143 8 143 16
  let%span sunion_find'29 = "union_find.rs" 24 8 24 16
  let%span sunion_find'30 = "union_find.rs" 74 8 74 20
  let%span sunion_find'31 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 372 22 372 26
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 372 4 372 50
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 364 14 371 9
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 406 30 406 34
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 406 4 406 62
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 394 14 403 9
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 404 14 404 89
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 405 14 405 44
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'11 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sfmap'12 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'13 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'14 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 68 14 68 18
  let%span sghost'0 = "../../creusot-contracts/src/ghost.rs" 68 4 68 36
  let%span sghost'1 = "../../creusot-contracts/src/ghost.rs" 67 14 67 43
  let%span sghost'2 = "../../creusot-contracts/src/ghost.rs" 164 15 164 16
  let%span sghost'3 = "../../creusot-contracts/src/ghost.rs" 164 4 164 28
  let%span sghost'4 = "../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sghost'5 = "../../creusot-contracts/src/ghost.rs" 79 22 79 26
  let%span sghost'6 = "../../creusot-contracts/src/ghost.rs" 79 4 79 48
  let%span sghost'7 = "../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'8 = "../../creusot-contracts/src/ghost.rs" 78 14 78 31
  let%span sghost'9 = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 83 41 83 44
  let%span sptr_own'0 = "../../creusot-contracts/src/ptr_own.rs" 80 15 80 31
  let%span sptr_own'1 = "../../creusot-contracts/src/ptr_own.rs" 83 4 83 70
  let%span sptr_own'2 = "../../creusot-contracts/src/ptr_own.rs" 81 14 81 35
  let%span sptr_own'3 = "../../creusot-contracts/src/ptr_own.rs" 102 41 102 44
  let%span sptr_own'4 = "../../creusot-contracts/src/ptr_own.rs" 97 15 97 31
  let%span sptr_own'5 = "../../creusot-contracts/src/ptr_own.rs" 102 4 102 78
  let%span sptr_own'6 = "../../creusot-contracts/src/ptr_own.rs" 98 14 98 35
  let%span sptr_own'7 = "../../creusot-contracts/src/ptr_own.rs" 100 14 100 53
  let%span sptr_own'8 = "../../creusot-contracts/src/ptr_own.rs" 101 14 101 52
  let%span sptr_own'9 = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span speano = "../../creusot-contracts/src/peano.rs" 77 14 77 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 67 14 67 38
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 150 16 150 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 151 27 151 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 152 26 152 46
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'29] addr_logic self.t_Element__0
  
  function deep_model'0 (self: t_Element) : UInt64.t =
    [%#smodel] deep_model self
  
  let rec eq (self:t_Element) (other:t_Element) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sunion_find'17] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'12] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'9] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap'7] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'8] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'14] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'13] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'31] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'30] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own'9] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'11] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost'9] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  predicate resolve (self: MutBorrow.t t_UnionFind) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_UnionFind) =
    resolve _0
  
  predicate invariant''6 (self:  t_FMap) =
    [%#sinvariant'0] inv'6 self
  
  predicate inv'9 (_0:  t_FMap)
  
  axiom inv_axiom'8 [@rewrite]: forall x:  t_FMap [inv'9 x]. inv'9 x = invariant''6 x
  
  predicate invariant''7 (self: t_FMap) =
    [%#sinvariant'0] inv'5 self
  
  predicate inv'10 (_0: t_FMap)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_FMap [inv'10 x]. inv'10 x = invariant''7 x
  
  let rec deref (self: t_FMap) (return'  (x:t_FMap))= {[@expl:deref 'self' type invariant] [%#sghost] inv'9 self}
    any [ return''0 (result:t_FMap)-> {[%#sghost'0] inv'10 result} {[%#sghost'1] self = result} (! return' {result}) ] 
  
  let rec addr (self:t_Element) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sunion_find'18] result = deep_model self} (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_PtrOwn
  
  predicate invariant''8 (self: t_PtrOwn) =
    [%#sinvariant'0] inv'3 self
  
  predicate inv'11 (_0: t_PtrOwn)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_PtrOwn [inv'11 x]. inv'11 x = invariant''8 x
  
  predicate inv'12 (_0: t_Option'0)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'0 [inv'12 x]. inv'12 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'11 a_0
    end
  
  let rec get_ghost (self:t_FMap) (key:UInt64.t) (return'  (x:t_Option'0))= {[@expl:get_ghost 'self' type invariant] [%#sfmap] inv'10 self}
    any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'0] inv'12 result}
      {[%#sfmap'1] if contains'0 self key then
        match result with
          | C_None'0 -> false
          | C_Some'0 r -> lookup_unsized self key = r
          end
      else
        result = C_None'0
      }
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self_:t_Option'0) (return'  (x:t_PtrOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'0}
    any [ return''0 (result:t_PtrOwn)-> {inv'11 result} {[%#soption'1] C_Some'0 result = self_} (! return' {result}) ] 
  
  predicate invariant''9 (self:  t_PtrOwn) =
    [%#sghost'9] inv'11 self
  
  predicate inv'13 (_0:  t_PtrOwn)
  
  axiom inv_axiom'12 [@rewrite]: forall x:  t_PtrOwn [inv'13 x]. inv'13 x = invariant''9 x
  
  let rec new (x:t_PtrOwn) (return'  (x'0: t_PtrOwn))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'11 x}
    any [ return''0 (result: t_PtrOwn)-> {[%#sghost'3] inv'13 result} {[%#sghost'4] result = x} (! return' {result}) ] 
  
  predicate invariant''10 (self: t_Content) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'14 (_0: t_Content)
  
  axiom inv_axiom'13 [@rewrite]: forall x: t_Content [inv'14 x]. inv'14 x = invariant''10 x
  
  let rec as_ref (ptr'0:Opaque.ptr) (own: t_PtrOwn) (return'  (x:t_Content))= {[@expl:as_ref 'own' type invariant] [%#sptr_own] inv'13 own}
    {[@expl:as_ref requires] [%#sptr_own'0] ptr'0 = ptr own}
    any
    [ return''0 (result:t_Content)-> {[%#sptr_own'1] inv'14 result}
      {[%#sptr_own'2] result = val' own}
      (! return' {result}) ]
  
  
  let rec v_Root (input:t_Content) (ret  (rank:t_PeanoInt) (value:t_T))= any
    [ good (rank:t_PeanoInt) (value:t_T)-> {C_Root rank value = input} (! ret {rank} {value})
    | bad -> {forall rank: t_PeanoInt, value: t_T [C_Root rank value: t_Content]. C_Root rank value <> input}
      (! {false}
      any) ]
  
  
  function view'0 (self: t_PeanoInt) : int
  
  let rec to_u64 (self:t_PeanoInt) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#speano] UInt64.t'int result = view'0 self} (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt64.t; _p1: t_T }
  
  predicate invariant''11 (self: MutBorrow.t ( t_FMap)) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'15 (_0: MutBorrow.t ( t_FMap))
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t ( t_FMap) [inv'15 x]. inv'15 x = invariant''11 x
  
  predicate invariant''12 (self: MutBorrow.t t_FMap) =
    [%#sinvariant] inv'5 self.current /\ inv'5 self.final
  
  predicate inv'16 (_0: MutBorrow.t t_FMap)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_FMap [inv'16 x]. inv'16 x = invariant''12 x
  
  let rec deref_mut (self:MutBorrow.t ( t_FMap)) (return'  (x:MutBorrow.t t_FMap))= {[@expl:deref_mut 'self' type invariant] [%#sghost'5] inv'15 self}
    any
    [ return''0 (result:MutBorrow.t t_FMap)-> {[%#sghost'6] inv'16 result}
      {[%#sghost'7] result.current = self.current}
      {[%#sghost'8] result.final = self.final}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_PtrOwn)
  
  predicate invariant''13 (self: MutBorrow.t t_PtrOwn) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'17 (_0: MutBorrow.t t_PtrOwn)
  
  axiom inv_axiom'16 [@rewrite]: forall x: MutBorrow.t t_PtrOwn [inv'17 x]. inv'17 x = invariant''13 x
  
  predicate inv'18 (_0: t_Option'1)
  
  axiom inv_axiom'17 [@rewrite]: forall x: t_Option'1 [inv'18 x]. inv'18 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'17 a_0
    end
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'10] len self >= 0
  
  let rec get_mut_ghost (self:MutBorrow.t t_FMap) (key:UInt64.t) (return'  (x:t_Option'1))= {[@expl:get_mut_ghost 'self' type invariant] [%#sfmap'2] inv'16 self}
    any
    [ return''0 (result:t_Option'1)-> {[%#sfmap'3] inv'18 result}
      {[%#sfmap'4] if contains'0 self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains'0 self.final key
          /\ lookup_unsized self.current key = r.current /\ lookup_unsized self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'5] forall k: UInt64.t. k <> key  -> get_unsized self.current k = get_unsized self.final k}
      {[%#sfmap'6] len self.current = len self.final}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self_:t_Option'1) (return'  (x:MutBorrow.t t_PtrOwn))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'18 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None'1}
    any
    [ return''0 (result:MutBorrow.t t_PtrOwn)-> {inv'17 result}
      {[%#soption'1] C_Some'1 result = self_}
      (! return' {result}) ]
  
  
  predicate invariant''14 (self:  (MutBorrow.t t_PtrOwn)) =
    [%#sghost'9] inv'17 self
  
  predicate inv'19 (_0:  (MutBorrow.t t_PtrOwn))
  
  axiom inv_axiom'18 [@rewrite]: forall x:  (MutBorrow.t t_PtrOwn) [inv'19 x]. inv'19 x = invariant''14 x
  
  let rec new'0 (x:MutBorrow.t t_PtrOwn) (return'  (x'0: (MutBorrow.t t_PtrOwn)))= {[@expl:new 'x' type invariant] [%#sghost'2] inv'17 x}
    any
    [ return''0 (result: (MutBorrow.t t_PtrOwn))-> {[%#sghost'3] inv'19 result}
      {[%#sghost'4] result = x}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_FMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_FMap) =
    resolve'1 _0
  
  predicate resolve'3 (self: MutBorrow.t t_PtrOwn) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_PtrOwn) =
    resolve'3 _0
  
  predicate invariant''15 (self: MutBorrow.t t_Content) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'20 (_0: MutBorrow.t t_Content)
  
  axiom inv_axiom'19 [@rewrite]: forall x: MutBorrow.t t_Content [inv'20 x]. inv'20 x = invariant''15 x
  
  let rec as_mut (ptr'0:Opaque.ptr) (own: (MutBorrow.t t_PtrOwn)) (return'  (x:MutBorrow.t t_Content))= {[@expl:as_mut 'own' type invariant] [%#sptr_own'3] inv'19 own}
    {[@expl:as_mut requires] [%#sptr_own'4] ptr'0 = ptr own.current}
    any
    [ return''0 (result:MutBorrow.t t_Content)-> {[%#sptr_own'5] inv'20 result}
      {[%#sptr_own'6] result.current = val' own.current}
      {[%#sptr_own'7] ptr own.final = ptr own.current}
      {[%#sptr_own'8] val' own.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve'5 (self: MutBorrow.t t_Content) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_Content) =
    resolve'5 _0
  
  let rec incr (self:MutBorrow.t t_PeanoInt) (return'  (x:()))= any
    [ return''0 (result:())-> {[%#speano'0] view'0 self.final = view'0 self.current + 1} (! return' {result}) ]
  
  
  predicate resolve'7 (self: MutBorrow.t t_PeanoInt) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'8 (_0: MutBorrow.t t_PeanoInt) =
    resolve'7 _0
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'21] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'19] inv'7 self)
   -> ([%#sunion_find'20] forall e1: t_Element, e2: t_Element. contains (domain self) e1
  /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'24] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'22] inv'7 self)
   -> ([%#sunion_find'23] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  predicate equiv_log [#"union_find.rs" 244 8 244 68] (self: t_UnionFind) (x: t_Element) (y: t_Element) =
    [%#sunion_find'25] index_logic'1 (root_of self) x = index_logic'1 (root_of self) y
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'28] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'26] inv'7 self)
   -> ([%#sunion_find'27] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  meta "compute_max_steps" 1000000
  
  let rec link[#"union_find.rs" 270 8 270 70] (self:MutBorrow.t t_UnionFind) (x:t_Element) (y:t_Element) (return'  (x'0:t_Element))= {[@expl:link 'self' type invariant] [%#sunion_find'7] inv'8 self}
    {[@expl:link requires #0] [%#sunion_find'8] contains (domain self.current) x}
    {[@expl:link requires #1] [%#sunion_find'9] index_logic'1 (root_of self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find'10] contains (domain self.current) y}
    {[@expl:link requires #3] [%#sunion_find'11] index_logic'1 (root_of self.current) y = y}
    (! bb0
    [ bb0 = s0 [ s0 = eq {x'0} {y'0} (fun (_ret:bool) ->  [ &_14 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_14 = false} (! bb3) | br1 -> {_14} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'8 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0 <- x'0 ] s3
      | s3 = bb67 ]
    
    | bb3 = s0
      [ s0 = deref {(self'0.current).t_UnionFind__map} (fun (_ret:t_FMap) ->  [ &_22 <- _ret ] s1) | s1 = bb4 ]
    
    | bb4 = s0 [ s0 = addr {x'0} (fun (_ret:UInt64.t) ->  [ &_26 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_25 <- _26 ] s1
      | s1 = get_ghost {_22} {_25} (fun (_ret:t_Option'0) ->  [ &_20 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0 [ s0 = unwrap'0 {_20} (fun (_ret:t_PtrOwn) ->  [ &_19 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0 [ s0 = new {_19} (fun (_ret: t_PtrOwn) ->  [ &perm_x <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = deref {(self'0.current).t_UnionFind__map} (fun (_ret:t_FMap) ->  [ &_32 <- _ret ] s1) | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = addr {y'0} (fun (_ret:UInt64.t) ->  [ &_36 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_35 <- _36 ] s1
      | s1 = get_ghost {_32} {_35} (fun (_ret:t_Option'0) ->  [ &_30 <- _ret ] s2)
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = unwrap'0 {_30} (fun (_ret:t_PtrOwn) ->  [ &_29 <- _ret ] s1) | s1 = bb12 ] 
    | bb12 = s0 [ s0 = new {_29} (fun (_ret: t_PtrOwn) ->  [ &perm_y <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0 [ s0 = as_ref {x'0.t_Element__0} {perm_x} (fun (_ret:t_Content) ->  [ &_41 <- _ret ] s1) | s1 = bb14 ] 
    | bb14 = any
      [ br0 (x0:t_PeanoInt) (x1:t_T)-> {_41 = C_Root x0 x1} (! bb16) | br1 (x0:t_Element)-> {_41 = C_Link x0} (! bb15) ]
    
    | bb15 = s0 [ s0 = {[@expl:type invariant] inv'8 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = {false} any ] 
    | bb16 = bb17
    | bb17 = s0
      [ s0 = v_Root {_41} (fun (rrank:t_PeanoInt) (rvalue:t_T) ->  [ &rank <- rrank ] s1)
      | s1 = v_Root {_41} (fun (rrank:t_PeanoInt) (rvalue:t_T) ->  [ &value <- rvalue ] s2)
      | s2 = to_u64 {rank} (fun (_ret:UInt64.t) ->  [ &_47 <- _ret ] s3)
      | s3 = bb18 ]
    
    | bb18 = s0
      [ s0 =  [ &_40 <- { _p0 = _47; _p1 = value } ] s1
      | s1 =  [ &rx <- _40._p0 ] s2
      | s2 =  [ &vx <- _40._p1 ] s3
      | s3 = as_ref {y'0.t_Element__0} {perm_y} (fun (_ret:t_Content) ->  [ &_54 <- _ret ] s4)
      | s4 = bb19 ]
    
    | bb19 = any
      [ br0 (x0:t_PeanoInt) (x1:t_T)-> {_54 = C_Root x0 x1} (! bb21) | br1 (x0:t_Element)-> {_54 = C_Link x0} (! bb20) ]
    
    | bb20 = s0 [ s0 = {[@expl:type invariant] inv'8 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = {false} any ] 
    | bb21 = bb22
    | bb22 = s0
      [ s0 = v_Root {_54} (fun (rrank:t_PeanoInt) (rvalue:t_T) ->  [ &rank'0 <- rrank ] s1)
      | s1 = v_Root {_54} (fun (rrank:t_PeanoInt) (rvalue:t_T) ->  [ &value'0 <- rvalue ] s2)
      | s2 = to_u64 {rank'0} (fun (_ret:UInt64.t) ->  [ &_60 <- _ret ] s3)
      | s3 = bb23 ]
    
    | bb23 = s0
      [ s0 =  [ &_53 <- { _p0 = _60; _p1 = value'0 } ] s1
      | s1 =  [ &ry <- _53._p0 ] s2
      | s2 =  [ &vy <- _53._p1 ] s3
      | s3 =  [ &_64 <- UInt64.lt rx ry ] s4
      | s4 = any [ br0 -> {_64 = false} (! bb25) | br1 -> {_64} (! bb24) ]  ]
    
    | bb24 = s0
      [ s0 = {inv'6 (self'0.current).t_UnionFind__map}
        MutBorrow.borrow_final
          < t_FMap>
          {(self'0.current).t_UnionFind__map}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->
             [ &_73 <- _ret ] 
            -{inv'6 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__map = _ret.final } } ] 
            s1)
      | s1 = deref_mut {_73} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_72 <- _ret ] s2)
      | s2 = bb26 ]
    
    | bb26 = s0 [ s0 = addr {x'0} (fun (_ret:UInt64.t) ->  [ &_76 <- _ret ] s1) | s1 = bb27 ] 
    | bb27 = s0
      [ s0 =  [ &_75 <- _76 ] s1
      | s1 = {inv'5 _72.current}
        MutBorrow.borrow_final <t_FMap> {_72.current} {MutBorrow.get_id _72}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_71 <- _ret ] 
            -{inv'5 _ret.final}-
             [ &_72 <- { _72 with current = _ret.final } ] 
            s2)
      | s2 = get_mut_ghost {_71} {_75} (fun (_ret:t_Option'1) ->  [ &_70 <- _ret ] s3)
      | s3 = bb28 ]
    
    | bb28 = s0 [ s0 = unwrap'1 {_70} (fun (_ret:MutBorrow.t t_PtrOwn) ->  [ &_69 <- _ret ] s1) | s1 = bb29 ] 
    | bb29 = s0
      [ s0 = {inv'3 _69.current}
        MutBorrow.borrow_final <t_PtrOwn> {_69.current} {MutBorrow.get_id _69}
          (fun (_ret:MutBorrow.t t_PtrOwn) ->
             [ &_68 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_69 <- { _69 with current = _ret.final } ] 
            s1)
      | s1 = new'0 {_68} (fun (_ret: (MutBorrow.t t_PtrOwn)) ->  [ &perm_mut_x <- _ret ] s2)
      | s2 = bb30 ]
    
    | bb30 = s0
      [ s0 = {[@expl:type invariant] inv'16 _72} s1
      | s1 = -{resolve'2 _72}- s2
      | s2 = {[@expl:type invariant] inv'17 _69} s3
      | s3 = -{resolve'4 _69}- s4
      | s4 =  [ &_79 <- C_Link y'0 ] s5
      | s5 = as_mut {x'0.t_Element__0} {perm_mut_x} (fun (_ret:MutBorrow.t t_Content) ->  [ &_81 <- _ret ] s6)
      | s6 = bb31 ]
    
    | bb31 = bb32
    | bb32 = s0
      [ s0 = {[@expl:type invariant] match _81 with
          | {current = x'1} -> inv'1 x'1
          | _ -> true
          end}
        s1
      | s1 =  [ &_81 <- { _81 with current = _79 } ] s2
      | s2 = {[@expl:type invariant] inv'20 _81} s3
      | s3 = -{resolve'6 _81}- s4
      | s4 = bb34 ]
    
    | bb34 = s0
      [ s0 = 
        [ &_84 <- [%#sunion_find] fun (z: t_Element) -> if index_logic'1 (self'0.current).t_UnionFind__root_of z
        = x'0 then
          y'0
        else
          index_logic'1 (self'0.current).t_UnionFind__root_of z
         ]
        
        s1
      | s1 = bb35 ]
    
    | bb35 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__root_of = _84 } } ] s1
      | s1 = 
        [ &_86 <- [%#sunion_find'0] fun (z: t_Element) -> if index_logic'1 (self'0.current).t_UnionFind__root_of z
        = y'0 then
          vy
        else
          index_logic'0 (self'0.current).t_UnionFind__values z
         ]
        
        s2
      | s2 = bb36 ]
    
    | bb36 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__values = _86 } } ] s1
      | s1 =  [ &_88 <- [%#sunion_find'1] (self'0.current).t_UnionFind__max_depth + 1 ] s2
      | s2 = bb37 ]
    
    | bb37 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__max_depth = _88 } } ] s1
      | s1 = 
        [ &_90 <- [%#sunion_find'2] Map.set (self'0.current).t_UnionFind__distance y'0 (1
        + MinMax.max (index_logic'2 (self'0.current).t_UnionFind__distance x'0) (index_logic'2 (self'0.current).t_UnionFind__distance y'0)) ]
        
        s2
      | s2 = bb38 ]
    
    | bb38 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__distance = _90 } } ] s1
      | s1 = {[@expl:type invariant] inv'8 self'0} s2
      | s2 = -{resolve'0 self'0}- s3
      | s3 =  [ &_0 <- y'0 ] s4
      | s4 = bb66 ]
    
    | bb25 = s0
      [ s0 = {inv'6 (self'0.current).t_UnionFind__map}
        MutBorrow.borrow_mut < t_FMap> {(self'0.current).t_UnionFind__map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->
             [ &_98 <- _ret ] 
            -{inv'6 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__map = _ret.final } } ] 
            s1)
      | s1 = deref_mut {_98} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_97 <- _ret ] s2)
      | s2 = bb39 ]
    
    | bb39 = s0 [ s0 = addr {y'0} (fun (_ret:UInt64.t) ->  [ &_101 <- _ret ] s1) | s1 = bb40 ] 
    | bb40 = s0
      [ s0 =  [ &_100 <- _101 ] s1
      | s1 = {inv'5 _97.current}
        MutBorrow.borrow_final <t_FMap> {_97.current} {MutBorrow.get_id _97}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_96 <- _ret ] 
            -{inv'5 _ret.final}-
             [ &_97 <- { _97 with current = _ret.final } ] 
            s2)
      | s2 = get_mut_ghost {_96} {_100} (fun (_ret:t_Option'1) ->  [ &_95 <- _ret ] s3)
      | s3 = bb41 ]
    
    | bb41 = s0 [ s0 = unwrap'1 {_95} (fun (_ret:MutBorrow.t t_PtrOwn) ->  [ &_94 <- _ret ] s1) | s1 = bb42 ] 
    | bb42 = s0
      [ s0 = {inv'3 _94.current}
        MutBorrow.borrow_final <t_PtrOwn> {_94.current} {MutBorrow.get_id _94}
          (fun (_ret:MutBorrow.t t_PtrOwn) ->
             [ &_93 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_94 <- { _94 with current = _ret.final } ] 
            s1)
      | s1 = new'0 {_93} (fun (_ret: (MutBorrow.t t_PtrOwn)) ->  [ &perm_mut_y <- _ret ] s2)
      | s2 = bb43 ]
    
    | bb43 = s0
      [ s0 = {[@expl:type invariant] inv'16 _97} s1
      | s1 = -{resolve'2 _97}- s2
      | s2 = {[@expl:type invariant] inv'17 _94} s3
      | s3 = -{resolve'4 _94}- s4
      | s4 =  [ &_104 <- C_Link x'0 ] s5
      | s5 = as_mut {y'0.t_Element__0} {perm_mut_y} (fun (_ret:MutBorrow.t t_Content) ->  [ &_106 <- _ret ] s6)
      | s6 = bb44 ]
    
    | bb44 = bb45
    | bb45 = s0
      [ s0 = {[@expl:type invariant] match _106 with
          | {current = x'1} -> inv'1 x'1
          | _ -> true
          end}
        s1
      | s1 =  [ &_106 <- { _106 with current = _104 } ] s2
      | s2 = {[@expl:type invariant] inv'20 _106} s3
      | s3 = -{resolve'6 _106}- s4
      | s4 = bb47 ]
    
    | bb47 = s0
      [ s0 =  [ &_110 <- rx = ry ] s1 | s1 = any [ br0 -> {_110 = false} (! bb60) | br1 -> {_110} (! bb48) ]  ]
    
    | bb48 = s0
      [ s0 = {inv'6 (self'0.current).t_UnionFind__map}
        MutBorrow.borrow_final
          < t_FMap>
          {(self'0.current).t_UnionFind__map}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->
             [ &_119 <- _ret ] 
            -{inv'6 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__map = _ret.final } } ] 
            s1)
      | s1 = deref_mut {_119} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_118 <- _ret ] s2)
      | s2 = bb49 ]
    
    | bb49 = s0 [ s0 = addr {x'0} (fun (_ret:UInt64.t) ->  [ &_122 <- _ret ] s1) | s1 = bb50 ] 
    | bb50 = s0
      [ s0 =  [ &_121 <- _122 ] s1
      | s1 = {inv'5 _118.current}
        MutBorrow.borrow_final <t_FMap> {_118.current} {MutBorrow.get_id _118}
          (fun (_ret:MutBorrow.t t_FMap) ->
             [ &_117 <- _ret ] 
            -{inv'5 _ret.final}-
             [ &_118 <- { _118 with current = _ret.final } ] 
            s2)
      | s2 = get_mut_ghost {_117} {_121} (fun (_ret:t_Option'1) ->  [ &_116 <- _ret ] s3)
      | s3 = bb51 ]
    
    | bb51 = s0 [ s0 = unwrap'1 {_116} (fun (_ret:MutBorrow.t t_PtrOwn) ->  [ &_115 <- _ret ] s1) | s1 = bb52 ] 
    | bb52 = s0
      [ s0 = {inv'3 _115.current}
        MutBorrow.borrow_final <t_PtrOwn> {_115.current} {MutBorrow.get_id _115}
          (fun (_ret:MutBorrow.t t_PtrOwn) ->
             [ &_114 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_115 <- { _115 with current = _ret.final } ] 
            s1)
      | s1 = new'0 {_114} (fun (_ret: (MutBorrow.t t_PtrOwn)) ->  [ &perm_mut_x'0 <- _ret ] s2)
      | s2 = bb53 ]
    
    | bb53 = s0
      [ s0 = {[@expl:type invariant] inv'16 _118} s1
      | s1 = -{resolve'2 _118}- s2
      | s2 = {[@expl:type invariant] inv'17 _115} s3
      | s3 = -{resolve'4 _115}- s4
      | s4 = as_mut {x'0.t_Element__0} {perm_mut_x'0} (fun (_ret:MutBorrow.t t_Content) ->  [ &_124 <- _ret ] s5)
      | s5 = bb54 ]
    
    | bb54 = any
      [ br0 (x0:t_PeanoInt) (x1:t_T)-> {_124.current = C_Root x0 x1} (! bb56)
      | br1 (x0:t_Element)-> {_124.current = C_Link x0} (! bb55) ]
    
    | bb55 = s0 [ s0 = {[@expl:type invariant] inv'20 _124} s1 | s1 = -{resolve'6 _124}- s2 | s2 = bb59 ] 
    | bb56 = bb57
    | bb57 = s0
      [ s0 = v_Root {_124.current}
          (fun (rrank:t_PeanoInt) (rvalue:t_T) ->
            MutBorrow.borrow_final <t_PeanoInt> {rrank} {MutBorrow.inherit_id (MutBorrow.get_id _124) 1}
              (fun (_ret:MutBorrow.t t_PeanoInt) ->
                 [ &rank'1 <- _ret ] 
                 [ &_124 <- { _124 with current = C_Root _ret.final rvalue } ] 
                s1))
      | s1 = MutBorrow.borrow_final <t_PeanoInt> {rank'1.current} {MutBorrow.get_id rank'1}
          (fun (_ret:MutBorrow.t t_PeanoInt) ->
             [ &_129 <- _ret ] 
             [ &rank'1 <- { rank'1 with current = _ret.final } ] 
            s2)
      | s2 = incr {_129} (fun (_ret:()) ->  [ &_109 <- _ret ] s3)
      | s3 = bb58 ]
    
    | bb58 = s0
      [ s0 = -{resolve'8 rank'1}- s1
      | s1 = {[@expl:type invariant] inv'20 _124} s2
      | s2 = -{resolve'6 _124}- s3
      | s3 = bb59 ]
    
    | bb59 = bb61
    | bb60 = bb61
    | bb61 = s0
      [ s0 = 
        [ &_130 <- [%#sunion_find'3] fun (z: t_Element) -> if index_logic'1 (self'0.current).t_UnionFind__root_of z
        = y'0 then
          x'0
        else
          index_logic'1 (self'0.current).t_UnionFind__root_of z
         ]
        
        s1
      | s1 = bb62 ]
    
    | bb62 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__root_of = _130 } } ] s1
      | s1 = 
        [ &_132 <- [%#sunion_find'4] fun (z: t_Element) -> if index_logic'1 (self'0.current).t_UnionFind__root_of z
        = x'0 then
          vx
        else
          index_logic'0 (self'0.current).t_UnionFind__values z
         ]
        
        s2
      | s2 = bb63 ]
    
    | bb63 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__values = _132 } } ] s1
      | s1 =  [ &_134 <- [%#sunion_find'5] (self'0.current).t_UnionFind__max_depth + 1 ] s2
      | s2 = bb64 ]
    
    | bb64 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__max_depth = _134 } } ] s1
      | s1 = 
        [ &_136 <- [%#sunion_find'6] Map.set (self'0.current).t_UnionFind__distance x'0 (1
        + MinMax.max (index_logic'2 (self'0.current).t_UnionFind__distance x'0) (index_logic'2 (self'0.current).t_UnionFind__distance y'0)) ]
        
        s2
      | s2 = bb65 ]
    
    | bb65 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_UnionFind__distance = _136 } } ] s1
      | s1 = {[@expl:type invariant] inv'8 self'0} s2
      | s2 = -{resolve'0 self'0}- s3
      | s3 =  [ &_0 <- x'0 ] s4
      | s4 = bb66 ]
    
    | bb66 = bb67
    | bb67 = return''0 {_0} ]
    )
    [ & _0: t_Element = Any.any_l ()
    | & self'0: MutBorrow.t t_UnionFind = self
    | & x'0: t_Element = x
    | & y'0: t_Element = y
    | & _14: bool = Any.any_l ()
    | & perm_x:  t_PtrOwn = Any.any_l ()
    | & _19: t_PtrOwn = Any.any_l ()
    | & _20: t_Option'0 = Any.any_l ()
    | & _22: t_FMap = Any.any_l ()
    | & _25: UInt64.t = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & perm_y:  t_PtrOwn = Any.any_l ()
    | & _29: t_PtrOwn = Any.any_l ()
    | & _30: t_Option'0 = Any.any_l ()
    | & _32: t_FMap = Any.any_l ()
    | & _35: UInt64.t = Any.any_l ()
    | & _36: UInt64.t = Any.any_l ()
    | & rx: UInt64.t = Any.any_l ()
    | & vx: t_T = Any.any_l ()
    | & _40: tuple = Any.any_l ()
    | & _41: t_Content = Any.any_l ()
    | & rank: t_PeanoInt = Any.any_l ()
    | & value: t_T = Any.any_l ()
    | & _47: UInt64.t = Any.any_l ()
    | & ry: UInt64.t = Any.any_l ()
    | & vy: t_T = Any.any_l ()
    | & _53: tuple = Any.any_l ()
    | & _54: t_Content = Any.any_l ()
    | & rank'0: t_PeanoInt = Any.any_l ()
    | & value'0: t_T = Any.any_l ()
    | & _60: UInt64.t = Any.any_l ()
    | & _64: bool = Any.any_l ()
    | & perm_mut_x:  (MutBorrow.t t_PtrOwn) = Any.any_l ()
    | & _68: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _69: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _70: t_Option'1 = Any.any_l ()
    | & _71: MutBorrow.t t_FMap = Any.any_l ()
    | & _72: MutBorrow.t t_FMap = Any.any_l ()
    | & _73: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _75: UInt64.t = Any.any_l ()
    | & _76: UInt64.t = Any.any_l ()
    | & _79: t_Content = Any.any_l ()
    | & _81: MutBorrow.t t_Content = Any.any_l ()
    | & _84: Map.map t_Element t_Element = Any.any_l ()
    | & _86: Map.map t_Element t_T = Any.any_l ()
    | & _88: int = Any.any_l ()
    | & _90: Map.map t_Element int = Any.any_l ()
    | & perm_mut_y:  (MutBorrow.t t_PtrOwn) = Any.any_l ()
    | & _93: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _94: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _95: t_Option'1 = Any.any_l ()
    | & _96: MutBorrow.t t_FMap = Any.any_l ()
    | & _97: MutBorrow.t t_FMap = Any.any_l ()
    | & _98: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _100: UInt64.t = Any.any_l ()
    | & _101: UInt64.t = Any.any_l ()
    | & _104: t_Content = Any.any_l ()
    | & _106: MutBorrow.t t_Content = Any.any_l ()
    | & _109: () = Any.any_l ()
    | & _110: bool = Any.any_l ()
    | & perm_mut_x'0:  (MutBorrow.t t_PtrOwn) = Any.any_l ()
    | & _114: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _115: MutBorrow.t t_PtrOwn = Any.any_l ()
    | & _116: t_Option'1 = Any.any_l ()
    | & _117: MutBorrow.t t_FMap = Any.any_l ()
    | & _118: MutBorrow.t t_FMap = Any.any_l ()
    | & _119: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _121: UInt64.t = Any.any_l ()
    | & _122: UInt64.t = Any.any_l ()
    | & _124: MutBorrow.t t_Content = Any.any_l ()
    | & rank'1: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _129: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _130: Map.map t_Element t_Element = Any.any_l ()
    | & _132: Map.map t_Element t_T = Any.any_l ()
    | & _134: int = Any.any_l ()
    | & _136: Map.map t_Element int = Any.any_l () ]
    
    [ return''0 (result:t_Element)-> {[@expl:link ensures #0] [%#sunion_find'12] domain self.final
      = domain self.current}
      {[@expl:link ensures #1] [%#sunion_find'13] result = index_logic'1 (root_of self.current) x
      \/ result = index_logic'1 (root_of self.current) y}
      {[@expl:link ensures #2] [%#sunion_find'14] result = index_logic'1 (root_of self.final) result}
      {[@expl:link ensures #3] [%#sunion_find'15] forall z: t_Element. contains (domain self.current) z
       -> index_logic'1 (root_of self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        result
      else
        index_logic'1 (root_of self.current) z
      )}
      {[@expl:link ensures #4] [%#sunion_find'16] forall z: t_Element. contains (domain self.current) z
       -> index_logic'0 (values self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        index_logic'0 (values self.final) result
      else
        index_logic'0 (values self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union_aux [#"union_find.rs" 335 8 335 75] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 335 26 335 30
  let%span sunion_find'0 = "union_find.rs" 317 19 317 44
  let%span sunion_find'1 = "union_find.rs" 318 19 318 44
  let%span sunion_find'2 = "union_find.rs" 319 18 319 54
  let%span sunion_find'3 = "union_find.rs" 320 18 320 82
  let%span sunion_find'4 = "union_find.rs" 321 18 326 13
  let%span sunion_find'5 = "union_find.rs" 328 18 333 13
  let%span sunion_find'6 = "union_find.rs" 210 25 210 29
  let%span sunion_find'7 = "union_find.rs" 207 19 207 47
  let%span sunion_find'8 = "union_find.rs" 208 18 208 48
  let%span sunion_find'9 = "union_find.rs" 209 18 209 34
  let%span sunion_find'10 = "union_find.rs" 270 21 270 25
  let%span sunion_find'11 = "union_find.rs" 249 19 249 44
  let%span sunion_find'12 = "union_find.rs" 250 19 250 41
  let%span sunion_find'13 = "union_find.rs" 251 19 251 44
  let%span sunion_find'14 = "union_find.rs" 252 19 252 41
  let%span sunion_find'15 = "union_find.rs" 253 18 253 54
  let%span sunion_find'16 = "union_find.rs" 254 18 254 82
  let%span sunion_find'17 = "union_find.rs" 255 18 255 53
  let%span sunion_find'18 = "union_find.rs" 256 18 261 13
  let%span sunion_find'19 = "union_find.rs" 263 18 268 13
  let%span sunion_find'20 = "union_find.rs" 125 19 125 28
  let%span sunion_find'21 = "union_find.rs" 126 18 126 150
  let%span sunion_find'22 = "union_find.rs" 124 8 124 16
  let%span sunion_find'23 = "union_find.rs" 136 19 136 28
  let%span sunion_find'24 = "union_find.rs" 137 18 137 98
  let%span sunion_find'25 = "union_find.rs" 135 8 135 16
  let%span sunion_find'26 = "union_find.rs" 245 12 245 50
  let%span sunion_find'27 = "union_find.rs" 144 19 144 28
  let%span sunion_find'28 = "union_find.rs" 145 18 145 106
  let%span sunion_find'29 = "union_find.rs" 143 8 143 16
  let%span sunion_find'30 = "union_find.rs" 155 16 157 52
  let%span sunion_find'31 = "union_find.rs" 24 8 24 16
  let%span sunion_find'32 = "union_find.rs" 74 8 74 20
  let%span sunion_find'33 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'31] addr_logic self.t_Element__0
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'0] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'4] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'33] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'32] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'5] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'22] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'20] inv'7 self)
   -> ([%#sunion_find'21] forall e1: t_Element, e2: t_Element. contains (domain self) e1
  /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'25] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'23] inv'7 self)
   -> ([%#sunion_find'24] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'29] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'27] inv'7 self)
   -> ([%#sunion_find'28] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  predicate unchanged [#"union_find.rs" 153 8 153 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'30] domain self.current = domain self.final
    /\ root_of self.current = root_of self.final /\ values self.current = values self.final
  
  let rec find (self:MutBorrow.t t_UnionFind) (elem:t_Element) (return'  (x:t_Element))= {[@expl:find 'self' type invariant] [%#sunion_find'6] inv'8 self}
    {[@expl:find requires] [%#sunion_find'7] contains (domain self.current) elem}
    any
    [ return''0 (result:t_Element)-> {[%#sunion_find'8] result = index_logic'1 (root_of self.current) elem}
      {[%#sunion_find'9] unchanged self}
      (! return' {result}) ]
  
  
  predicate equiv_log [#"union_find.rs" 244 8 244 68] (self: t_UnionFind) (x: t_Element) (y: t_Element) =
    [%#sunion_find'26] index_logic'1 (root_of self) x = index_logic'1 (root_of self) y
  
  let rec link (self:MutBorrow.t t_UnionFind) (x:t_Element) (y:t_Element) (return'  (x'0:t_Element))= {[@expl:link 'self' type invariant] [%#sunion_find'10] inv'8 self}
    {[@expl:link requires #0] [%#sunion_find'11] contains (domain self.current) x}
    {[@expl:link requires #1] [%#sunion_find'12] index_logic'1 (root_of self.current) x = x}
    {[@expl:link requires #2] [%#sunion_find'13] contains (domain self.current) y}
    {[@expl:link requires #3] [%#sunion_find'14] index_logic'1 (root_of self.current) y = y}
    any
    [ return''0 (result:t_Element)-> {[%#sunion_find'15] domain self.final = domain self.current}
      {[%#sunion_find'16] result = index_logic'1 (root_of self.current) x
      \/ result = index_logic'1 (root_of self.current) y}
      {[%#sunion_find'17] result = index_logic'1 (root_of self.final) result}
      {[%#sunion_find'18] forall z: t_Element. contains (domain self.current) z
       -> index_logic'1 (root_of self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        result
      else
        index_logic'1 (root_of self.current) z
      )}
      {[%#sunion_find'19] forall z: t_Element. contains (domain self.current) z
       -> index_logic'0 (values self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        index_logic'0 (values self.final) result
      else
        index_logic'0 (values self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_UnionFind) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_UnionFind) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec union_aux[#"union_find.rs" 335 8 335 75] (self:MutBorrow.t t_UnionFind) (x:t_Element) (y:t_Element) (return'  (x'0:t_Element))= {[@expl:union_aux 'self' type invariant] [%#sunion_find] inv'8 self}
    {[@expl:union_aux requires #0] [%#sunion_find'0] contains (domain self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find'1] contains (domain self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'7 self'0.current}
        MutBorrow.borrow_mut <t_UnionFind> {self'0.current}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_11 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = find {_11} {x'0} (fun (_ret:t_Element) ->  [ &rx <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'7 self'0.current}
        MutBorrow.borrow_mut <t_UnionFind> {self'0.current}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_14 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = find {_14} {y'0} (fun (_ret:t_Element) ->  [ &ry <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'7 self'0.current}
        MutBorrow.borrow_final <t_UnionFind> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_16 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = link {_16} {rx} {ry} (fun (_ret:t_Element) ->  [ &_0 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'8 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: t_Element = Any.any_l ()
    | & self'0: MutBorrow.t t_UnionFind = self
    | & x'0: t_Element = x
    | & y'0: t_Element = y
    | & rx: t_Element = Any.any_l ()
    | & _11: MutBorrow.t t_UnionFind = Any.any_l ()
    | & ry: t_Element = Any.any_l ()
    | & _14: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _16: MutBorrow.t t_UnionFind = Any.any_l () ]
    
    [ return''0 (result:t_Element)-> {[@expl:union_aux ensures #0] [%#sunion_find'2] domain self.final
      = domain self.current}
      {[@expl:union_aux ensures #1] [%#sunion_find'3] result = index_logic'1 (root_of self.current) x
      \/ result = index_logic'1 (root_of self.current) y}
      {[@expl:union_aux ensures #2] [%#sunion_find'4] forall z: t_Element. contains (domain self.current) z
       -> index_logic'1 (root_of self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        result
      else
        index_logic'1 (root_of self.current) z
      )}
      {[@expl:union_aux ensures #3] [%#sunion_find'5] forall z: t_Element. contains (domain self.current) z
       -> index_logic'0 (values self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        index_logic'0 (values self.final) result
      else
        index_logic'0 (values self.current) z
      )}
      (! return' {result}) ]

end
module M_union_find__implementation__qyi1944850640244667852__union [#"union_find.rs" 358 8 358 61] (* implementation::UnionFind<T> *)
  let%span sunion_find = "union_find.rs" 358 26 358 30
  let%span sunion_find'0 = "union_find.rs" 342 19 342 44
  let%span sunion_find'1 = "union_find.rs" 343 19 343 44
  let%span sunion_find'2 = "union_find.rs" 344 18 344 54
  let%span sunion_find'3 = "union_find.rs" 345 18 357 9
  let%span sunion_find'4 = "union_find.rs" 335 26 335 30
  let%span sunion_find'5 = "union_find.rs" 317 19 317 44
  let%span sunion_find'6 = "union_find.rs" 318 19 318 44
  let%span sunion_find'7 = "union_find.rs" 319 18 319 54
  let%span sunion_find'8 = "union_find.rs" 320 18 320 82
  let%span sunion_find'9 = "union_find.rs" 321 18 326 13
  let%span sunion_find'10 = "union_find.rs" 328 18 333 13
  let%span sunion_find'11 = "union_find.rs" 125 19 125 28
  let%span sunion_find'12 = "union_find.rs" 126 18 126 150
  let%span sunion_find'13 = "union_find.rs" 124 8 124 16
  let%span sunion_find'14 = "union_find.rs" 136 19 136 28
  let%span sunion_find'15 = "union_find.rs" 137 18 137 98
  let%span sunion_find'16 = "union_find.rs" 135 8 135 16
  let%span sunion_find'17 = "union_find.rs" 245 12 245 50
  let%span sunion_find'18 = "union_find.rs" 144 19 144 28
  let%span sunion_find'19 = "union_find.rs" 145 18 145 106
  let%span sunion_find'20 = "union_find.rs" 143 8 143 16
  let%span sunion_find'21 = "union_find.rs" 24 8 24 16
  let%span sunion_find'22 = "union_find.rs" 74 8 74 20
  let%span sunion_find'23 = "union_find.rs" 118 8 118 16
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate contains [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'21] addr_logic self.t_Element__0
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'2] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'0] Map.get (view self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap] get_unsized self k <> C_None
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'4] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'3] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] lookup self key
  
  function get_perm [#"union_find.rs" 119 8 119 62] (self: t_UnionFind) (e: t_Element) : t_PtrOwn =
    [%#sunion_find'23] index_logic self.t_UnionFind__map (deep_model e)
  
  function index_logic'0 (self: Map.map t_Element t_T) (a: t_Element) : t_T =
    [%#smapping] Map.get self a
  
  function index_logic'1 (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function val' (self: t_PtrOwn) : t_Content
  
  function index_logic'2 (self: Map.map t_Element int) (a: t_Element) : int =
    [%#smapping] Map.get self a
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind) =
    [%#sunion_find'22] let domain = self.t_UnionFind__domain in (forall e1: t_Element, e2: t_Element. contains domain e1
    /\ contains domain e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
    /\ (forall e: t_Element. contains domain e  -> contains'0 self.t_UnionFind__map (deep_model e))
    /\ (forall e: t_Element. contains domain e  -> e.t_Element__0 = ptr (get_perm self e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'0 self.t_UnionFind__values e
    = index_logic'0 self.t_UnionFind__values (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> index_logic'1 self.t_UnionFind__root_of (index_logic'1 self.t_UnionFind__root_of e)
    = index_logic'1 self.t_UnionFind__root_of e)
    /\ (forall e: t_Element. contains domain e  -> contains domain (index_logic'1 self.t_UnionFind__root_of e))
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> e <> e2
      /\ contains domain e2 /\ index_logic'1 self.t_UnionFind__root_of e = index_logic'1 self.t_UnionFind__root_of e2
      | C_Root _ v -> index_logic'0 self.t_UnionFind__values e = v /\ index_logic'1 self.t_UnionFind__root_of e = e
      end)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self e) with
      | C_Link e2 -> index_logic'2 self.t_UnionFind__distance e < index_logic'2 self.t_UnionFind__distance e2
      | C_Root _ _ -> true
      end)
    /\ self.t_UnionFind__max_depth >= 0
    /\ (forall e: t_Element. contains domain e
     -> 0 <= index_logic'2 self.t_UnionFind__distance e
    /\ index_logic'2 self.t_UnionFind__distance e <= self.t_UnionFind__max_depth)
    /\ (forall e: t_Element. contains domain e
     -> match val' (get_perm self (index_logic'1 self.t_UnionFind__root_of e)) with
      | C_Root _ _ -> true
      | C_Link _ -> false
      end)
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val''0} -> inv'2 val''0
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap'5] forall k: UInt64.t. contains'0 self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''5 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'7 self.current /\ inv'7 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element =
    [%#sunion_find'13] self.t_UnionFind__domain
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'11] inv'7 self)
   -> ([%#sunion_find'12] forall e1: t_Element, e2: t_Element. contains (domain self) e1
  /\ contains (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element =
    [%#sunion_find'16] self.t_UnionFind__root_of
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'14] inv'7 self)
   -> ([%#sunion_find'15] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'1 (root_of self) e = index_logic'1 (root_of self) (index_logic'1 (root_of self) e))
  
  predicate equiv_log [#"union_find.rs" 244 8 244 68] (self: t_UnionFind) (x: t_Element) (y: t_Element) =
    [%#sunion_find'17] index_logic'1 (root_of self) x = index_logic'1 (root_of self) y
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element t_T =
    [%#sunion_find'20] self.t_UnionFind__values
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'18] inv'7 self)
   -> ([%#sunion_find'19] forall e: t_Element. contains self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic'1 (root_of self) e))
  
  let rec union_aux (self:MutBorrow.t t_UnionFind) (x:t_Element) (y:t_Element) (return'  (x'0:t_Element))= {[@expl:union_aux 'self' type invariant] [%#sunion_find'4] inv'8 self}
    {[@expl:union_aux requires #0] [%#sunion_find'5] contains (domain self.current) x}
    {[@expl:union_aux requires #1] [%#sunion_find'6] contains (domain self.current) y}
    any
    [ return''0 (result:t_Element)-> {[%#sunion_find'7] domain self.final = domain self.current}
      {[%#sunion_find'8] result = index_logic'1 (root_of self.current) x
      \/ result = index_logic'1 (root_of self.current) y}
      {[%#sunion_find'9] forall z: t_Element. contains (domain self.current) z
       -> index_logic'1 (root_of self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        result
      else
        index_logic'1 (root_of self.current) z
      )}
      {[%#sunion_find'10] forall z: t_Element. contains (domain self.current) z
       -> index_logic'0 (values self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        index_logic'0 (values self.final) result
      else
        index_logic'0 (values self.current) z
      )}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_UnionFind) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_UnionFind) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  let rec union[#"union_find.rs" 358 8 358 61] (self:MutBorrow.t t_UnionFind) (x:t_Element) (y:t_Element) (return'  (x'0:()))= {[@expl:union 'self' type invariant] [%#sunion_find] inv'8 self}
    {[@expl:union requires #0] [%#sunion_find'0] contains (domain self.current) x}
    {[@expl:union requires #1] [%#sunion_find'1] contains (domain self.current) y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'7 self'0.current}
        MutBorrow.borrow_final <t_UnionFind> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_UnionFind) ->
             [ &_9 <- _ret ] 
            -{inv'7 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = union_aux {_9} {x'0} {y'0} (fun (_ret:t_Element) ->  [ &_8 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'8 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_UnionFind = self
    | & x'0: t_Element = x
    | & y'0: t_Element = y
    | & _8: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:union ensures #0] [%#sunion_find'2] domain self.final = domain self.current}
      {[@expl:union ensures #1] [%#sunion_find'3] exists r: t_Element. (r = index_logic'1 (root_of self.current) x
      \/ r = index_logic'1 (root_of self.current) y)
      /\ (forall z: t_Element. contains (domain self.current) z
       -> index_logic'1 (root_of self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then r else index_logic'1 (root_of self.current) z)
      /\ index_logic'0 (values self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        index_logic'0 (values self.final) r
      else
        index_logic'0 (values self.current) z
      ))}
      (! return' {result}) ]

end
module M_union_find__example [#"union_find.rs" 367 0 367 16]
  let%span sunion_find = "union_find.rs" 370 20 370 21
  let%span sunion_find'0 = "union_find.rs" 371 20 371 21
  let%span sunion_find'1 = "union_find.rs" 372 20 372 21
  let%span sunion_find'2 = "union_find.rs" 374 26 374 27
  let%span sunion_find'3 = "union_find.rs" 375 26 375 27
  let%span sunion_find'4 = "union_find.rs" 376 26 376 27
  let%span sunion_find'5 = "union_find.rs" 383 26 383 27
  let%span sunion_find'6 = "union_find.rs" 383 4 383 28
  let%span sunion_find'7 = "union_find.rs" 382 4 382 37
  let%span sunion_find'8 = "union_find.rs" 376 4 376 28
  let%span sunion_find'9 = "union_find.rs" 375 4 375 28
  let%span sunion_find'10 = "union_find.rs" 374 4 374 28
  let%span sunion_find'11 = "union_find.rs" 107 24 107 28
  let%span sunion_find'12 = "union_find.rs" 106 8 106 44
  let%span sunion_find'13 = "union_find.rs" 165 25 165 29
  let%span sunion_find'14 = "union_find.rs" 161 18 161 52
  let%span sunion_find'15 = "union_find.rs" 162 18 162 69
  let%span sunion_find'16 = "union_find.rs" 163 18 163 76
  let%span sunion_find'17 = "union_find.rs" 164 18 164 73
  let%span sunion_find'18 = "union_find.rs" 220 20 220 24
  let%span sunion_find'19 = "union_find.rs" 217 19 217 47
  let%span sunion_find'20 = "union_find.rs" 218 19 218 47
  let%span sunion_find'21 = "union_find.rs" 219 18 219 48
  let%span sunion_find'22 = "union_find.rs" 358 26 358 30
  let%span sunion_find'23 = "union_find.rs" 342 19 342 44
  let%span sunion_find'24 = "union_find.rs" 343 19 343 44
  let%span sunion_find'25 = "union_find.rs" 344 18 344 54
  let%span sunion_find'26 = "union_find.rs" 345 18 357 9
  let%span sunion_find'27 = "union_find.rs" 210 25 210 29
  let%span sunion_find'28 = "union_find.rs" 207 19 207 47
  let%span sunion_find'29 = "union_find.rs" 208 18 208 48
  let%span sunion_find'30 = "union_find.rs" 209 18 209 34
  let%span sunion_find'31 = "union_find.rs" 125 19 125 28
  let%span sunion_find'32 = "union_find.rs" 126 18 126 150
  let%span sunion_find'33 = "union_find.rs" 136 19 136 28
  let%span sunion_find'34 = "union_find.rs" 137 18 137 98
  let%span sunion_find'35 = "union_find.rs" 144 19 144 28
  let%span sunion_find'36 = "union_find.rs" 145 18 145 106
  let%span sunion_find'37 = "union_find.rs" 245 12 245 50
  let%span sunion_find'38 = "union_find.rs" 155 16 157 52
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sfset'0 = "../../creusot-contracts/src/logic/fset.rs" 66 8 66 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use set.Fset
  use creusot.int.Int32
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  type t_FMap
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element Int32.t;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind)
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt Int32.t
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'3] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'2] Map.get (view self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap'0] get_unsized self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_PtrOwn)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn [inv'0 x]. inv'0 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> true
    end)
  
  predicate invariant''1 (self: t_PtrOwn) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_PtrOwn)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_PtrOwn [inv'1 x]. inv'1 x = invariant''1 x
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] unwrap (get_unsized self k)
  
  predicate invariant''2 (self: t_FMap) =
    [%#sfmap] forall k: UInt64.t. contains self k  -> inv k /\ inv'1 (lookup_unsized self k)
  
  predicate inv'2 (_0: t_FMap)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_FMap [inv'2 x]. inv'2 x = invariant''2 x
  
  predicate invariant''3 (self:  t_FMap) =
    [%#sghost] inv'2 self
  
  predicate inv'3 (_0:  t_FMap)
  
  axiom inv_axiom'3 [@rewrite]: forall x:  t_FMap [inv'3 x]. inv'3 x = invariant''3 x
  
  predicate inv'4 (_0: t_UnionFind)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_UnionFind [inv'4 x]. inv'4 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'3 map
    end)
  
  let rec new (return'  (x:t_UnionFind))= any
    [ return''0 (result:t_UnionFind)-> {[%#sunion_find'11] inv'4 result}
      {[%#sunion_find'12] Fset.is_empty result.t_UnionFind__domain}
      (! return' {result}) ]
  
  
  predicate invariant''4 (self: MutBorrow.t t_UnionFind) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_UnionFind)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_UnionFind [inv'5 x]. inv'5 x = invariant''4 x
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'31] inv'4 self)
   -> ([%#sunion_find'32] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
  /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  function insert [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element =
    [%#sfset'0] Fset.add e self
  
  function index_logic (self: Map.map t_Element t_Element) (a: t_Element) : t_Element =
    [%#smapping] Map.get self a
  
  function root_of [#"union_find.rs" 138 8 138 63] (self: t_UnionFind) : Map.map t_Element t_Element
  
  axiom root_of_spec: forall self: t_UnionFind. ([%#sunion_find'33] inv'4 self)
   -> ([%#sunion_find'34] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic (root_of self) e = index_logic (root_of self) (index_logic (root_of self) e))
  
  function index_logic'0 (self: Map.map t_Element Int32.t) (a: t_Element) : Int32.t =
    [%#smapping] Map.get self a
  
  function values [#"union_find.rs" 146 8 146 53] (self: t_UnionFind) : Map.map t_Element Int32.t
  
  axiom values_spec: forall self: t_UnionFind. ([%#sunion_find'35] inv'4 self)
   -> ([%#sunion_find'36] forall e: t_Element. contains'0 self.t_UnionFind__domain e
   -> index_logic'0 (values self) e = index_logic'0 (values self) (index_logic (root_of self) e))
  
  let rec make (self:MutBorrow.t t_UnionFind) (value:Int32.t) (return'  (x:t_Element))= {[@expl:make 'self' type invariant] [%#sunion_find'13] inv'5 self}
    any
    [ return''0 (result:t_Element)-> {[%#sunion_find'14] not contains'0 (domain self.current) result}
      {[%#sunion_find'15] domain self.final = insert (domain self.current) result}
      {[%#sunion_find'16] root_of self.final = Map.set (root_of self.current) result result}
      {[%#sunion_find'17] values self.final = Map.set (values self.current) result value}
      (! return' {result}) ]
  
  
  predicate invariant''5 (self: t_UnionFind) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'6 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'6 x]. inv'6 x = invariant''5 x
  
  let rec get (self:t_UnionFind) (elem:t_Element) (return'  (x:Int32.t))= {[@expl:get 'self' type invariant] [%#sunion_find'18] inv'6 self}
    {[@expl:get requires #0] [%#sunion_find'19] contains'0 (domain self) elem}
    {[@expl:get requires #1] [%#sunion_find'20] index_logic (root_of self) elem = elem}
    any
    [ return''0 (result:Int32.t)-> {[%#sunion_find'21] result = index_logic'0 (values self) elem} (! return' {result}) ]
  
  
  predicate equiv_log [#"union_find.rs" 244 8 244 68] (self: t_UnionFind) (x: t_Element) (y: t_Element) =
    [%#sunion_find'37] index_logic (root_of self) x = index_logic (root_of self) y
  
  let rec union (self:MutBorrow.t t_UnionFind) (x:t_Element) (y:t_Element) (return'  (x'0:()))= {[@expl:union 'self' type invariant] [%#sunion_find'22] inv'5 self}
    {[@expl:union requires #0] [%#sunion_find'23] contains'0 (domain self.current) x}
    {[@expl:union requires #1] [%#sunion_find'24] contains'0 (domain self.current) y}
    any
    [ return''0 (result:())-> {[%#sunion_find'25] domain self.final = domain self.current}
      {[%#sunion_find'26] exists r: t_Element. (r = index_logic (root_of self.current) x
      \/ r = index_logic (root_of self.current) y)
      /\ (forall z: t_Element. contains'0 (domain self.current) z
       -> index_logic (root_of self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then r else index_logic (root_of self.current) z)
      /\ index_logic'0 (values self.final) z
      = (if equiv_log self.current z x \/ equiv_log self.current z y then
        index_logic'0 (values self.final) r
      else
        index_logic'0 (values self.current) z
      ))}
      (! return' {result}) ]
  
  
  predicate unchanged [#"union_find.rs" 153 8 153 43] (self: MutBorrow.t t_UnionFind) =
    [%#sunion_find'38] domain self.current = domain self.final
    /\ root_of self.current = root_of self.final /\ values self.current = values self.final
  
  let rec find (self:MutBorrow.t t_UnionFind) (elem:t_Element) (return'  (x:t_Element))= {[@expl:find 'self' type invariant] [%#sunion_find'27] inv'5 self}
    {[@expl:find requires] [%#sunion_find'28] contains'0 (domain self.current) elem}
    any
    [ return''0 (result:t_Element)-> {[%#sunion_find'29] result = index_logic (root_of self.current) elem}
      {[%#sunion_find'30] unchanged self}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec example[#"union_find.rs" 367 0 367 16] (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret:t_UnionFind) ->  [ &uf <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret:MutBorrow.t t_UnionFind) ->  [ &_3 <- _ret ] -{inv'4 _ret.final}-  [ &uf <- _ret.final ] s1)
      | s1 = make {_3} {[%#sunion_find] (1: Int32.t)} (fun (_ret:t_Element) ->  [ &x <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret:MutBorrow.t t_UnionFind) ->  [ &_5 <- _ret ] -{inv'4 _ret.final}-  [ &uf <- _ret.final ] s1)
      | s1 = make {_5} {[%#sunion_find'0] (2: Int32.t)} (fun (_ret:t_Element) ->  [ &y <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret:MutBorrow.t t_UnionFind) ->  [ &_7 <- _ret ] -{inv'4 _ret.final}-  [ &uf <- _ret.final ] s1)
      | s1 = make {_7} {[%#sunion_find'1] (3: Int32.t)} (fun (_ret:t_Element) ->  [ &z <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = s0 [ s0 = get {uf} {x} (fun (_ret:Int32.t) ->  [ &_11 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 =  [ &_9 <- _11 = ([%#sunion_find'2] (1: Int32.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
    
    | bb6 = s0 [ s0 = get {uf} {y} (fun (_ret:Int32.t) ->  [ &_18 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 =  [ &_16 <- _18 = ([%#sunion_find'3] (2: Int32.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb9) ]  ]
    
    | bb9 = s0 [ s0 = get {uf} {z} (fun (_ret:Int32.t) ->  [ &_25 <- _ret ] s1) | s1 = bb11 ] 
    | bb11 = s0
      [ s0 =  [ &_23 <- _25 = ([%#sunion_find'4] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb13) | br1 -> {_23} (! bb12) ]  ]
    
    | bb12 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret:MutBorrow.t t_UnionFind) ->  [ &_30 <- _ret ] -{inv'4 _ret.final}-  [ &uf <- _ret.final ] s1)
      | s1 = union {_30} {x} {y} (fun (_ret:()) ->  [ &_29 <- _ret ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret:MutBorrow.t t_UnionFind) ->  [ &_34 <- _ret ] -{inv'4 _ret.final}-  [ &uf <- _ret.final ] s1)
      | s1 = find {_34} {x} (fun (_ret:t_Element) ->  [ &x'0 <- _ret ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0
      [ s0 = {inv'4 uf}
        MutBorrow.borrow_mut <t_UnionFind> {uf}
          (fun (_ret:MutBorrow.t t_UnionFind) ->  [ &_37 <- _ret ] -{inv'4 _ret.final}-  [ &uf <- _ret.final ] s1)
      | s1 = find {_37} {y} (fun (_ret:t_Element) ->  [ &y'0 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = get {uf} {x'0} (fun (_ret:Int32.t) ->  [ &_42 <- _ret ] s1) | s1 = bb17 ] 
    | bb17 = s0 [ s0 = get {uf} {y'0} (fun (_ret:Int32.t) ->  [ &_46 <- _ret ] s1) | s1 = bb18 ] 
    | bb18 = s0
      [ s0 =  [ &_40 <- _42 = _46 ] s1 | s1 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb19) ]  ]
    
    | bb19 = s0 [ s0 = get {uf} {z} (fun (_ret:Int32.t) ->  [ &_53 <- _ret ] s1) | s1 = bb21 ] 
    | bb21 = s0
      [ s0 =  [ &_51 <- _53 = ([%#sunion_find'5] (3: Int32.t)) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb23) | br1 -> {_51} (! bb22) ]  ]
    
    | bb22 = return''0 {_0}
    | bb23 = {[%#sunion_find'6] false} any
    | bb20 = {[%#sunion_find'7] false} any
    | bb13 = {[%#sunion_find'8] false} any
    | bb10 = {[%#sunion_find'9] false} any
    | bb7 = {[%#sunion_find'10] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & uf: t_UnionFind = Any.any_l ()
    | & x: t_Element = Any.any_l ()
    | & _3: MutBorrow.t t_UnionFind = Any.any_l ()
    | & y: t_Element = Any.any_l ()
    | & _5: MutBorrow.t t_UnionFind = Any.any_l ()
    | & z: t_Element = Any.any_l ()
    | & _7: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: Int32.t = Any.any_l ()
    | & _23: bool = Any.any_l ()
    | & _25: Int32.t = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_UnionFind = Any.any_l ()
    | & x'0: t_Element = Any.any_l ()
    | & _34: MutBorrow.t t_UnionFind = Any.any_l ()
    | & y'0: t_Element = Any.any_l ()
    | & _37: MutBorrow.t t_UnionFind = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & _42: Int32.t = Any.any_l ()
    | & _46: Int32.t = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & _53: Int32.t = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_union_find__example_addrs_eq [#"union_find.rs" 387 0 387 77]
  let%span sunion_find = "union_find.rs" 391 22 391 30
  let%span sunion_find'0 = "union_find.rs" 387 27 387 29
  let%span sunion_find'1 = "union_find.rs" 386 11 386 63
  let%span sunion_find'2 = "union_find.rs" 17 18 17 69
  let%span sunion_find'3 = "union_find.rs" 125 19 125 28
  let%span sunion_find'4 = "union_find.rs" 126 18 126 150
  let%span sptr = "../../creusot-contracts/src/std/ptr.rs" 59 14 59 53
  let%span sptr'0 = "../../creusot-contracts/src/std/ptr.rs" 61 8 61 35
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 567 20 567 91
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sutil = "../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 55 10 55 28
  let%span sghost = "../../creusot-contracts/src/ghost.rs" 99 8 99 18
  let%span sfset = "../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span sptr_own = "../../creusot-contracts/src/ptr_own.rs" 49 8 49 35
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use map.Map
  use creusot.prelude.Any
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t
  
  function deep_model'0 (self: t_Element) : UInt64.t =
    [%#smodel] deep_model self
  
  let rec eq (self:t_Element) (other:t_Element) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sunion_find'2] result = (deep_model'0 self = deep_model'0 other)}
      (! return' {result}) ]
  
  
  type t_FMap
  
  type t_T
  
  type t_UnionFind  =
    { t_UnionFind__domain: Fset.fset t_Element;
      t_UnionFind__map:  t_FMap;
      t_UnionFind__values: Map.map t_Element t_T;
      t_UnionFind__distance: Map.map t_Element int;
      t_UnionFind__root_of: Map.map t_Element t_Element;
      t_UnionFind__max_depth: int }
  
  predicate invariant' [@inline:trivial] [#"union_find.rs" 76 8 76 34] (self: t_UnionFind)
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Content  =
    | C_Root t_PeanoInt t_T
    | C_Link t_Element
  
  type t_PtrOwn  =
    { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Content }
  
  type t_Option  =
    | C_None
    | C_Some t_PtrOwn
  
  function view (self: t_FMap) : Map.map UInt64.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'3] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_Option =
    [%#sfmap'2] Map.get (view self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: UInt64.t) : bool =
    [%#sfmap'0] get_unsized self k <> C_None
  
  predicate inv (_0: UInt64.t)
  
  axiom inv_axiom [@rewrite]: forall x: UInt64.t [inv x]. inv x = true
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function is_null_logic (self: Opaque.ptr) : bool =
    [%#sptr'0] addr_logic self = (0: UInt64.t)
  
  axiom is_null_logic_spec: forall self: Opaque.ptr. [%#sptr] is_null_logic self = (addr_logic self = (0: UInt64.t))
  
  function ptr (self: t_PtrOwn) : Opaque.ptr
  
  predicate invariant''0 (self: t_PtrOwn) =
    [%#sptr_own] not is_null_logic (ptr self)
  
  predicate inv'0 (_0: t_T)
  
  predicate inv'1 (_0: t_Content)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Content [inv'1 x]. inv'1 x
  = match x with
    | C_Root rank value -> inv'0 value
    | C_Link a_0 -> true
    end
  
  predicate invariant''1 (self: t_Content) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Content)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Content [inv'2 x]. inv'2 x = invariant''1 x
  
  predicate inv'3 (_0: t_PtrOwn)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_PtrOwn [inv'3 x]. inv'3 x
  = (invariant''0 x
  /\ match x with
    | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'2 val'
    end)
  
  predicate invariant''2 (self: t_PtrOwn) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_PtrOwn)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_PtrOwn [inv'4 x]. inv'4 x = invariant''2 x
  
  function unwrap (op: t_Option) : t_PtrOwn
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: UInt64.t) : t_PtrOwn =
    [%#sfmap'1] unwrap (get_unsized self k)
  
  predicate invariant''3 (self: t_FMap) =
    [%#sfmap] forall k: UInt64.t. contains self k  -> inv k /\ inv'4 (lookup_unsized self k)
  
  predicate inv'5 (_0: t_FMap)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_FMap [inv'5 x]. inv'5 x = invariant''3 x
  
  predicate invariant''4 (self:  t_FMap) =
    [%#sghost] inv'5 self
  
  predicate inv'6 (_0:  t_FMap)
  
  axiom inv_axiom'5 [@rewrite]: forall x:  t_FMap [inv'6 x]. inv'6 x = invariant''4 x
  
  predicate inv'7 (_0: t_UnionFind)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_UnionFind [inv'7 x]. inv'7 x
  = (invariant' x
  /\ match x with
    | {t_UnionFind__domain = domain ; t_UnionFind__map = map ; t_UnionFind__values = values ; t_UnionFind__distance = distance ; t_UnionFind__root_of = root_of ; t_UnionFind__max_depth = max_depth} -> inv'6 map
    end)
  
  predicate invariant''5 (self: t_UnionFind) =
    [%#sinvariant] inv'7 self
  
  predicate inv'8 (_0: t_UnionFind)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_UnionFind [inv'8 x]. inv'8 x = invariant''5 x
  
  predicate contains'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) =
    [%#sfset] Fset.mem e self
  
  function domain [#"union_find.rs" 127 8 127 47] (self: t_UnionFind) : Fset.fset t_Element
  
  axiom domain_spec: forall self: t_UnionFind. ([%#sunion_find'3] inv'7 self)
   -> ([%#sunion_find'4] forall e1: t_Element, e2: t_Element. contains'0 (domain self) e1
  /\ contains'0 (domain self) e2 /\ deep_model e1 = deep_model e2  -> e1 = e2)
  
  meta "compute_max_steps" 1000000
  
  let rec example_addrs_eq[#"union_find.rs" 387 0 387 77] (uf:t_UnionFind) (e1:t_Element) (e2:t_Element) (return'  (x:()))= {[@expl:example_addrs_eq 'uf' type invariant] [%#sunion_find'0] inv'8 uf}
    {[@expl:example_addrs_eq requires] [%#sunion_find'1] contains'0 (domain uf) e1 /\ contains'0 (domain uf) e2}
    (! bb0
    [ bb0 = s0 [ s0 = eq {e1'0} {e2'0} (fun (_ret:bool) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ] 
    | bb2 = s0 [ s0 = {[@expl:assertion] [%#sunion_find] e1'0 = e2'0} s1 | s1 = bb4 ] 
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & e1'0: t_Element = e1 | & e2'0: t_Element = e2 | & _5: bool = Any.any_l () ] 
    [ return''0 (result:())-> (! return' {result}) ]

end
module M_union_find__implementation__qyi17232405883558456141__eq__refines [#"union_find.rs" 18 8 18 42] (* <implementation::Element<T> as creusot_contracts::PartialEq> *)
  let%span sunion_find = "union_find.rs" 18 8 18 42
  let%span sunion_find'0 = "union_find.rs" 24 8 24 16
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  type t_Element  =
    { t_Element__0: Opaque.ptr }
  
  function addr_logic (self: Opaque.ptr) : UInt64.t
  
  function deep_model [#"union_find.rs" 25 8 25 36] (self: t_Element) : UInt64.t =
    [%#sunion_find'0] addr_logic self.t_Element__0
  
  function deep_model'0 (self: t_Element) : UInt64.t =
    [%#smodel] deep_model self
  
  goal refines: [%#sunion_find] forall self_: t_Element. forall rhs: t_Element. forall result: bool. result
  = (deep_model'0 self_ = deep_model'0 rhs)  -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
