module M_implementation__impl_PartialEq_for_Element__eq (* <implementation::Element as std::cmp::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Element = { f0: Opaque.ptr }
  
  let rec addr_eq_unit (p: Opaque.ptr) (q: Opaque.ptr) (return (x: bool)) = any
    [ return (result: bool) -> {result = (Ptr.addr_logic_u64 p = Ptr.addr_logic_u64 q)} (! return {result}) ]
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  function deep_model_ref_Element [@inline:trivial] (self: t_Element) : UInt64.t = deep_model_Element self
  
  meta "rewrite_def" function deep_model_ref_Element
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_Element (self: t_Element) (other: t_Element) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = addr_eq_unit {self.f0} {other.f0} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ] [ & _0: bool = Any.any_l () | & self: t_Element = self | & other: t_Element = other ])
    [ return (result: bool) -> {[@expl:eq ensures] result
      = (deep_model_ref_Element self = deep_model_ref_Element other)}
      (! return {result}) ]
end
module M_implementation__impl_Clone_for_Element__clone (* <implementation::Element as std::clone::Clone> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Element (self: t_Element) (return (x: t_Element)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { f0 = self.f0 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Element = Any.any_l () | & self: t_Element = self ])
    [ return (result: t_Element) -> {[@expl:clone ensures] self = result} (! return {result}) ]
end
module M_implementation__impl_UnionFind_T__domain (* implementation::UnionFind<T> *)
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UnionFind_T
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element
  
  goal vc_domain_T: inv_UnionFind_T self
    -> (let result = self.f0'0.domain in [@expl:domain ensures] forall e1: t_Element, e2: t_Element. contains_Element result e1
        /\ contains_Element result e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
end
module M_implementation__impl_UnionFind_T__roots_map (* implementation::UnionFind<T> *)
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'0.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UnionFind_T
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element
  
  goal vc_roots_map_T: inv_UnionFind_T self
    -> (let result = self.f0'0.roots in [@expl:roots_map ensures] forall e: t_Element. in_domain_T self e
      -> in_domain_T self (index_Mapping_Element_Element result e)
      /\ index_Mapping_Element_Element result e
      = index_Mapping_Element_Element result (index_Mapping_Element_Element result e))
end
module M_implementation__new
  use set.Fset
  use creusot.prelude.Opaque
  use map.Map
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  use map.Const
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_T
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'1 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate invariant_Ghost_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    inv_FMap_Element_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_FMap_Element_PtrOwn_Node_T
  
  predicate inv_Ghost_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Element_PtrOwn_Node_T) =
    invariant_Ghost_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_FMap_Element_PtrOwn_Node_T
  
  predicate ext_eq_Element (self: t_FMap_Element_PtrOwn_Node_T) (other: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. get_Element self k = get_Element other k
  
  axiom ext_eq_Element_spec:
    forall self: t_FMap_Element_PtrOwn_Node_T, other: t_FMap_Element_PtrOwn_Node_T. ext_eq_Element self other
      = (self = other)
  
  function len_Element (self: t_FMap_Element_PtrOwn_Node_T) : int
  
  axiom len_Element_spec: forall self: t_FMap_Element_PtrOwn_Node_T. len_Element self >= 0
  
  constant empty_Element : t_FMap_Element_PtrOwn_Node_T
  
  axiom empty_Element_spec: len_Element empty_Element = 0
  
  axiom empty_Element_spec'0: view_FMap_Element_PtrOwn_Node_T empty_Element = Const.const (None)
  
  predicate is_empty_Element (self: t_FMap_Element_PtrOwn_Node_T) = ext_eq_Element self empty_Element
  
  let rec new_Element (return (x: t_FMap_Element_PtrOwn_Node_T)) = any
    [ return (result: t_FMap_Element_PtrOwn_Node_T) -> {inv_Ghost_FMap_Element_PtrOwn_Node_T result}
      {is_empty_Element result}
      (! return {result}) ]
  
  let rec into_inner_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T)
    (return (x: t_FMap_Element_PtrOwn_Node_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_FMap_Element_PtrOwn_Node_T self}
    any
    [ return (result: t_FMap_Element_PtrOwn_Node_T) -> {inv_FMap_Element_PtrOwn_Node_T result}
      {result = self}
      (! return {result}) ]
  
  predicate index_Mapping_Mapping_Element_T_bool [@inline:trivial] (self: Map.map (Map.map t_Element t_T) bool) (a: Map.map t_Element t_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Mapping_Element_T_bool
  
  function such_that_Mapping_Element_T (p: Map.map (Map.map t_Element t_T) bool) : Map.map t_Element t_T
  
  axiom such_that_Mapping_Element_T_spec:
    forall p: Map.map (Map.map t_Element t_T) bool. (exists x: Map.map t_Element t_T. index_Mapping_Mapping_Element_T_bool p x)
      -> index_Mapping_Mapping_Element_T_bool p (such_that_Mapping_Element_T p)
  
  predicate index_Mapping_Mapping_Element_Int_bool [@inline:trivial] (self: Map.map (Map.map t_Element int) bool) (a: Map.map t_Element int) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Mapping_Element_Int_bool
  
  function such_that_Mapping_Element_Int (p: Map.map (Map.map t_Element int) bool) : Map.map t_Element int
  
  axiom such_that_Mapping_Element_Int_spec:
    forall p: Map.map (Map.map t_Element int) bool. (exists x: Map.map t_Element int. index_Mapping_Mapping_Element_Int_bool p x)
      -> index_Mapping_Mapping_Element_Int_bool p (such_that_Mapping_Element_Int p)
  
  predicate index_Mapping_Mapping_Element_Element_bool [@inline:trivial] (self: Map.map (Map.map t_Element t_Element) bool) (a: Map.map t_Element t_Element) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Mapping_Element_Element_bool
  
  function such_that_Mapping_Element_Element (p: Map.map (Map.map t_Element t_Element) bool) : Map.map t_Element t_Element
  
  axiom such_that_Mapping_Element_Element_spec:
    forall p: Map.map (Map.map t_Element t_Element) bool. (exists x: Map.map t_Element t_Element. index_Mapping_Mapping_Element_Element_bool p x)
      -> index_Mapping_Mapping_Element_Element_bool p (such_that_Mapping_Element_Element p)
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'1: t_UFInner_T }
  
  predicate contains_Element'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element'0
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element'0 self.f0'1.domain e1
          /\ contains_Element'0 self.f0'1.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element'0 self.f0'1.domain e
      -> contains_Element self.f0'1.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'1.perms e) = e.f0
      /\ contains_Element'0 self.f0'1.domain (index_Mapping_Element_Element self.f0'1.roots e)
      /\ index_Mapping_Element_Element self.f0'1.roots (index_Mapping_Element_Element self.f0'1.roots e)
        = index_Mapping_Element_Element self.f0'1.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'1.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'1.roots e <> e
          /\ contains_Element'0 self.f0'1.domain e2
          /\ index_Mapping_Element_Element self.f0'1.roots e = index_Mapping_Element_Element self.f0'1.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'1.roots e = e
          /\ index_Mapping_Element_T self.f0'1.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'1.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'1.depth e < index_Mapping_Element_Int self.f0'1.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'1.depth e <= self.f0'1.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'1)
  
  predicate invariant_Ghost_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) = inv_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_UnionFind_T
  
  predicate inv_Ghost_UnionFind_T [@inline:trivial] (_1: t_UnionFind_T) = invariant_Ghost_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_UnionFind_T
  
  let rec new_UnionFind_T (x: t_UnionFind_T) (return (x'0: t_UnionFind_T)) =
    {[@expl:new 'x' type invariant] inv_UnionFind_T x}
    any [ return (result: t_UnionFind_T) -> {inv_Ghost_UnionFind_T result} {result = x} (! return {result}) ]
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'1.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element'0 (domain_T self) e1
          /\ contains_Element'0 (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_T (return (x: t_UnionFind_T)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- Fset.empty: Fset.fset t_Element ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new_Element (fun (_ret: t_FMap_Element_PtrOwn_Node_T) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = into_inner_FMap_Element_PtrOwn_Node_T {_7} (fun (_ret: t_FMap_Element_PtrOwn_Node_T) -> [ &_6 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_8 <- such_that_Mapping_Element_T (fun (__0: Map.map t_Element t_T) -> true) ] s1 | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_10 <- such_that_Mapping_Element_Int (fun (__0: Map.map t_Element int) -> true) ] s1 | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_12 <- such_that_Mapping_Element_Element (fun (__0: Map.map t_Element t_Element) -> true) ] s1
      | s1 = bb6 ]
    | bb6 = s0 [ s0 = [ &_14 <- 0 ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_3 <- { domain = _4; perms = _6; payloads = _8; roots = _12; depth = _10; max_depth = _14 } ] s1
      | s1 = [ &_2 <- { f0'1 = _3 } ] s2
      | s2 = new_UnionFind_T {_2} (fun (_ret: t_UnionFind_T) -> [ &_0 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = return {_0} ]
    [ & _0: t_UnionFind_T = Any.any_l ()
    | & _2: t_UnionFind_T = Any.any_l ()
    | & _3: t_UFInner_T = Any.any_l ()
    | & _4: Fset.fset t_Element = Any.any_l ()
    | & _6: t_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _7: t_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _8: Map.map t_Element t_T = Any.any_l ()
    | & _10: Map.map t_Element int = Any.any_l ()
    | & _12: Map.map t_Element t_Element = Any.any_l ()
    | & _14: int = Any.any_l () ])
    [ return (result: t_UnionFind_T) -> {[@expl:new result type invariant] inv_Ghost_UnionFind_T result}
      {[@expl:new ensures] Fset.is_empty (domain_T result)}
      (! return {result}) ]
end
module M_implementation__make
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec new (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {result.f0 = (0: UInt64.t)} (! return {result}) ]
  
  type t_T
  
  type t_Element = { f0'0: Opaque.ptr }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  type t_PtrOwn_Node_T
  
  type tup2_ptr_Node_T_Ghost_PtrOwn_Node_T = { f0'1: Opaque.ptr; f1'1: t_PtrOwn_Node_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_Ghost_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_PtrOwn_Node_T
  
  predicate inv_Ghost_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_Ghost_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_PtrOwn_Node_T
  
  predicate inv_tup2_ptr_Node_T_Ghost_PtrOwn_Node_T [@inline:trivial] (_1: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T) =
    inv_Ghost_PtrOwn_Node_T _1.f1'1
  
  meta "rewrite_def" predicate inv_tup2_ptr_Node_T_Ghost_PtrOwn_Node_T
  
  let rec new_Node_T (v: t_Node_T) (return (x: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T)) =
    {[@expl:new 'v' type invariant] inv_Node_T v}
    any
    [ return (result: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T) -> {inv_tup2_ptr_Node_T_Ghost_PtrOwn_Node_T result}
      {ptr_Node_T result.f1'1 = result.f0'1 /\ val_Node_T result.f1'1 = v}
      (! return {result}) ]
  
  let rec into_inner_PtrOwn_Node_T (self: t_PtrOwn_Node_T) (return (x: t_PtrOwn_Node_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_PtrOwn_Node_T self}
    any [ return (result: t_PtrOwn_Node_T) -> {inv_PtrOwn_Node_T result} {result = self} (! return {result}) ]
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'2: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0'0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'2.domain e1
          /\ contains_Element self.f0'2.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'2.domain e
      -> contains_Element'0 self.f0'2.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'2.perms e) = e.f0'0
      /\ contains_Element self.f0'2.domain (index_Mapping_Element_Element self.f0'2.roots e)
      /\ index_Mapping_Element_Element self.f0'2.roots (index_Mapping_Element_Element self.f0'2.roots e)
        = index_Mapping_Element_Element self.f0'2.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'2.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'2.roots e <> e
          /\ contains_Element self.f0'2.domain e2
          /\ index_Mapping_Element_Element self.f0'2.roots e = index_Mapping_Element_Element self.f0'2.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'2.roots e = e
          /\ index_Mapping_Element_T self.f0'2.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'2.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'2.depth e < index_Mapping_Element_Int self.f0'2.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'2.depth e <= self.f0'2.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'2)
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_UnionFind_T self.current /\ inv_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate invariant_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_T
  
  predicate inv_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) =
    invariant_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_T
  
  let rec into_inner_ref_UnionFind_T (self: MutBorrow.t t_UnionFind_T) (return (x: MutBorrow.t t_UnionFind_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_ref_UnionFind_T self}
    any
    [ return (result: MutBorrow.t t_UnionFind_T) -> {inv_ref_UnionFind_T result} {result = self} (! return {result}) ]
  
  type tup2_PtrOwn_Node_T_ref_UnionFind_T = { f0'3: t_PtrOwn_Node_T; f1'3: MutBorrow.t t_UnionFind_T }
  
  predicate index_Mapping_Element_bool [@inline:trivial] (self: Map.map t_Element bool) (a: t_Element) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Element_bool
  
  function such_that_Element (p: Map.map t_Element bool) : t_Element
  
  axiom such_that_Element_spec: forall p: Map.map t_Element bool. (exists x: t_Element. index_Mapping_Element_bool p x)
      -> index_Mapping_Element_bool p (such_that_Element p)
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'2.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  let rec into_ghost_ptr_unit (self: Opaque.ptr) (return (x: Opaque.ptr)) = any
    [ return (result: Opaque.ptr) -> {result = self} (! return {result}) ]
  
  let rec into_inner_ptr_unit (self: Opaque.ptr) (return (x: Opaque.ptr)) = any
    [ return (result: Opaque.ptr) -> {result = self} (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 t_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    inv_FMap_Element_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Element_PtrOwn_Node_T) =
    invariant_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Element_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'4 -> inv_ref_PtrOwn_Node_T f0'4
        end
  
  function map_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) (f: Map.map t_PtrOwn_Node_T t_PtrOwn_Node_T) : t_Option_ref_PtrOwn_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Element (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Element_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {result = map_Option_PtrOwn_Node_T (get_Element self key) (fun (v: t_PtrOwn_Node_T) -> v)}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_ref_PtrOwn_Node_T) (ret (f0'4: t_PtrOwn_Node_T)) = any
    [ good (f0'4: t_PtrOwn_Node_T) -> {Some'0 f0'4 = input} (! ret {f0'4})
    | bad -> {forall f0'4: t_PtrOwn_Node_T [Some'0 f0'4: t_Option_ref_PtrOwn_Node_T]. Some'0 f0'4 <> input}
      (! {false}
      any) ]
  
  predicate invariant_ref_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_PtrOwn_Node_T self.current /\ inv_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T'0
  
  predicate inv_ref_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_ref_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T'0
  
  let rec disjoint_lemma_Node_T (own1: MutBorrow.t t_PtrOwn_Node_T) (own2: t_PtrOwn_Node_T) (return (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] inv_ref_PtrOwn_Node_T'0 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] inv_ref_PtrOwn_Node_T own2}
    {[@expl:disjoint_lemma requires] size_of_Node_T <> 0}
    any
    [ return (result: ()) -> {Ptr.addr_logic_u64 (ptr_Node_T own1.current) <> Ptr.addr_logic_u64 (ptr_Node_T own2)}
      {own1.current = own1.final}
      (! return {result}) ]
  
  predicate resolve_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Element_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    inv_FMap_Element_PtrOwn_Node_T self.current /\ inv_FMap_Element_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_Element_PtrOwn_Node_T'0
  
  predicate inv_ref_FMap_Element_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    invariant_ref_FMap_Element_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Element_PtrOwn_Node_T'0
  
  predicate inv_Option_PtrOwn_Node_T (_1: t_Option_PtrOwn_Node_T)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_PtrOwn_Node_T [inv_Option_PtrOwn_Node_T x]. inv_Option_PtrOwn_Node_T x
      = match x with
        | None -> true
        | Some f0'4 -> inv_PtrOwn_Node_T f0'4
        end
  
  function len_Element (self: t_FMap_Element_PtrOwn_Node_T) : int
  
  axiom len_Element_spec: forall self: t_FMap_Element_PtrOwn_Node_T. len_Element self >= 0
  
  function insert_Element (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) (v: t_PtrOwn_Node_T) : t_FMap_Element_PtrOwn_Node_T
  
  axiom insert_Element_spec:
    forall self: t_FMap_Element_PtrOwn_Node_T, k: t_Element, v: t_PtrOwn_Node_T. view_FMap_Element_PtrOwn_Node_T (insert_Element self k v)
      = Map.set (view_FMap_Element_PtrOwn_Node_T self) k (Some v)
  
  axiom insert_Element_spec'0:
    forall self: t_FMap_Element_PtrOwn_Node_T, k: t_Element, v: t_PtrOwn_Node_T. len_Element (insert_Element self k v)
      = (if contains_Element'0 self k then len_Element self else len_Element self + 1)
  
  let rec insert_ghost_Element (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) (key: t_Element)
    (value: t_PtrOwn_Node_T) (return (x: t_Option_PtrOwn_Node_T)) =
    {[@expl:insert_ghost 'self' type invariant] inv_ref_FMap_Element_PtrOwn_Node_T'0 self}
    {[@expl:insert_ghost 'value' type invariant] inv_PtrOwn_Node_T value}
    any
    [ return (result: t_Option_PtrOwn_Node_T) -> {inv_Option_PtrOwn_Node_T result}
      {self.final = insert_Element self.current key value}
      {result = get_Element self.current key}
      (! return {result}) ]
  
  predicate resolve_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  predicate resolve_Option_PtrOwn_Node_T (_1: t_Option_PtrOwn_Node_T)
  
  axiom resolve_axiom [@rewrite]:
    forall x: t_Option_PtrOwn_Node_T [resolve_Option_PtrOwn_Node_T x]. resolve_Option_PtrOwn_Node_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_PtrOwn_Node_T x0
        end
  
  function insert_Element'0 [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element =
    Fset.add e self
  
  meta "rewrite_def" function insert_Element'0
  
  predicate resolve_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UnionFind_T
  
  let rec new_unit (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  function fin_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) : t_UnionFind_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UnionFind_T
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element = self.f0'2.roots
  
  axiom roots_map_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e: t_Element. in_domain_T self e
        -> in_domain_T self (index_Mapping_Element_Element (roots_map_T self) e)
        /\ index_Mapping_Element_Element (roots_map_T self) e
        = index_Mapping_Element_Element (roots_map_T self) (index_Mapping_Element_Element (roots_map_T self) e))
  
  function payloads_map_T (self: t_UnionFind_T) : Map.map t_Element t_T = self.f0'2.payloads
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec make_T (uf: MutBorrow.t t_UnionFind_T) (payload: t_T) (return (x: t_Element)) =
    {[@expl:make 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:make 'payload' type invariant] inv_T payload}
    (! bb0
    [ bb0 = s0 [ s0 = [ &payload_snap <- payload ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_PeanoInt) -> [ &_19 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_18 <- Root _19 payload ] s1 | s1 = bb3 ]
    | bb3 = s0
      [ s0 = new_Node_T {_18} (fun (_ret: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T) -> [ &_17 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &ptr <- _17.f0'1 ] s1
      | s1 = [ &perm <- _17.f1'1 ] s2
      | s2 = [ &_22 <- ptr ] s3
      | s3 = [ &elt <- { f0'0 = _22 } ] s4
      | s4 = into_inner_PtrOwn_Node_T {perm} (fun (_ret: t_PtrOwn_Node_T) -> [ &_29 <- _ret ] s5)
      | s5 = bb5 ]
    | bb5 = s0
      [ s0 = into_inner_ref_UnionFind_T {uf} (fun (_ret: MutBorrow.t t_UnionFind_T) -> [ &_31 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_28 <- { f0'3 = _29; f1'3 = _31 } ] s1
      | s1 = [ &perm'0 <- _28.f0'3 ] s2
      | s2 = [ &uf'0 <- _28.f1'3 ] s3
      | s3 = [ &other_elt_ptr_snap <- (such_that_Element (fun (e: t_Element) -> in_domain_T uf'0.current e
        /\ deep_model_Element e = deep_model_Element elt)).f0'0 ] s4
      | s4 = bb7 ]
    | bb7 = s0
      [ s0 = into_ghost_ptr_unit {other_elt_ptr_snap} (fun (_ret: Opaque.ptr) -> [ &_39 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = into_inner_ptr_unit {_39} (fun (_ret: Opaque.ptr) -> [ &_38 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &other_elt <- { f0'0 = _38 } ] s1
      | s1 = [ &_45 <- other_elt ] s2
      | s2 = get_ghost_Element {uf'0.current.f0'2.perms} {_45}
          (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_42 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = any [ br0 -> {_42 = None'0} (! bb16) | br1 (x0: t_PtrOwn_Node_T) -> {_42 = Some'0 x0} (! bb13) ]
    | bb13 = s0
      [ s0 = elim_Some {_42} (fun (r0: t_PtrOwn_Node_T) -> [ &other_perm <- r0 ] s1)
      | s1 = {inv_PtrOwn_Node_T perm'0}
        MutBorrow.borrow_mut <t_PtrOwn_Node_T> {perm'0}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_49 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &perm'0 <- _ret.final ] s2)
      | s2 = {inv_PtrOwn_Node_T _49.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {_49.current} {MutBorrow.get_id _49}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_48 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &_49 <- { _49 with current = _ret.final } ] s3)
      | s3 = disjoint_lemma_Node_T {_48} {other_perm} (fun (_ret: ()) -> [ &_41 <- _ret ] s4)
      | s4 = bb15 ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T'0 _49} s1
      | s1 = -{resolve_ref_PtrOwn_Node_T _49}- s2
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = {inv_FMap_Element_PtrOwn_Node_T uf'0.current.f0'2.perms}
        MutBorrow.borrow_final <t_FMap_Element_PtrOwn_Node_T> {uf'0.current.f0'2.perms}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id uf'0) 1) 2}
          (fun (_ret: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) ->
            [ &_52 <- _ret ] -{inv_FMap_Element_PtrOwn_Node_T _ret.final}-
            [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with perms = _ret.final } } } ] s1)
      | s1 = insert_ghost_Element {_52} {elt} {perm'0} (fun (_ret: t_Option_PtrOwn_Node_T) -> [ &_51 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv_Option_PtrOwn_Node_T _51} s3
      | s3 = -{resolve_Option_PtrOwn_Node_T _51}- s4
      | s4 = bb17 ]
    | bb17 = s0 [ s0 = [ &_55 <- insert_Element'0 uf'0.current.f0'2.domain elt ] s1 | s1 = bb18 ]
    | bb18 = s0
      [ s0 = [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with domain = _55 } } } ] s1
      | s1 = [ &_59 <- Map.set uf'0.current.f0'2.payloads elt payload_snap ] s2
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with payloads = _59 } } } ] s1
      | s1 = [ &_64 <- Map.set uf'0.current.f0'2.depth elt uf'0.current.f0'2.max_depth ] s2
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 = [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with depth = _64 } } } ] s1
      | s1 = [ &_69 <- Map.set uf'0.current.f0'2.roots elt elt ] s2
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with roots = _69 } } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_UnionFind_T uf'0} s2
      | s2 = -{resolve_ref_UnionFind_T uf'0}- s3
      | s3 = new_unit {_25} (fun (_ret: ()) -> [ &_24 <- _ret ] s4)
      | s4 = bb22 ]
    | bb22 = s0 [ s0 = [ &_0 <- elt ] s1 | s1 = bb23 ]
    | bb23 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind_T = uf
    | & payload: t_T = payload
    | & payload_snap: t_T = Any.any_l ()
    | & ptr: Opaque.ptr = Any.any_l ()
    | & perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _17: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T = Any.any_l ()
    | & _18: t_Node_T = Any.any_l ()
    | & _19: t_PeanoInt = Any.any_l ()
    | & elt: t_Element = Any.any_l ()
    | & _22: Opaque.ptr = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: () = Any.any_l ()
    | & perm'0: t_PtrOwn_Node_T = Any.any_l ()
    | & uf'0: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _28: tup2_PtrOwn_Node_T_ref_UnionFind_T = Any.any_l ()
    | & _29: t_PtrOwn_Node_T = Any.any_l ()
    | & _31: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & other_elt_ptr_snap: Opaque.ptr = Any.any_l ()
    | & other_elt: t_Element = Any.any_l ()
    | & _38: Opaque.ptr = Any.any_l ()
    | & _39: Opaque.ptr = Any.any_l ()
    | & _41: () = Any.any_l ()
    | & _42: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _45: t_Element = Any.any_l ()
    | & other_perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _48: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _49: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _51: t_Option_PtrOwn_Node_T = Any.any_l ()
    | & _52: MutBorrow.t t_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _55: Fset.fset t_Element = Any.any_l ()
    | & _59: Map.map t_Element t_T = Any.any_l ()
    | & _64: Map.map t_Element int = Any.any_l ()
    | & _69: Map.map t_Element t_Element = Any.any_l () ])
    [ return (result: t_Element) -> {[@expl:make ensures #0] not in_domain_T uf.current result}
      {[@expl:make ensures #1] domain_T (fin_Ghost_ref_UnionFind_T uf) = insert_Element'0 (domain_T uf.current) result}
      {[@expl:make ensures #2] roots_map_T (fin_Ghost_ref_UnionFind_T uf)
      = Map.set (roots_map_T uf.current) result result}
      {[@expl:make ensures #3] payloads_map_T (fin_Ghost_ref_UnionFind_T uf)
      = Map.set (payloads_map_T uf.current) result payload}
      (! return {result}) ]
end
module M_implementation__find_inner
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_UnionFind_T self.current /\ inv_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate invariant_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_T
  
  predicate inv_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) =
    invariant_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_Ghost_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UnionFind_T
  
  predicate inv_ref_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) =
    invariant_ref_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) = inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_UnionFind_T
  
  predicate inv_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = invariant_ref_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UnionFind_T
  
  let rec deref_Ghost_ref_UnionFind_T (self: MutBorrow.t t_UnionFind_T) (return (x: MutBorrow.t t_UnionFind_T)) =
    {[@expl:deref 'self' type invariant] inv_ref_Ghost_ref_UnionFind_T self}
    any
    [ return (result: MutBorrow.t t_UnionFind_T) -> {inv_ref_ref_UnionFind_T result}
      {result = self}
      (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 t_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    inv_FMap_Element_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Element_PtrOwn_Node_T) =
    invariant_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Element_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_ref_PtrOwn_Node_T f0'2
        end
  
  function map_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) (f: Map.map t_PtrOwn_Node_T t_PtrOwn_Node_T) : t_Option_ref_PtrOwn_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Element (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Element_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {result = map_Option_PtrOwn_Node_T (get_Element self key) (fun (v: t_PtrOwn_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T (self_: t_Option_ref_PtrOwn_Node_T) (return (x: t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T result} {Some'0 result = self_} (! return {result}) ]
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_ref_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_Ghost_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T
  
  let rec new_ref_PtrOwn_Node_T (x: t_PtrOwn_Node_T) (return (x'0: t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T x}
    any [ return (result: t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T result} {result = x} (! return {result}) ]
  
  let rec as_ref_Node_T (ptr: Opaque.ptr) (own: t_PtrOwn_Node_T) (return (x: t_Node_T)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T own}
    {[@expl:as_ref requires] ptr = ptr_Node_T own}
    any [ return (result: t_Node_T) -> {inv_ref_Node_T result} {result = val_Node_T own} (! return {result}) ]
  
  let rec elim_Link (input: t_Node_T) (ret (f0'2: t_Element)) = any
    [ good (f0'2: t_Element) -> {Link f0'2 = input} (! ret {f0'2})
    | bad -> {forall f0'2: t_Element [Link f0'2: t_Node_T]. Link f0'2 <> input} (! {false} any) ]
  
  predicate invariant_ref_Ghost_ref_UnionFind_T'0 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_Ghost_ref_UnionFind_T self.current /\ inv_Ghost_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UnionFind_T'0
  
  predicate inv_ref_Ghost_ref_UnionFind_T'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_Ghost_ref_UnionFind_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UnionFind_T'0
  
  predicate invariant_ref_ref_UnionFind_T'0 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_ref_UnionFind_T self.current /\ inv_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UnionFind_T'0
  
  predicate inv_ref_ref_UnionFind_T'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_ref_UnionFind_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_ref_UnionFind_T'0
  
  let rec deref_mut_Ghost_ref_UnionFind_T (self: MutBorrow.t (MutBorrow.t t_UnionFind_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UnionFind_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UnionFind_T'0 self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> {inv_ref_ref_UnionFind_T'0 result}
      {result = self}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UnionFind_T
  
  predicate resolve_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UnionFind_T
  
  let rec new_ref_UnionFind_T (x: MutBorrow.t t_UnionFind_T) (return (x'0: MutBorrow.t t_UnionFind_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UnionFind_T x}
    any
    [ return (result: MutBorrow.t t_UnionFind_T) -> {inv_Ghost_ref_UnionFind_T result}
      {result = x}
      (! return {result}) ]
  
  predicate invariant_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_UFInner_T self.current /\ inv_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UFInner_T
  
  predicate inv_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_UFInner_T
  
  predicate invariant_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) = inv_ref_UFInner_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UFInner_T
  
  predicate inv_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UFInner_T
  
  let rec new_ref_UFInner_T (x: MutBorrow.t t_UFInner_T) (return (x'0: MutBorrow.t t_UFInner_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UFInner_T x}
    any
    [ return (result: MutBorrow.t t_UFInner_T) -> {inv_Ghost_ref_UFInner_T result} {result = x} (! return {result}) ]
  
  predicate invariant_ref_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_Ghost_ref_UFInner_T self.current /\ inv_Ghost_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UFInner_T
  
  predicate inv_ref_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UFInner_T
  
  predicate invariant_ref_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_ref_UFInner_T self.current /\ inv_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UFInner_T
  
  predicate inv_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UFInner_T
  
  let rec deref_mut_Ghost_ref_UFInner_T (self: MutBorrow.t (MutBorrow.t t_UFInner_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UFInner_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UFInner_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> {inv_ref_ref_UFInner_T result}
      {result = self}
      (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T'0 = None'1 | Some'1 (MutBorrow.t t_PtrOwn_Node_T)
  
  predicate invariant_ref_FMap_Element_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    inv_FMap_Element_PtrOwn_Node_T self.current /\ inv_FMap_Element_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_Element_PtrOwn_Node_T'0
  
  predicate inv_ref_FMap_Element_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    invariant_ref_FMap_Element_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Element_PtrOwn_Node_T'0
  
  predicate invariant_ref_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_PtrOwn_Node_T self.current /\ inv_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T'0
  
  predicate inv_ref_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_ref_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T'0
  
  predicate inv_Option_ref_PtrOwn_Node_T'0 (_1: t_Option_ref_PtrOwn_Node_T'0)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T'0 [inv_Option_ref_PtrOwn_Node_T'0 x]. inv_Option_ref_PtrOwn_Node_T'0 x
      = match x with
        | None'1 -> true
        | Some'1 f0'2 -> inv_ref_PtrOwn_Node_T'0 f0'2
        end
  
  function len_Element (self: t_FMap_Element_PtrOwn_Node_T) : int
  
  axiom len_Element_spec: forall self: t_FMap_Element_PtrOwn_Node_T. len_Element self >= 0
  
  let rec get_mut_ghost_Element (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) (key: t_Element)
    (return (x: t_Option_ref_PtrOwn_Node_T'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv_ref_FMap_Element_PtrOwn_Node_T'0 self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T'0) -> {inv_Option_ref_PtrOwn_Node_T'0 result}
      {if contains_Element'0 self.current key then
        match result with
          | None'1 -> false
          | Some'1 r -> contains_Element'0 self.final key
          /\ index_FMap_Element_PtrOwn_Node_T self.current key = r.current
          /\ index_FMap_Element_PtrOwn_Node_T self.final key = r.final
          end
      else
        result = None'1 /\ self.current = self.final
      }
      {forall k: t_Element. k <> key -> get_Element self.current k = get_Element self.final k}
      {len_Element self.current = len_Element self.final}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T'0 (self_: t_Option_ref_PtrOwn_Node_T'0) (return (x: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T'0 self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T'0 result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UFInner_T
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_ref_PtrOwn_Node_T'0 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T'0
  
  predicate inv_Ghost_ref_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_Ghost_ref_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T'0
  
  let rec new_ref_PtrOwn_Node_T'0 (x: MutBorrow.t t_PtrOwn_Node_T) (return (x'0: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T'0 x}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T'0 result}
      {result = x}
      (! return {result}) ]
  
  predicate resolve_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_PtrOwn_Node_T
  
  predicate invariant_ref_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_Node_T) =
    inv_Node_T self.current /\ inv_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_T'0
  
  predicate inv_ref_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_Node_T) = invariant_ref_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_Node_T'0
  
  function fin_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) : t_PtrOwn_Node_T =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_PtrOwn_Node_T
  
  let rec as_mut_Node_T (ptr: Opaque.ptr) (own: MutBorrow.t t_PtrOwn_Node_T) (return (x: MutBorrow.t t_Node_T)) =
    {[@expl:as_mut 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T'0 own}
    {[@expl:as_mut requires] ptr = ptr_Node_T own.current}
    any
    [ return (result: MutBorrow.t t_Node_T) -> {inv_ref_Node_T'0 result}
      {result.current = val_Node_T own.current}
      {ptr_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = ptr_Node_T own.current}
      {val_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = result.final}
      (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Node_T (_1: t_Node_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_T [resolve_Node_T x]. resolve_Node_T x
      = match x with
        | Root x0 x1 -> resolve_T x1
        | Link x0 -> true
        end
  
  predicate resolve_ref_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_T
  
  predicate resolve_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UFInner_T
  
  predicate resolve_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = resolve_ref_UFInner_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UFInner_T
  
  predicate resolve_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = resolve_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UnionFind_T
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'0.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e: t_Element. in_domain_T self e
        -> in_domain_T self (index_Mapping_Element_Element (roots_map_T self) e)
        /\ index_Mapping_Element_Element (roots_map_T self) e
        = index_Mapping_Element_Element (roots_map_T self) (index_Mapping_Element_Element (roots_map_T self) e))
  
  function root_T (self: t_UnionFind_T) (e: t_Element) : t_Element = index_Mapping_Element_Element (roots_map_T self) e
  
  function payloads_map_T (self: t_UnionFind_T) : Map.map t_Element t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UnionFind_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) : t_UnionFind_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UnionFind_T
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find_inner_T (uf: MutBorrow.t t_UnionFind_T) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find_inner 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:find_inner requires] in_domain_T uf.current elem}
    (! bb0
    [ bb0 = s0
      [ s0 = deref_Ghost_ref_UnionFind_T {uf} (fun (_ret: MutBorrow.t t_UnionFind_T) -> [ &_23 <- _ret ] s1)
      | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_26 <- elem ] s1
      | s1 = get_ghost_Element {_23.current.f0'0.perms} {_26}
          (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap_ref_PtrOwn_Node_T {_21} (fun (_ret: t_PtrOwn_Node_T) -> [ &_20 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new_ref_PtrOwn_Node_T {_20} (fun (_ret: t_PtrOwn_Node_T) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_29 <- elem.f0 ] s1
      | s1 = as_ref_Node_T {_29} {perm} (fun (_ret: t_Node_T) -> [ &_27 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_27 = Root x0 x1} (! bb7) | br1 (x0: t_Element) -> {_27 = Link x0} (! bb8) ]
    | bb8 = s0
      [ s0 = elim_Link {_27} (fun (r0: t_Element) -> [ &e <- r0 ] s1)
      | s1 = {inv_Ghost_ref_UnionFind_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) ->
            [ &_40 <- _ret ] -{inv_Ghost_ref_UnionFind_T _ret.final}-
            [ &uf <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_ref_UnionFind_T {_40}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> [ &_39 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {inv_UnionFind_T _39.current.current}
        MutBorrow.borrow_mut <t_UnionFind_T> {_39.current.current}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_38 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_39 <- { _39 with current = { _39.current with current = _ret.final } } ] s1)
      | s1 = {inv_UnionFind_T _38.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_38.current} {MutBorrow.get_id _38}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_37 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_38 <- { _38 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_ref_UnionFind_T'0 _39} s3
      | s3 = -{resolve_ref_ref_UnionFind_T _39}- s4
      | s4 = {[@expl:type invariant] inv_ref_UnionFind_T _38} s5
      | s5 = -{resolve_ref_UnionFind_T _38}- s6
      | s6 = {inv_UnionFind_T _37.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_37.current} {MutBorrow.get_id _37}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_36 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_37 <- { _37 with current = _ret.final } ] s7)
      | s7 = new_ref_UnionFind_T {_36} (fun (_ret: MutBorrow.t t_UnionFind_T) -> [ &_35 <- _ret ] s8)
      | s8 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_ref_UnionFind_T _37} s1
      | s1 = -{resolve_ref_UnionFind_T _37}- s2
      | s2 = find_inner_T {_35} {e} (fun (_ret: t_Element) -> [ &root <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Ghost_ref_UnionFind_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) ->
            [ &_44 <- _ret ] -{inv_Ghost_ref_UnionFind_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UnionFind_T {_44}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> [ &_43 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = {inv_UFInner_T _43.current.current.f0'0}
        MutBorrow.borrow_mut <t_UFInner_T> {_43.current.current.f0'0}
          (fun (_ret: MutBorrow.t t_UFInner_T) ->
            [ &__temp <- _ret ] -{inv_UFInner_T _ret.final}-
            [ &_43 <- { _43 with current = { _43.current with current = { f0'0 = _ret.final } } } ] s1)
      | s1 = new_ref_UFInner_T {__temp} (fun (_ret: MutBorrow.t t_UFInner_T) -> [ &uf'0 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {[@expl:assertion] index_Mapping_Element_Int uf'0.current.depth elem
        < index_Mapping_Element_Int uf'0.current.depth root}
        s1
      | s1 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_58 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_ref_UFInner_T {_58}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_57 <- _ret ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = [ &_60 <- elem ] s1
      | s1 = {inv_FMap_Element_PtrOwn_Node_T _57.current.current.perms}
        MutBorrow.borrow_mut <t_FMap_Element_PtrOwn_Node_T> {_57.current.current.perms}
          (fun (_ret: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) ->
            [ &_56 <- _ret ] -{inv_FMap_Element_PtrOwn_Node_T _ret.final}-
            [ &_57 <- { _57 with current = { _57.current with current = { _57.current.current with perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost_Element {_56} {_60} (fun (_ret: t_Option_ref_PtrOwn_Node_T'0) -> [ &_55 <- _ret ] s3)
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = unwrap_ref_PtrOwn_Node_T'0 {_55} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &_54 <- _ret ] s1)
      | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv_ref_ref_UFInner_T _57} s1
      | s1 = -{resolve_ref_ref_UFInner_T _57}- s2
      | s2 = {inv_PtrOwn_Node_T _54.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {_54.current} {MutBorrow.get_id _54}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_53 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &_54 <- { _54 with current = _ret.final } ] s3)
      | s3 = new_ref_PtrOwn_Node_T'0 {_53} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &mut_perm <- _ret ] s4)
      | s4 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T'0 _54} s1
      | s1 = -{resolve_ref_PtrOwn_Node_T _54}- s2
      | s2 = [ &_62 <- Link root ] s3
      | s3 = [ &_65 <- elem.f0 ] s4
      | s4 = as_mut_Node_T {_65} {mut_perm} (fun (_ret: MutBorrow.t t_Node_T) -> [ &_64 <- _ret ] s5)
      | s5 = bb20 ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv_Node_T _64.current} s1
      | s1 = -{resolve_Node_T _64.current}- s2
      | s2 = [ &_64 <- { _64 with current = _62 } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_T'0 _64} s4
      | s4 = -{resolve_ref_Node_T _64}- s5
      | s5 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s6
      | s6 = -{resolve_Ghost_ref_UFInner_T uf'0}- s7
      | s7 = {[@expl:type invariant] inv_ref_ref_UnionFind_T'0 _43} s8
      | s8 = -{resolve_ref_ref_UnionFind_T _43}- s9
      | s9 = {[@expl:type invariant] inv_Ghost_ref_UnionFind_T uf} s10
      | s10 = -{resolve_Ghost_ref_UnionFind_T uf}- s11
      | s11 = bb22 ]
    | bb22 = s0 [ s0 = [ &_0 <- root ] s1 | s1 = bb23 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_ref_UnionFind_T uf} s1
      | s1 = -{resolve_Ghost_ref_UnionFind_T uf}- s2
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- elem ] s1 | s1 = bb23 ]
    | bb23 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind_T = uf
    | & elem: t_Element = elem
    | & perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _20: t_PtrOwn_Node_T = Any.any_l ()
    | & _21: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _23: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _26: t_Element = Any.any_l ()
    | & _27: t_Node_T = Any.any_l ()
    | & _29: Opaque.ptr = Any.any_l ()
    | & e: t_Element = Any.any_l ()
    | & root: t_Element = Any.any_l ()
    | & _35: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _36: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _37: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _38: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _39: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & _40: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & __temp: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _43: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & _44: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & mut_perm: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _53: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _54: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _55: t_Option_ref_PtrOwn_Node_T'0 = Any.any_l ()
    | & _56: MutBorrow.t t_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _57: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _58: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _60: t_Element = Any.any_l ()
    | & _62: t_Node_T = Any.any_l ()
    | & _64: MutBorrow.t t_Node_T = Any.any_l ()
    | & _65: Opaque.ptr = Any.any_l () ]
    [ find_inner_T (uf: MutBorrow.t t_UnionFind_T) (elem: t_Element) (_ret (_r: t_Element)) ->
    {[@expl:function variant] well_founded_relation_Int function_variant (uf.current.f0'0.max_depth
      - index_Mapping_Element_Int uf.current.f0'0.depth elem)}
      find_inner_T {uf} {elem} (_ret) ]
    [ function_variant: int = uf.current.f0'0.max_depth - index_Mapping_Element_Int uf.current.f0'0.depth elem ])
    [ return (result: t_Element) -> {[@expl:find_inner ensures #0] result = root_T uf.current elem}
      {[@expl:find_inner ensures #1] unchanged_T uf}
      {[@expl:find_inner ensures #2] (fin_Ghost_ref_UnionFind_T uf).f0'0.depth = uf.current.f0'0.depth}
      {[@expl:find_inner ensures #3] index_Mapping_Element_Int uf.current.f0'0.depth result
      >= index_Mapping_Element_Int uf.current.f0'0.depth elem}
      (! return {result}) ]
end
module M_implementation__find
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use mach.int.Int
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_UnionFind_T self.current /\ inv_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate invariant_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_T
  
  predicate inv_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) =
    invariant_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_T
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'0.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e: t_Element. in_domain_T self e
        -> in_domain_T self (index_Mapping_Element_Element (roots_map_T self) e)
        /\ index_Mapping_Element_Element (roots_map_T self) e
        = index_Mapping_Element_Element (roots_map_T self) (index_Mapping_Element_Element (roots_map_T self) e))
  
  function root_T (self: t_UnionFind_T) (e: t_Element) : t_Element = index_Mapping_Element_Element (roots_map_T self) e
  
  function payloads_map_T (self: t_UnionFind_T) : Map.map t_Element t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UnionFind_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) : t_UnionFind_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UnionFind_T
  
  let rec find_inner_T (uf: MutBorrow.t t_UnionFind_T) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find_inner 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:find_inner requires] in_domain_T uf.current elem}
    any
    [ return (result: t_Element) -> {result = root_T uf.current elem}
      {unchanged_T uf}
      {(fin_Ghost_ref_UnionFind_T uf).f0'0.depth = uf.current.f0'0.depth}
      {index_Mapping_Element_Int uf.current.f0'0.depth result >= index_Mapping_Element_Int uf.current.f0'0.depth elem}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find_T (uf: MutBorrow.t t_UnionFind_T) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:find requires] in_domain_T uf.current elem}
    (! bb0
    [ bb0 = s0 [ s0 = find_inner_T {uf} {elem} (fun (_ret: t_Element) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ]
    [ & _0: t_Element = Any.any_l () | & uf: MutBorrow.t t_UnionFind_T = uf | & elem: t_Element = elem ])
    [ return (result: t_Element) -> {[@expl:find ensures #0] result = root_T uf.current elem}
      {[@expl:find ensures #1] unchanged_T uf}
      (! return {result}) ]
end
module M_implementation__get
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) = inv_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate invariant_Ghost_ref_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) = inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_T
  
  predicate inv_Ghost_ref_UnionFind_T [@inline:trivial] (_1: t_UnionFind_T) = invariant_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_Ghost_ref_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) = inv_Ghost_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UnionFind_T
  
  predicate inv_ref_Ghost_ref_UnionFind_T [@inline:trivial] (_1: t_UnionFind_T) = invariant_ref_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_ref_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) = inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_UnionFind_T
  
  predicate inv_ref_ref_UnionFind_T [@inline:trivial] (_1: t_UnionFind_T) = invariant_ref_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UnionFind_T
  
  let rec deref_Ghost_ref_UnionFind_T (self: t_UnionFind_T) (return (x: t_UnionFind_T)) =
    {[@expl:deref 'self' type invariant] inv_ref_Ghost_ref_UnionFind_T self}
    any [ return (result: t_UnionFind_T) -> {inv_ref_ref_UnionFind_T result} {result = self} (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 t_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    inv_FMap_Element_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Element_PtrOwn_Node_T) =
    invariant_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Element_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_ref_PtrOwn_Node_T f0'2
        end
  
  function map_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) (f: Map.map t_PtrOwn_Node_T t_PtrOwn_Node_T) : t_Option_ref_PtrOwn_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Element (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Element_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {result = map_Option_PtrOwn_Node_T (get_Element self key) (fun (v: t_PtrOwn_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T (self_: t_Option_ref_PtrOwn_Node_T) (return (x: t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T result} {Some'0 result = self_} (! return {result}) ]
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_ref_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_Ghost_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T
  
  let rec new_ref_PtrOwn_Node_T (x: t_PtrOwn_Node_T) (return (x'0: t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T x}
    any [ return (result: t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T result} {result = x} (! return {result}) ]
  
  let rec as_ref_Node_T (ptr: Opaque.ptr) (own: t_PtrOwn_Node_T) (return (x: t_Node_T)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T own}
    {[@expl:as_ref requires] ptr = ptr_Node_T own}
    any [ return (result: t_Node_T) -> {inv_ref_Node_T result} {result = val_Node_T own} (! return {result}) ]
  
  let rec elim_Root (input: t_Node_T) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [Root rank payload: t_Node_T]. Root rank payload <> input}
      (! {false}
      any) ]
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'0.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e: t_Element. in_domain_T self e
        -> in_domain_T self (index_Mapping_Element_Element (roots_map_T self) e)
        /\ index_Mapping_Element_Element (roots_map_T self) e
        = index_Mapping_Element_Element (roots_map_T self) (index_Mapping_Element_Element (roots_map_T self) e))
  
  function root_T (self: t_UnionFind_T) (e: t_Element) : t_Element = index_Mapping_Element_Element (roots_map_T self) e
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  function payloads_map_T (self: t_UnionFind_T) : Map.map t_Element t_T = self.f0'0.payloads
  
  function payload_T (self: t_UnionFind_T) (e: t_Element) : t_T = index_Mapping_Element_T (payloads_map_T self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_T (uf: t_UnionFind_T) (elem: t_Element) (return (x: t_T)) =
    {[@expl:get 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:get requires #0] in_domain_T uf elem}
    {[@expl:get requires #1] root_T uf elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref_Ghost_ref_UnionFind_T {uf} (fun (_ret: t_UnionFind_T) -> [ &_16 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_19 <- elem ] s1
      | s1 = get_ghost_Element {_16.f0'0.perms} {_19} (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_14 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap_ref_PtrOwn_Node_T {_14} (fun (_ret: t_PtrOwn_Node_T) -> [ &_13 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new_ref_PtrOwn_Node_T {_13} (fun (_ret: t_PtrOwn_Node_T) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_22 <- elem.f0 ] s1
      | s1 = as_ref_Node_T {_22} {perm} (fun (_ret: t_Node_T) -> [ &_20 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_20 = Root x0 x1} (! bb8) | br1 (x0: t_Element) -> {_20 = Link x0} (! bb6) ]
    | bb6 = {false} any
    | bb8 = s0
      [ s0 = elim_Root {_20} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &payload <- rpayload ] s1)
      | s1 = [ &_0 <- payload ] s2
      | s2 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & uf: t_UnionFind_T = uf
    | & elem: t_Element = elem
    | & perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _13: t_PtrOwn_Node_T = Any.any_l ()
    | & _14: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _16: t_UnionFind_T = Any.any_l ()
    | & _19: t_Element = Any.any_l ()
    | & _20: t_Node_T = Any.any_l ()
    | & _22: Opaque.ptr = Any.any_l ()
    | & payload: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:get result type invariant] inv_ref_T result}
      {[@expl:get ensures] result = payload_T uf elem}
      (! return {result}) ]
end
module M_implementation__equiv
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_UnionFind_T self.current /\ inv_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate invariant_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_T
  
  predicate inv_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) =
    invariant_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_Ghost_ref_UnionFind_T self.current /\ inv_Ghost_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UnionFind_T
  
  predicate inv_ref_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_ref_UnionFind_T self.current /\ inv_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UnionFind_T
  
  predicate inv_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UnionFind_T
  
  let rec deref_mut_Ghost_ref_UnionFind_T (self: MutBorrow.t (MutBorrow.t t_UnionFind_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UnionFind_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UnionFind_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> {inv_ref_ref_UnionFind_T result}
      {result = self}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UnionFind_T
  
  predicate resolve_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UnionFind_T
  
  let rec new_ref_UnionFind_T (x: MutBorrow.t t_UnionFind_T) (return (x'0: MutBorrow.t t_UnionFind_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UnionFind_T x}
    any
    [ return (result: MutBorrow.t t_UnionFind_T) -> {inv_Ghost_ref_UnionFind_T result}
      {result = x}
      (! return {result}) ]
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'0.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e: t_Element. in_domain_T self e
        -> in_domain_T self (index_Mapping_Element_Element (roots_map_T self) e)
        /\ index_Mapping_Element_Element (roots_map_T self) e
        = index_Mapping_Element_Element (roots_map_T self) (index_Mapping_Element_Element (roots_map_T self) e))
  
  function root_T (self: t_UnionFind_T) (e: t_Element) : t_Element = index_Mapping_Element_Element (roots_map_T self) e
  
  function payloads_map_T (self: t_UnionFind_T) : Map.map t_Element t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UnionFind_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  let rec find_T (uf: MutBorrow.t t_UnionFind_T) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:find requires] in_domain_T uf.current elem}
    any [ return (result: t_Element) -> {result = root_T uf.current elem} {unchanged_T uf} (! return {result}) ]
  
  function deep_model_ref_Element [@inline:trivial] (self: t_Element) : UInt64.t = deep_model_Element self
  
  meta "rewrite_def" function deep_model_ref_Element
  
  let rec eq_Element (self: t_Element) (other: t_Element) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Element self = deep_model_ref_Element other)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec equiv_T (uf: MutBorrow.t t_UnionFind_T) (e1: t_Element) (e2: t_Element) (return (x: bool)) =
    {[@expl:equiv 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:equiv requires #0] in_domain_T uf.current e1}
    {[@expl:equiv requires #1] in_domain_T uf.current e2}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Ghost_ref_UnionFind_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) ->
            [ &_22 <- _ret ] -{inv_Ghost_ref_UnionFind_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UnionFind_T {_22}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> [ &_21 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_UnionFind_T _21.current.current}
        MutBorrow.borrow_mut <t_UnionFind_T> {_21.current.current}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_20 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_21 <- { _21 with current = { _21.current with current = _ret.final } } ] s1)
      | s1 = {inv_UnionFind_T _20.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_19 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_ref_UnionFind_T _21} s3
      | s3 = -{resolve_ref_ref_UnionFind_T _21}- s4
      | s4 = {[@expl:type invariant] inv_ref_UnionFind_T _20} s5
      | s5 = -{resolve_ref_UnionFind_T _20}- s6
      | s6 = {inv_UnionFind_T _19.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_18 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s7)
      | s7 = new_ref_UnionFind_T {_18} (fun (_ret: MutBorrow.t t_UnionFind_T) -> [ &_17 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_UnionFind_T _19} s1
      | s1 = -{resolve_ref_UnionFind_T _19}- s2
      | s2 = find_T {_17} {e1} (fun (_ret: t_Element) -> [ &r1 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0 [ s0 = find_T {uf} {e2} (fun (_ret: t_Element) -> [ &r2 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = eq_Element {r1} {r2} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind_T = uf
    | & e1: t_Element = e1
    | & e2: t_Element = e2
    | & r1: t_Element = Any.any_l ()
    | & _17: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _18: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _19: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _20: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & r2: t_Element = Any.any_l () ])
    [ return (result: bool) -> {[@expl:equiv ensures #0] result = (root_T uf.current e1 = root_T uf.current e2)}
      {[@expl:equiv ensures #1] unchanged_T uf}
      (! return {result}) ]
end
module M_implementation__link
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use creusot.int.Int64
  use int.MinMax
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  function deep_model_ref_Element [@inline:trivial] (self: t_Element) : UInt64.t = deep_model_Element self
  
  meta "rewrite_def" function deep_model_ref_Element
  
  let rec eq_Element (self: t_Element) (other: t_Element) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Element self = deep_model_ref_Element other)}
      (! return {result}) ]
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_UnionFind_T self.current /\ inv_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate invariant_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_T
  
  predicate inv_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) =
    invariant_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_T
  
  predicate resolve_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UnionFind_T
  
  predicate resolve_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = resolve_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_Ghost_ref_UnionFind_T self.current /\ inv_Ghost_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UnionFind_T
  
  predicate inv_ref_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_ref_UnionFind_T self.current /\ inv_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UnionFind_T
  
  predicate inv_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UnionFind_T
  
  let rec deref_mut_Ghost_ref_UnionFind_T (self: MutBorrow.t (MutBorrow.t t_UnionFind_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UnionFind_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UnionFind_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> {inv_ref_ref_UnionFind_T result}
      {result = self}
      (! return {result}) ]
  
  predicate invariant_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_UFInner_T self.current /\ inv_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UFInner_T
  
  predicate inv_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_UFInner_T
  
  predicate invariant_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) = inv_ref_UFInner_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UFInner_T
  
  predicate inv_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UFInner_T
  
  let rec new_ref_UFInner_T (x: MutBorrow.t t_UFInner_T) (return (x'0: MutBorrow.t t_UFInner_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UFInner_T x}
    any
    [ return (result: MutBorrow.t t_UFInner_T) -> {inv_Ghost_ref_UFInner_T result} {result = x} (! return {result}) ]
  
  predicate invariant_ref_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_Ghost_ref_UFInner_T self.current /\ inv_Ghost_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UFInner_T
  
  predicate inv_ref_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UFInner_T
  
  predicate invariant_ref_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_ref_UFInner_T self.current /\ inv_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UFInner_T
  
  predicate inv_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UFInner_T
  
  let rec deref_mut_Ghost_ref_UFInner_T (self: MutBorrow.t (MutBorrow.t t_UFInner_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UFInner_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UFInner_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> {inv_ref_ref_UFInner_T result}
      {result = self}
      (! return {result}) ]
  
  type tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T = {
    f0'2: MutBorrow.t t_PtrOwn_Node_T;
    f1'2: MutBorrow.t t_FMap_Element_PtrOwn_Node_T }
  
  predicate invariant_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    inv_FMap_Element_PtrOwn_Node_T self.current /\ inv_FMap_Element_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    invariant_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Element_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_PtrOwn_Node_T self.current /\ inv_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T) =
    inv_ref_PtrOwn_Node_T _1.f0'2 /\ inv_ref_FMap_Element_PtrOwn_Node_T _1.f1'2
  
  meta "rewrite_def" predicate inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T
  
  function len_Element (self: t_FMap_Element_PtrOwn_Node_T) : int
  
  axiom len_Element_spec: forall self: t_FMap_Element_PtrOwn_Node_T. len_Element self >= 0
  
  function remove_Element (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_FMap_Element_PtrOwn_Node_T
  
  axiom remove_Element_spec:
    forall self: t_FMap_Element_PtrOwn_Node_T, k: t_Element. view_FMap_Element_PtrOwn_Node_T (remove_Element self k)
      = Map.set (view_FMap_Element_PtrOwn_Node_T self) k (None)
  
  axiom remove_Element_spec'0:
    forall self: t_FMap_Element_PtrOwn_Node_T, k: t_Element. len_Element (remove_Element self k)
      = (if contains_Element'0 self k then len_Element self - 1 else len_Element self)
  
  function insert_Element (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) (v: t_PtrOwn_Node_T) : t_FMap_Element_PtrOwn_Node_T
  
  axiom insert_Element_spec:
    forall self: t_FMap_Element_PtrOwn_Node_T, k: t_Element, v: t_PtrOwn_Node_T. view_FMap_Element_PtrOwn_Node_T (insert_Element self k v)
      = Map.set (view_FMap_Element_PtrOwn_Node_T self) k (Some v)
  
  axiom insert_Element_spec'0:
    forall self: t_FMap_Element_PtrOwn_Node_T, k: t_Element, v: t_PtrOwn_Node_T. len_Element (insert_Element self k v)
      = (if contains_Element'0 self k then len_Element self else len_Element self + 1)
  
  let rec split_mut_ghost_Element (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) (key: t_Element)
    (return (x: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T)) =
    {[@expl:split_mut_ghost 'self' type invariant] inv_ref_FMap_Element_PtrOwn_Node_T self}
    {[@expl:split_mut_ghost requires] contains_Element'0 self.current key}
    any
    [ return (result: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T) ->
    {inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T result}
      {result.f1'2.current = remove_Element self.current key}
      {index_FMap_Element_PtrOwn_Node_T self.current key = result.f0'2.current
      /\ self.final = insert_Element result.f1'2.final key result.f0'2.final}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UFInner_T
  
  predicate invariant_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T) =
    inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T) =
    invariant_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T
  
  let rec new_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T
    (x: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T)
    (return (x'0: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T x}
    any
    [ return (result: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T) ->
    {inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T result}
      {result = x}
      (! return {result}) ]
  
  type tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T = {
    f0'3: MutBorrow.t t_PtrOwn_Node_T;
    f1'3: MutBorrow.t t_FMap_Element_PtrOwn_Node_T }
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_ref_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_Ghost_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T
  
  predicate invariant_Ghost_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    inv_ref_FMap_Element_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    invariant_Ghost_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T) =
    inv_Ghost_ref_PtrOwn_Node_T _1.f0'3 /\ inv_Ghost_ref_FMap_Element_PtrOwn_Node_T _1.f1'3
  
  meta "rewrite_def" predicate inv_tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T
  
  let rec split_ref_PtrOwn_Node_T (self: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T)
    (return (x: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T)) =
    {[@expl:split 'self' type invariant] inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T self}
    any
    [ return (result: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T) ->
    {inv_tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T result}
      {self.f0'2 = result.f0'3}
      {self.f1'2 = result.f1'3}
      (! return {result}) ]
  
  predicate invariant_ref_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_Node_T) =
    inv_Node_T self.current /\ inv_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_T'0
  
  predicate inv_ref_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_Node_T) = invariant_ref_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_Node_T'0
  
  function fin_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) : t_PtrOwn_Node_T =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_PtrOwn_Node_T
  
  let rec as_mut_Node_T (ptr: Opaque.ptr) (own: MutBorrow.t t_PtrOwn_Node_T) (return (x: MutBorrow.t t_Node_T)) =
    {[@expl:as_mut 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T own}
    {[@expl:as_mut requires] ptr = ptr_Node_T own.current}
    any
    [ return (result: MutBorrow.t t_Node_T) -> {inv_ref_Node_T'0 result}
      {result.current = val_Node_T own.current}
      {ptr_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = ptr_Node_T own.current}
      {val_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_T
  
  predicate invariant_ref_Ghost_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) =
    inv_Ghost_ref_FMap_Element_PtrOwn_Node_T self.current /\ inv_Ghost_ref_FMap_Element_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_ref_Ghost_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) =
    invariant_ref_Ghost_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_FMap_Element_PtrOwn_Node_T
  
  predicate invariant_ref_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) =
    inv_ref_FMap_Element_PtrOwn_Node_T self.current /\ inv_ref_FMap_Element_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_FMap_Element_PtrOwn_Node_T
  
  predicate inv_ref_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) =
    invariant_ref_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_FMap_Element_PtrOwn_Node_T
  
  let rec deref_mut_Ghost_ref_FMap_Element_PtrOwn_Node_T (self: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T))
    (return (x: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_FMap_Element_PtrOwn_Node_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) ->
    {inv_ref_ref_FMap_Element_PtrOwn_Node_T result}
      {result = self}
      (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 (MutBorrow.t t_PtrOwn_Node_T)
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'4 -> inv_ref_PtrOwn_Node_T f0'4
        end
  
  let rec get_mut_ghost_Element (self: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) (key: t_Element)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv_ref_FMap_Element_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {if contains_Element'0 self.current key then
        match result with
          | None'0 -> false
          | Some'0 r -> contains_Element'0 self.final key
          /\ index_FMap_Element_PtrOwn_Node_T self.current key = r.current
          /\ index_FMap_Element_PtrOwn_Node_T self.final key = r.final
          end
      else
        result = None'0 /\ self.current = self.final
      }
      {forall k: t_Element. k <> key -> get_Element self.current k = get_Element self.final k}
      {len_Element self.current = len_Element self.final}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T (self_: t_Option_ref_PtrOwn_Node_T) (return (x: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_FMap_Element_PtrOwn_Node_T
  
  predicate resolve_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_PtrOwn_Node_T
  
  let rec new_ref_PtrOwn_Node_T (x: MutBorrow.t t_PtrOwn_Node_T) (return (x'0: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T x}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T result}
      {result = x}
      (! return {result}) ]
  
  let rec elim_Root (input: t_Node_T) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [Root rank payload: t_Node_T]. Root rank payload <> input}
      (! {false}
      any) ]
  
  predicate resolve_ref_PeanoInt [@inline:trivial] (_1: MutBorrow.t t_PeanoInt) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_PeanoInt
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'1
  
  meta "rewrite_def" function view_PeanoInt
  
  let rec lt_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = any
    [ return (result: bool) -> {result = UInt64.lt (view_PeanoInt self) (view_PeanoInt other)} (! return {result}) ]
  
  predicate resolve_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMap_Element_PtrOwn_Node_T
  
  predicate resolve_Ghost_ref_FMap_Element_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) =
    resolve_ref_FMap_Element_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_FMap_Element_PtrOwn_Node_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Node_T (_1: t_Node_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_T [resolve_Node_T x]. resolve_Node_T x
      = match x with
        | Root x0 x1 -> resolve_T x1
        | Link x0 -> true
        end
  
  predicate resolve_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UFInner_T
  
  predicate resolve_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = resolve_ref_UFInner_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UFInner_T
  
  predicate resolve_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UnionFind_T
  
  let rec new_unit (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  let rec eq_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self = other)} (! return {result}) ]
  
  let rec incr (self: t_PeanoInt) (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {UInt64.t'int result.f0'1 = UInt64.t'int self.f0'1 + 1} (! return {result}) ]
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'0.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e: t_Element. in_domain_T self e
        -> in_domain_T self (index_Mapping_Element_Element (roots_map_T self) e)
        /\ index_Mapping_Element_Element (roots_map_T self) e
        = index_Mapping_Element_Element (roots_map_T self) (index_Mapping_Element_Element (roots_map_T self) e))
  
  function root_T (self: t_UnionFind_T) (e: t_Element) : t_Element = index_Mapping_Element_Element (roots_map_T self) e
  
  predicate domain_unchanged_T (self: MutBorrow.t t_UnionFind_T) = domain_T self.current = domain_T self.final
  
  function payloads_map_T (self: t_UnionFind_T) : Map.map t_Element t_T = self.f0'0.payloads
  
  predicate payloads_unchanged_T (self: MutBorrow.t t_UnionFind_T) =
    payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) : t_UnionFind_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UnionFind_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec link_T (uf: MutBorrow.t t_UnionFind_T) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:link 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:link requires #0] in_domain_T uf.current x /\ in_domain_T uf.current y}
    {[@expl:link requires #1] root_T uf.current x = x /\ root_T uf.current y = y}
    (! bb0
    [ bb0 = s0 [ s0 = eq_Element {x} {y} (fun (_ret: bool) -> [ &_25 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_25 = false} (! bb3) | br1 -> {_25} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_ref_UnionFind_T uf} s1
      | s1 = -{resolve_Ghost_ref_UnionFind_T uf}- s2
      | s2 = [ &_0 <- x ] s3
      | s3 = bb51 ]
    | bb3 = s0
      [ s0 = {inv_Ghost_ref_UnionFind_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) ->
            [ &_31 <- _ret ] -{inv_Ghost_ref_UnionFind_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UnionFind_T {_31}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> [ &_30 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv_UFInner_T _30.current.current.f0'0}
        MutBorrow.borrow_mut <t_UFInner_T> {_30.current.current.f0'0}
          (fun (_ret: MutBorrow.t t_UFInner_T) ->
            [ &__temp <- _ret ] -{inv_UFInner_T _ret.final}-
            [ &_30 <- { _30 with current = { _30.current with current = { f0'0 = _ret.final } } } ] s1)
      | s1 = new_ref_UFInner_T {__temp} (fun (_ret: MutBorrow.t t_UFInner_T) -> [ &uf'0 <- _ret ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_41 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_41}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_40 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_43 <- x ] s1
      | s1 = {inv_FMap_Element_PtrOwn_Node_T _40.current.current.perms}
        MutBorrow.borrow_mut <t_FMap_Element_PtrOwn_Node_T> {_40.current.current.perms}
          (fun (_ret: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) ->
            [ &_39 <- _ret ] -{inv_FMap_Element_PtrOwn_Node_T _ret.final}-
            [ &_40 <- { _40 with current = { _40.current with current = { _40.current.current with perms = _ret.final } } } ]
            s2)
      | s2 = split_mut_ghost_Element {_39} {_43}
          (fun (_ret: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T) -> [ &_38 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_ref_ref_UFInner_T _40} s1
      | s1 = -{resolve_ref_ref_UFInner_T _40}- s2
      | s2 = new_tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T {_38}
          (fun (_ret: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T) -> [ &_37 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = s0
      [ s0 = split_ref_PtrOwn_Node_T {_37}
          (fun (_ret: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T) -> [ &_36 <- _ret ] s1)
      | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &perm_x <- _36.f0'3 ] s1
      | s1 = [ &m <- _36.f1'3 ] s2
      | s2 = [ &_46 <- x.f0 ] s3
      | s3 = as_mut_Node_T {_46} {perm_x} (fun (_ret: MutBorrow.t t_Node_T) -> [ &_45 <- _ret ] s4)
      | s4 = bb10 ]
    | bb10 = s0
      [ s0 = {inv_Node_T _45.current}
        MutBorrow.borrow_final <t_Node_T> {_45.current} {MutBorrow.get_id _45}
          (fun (_ret: MutBorrow.t t_Node_T) ->
            [ &bx <- _ret ] -{inv_Node_T _ret.final}-
            [ &_45 <- { _45 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 _45} s2
      | s2 = -{resolve_ref_Node_T _45}- s3
      | s3 = [ &_51 <- y.f0 ] s4
      | s4 = {inv_Ghost_ref_FMap_Element_PtrOwn_Node_T m}
        MutBorrow.borrow_mut <MutBorrow.t t_FMap_Element_PtrOwn_Node_T> {m}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) ->
            [ &_60 <- _ret ] -{inv_Ghost_ref_FMap_Element_PtrOwn_Node_T _ret.final}-
            [ &m <- _ret.final ] s5)
      | s5 = deref_mut_Ghost_ref_FMap_Element_PtrOwn_Node_T {_60}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T)) -> [ &_59 <- _ret ] s6)
      | s6 = bb11 ]
    | bb11 = s0
      [ s0 = [ &_62 <- y ] s1
      | s1 = {inv_FMap_Element_PtrOwn_Node_T _59.current.current}
        MutBorrow.borrow_mut <t_FMap_Element_PtrOwn_Node_T> {_59.current.current}
          (fun (_ret: MutBorrow.t t_FMap_Element_PtrOwn_Node_T) ->
            [ &_58 <- _ret ] -{inv_FMap_Element_PtrOwn_Node_T _ret.final}-
            [ &_59 <- { _59 with current = { _59.current with current = _ret.final } } ] s2)
      | s2 = get_mut_ghost_Element {_58} {_62} (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_57 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = unwrap_ref_PtrOwn_Node_T {_57} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &_56 <- _ret ] s1)
      | s1 = bb13 ]
    | bb13 = s0
      [ s0 = {inv_PtrOwn_Node_T _56.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {_56.current} {MutBorrow.get_id _56}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_55 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &_56 <- { _56 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_ref_FMap_Element_PtrOwn_Node_T _59} s2
      | s2 = -{resolve_ref_ref_FMap_Element_PtrOwn_Node_T _59}- s3
      | s3 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T _56} s4
      | s4 = -{resolve_ref_PtrOwn_Node_T _56}- s5
      | s5 = {inv_PtrOwn_Node_T _55.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {_55.current} {MutBorrow.get_id _55}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_54 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &_55 <- { _55 with current = _ret.final } ] s6)
      | s6 = new_ref_PtrOwn_Node_T {_54} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &_53 <- _ret ] s7)
      | s7 = bb14 ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T _55} s1
      | s1 = -{resolve_ref_PtrOwn_Node_T _55}- s2
      | s2 = as_mut_Node_T {_51} {_53} (fun (_ret: MutBorrow.t t_Node_T) -> [ &_50 <- _ret ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = {inv_Node_T _50.current}
        MutBorrow.borrow_final <t_Node_T> {_50.current} {MutBorrow.get_id _50}
          (fun (_ret: MutBorrow.t t_Node_T) ->
            [ &by' <- _ret ] -{inv_Node_T _ret.final}-
            [ &_50 <- { _50 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 _50} s2
      | s2 = -{resolve_ref_Node_T _50}- s3
      | s3 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {bx.current = Root x0 x1} (! bb18)
        | br1 (x0: t_Element) -> {bx.current = Link x0} (! bb16) ] ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s1
      | s1 = -{resolve_ref_Node_T by'}- s2
      | s2 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s3
      | s3 = -{resolve_ref_Node_T bx}- s4
      | s4 = {false} any ]
    | bb18 = s0
      [ s0 = elim_Root {bx.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &rx <- _ret ] [ &bx <- { bx with current = Root _ret.final rpayload } ] s1))
      | s1 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {by'.current = Root x0 x1} (! bb21)
        | br1 (x0: t_Element) -> {by'.current = Link x0} (! bb19) ] ]
    | bb19 = s0
      [ s0 = -{resolve_ref_PeanoInt rx}- s1
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s2
      | s2 = -{resolve_ref_Node_T by'}- s3
      | s3 = {false} any ]
    | bb21 = s0
      [ s0 = elim_Root {by'.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &ry <- _ret ] [ &by' <- { by' with current = Root _ret.final rpayload } ] s1))
      | s1 = lt_PeanoInt {rx.current} {ry.current} (fun (_ret: bool) -> [ &_69 <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = any [ br0 -> {_69 = false} (! bb34) | br1 -> {_69} (! bb23) ]
    | bb23 = s0
      [ s0 = -{resolve_ref_PeanoInt ry}- s1
      | s1 = -{resolve_ref_PeanoInt rx}- s2
      | s2 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s3
      | s3 = -{resolve_ref_Node_T by'}- s4
      | s4 = {[@expl:type invariant] inv_Ghost_ref_FMap_Element_PtrOwn_Node_T m} s5
      | s5 = -{resolve_Ghost_ref_FMap_Element_PtrOwn_Node_T m}- s6
      | s6 = [ &_72 <- Link y ] s7
      | s7 = bb24 ]
    | bb24 = s0
      [ s0 = {[@expl:type invariant] inv_Node_T bx.current} s1
      | s1 = -{resolve_Node_T bx.current}- s2
      | s2 = [ &bx <- { bx with current = _72 } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s4
      | s4 = -{resolve_ref_Node_T bx}- s5
      | s5 = bb26 ]
    | bb26 = s0
      [ s0 = [ &_76 <- fun (z: t_Element) -> if index_Mapping_Element_Element uf'0.current.roots z = x then
          y
        else
          index_Mapping_Element_Element uf'0.current.roots z
         ] s1
      | s1 = bb27 ]
    | bb27 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_82 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_82}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_81 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0
      [ s0 = [ &_81 <- { _81 with current = { _81.current with current = { _81.current.current with roots = _76 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _81} s2
      | s2 = -{resolve_ref_ref_UFInner_T _81}- s3
      | s3 = [ &_83 <- uf'0.current.max_depth + 1 ] s4
      | s4 = bb29 ]
    | bb29 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_87 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_87}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_86 <- _ret ] s2)
      | s2 = bb30 ]
    | bb30 = s0
      [ s0 =
        [ &_86 <- { _86 with current = { _86.current with current = { _86.current.current with max_depth = _83 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _86} s2
      | s2 = -{resolve_ref_ref_UFInner_T _86}- s3
      | s3 = [ &_88 <- Map.set uf'0.current.depth y (1
        + MinMax.max (index_Mapping_Element_Int uf'0.current.depth x) (index_Mapping_Element_Int uf'0.current.depth y)) ]
        s4
      | s4 = bb31 ]
    | bb31 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_94 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_94}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_93 <- _ret ] s2)
      | s2 = bb32 ]
    | bb32 = s0
      [ s0 = [ &_93 <- { _93 with current = { _93.current with current = { _93.current.current with depth = _88 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _93} s2
      | s2 = -{resolve_ref_ref_UFInner_T _93}- s3
      | s3 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s4
      | s4 = -{resolve_Ghost_ref_UFInner_T uf'0}- s5
      | s5 = {[@expl:type invariant] inv_ref_ref_UnionFind_T _30} s6
      | s6 = -{resolve_ref_ref_UnionFind_T _30}- s7
      | s7 = {[@expl:type invariant] inv_Ghost_ref_UnionFind_T uf} s8
      | s8 = -{resolve_Ghost_ref_UnionFind_T uf}- s9
      | s9 = new_unit {_75} (fun (_ret: ()) -> [ &_74 <- _ret ] s10)
      | s10 = bb33 ]
    | bb33 = s0 [ s0 = [ &_0 <- y ] s1 | s1 = bb51 ]
    | bb34 = s0
      [ s0 = -{resolve_ref_PeanoInt ry}- s1
      | s1 = eq_PeanoInt {rx.current} {ry.current} (fun (_ret: bool) -> [ &_96 <- _ret ] s2)
      | s2 = bb35 ]
    | bb35 = any [ br0 -> {_96 = false} (! bb38) | br1 -> {_96} (! bb36) ]
    | bb36 = s0
      [ s0 = -{resolve_ref_PeanoInt rx}- s1
      | s1 = incr {rx.current} (fun (_ret: t_PeanoInt) -> [ &_99 <- _ret ] s2)
      | s2 = bb37 ]
    | bb37 = s0 [ s0 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s1 | s1 = -{resolve_ref_Node_T bx}- s2 | s2 = bb39 ]
    | bb38 = s0
      [ s0 = -{resolve_ref_PeanoInt rx}- s1
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s2
      | s2 = -{resolve_ref_Node_T bx}- s3
      | s3 = bb39 ]
    | bb39 = s0 [ s0 = [ &_101 <- Link x ] s1 | s1 = bb40 ]
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv_Node_T by'.current} s1
      | s1 = -{resolve_Node_T by'.current}- s2
      | s2 = [ &by' <- { by' with current = _101 } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s4
      | s4 = -{resolve_ref_Node_T by'}- s5
      | s5 = {[@expl:type invariant] inv_Ghost_ref_FMap_Element_PtrOwn_Node_T m} s6
      | s6 = -{resolve_Ghost_ref_FMap_Element_PtrOwn_Node_T m}- s7
      | s7 = bb42 ]
    | bb42 = s0
      [ s0 = [ &_105 <- fun (z: t_Element) -> if index_Mapping_Element_Element uf'0.current.roots z = y then
          x
        else
          index_Mapping_Element_Element uf'0.current.roots z
         ] s1
      | s1 = bb43 ]
    | bb43 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_111 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_111}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_110 <- _ret ] s2)
      | s2 = bb44 ]
    | bb44 = s0
      [ s0 =
        [ &_110 <- { _110 with current = { _110.current with current = { _110.current.current with roots = _105 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _110} s2
      | s2 = -{resolve_ref_ref_UFInner_T _110}- s3
      | s3 = [ &_112 <- uf'0.current.max_depth + 1 ] s4
      | s4 = bb45 ]
    | bb45 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_116 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_116}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_115 <- _ret ] s2)
      | s2 = bb46 ]
    | bb46 = s0
      [ s0 =
        [ &_115 <- { _115 with current = { _115.current with current = { _115.current.current with max_depth = _112 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _115} s2
      | s2 = -{resolve_ref_ref_UFInner_T _115}- s3
      | s3 = [ &_117 <- Map.set uf'0.current.depth x (1
        + MinMax.max (index_Mapping_Element_Int uf'0.current.depth x) (index_Mapping_Element_Int uf'0.current.depth y)) ]
        s4
      | s4 = bb47 ]
    | bb47 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_123 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_123}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_122 <- _ret ] s2)
      | s2 = bb48 ]
    | bb48 = s0
      [ s0 =
        [ &_122 <- { _122 with current = { _122.current with current = { _122.current.current with depth = _117 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _122} s2
      | s2 = -{resolve_ref_ref_UFInner_T _122}- s3
      | s3 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s4
      | s4 = -{resolve_Ghost_ref_UFInner_T uf'0}- s5
      | s5 = {[@expl:type invariant] inv_ref_ref_UnionFind_T _30} s6
      | s6 = -{resolve_ref_ref_UnionFind_T _30}- s7
      | s7 = {[@expl:type invariant] inv_Ghost_ref_UnionFind_T uf} s8
      | s8 = -{resolve_Ghost_ref_UnionFind_T uf}- s9
      | s9 = new_unit {_104} (fun (_ret: ()) -> [ &_103 <- _ret ] s10)
      | s10 = bb49 ]
    | bb49 = s0 [ s0 = [ &_0 <- x ] s1 | s1 = bb51 ]
    | bb51 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind_T = uf
    | & x: t_Element = x
    | & y: t_Element = y
    | & _25: bool = Any.any_l ()
    | & __temp: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _30: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & _31: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & perm_x: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & m: MutBorrow.t t_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _36: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _37: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _38: tup2_ref_PtrOwn_Node_T_ref_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _39: MutBorrow.t t_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _40: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _41: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _43: t_Element = Any.any_l ()
    | & bx: MutBorrow.t t_Node_T = Any.any_l ()
    | & _45: MutBorrow.t t_Node_T = Any.any_l ()
    | & _46: Opaque.ptr = Any.any_l ()
    | & by': MutBorrow.t t_Node_T = Any.any_l ()
    | & _50: MutBorrow.t t_Node_T = Any.any_l ()
    | & _51: Opaque.ptr = Any.any_l ()
    | & _53: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _54: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _55: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _56: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _57: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _58: MutBorrow.t t_FMap_Element_PtrOwn_Node_T = Any.any_l ()
    | & _59: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T) = Any.any_l ()
    | & _60: MutBorrow.t (MutBorrow.t t_FMap_Element_PtrOwn_Node_T) = Any.any_l ()
    | & _62: t_Element = Any.any_l ()
    | & rx: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & ry: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & _72: t_Node_T = Any.any_l ()
    | & _74: () = Any.any_l ()
    | & _75: () = Any.any_l ()
    | & _76: Map.map t_Element t_Element = Any.any_l ()
    | & _81: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _82: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _83: int = Any.any_l ()
    | & _86: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _87: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _88: Map.map t_Element int = Any.any_l ()
    | & _93: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _94: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _96: bool = Any.any_l ()
    | & _99: t_PeanoInt = Any.any_l ()
    | & _101: t_Node_T = Any.any_l ()
    | & _103: () = Any.any_l ()
    | & _104: () = Any.any_l ()
    | & _105: Map.map t_Element t_Element = Any.any_l ()
    | & _110: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _111: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _112: int = Any.any_l ()
    | & _115: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _116: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _117: Map.map t_Element int = Any.any_l ()
    | & _122: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _123: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l () ])
    [ return (result: t_Element) -> {[@expl:link ensures #0] domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {[@expl:link ensures #1] result = root_T uf.current x \/ result = root_T uf.current y}
      {[@expl:link ensures #2] result = root_T (fin_Ghost_ref_UnionFind_T uf) result}
      {[@expl:link ensures #3] forall z: t_Element. in_domain_T uf.current z
        -> root_T (fin_Ghost_ref_UnionFind_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
end
module M_implementation__union
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Element = { f0: Opaque.ptr }
  
  type t_FMap_Element_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Element;
    perms: t_FMap_Element_PtrOwn_Node_T;
    payloads: Map.map t_Element t_T;
    roots: Map.map t_Element t_Element;
    depth: Map.map t_Element int;
    max_depth: int }
  
  type t_UnionFind_T = { f0'0: t_UFInner_T }
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Element_PtrOwn_Node_T (self: t_FMap_Element_PtrOwn_Node_T) : Map.map t_Element t_Option_PtrOwn_Node_T
  
  function get_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Element_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Element
  
  predicate contains_Element'0 [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) =
    get_Element self k <> None
  
  meta "rewrite_def" predicate contains_Element'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Element [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (k: t_Element) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Element self k)
  
  meta "rewrite_def" function lookup_Element
  
  function index_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) (key: t_Element) : t_PtrOwn_Node_T
   = lookup_Element self key
  
  meta "rewrite_def" function index_FMap_Element_PtrOwn_Node_T
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Element
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Element_T [@inline:trivial] (self: Map.map t_Element t_T) (a: t_Element) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_T
  
  function index_Mapping_Element_Int [@inline:trivial] (self: Map.map t_Element int) (a: t_Element) : int =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Int
  
  predicate invariant_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) =
    (forall e1: t_Element, e2: t_Element. contains_Element self.f0'0.domain e1
          /\ contains_Element self.f0'0.domain e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
    /\ (forall e: t_Element. contains_Element self.f0'0.domain e
      -> contains_Element'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Element self.f0'0.domain (index_Mapping_Element_Element self.f0'0.roots e)
      /\ index_Mapping_Element_Element self.f0'0.roots (index_Mapping_Element_Element self.f0'0.roots e)
        = index_Mapping_Element_Element self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Element self.f0'0.roots e <> e
          /\ contains_Element self.f0'0.domain e2
          /\ index_Mapping_Element_Element self.f0'0.roots e = index_Mapping_Element_Element self.f0'0.roots e2
          | Root _ payload -> index_Mapping_Element_Element self.f0'0.roots e = e
          /\ index_Mapping_Element_T self.f0'0.payloads e = payload
          end
      /\ match val_Node_T (index_FMap_Element_PtrOwn_Node_T self.f0'0.perms e) with
          | Link e2 -> index_Mapping_Element_Int self.f0'0.depth e < index_Mapping_Element_Int self.f0'0.depth e2
          | Root _ _ -> true
          end
      /\ index_Mapping_Element_Int self.f0'0.depth e <= self.f0'0.max_depth)
  
  meta "rewrite_def" predicate invariant_UnionFind_T
  
  predicate inv_Element [@inline:trivial] (_1: t_Element) = true
  
  meta "rewrite_def" predicate inv_Element
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_PtrOwn_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self))
    /\ size_of_val_Node_T (val_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ptr_Node_T self)) + size_of_val_Node_T (val_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Element_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Element_PtrOwn_Node_T) =
    forall k: t_Element. contains_Element'0 self k
      -> inv_Element k /\ inv_PtrOwn_Node_T (index_FMap_Element_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Element_PtrOwn_Node_T
  
  predicate inv_FMap_Element_PtrOwn_Node_T (_1: t_FMap_Element_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Element_PtrOwn_Node_T [inv_FMap_Element_PtrOwn_Node_T x]. inv_FMap_Element_PtrOwn_Node_T x
      = invariant_FMap_Element_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Element_PtrOwn_Node_T x.perms
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x
      = (invariant_UnionFind_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_UnionFind_T self.current /\ inv_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate invariant_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) =
    inv_ref_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_T
  
  predicate inv_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) =
    invariant_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_Ghost_ref_UnionFind_T self.current /\ inv_Ghost_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UnionFind_T
  
  predicate inv_ref_Ghost_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_Ghost_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UnionFind_T
  
  predicate invariant_ref_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    inv_ref_UnionFind_T self.current /\ inv_ref_UnionFind_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UnionFind_T
  
  predicate inv_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    invariant_ref_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UnionFind_T
  
  let rec deref_mut_Ghost_ref_UnionFind_T (self: MutBorrow.t (MutBorrow.t t_UnionFind_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UnionFind_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UnionFind_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> {inv_ref_ref_UnionFind_T result}
      {result = self}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UnionFind_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UnionFind_T
  
  predicate resolve_ref_UnionFind_T [@inline:trivial] (_1: MutBorrow.t t_UnionFind_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UnionFind_T
  
  let rec new_ref_UnionFind_T (x: MutBorrow.t t_UnionFind_T) (return (x'0: MutBorrow.t t_UnionFind_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UnionFind_T x}
    any
    [ return (result: MutBorrow.t t_UnionFind_T) -> {inv_Ghost_ref_UnionFind_T result}
      {result = x}
      (! return {result}) ]
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element = self.f0'0.domain
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  function roots_map_T (self: t_UnionFind_T) : Map.map t_Element t_Element = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e: t_Element. in_domain_T self e
        -> in_domain_T self (index_Mapping_Element_Element (roots_map_T self) e)
        /\ index_Mapping_Element_Element (roots_map_T self) e
        = index_Mapping_Element_Element (roots_map_T self) (index_Mapping_Element_Element (roots_map_T self) e))
  
  function root_T (self: t_UnionFind_T) (e: t_Element) : t_Element = index_Mapping_Element_Element (roots_map_T self) e
  
  function payloads_map_T (self: t_UnionFind_T) : Map.map t_Element t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UnionFind_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  let rec find_T (uf: MutBorrow.t t_UnionFind_T) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:find requires] in_domain_T uf.current elem}
    any [ return (result: t_Element) -> {result = root_T uf.current elem} {unchanged_T uf} (! return {result}) ]
  
  predicate domain_unchanged_T (self: MutBorrow.t t_UnionFind_T) = domain_T self.current = domain_T self.final
  
  predicate payloads_unchanged_T (self: MutBorrow.t t_UnionFind_T) =
    payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_ref_UnionFind_T [@inline:trivial] (self: MutBorrow.t t_UnionFind_T) : t_UnionFind_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UnionFind_T
  
  let rec link_T (uf: MutBorrow.t t_UnionFind_T) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:link 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:link requires #0] in_domain_T uf.current x /\ in_domain_T uf.current y}
    {[@expl:link requires #1] root_T uf.current x = x /\ root_T uf.current y = y}
    any
    [ return (result: t_Element) -> {domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {result = root_T uf.current x \/ result = root_T uf.current y}
      {result = root_T (fin_Ghost_ref_UnionFind_T uf) result}
      {forall z: t_Element. in_domain_T uf.current z
        -> root_T (fin_Ghost_ref_UnionFind_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec union_T (uf: MutBorrow.t t_UnionFind_T) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:union 'uf' type invariant] inv_Ghost_ref_UnionFind_T uf}
    {[@expl:union requires] in_domain_T uf.current x /\ in_domain_T uf.current y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Ghost_ref_UnionFind_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) ->
            [ &_24 <- _ret ] -{inv_Ghost_ref_UnionFind_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UnionFind_T {_24}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> [ &_23 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_UnionFind_T _23.current.current}
        MutBorrow.borrow_mut <t_UnionFind_T> {_23.current.current}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_22 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_23 <- { _23 with current = { _23.current with current = _ret.final } } ] s1)
      | s1 = {inv_UnionFind_T _22.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_22.current} {MutBorrow.get_id _22}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_21 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_22 <- { _22 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_ref_UnionFind_T _23} s3
      | s3 = -{resolve_ref_ref_UnionFind_T _23}- s4
      | s4 = {[@expl:type invariant] inv_ref_UnionFind_T _22} s5
      | s5 = -{resolve_ref_UnionFind_T _22}- s6
      | s6 = {inv_UnionFind_T _21.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_20 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_21 <- { _21 with current = _ret.final } ] s7)
      | s7 = new_ref_UnionFind_T {_20} (fun (_ret: MutBorrow.t t_UnionFind_T) -> [ &_19 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_UnionFind_T _21} s1
      | s1 = -{resolve_ref_UnionFind_T _21}- s2
      | s2 = find_T {_19} {x} (fun (_ret: t_Element) -> [ &rx <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Ghost_ref_UnionFind_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UnionFind_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) ->
            [ &_32 <- _ret ] -{inv_Ghost_ref_UnionFind_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UnionFind_T {_32}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UnionFind_T)) -> [ &_31 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv_UnionFind_T _31.current.current}
        MutBorrow.borrow_mut <t_UnionFind_T> {_31.current.current}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_30 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_31 <- { _31 with current = { _31.current with current = _ret.final } } ] s1)
      | s1 = {inv_UnionFind_T _30.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_29 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_30 <- { _30 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_ref_UnionFind_T _31} s3
      | s3 = -{resolve_ref_ref_UnionFind_T _31}- s4
      | s4 = {[@expl:type invariant] inv_ref_UnionFind_T _30} s5
      | s5 = -{resolve_ref_UnionFind_T _30}- s6
      | s6 = {inv_UnionFind_T _29.current}
        MutBorrow.borrow_final <t_UnionFind_T> {_29.current} {MutBorrow.get_id _29}
          (fun (_ret: MutBorrow.t t_UnionFind_T) ->
            [ &_28 <- _ret ] -{inv_UnionFind_T _ret.final}-
            [ &_29 <- { _29 with current = _ret.final } ] s7)
      | s7 = new_ref_UnionFind_T {_28} (fun (_ret: MutBorrow.t t_UnionFind_T) -> [ &_27 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_UnionFind_T _29} s1
      | s1 = -{resolve_ref_UnionFind_T _29}- s2
      | s2 = find_T {_27} {y} (fun (_ret: t_Element) -> [ &ry <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = link_T {uf} {rx} {ry} (fun (_ret: t_Element) -> [ &_0 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Element = Any.any_l ()
    | & uf: MutBorrow.t t_UnionFind_T = uf
    | & x: t_Element = x
    | & y: t_Element = y
    | & rx: t_Element = Any.any_l ()
    | & _19: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _20: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _21: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _22: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _23: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & _24: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & ry: t_Element = Any.any_l ()
    | & _27: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _28: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _29: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _30: MutBorrow.t t_UnionFind_T = Any.any_l ()
    | & _31: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l ()
    | & _32: MutBorrow.t (MutBorrow.t t_UnionFind_T) = Any.any_l () ])
    [ return (result: t_Element) -> {[@expl:union ensures #0] domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {[@expl:union ensures #1] result = root_T uf.current x \/ result = root_T uf.current y}
      {[@expl:union ensures #2] forall z: t_Element. in_domain_T uf.current z
        -> root_T (fin_Ghost_ref_UnionFind_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
end
module M_example
  use set.Fset
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use creusot.int.Int32
  use map.Map
  use creusot.prelude.Any
  
  type t_UnionFind_i32
  
  predicate invariant_UnionFind_i32 (self: t_UnionFind_i32)
  
  predicate inv_UnionFind_i32 (_1: t_UnionFind_i32)
  
  axiom inv_axiom: forall x: t_UnionFind_i32 [inv_UnionFind_i32 x]. inv_UnionFind_i32 x -> invariant_UnionFind_i32 x
  
  predicate invariant_Ghost_UnionFind_i32 [@inline:trivial] (self: t_UnionFind_i32) = inv_UnionFind_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_UnionFind_i32
  
  predicate inv_Ghost_UnionFind_i32 [@inline:trivial] (_1: t_UnionFind_i32) = invariant_Ghost_UnionFind_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_UnionFind_i32
  
  type t_Element
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function deep_model_Element (self: t_Element) : UInt64.t
  
  function domain_i32 (self: t_UnionFind_i32) : Fset.fset t_Element
  
  axiom domain_i32_spec: forall self: t_UnionFind_i32. inv_UnionFind_i32 self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_i32 self) e1
          /\ contains_Element (domain_i32 self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  let rec new_i32 (return (x: t_UnionFind_i32)) = any
    [ return (result: t_UnionFind_i32) -> {inv_Ghost_UnionFind_i32 result}
      {Fset.is_empty (domain_i32 result)}
      (! return {result}) ]
  
  predicate invariant_ref_Ghost_UnionFind_i32 [@inline:trivial] (self: MutBorrow.t t_UnionFind_i32) =
    inv_Ghost_UnionFind_i32 self.current /\ inv_Ghost_UnionFind_i32 self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_UnionFind_i32
  
  predicate inv_ref_Ghost_UnionFind_i32 [@inline:trivial] (_1: MutBorrow.t t_UnionFind_i32) =
    invariant_ref_Ghost_UnionFind_i32 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_UnionFind_i32
  
  predicate invariant_ref_UnionFind_i32 [@inline:trivial] (self: MutBorrow.t t_UnionFind_i32) =
    inv_UnionFind_i32 self.current /\ inv_UnionFind_i32 self.final
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_i32
  
  predicate inv_ref_UnionFind_i32 [@inline:trivial] (_1: MutBorrow.t t_UnionFind_i32) = invariant_ref_UnionFind_i32 _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_i32
  
  predicate invariant_Ghost_ref_UnionFind_i32 [@inline:trivial] (self: MutBorrow.t t_UnionFind_i32) =
    inv_ref_UnionFind_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_i32
  
  predicate inv_Ghost_ref_UnionFind_i32 [@inline:trivial] (_1: MutBorrow.t t_UnionFind_i32) =
    invariant_Ghost_ref_UnionFind_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_i32
  
  let rec borrow_mut_UnionFind_i32 (self: MutBorrow.t t_UnionFind_i32) (return (x: MutBorrow.t t_UnionFind_i32)) =
    {[@expl:borrow_mut 'self' type invariant] inv_ref_Ghost_UnionFind_i32 self}
    any
    [ return (result: MutBorrow.t t_UnionFind_i32) -> {inv_Ghost_ref_UnionFind_i32 result}
      {result = self}
      (! return {result}) ]
  
  predicate inv_Element (_1: t_Element)
  
  predicate in_domain_i32 (self: t_UnionFind_i32) (e: t_Element) = contains_Element (domain_i32 self) e
  
  function fin_Ghost_ref_UnionFind_i32 [@inline:trivial] (self: MutBorrow.t t_UnionFind_i32) : t_UnionFind_i32 =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UnionFind_i32
  
  function insert_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) : Fset.fset t_Element =
    Fset.add e self
  
  meta "rewrite_def" function insert_Element
  
  function index_Mapping_Element_Element [@inline:trivial] (self: Map.map t_Element t_Element) (a: t_Element) : t_Element
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_Element
  
  function roots_map_i32 (self: t_UnionFind_i32) : Map.map t_Element t_Element
  
  axiom roots_map_i32_spec: forall self: t_UnionFind_i32. inv_UnionFind_i32 self
      -> (forall e: t_Element. in_domain_i32 self e
        -> in_domain_i32 self (index_Mapping_Element_Element (roots_map_i32 self) e)
        /\ index_Mapping_Element_Element (roots_map_i32 self) e
        = index_Mapping_Element_Element (roots_map_i32 self) (index_Mapping_Element_Element (roots_map_i32 self) e))
  
  function payloads_map_i32 (self: t_UnionFind_i32) : Map.map t_Element Int32.t
  
  let rec make_i32 (uf: MutBorrow.t t_UnionFind_i32) (payload: Int32.t) (return (x: t_Element)) =
    {[@expl:make 'uf' type invariant] inv_Ghost_ref_UnionFind_i32 uf}
    any
    [ return (result: t_Element) -> {inv_Element result}
      {not in_domain_i32 uf.current result}
      {domain_i32 (fin_Ghost_ref_UnionFind_i32 uf) = insert_Element (domain_i32 uf.current) result}
      {roots_map_i32 (fin_Ghost_ref_UnionFind_i32 uf) = Map.set (roots_map_i32 uf.current) result result}
      {payloads_map_i32 (fin_Ghost_ref_UnionFind_i32 uf) = Map.set (payloads_map_i32 uf.current) result payload}
      (! return {result}) ]
  
  predicate invariant_ref_Ghost_UnionFind_i32'0 [@inline:trivial] (self: t_UnionFind_i32) = inv_Ghost_UnionFind_i32 self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_UnionFind_i32'0
  
  predicate inv_ref_Ghost_UnionFind_i32'0 [@inline:trivial] (_1: t_UnionFind_i32) =
    invariant_ref_Ghost_UnionFind_i32'0 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_UnionFind_i32'0
  
  predicate invariant_ref_UnionFind_i32'0 [@inline:trivial] (self: t_UnionFind_i32) = inv_UnionFind_i32 self
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_i32'0
  
  predicate inv_ref_UnionFind_i32'0 [@inline:trivial] (_1: t_UnionFind_i32) = invariant_ref_UnionFind_i32'0 _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_i32'0
  
  predicate invariant_Ghost_ref_UnionFind_i32'0 [@inline:trivial] (self: t_UnionFind_i32) = inv_ref_UnionFind_i32'0 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UnionFind_i32'0
  
  predicate inv_Ghost_ref_UnionFind_i32'0 [@inline:trivial] (_1: t_UnionFind_i32) =
    invariant_Ghost_ref_UnionFind_i32'0 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UnionFind_i32'0
  
  let rec borrow_UnionFind_i32 (self: t_UnionFind_i32) (return (x: t_UnionFind_i32)) =
    {[@expl:borrow 'self' type invariant] inv_ref_Ghost_UnionFind_i32'0 self}
    any
    [ return (result: t_UnionFind_i32) -> {inv_Ghost_ref_UnionFind_i32'0 result} {result = self} (! return {result}) ]
  
  function root_i32 (self: t_UnionFind_i32) (e: t_Element) : t_Element =
    index_Mapping_Element_Element (roots_map_i32 self) e
  
  function index_Mapping_Element_i32 [@inline:trivial] (self: Map.map t_Element Int32.t) (a: t_Element) : Int32.t =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Element_i32
  
  function payload_i32 (self: t_UnionFind_i32) (e: t_Element) : Int32.t =
    index_Mapping_Element_i32 (payloads_map_i32 self) e
  
  let rec get_i32 (uf: t_UnionFind_i32) (elem: t_Element) (return (x: Int32.t)) =
    {[@expl:get 'uf' type invariant] inv_Ghost_ref_UnionFind_i32'0 uf}
    {[@expl:get 'elem' type invariant] inv_Element elem}
    {[@expl:get requires #0] in_domain_i32 uf elem}
    {[@expl:get requires #1] root_i32 uf elem = elem}
    any [ return (result: Int32.t) -> {result = payload_i32 uf elem} (! return {result}) ]
  
  predicate domain_unchanged_i32 (self: MutBorrow.t t_UnionFind_i32) = domain_i32 self.current = domain_i32 self.final
  
  predicate payloads_unchanged_i32 (self: MutBorrow.t t_UnionFind_i32) =
    payloads_map_i32 self.current = payloads_map_i32 self.final
  
  let rec union_i32 (uf: MutBorrow.t t_UnionFind_i32) (x: t_Element) (y: t_Element) (return (x'0: t_Element)) =
    {[@expl:union 'uf' type invariant] inv_Ghost_ref_UnionFind_i32 uf}
    {[@expl:union 'x' type invariant] inv_Element x}
    {[@expl:union 'y' type invariant] inv_Element y}
    {[@expl:union requires] in_domain_i32 uf.current x /\ in_domain_i32 uf.current y}
    any
    [ return (result: t_Element) -> {inv_Element result}
      {domain_unchanged_i32 uf /\ payloads_unchanged_i32 uf}
      {result = root_i32 uf.current x \/ result = root_i32 uf.current y}
      {forall z: t_Element. in_domain_i32 uf.current z
        -> root_i32 (fin_Ghost_ref_UnionFind_i32 uf) z
        = (if root_i32 uf.current z = root_i32 uf.current x \/ root_i32 uf.current z = root_i32 uf.current y then
          result
        else
          root_i32 uf.current z
        )}
      (! return {result}) ]
  
  predicate unchanged_i32 (self: MutBorrow.t t_UnionFind_i32) =
    domain_i32 self.current = domain_i32 self.final
    /\ roots_map_i32 self.current = roots_map_i32 self.final
    /\ payloads_map_i32 self.current = payloads_map_i32 self.final
  
  let rec equiv_i32 (uf: MutBorrow.t t_UnionFind_i32) (e1: t_Element) (e2: t_Element) (return (x: bool)) =
    {[@expl:equiv 'uf' type invariant] inv_Ghost_ref_UnionFind_i32 uf}
    {[@expl:equiv 'e1' type invariant] inv_Element e1}
    {[@expl:equiv 'e2' type invariant] inv_Element e2}
    {[@expl:equiv requires #0] in_domain_i32 uf.current e1}
    {[@expl:equiv requires #1] in_domain_i32 uf.current e2}
    any
    [ return (result: bool) -> {result = (root_i32 uf.current e1 = root_i32 uf.current e2)}
      {unchanged_i32 uf}
      (! return {result}) ]
  
  let rec find_i32 (uf: MutBorrow.t t_UnionFind_i32) (elem: t_Element) (return (x: t_Element)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_ref_UnionFind_i32 uf}
    {[@expl:find 'elem' type invariant] inv_Element elem}
    {[@expl:find requires] in_domain_i32 uf.current elem}
    any
    [ return (result: t_Element) -> {inv_Element result}
      {result = root_i32 uf.current elem}
      {unchanged_i32 uf}
      (! return {result}) ]
  
  predicate resolve_UnionFind_i32 (_1: t_UnionFind_i32)
  
  predicate resolve_Ghost_UnionFind_i32 [@inline:trivial] (_1: t_UnionFind_i32) = resolve_UnionFind_i32 _1
  
  meta "rewrite_def" predicate resolve_Ghost_UnionFind_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new_i32 (fun (_ret: t_UnionFind_i32) -> [ &uf <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Ghost_UnionFind_i32 uf}
        MutBorrow.borrow_mut <t_UnionFind_i32> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind_i32) ->
            [ &_4 <- _ret ] -{inv_Ghost_UnionFind_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UnionFind_i32 {_4} (fun (_ret: MutBorrow.t t_UnionFind_i32) -> [ &_3 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = make_i32 {_3} {(1: Int32.t)} (fun (_ret: t_Element) -> [ &x <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Ghost_UnionFind_i32 uf}
        MutBorrow.borrow_mut <t_UnionFind_i32> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind_i32) ->
            [ &_7 <- _ret ] -{inv_Ghost_UnionFind_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UnionFind_i32 {_7} (fun (_ret: MutBorrow.t t_UnionFind_i32) -> [ &_6 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = make_i32 {_6} {(2: Int32.t)} (fun (_ret: t_Element) -> [ &y <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv_Ghost_UnionFind_i32 uf}
        MutBorrow.borrow_mut <t_UnionFind_i32> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind_i32) ->
            [ &_10 <- _ret ] -{inv_Ghost_UnionFind_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UnionFind_i32 {_10} (fun (_ret: MutBorrow.t t_UnionFind_i32) -> [ &_9 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = make_i32 {_9} {(3: Int32.t)} (fun (_ret: t_Element) -> [ &z <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = borrow_UnionFind_i32 {uf} (fun (_ret: t_UnionFind_i32) -> [ &_15 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = get_i32 {_15} {x} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_12 <- _14 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0 [ s0 = borrow_UnionFind_i32 {uf} (fun (_ret: t_UnionFind_i32) -> [ &_23 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = get_i32 {_23} {y} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_20 <- _22 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_20 = false} (! bb15) | br1 -> {_20} (! bb14) ] ]
    | bb14 = s0 [ s0 = borrow_UnionFind_i32 {uf} (fun (_ret: t_UnionFind_i32) -> [ &_31 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0 [ s0 = get_i32 {_31} {z} (fun (_ret: Int32.t) -> [ &_30 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_28 <- _30 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_28 = false} (! bb19) | br1 -> {_28} (! bb18) ] ]
    | bb18 = s0
      [ s0 = {inv_Ghost_UnionFind_i32 uf}
        MutBorrow.borrow_mut <t_UnionFind_i32> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind_i32) ->
            [ &_37 <- _ret ] -{inv_Ghost_UnionFind_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UnionFind_i32 {_37} (fun (_ret: MutBorrow.t t_UnionFind_i32) -> [ &_36 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = union_i32 {_36} {x} {y} (fun (_ret: t_Element) -> [ &_35 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = s0
      [ s0 = {inv_Ghost_UnionFind_i32 uf}
        MutBorrow.borrow_mut <t_UnionFind_i32> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind_i32) ->
            [ &_43 <- _ret ] -{inv_Ghost_UnionFind_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UnionFind_i32 {_43} (fun (_ret: MutBorrow.t t_UnionFind_i32) -> [ &_42 <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = s0 [ s0 = equiv_i32 {_42} {x} {y} (fun (_ret: bool) -> [ &_41 <- _ret ] s1) | s1 = bb23 ]
    | bb23 = any [ br0 -> {_41 = false} (! bb25) | br1 -> {_41} (! bb24) ]
    | bb24 = s0
      [ s0 = {inv_Ghost_UnionFind_i32 uf}
        MutBorrow.borrow_mut <t_UnionFind_i32> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind_i32) ->
            [ &_49 <- _ret ] -{inv_Ghost_UnionFind_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UnionFind_i32 {_49} (fun (_ret: MutBorrow.t t_UnionFind_i32) -> [ &_48 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0 [ s0 = find_i32 {_48} {x} (fun (_ret: t_Element) -> [ &xr <- _ret ] s1) | s1 = bb27 ]
    | bb27 = s0
      [ s0 = {inv_Ghost_UnionFind_i32 uf}
        MutBorrow.borrow_mut <t_UnionFind_i32> {uf}
          (fun (_ret: MutBorrow.t t_UnionFind_i32) ->
            [ &_53 <- _ret ] -{inv_Ghost_UnionFind_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UnionFind_i32 {_53} (fun (_ret: MutBorrow.t t_UnionFind_i32) -> [ &_52 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0 [ s0 = find_i32 {_52} {y} (fun (_ret: t_Element) -> [ &yr <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0 [ s0 = borrow_UnionFind_i32 {uf} (fun (_ret: t_UnionFind_i32) -> [ &_59 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0 [ s0 = get_i32 {_59} {xr} (fun (_ret: Int32.t) -> [ &_58 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = s0 [ s0 = borrow_UnionFind_i32 {uf} (fun (_ret: t_UnionFind_i32) -> [ &_64 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0 [ s0 = get_i32 {_64} {yr} (fun (_ret: Int32.t) -> [ &_63 <- _ret ] s1) | s1 = bb33 ]
    | bb33 = s0 [ s0 = [ &_56 <- _58 = _63 ] s1 | s1 = any [ br0 -> {_56 = false} (! bb35) | br1 -> {_56} (! bb34) ] ]
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UnionFind_i32 uf} s1
      | s1 = -{resolve_Ghost_UnionFind_i32 uf}- s2
      | s2 = borrow_UnionFind_i32 {uf} (fun (_ret: t_UnionFind_i32) -> [ &_72 <- _ret ] s3)
      | s3 = bb36 ]
    | bb36 = s0 [ s0 = get_i32 {_72} {z} (fun (_ret: Int32.t) -> [ &_71 <- _ret ] s1) | s1 = bb37 ]
    | bb37 = s0
      [ s0 = [ &_69 <- _71 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_69 = false} (! bb39) | br1 -> {_69} (! bb38) ] ]
    | bb38 = return {_0}
    | bb39 = {false} any
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UnionFind_i32 uf} s1
      | s1 = -{resolve_Ghost_UnionFind_i32 uf}- s2
      | s2 = {false} any ]
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UnionFind_i32 uf} s1
      | s1 = -{resolve_Ghost_UnionFind_i32 uf}- s2
      | s2 = {false} any ]
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UnionFind_i32 uf} s1
      | s1 = -{resolve_Ghost_UnionFind_i32 uf}- s2
      | s2 = {false} any ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UnionFind_i32 uf} s1
      | s1 = -{resolve_Ghost_UnionFind_i32 uf}- s2
      | s2 = {false} any ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UnionFind_i32 uf} s1
      | s1 = -{resolve_Ghost_UnionFind_i32 uf}- s2
      | s2 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & uf: t_UnionFind_i32 = Any.any_l ()
    | & x: t_Element = Any.any_l ()
    | & _3: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _4: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & y: t_Element = Any.any_l ()
    | & _6: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _7: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & z: t_Element = Any.any_l ()
    | & _9: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _10: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _15: t_UnionFind_i32 = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _23: t_UnionFind_i32 = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _31: t_UnionFind_i32 = Any.any_l ()
    | & _35: t_Element = Any.any_l ()
    | & _36: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _37: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _41: bool = Any.any_l ()
    | & _42: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _43: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & xr: t_Element = Any.any_l ()
    | & _48: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _49: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & yr: t_Element = Any.any_l ()
    | & _52: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _53: MutBorrow.t t_UnionFind_i32 = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: Int32.t = Any.any_l ()
    | & _59: t_UnionFind_i32 = Any.any_l ()
    | & _63: Int32.t = Any.any_l ()
    | & _64: t_UnionFind_i32 = Any.any_l ()
    | & _69: bool = Any.any_l ()
    | & _71: Int32.t = Any.any_l ()
    | & _72: t_UnionFind_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_example_addrs_eq
  use creusot.int.UInt64
  use creusot.prelude.Any
  use set.Fset
  
  type t_Element
  
  predicate inv_Element (_1: t_Element)
  
  predicate invariant_ref_Element [@inline:trivial] (self: t_Element) = inv_Element self
  
  meta "rewrite_def" predicate invariant_ref_Element
  
  predicate inv_ref_Element [@inline:trivial] (_1: t_Element) = invariant_ref_Element _1
  
  meta "rewrite_def" predicate inv_ref_Element
  
  function deep_model_Element (self: t_Element) : UInt64.t
  
  function deep_model_ref_Element [@inline:trivial] (self: t_Element) : UInt64.t = deep_model_Element self
  
  meta "rewrite_def" function deep_model_ref_Element
  
  let rec eq_Element (self: t_Element) (other: t_Element) (return (x: bool)) =
    {[@expl:eq 'self' type invariant] inv_ref_Element self}
    {[@expl:eq 'other' type invariant] inv_ref_Element other}
    any
    [ return (result: bool) -> {result = (deep_model_ref_Element self = deep_model_ref_Element other)}
      (! return {result}) ]
  
  type t_UnionFind_T
  
  predicate invariant_UnionFind_T (self: t_UnionFind_T)
  
  predicate inv_UnionFind_T (_1: t_UnionFind_T)
  
  axiom inv_axiom: forall x: t_UnionFind_T [inv_UnionFind_T x]. inv_UnionFind_T x -> invariant_UnionFind_T x
  
  predicate invariant_ref_UnionFind_T [@inline:trivial] (self: t_UnionFind_T) = inv_UnionFind_T self
  
  meta "rewrite_def" predicate invariant_ref_UnionFind_T
  
  predicate inv_ref_UnionFind_T [@inline:trivial] (_1: t_UnionFind_T) = invariant_ref_UnionFind_T _1
  
  meta "rewrite_def" predicate inv_ref_UnionFind_T
  
  predicate contains_Element [@inline:trivial] (self: Fset.fset t_Element) (e: t_Element) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Element
  
  function domain_T (self: t_UnionFind_T) : Fset.fset t_Element
  
  axiom domain_T_spec: forall self: t_UnionFind_T. inv_UnionFind_T self
      -> (forall e1: t_Element, e2: t_Element. contains_Element (domain_T self) e1
          /\ contains_Element (domain_T self) e2 /\ deep_model_Element e1 = deep_model_Element e2 -> e1 = e2)
  
  predicate in_domain_T (self: t_UnionFind_T) (e: t_Element) = contains_Element (domain_T self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example_addrs_eq_T (uf: t_UnionFind_T) (e1: t_Element) (e2: t_Element) (return (x: ())) =
    {[@expl:example_addrs_eq 'uf' type invariant] inv_ref_UnionFind_T uf}
    {[@expl:example_addrs_eq 'e1' type invariant] inv_Element e1}
    {[@expl:example_addrs_eq 'e2' type invariant] inv_Element e2}
    {[@expl:example_addrs_eq requires] in_domain_T uf e1 /\ in_domain_T uf e2}
    (! bb0
    [ bb0 = s0 [ s0 = eq_Element {e1} {e2} (fun (_ret: bool) -> [ &_8 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_8 = false} (! bb4) | br1 -> {_8} (! bb2) ]
    | bb2 = s0 [ s0 = {[@expl:assertion] e1 = e2} s1 | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: () = Any.any_l () | & e1: t_Element = e1 | & e2: t_Element = e2 | & _8: bool = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_implementation__impl_PartialEq_for_Element__eq__refines (* <implementation::Element as std::cmp::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  
  type t_Element = { f0: Opaque.ptr }
  
  function deep_model_Element [@inline:trivial] (self: t_Element) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Element
  
  function deep_model_ref_Element [@inline:trivial] (self: t_Element) : UInt64.t = deep_model_Element self
  
  meta "rewrite_def" function deep_model_ref_Element
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Element. forall rhs: t_Element. forall result: bool. result
            = (deep_model_ref_Element self_ = deep_model_ref_Element rhs)
          -> result = (deep_model_ref_Element self_ = deep_model_ref_Element rhs)
end
