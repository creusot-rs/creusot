module M_impl_Clone_for_Product_A_B__clone (* <Product<A, B> as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Product_A_B = { a: t_A; b: t_B }
  
  predicate inv_A (_1: t_A)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_clone (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition_clone () args]. (let self_ = args in inv_ref_A self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef:
    forall args: t_A, res: t_A [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_A res)
  
  let rec clone_A (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_A) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  predicate inv_B (_1: t_B)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_clone'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition_clone'0 () args]. (let self_ = args in inv_ref_B self_)
      -> precondition_clone'0 () args
  
  predicate postcondition_once_clone'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'0:
    forall args: t_B, res: t_B [postcondition_once_clone'0 () args res]. postcondition_once_clone'0 () args res
      -> (let self_ = args in inv_B res)
  
  let rec clone_B (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition_clone'0 () self_}
    any [ return (result: t_B) -> {postcondition_once_clone'0 () self_ result} (! return {result}) ]
  
  predicate inv_Product_A_B (_1: t_Product_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Product_A_B [inv_Product_A_B x]. inv_Product_A_B x = (inv_A x.a /\ inv_B x.b)
  
  predicate invariant_ref_Product_A_B [@inline:trivial] (self: t_Product_A_B) = inv_Product_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Product_A_B
  
  predicate inv_ref_Product_A_B [@inline:trivial] (_1: t_Product_A_B) = invariant_ref_Product_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Product_A_B
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_A res)
  
  function fn_mut_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b'0: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b'0: (), c: (). hist_inv_clone self b'0
      -> hist_inv_clone b'0 c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'2:
    forall args: t_A, res: t_A [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_A res)
  
  function fn_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate resolve_clone'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'0
  
  predicate postcondition_mut_clone'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut_clone'0 () args () res]. postcondition_mut_clone'0 () args () res
      -> (let self_ = args in inv_B res)
  
  function fn_mut_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone'0 self args res
      = (exists res_state: (). postcondition_mut_clone'0 self args res_state res /\ resolve_clone'0 res_state)
  
  predicate hist_inv_clone'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'0
  
  function hist_inv_trans_clone'0 (self: ()) (b'0: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'0: forall self: (), b'0: (), c: (). hist_inv_clone'0 self b'0
      -> hist_inv_clone'0 b'0 c -> hist_inv_clone'0 self c
  
  function hist_inv_refl_clone'0 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'0: forall self: (). hist_inv_clone'0 self self
  
  function postcondition_mut_hist_inv_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      -> hist_inv_clone'0 self res_state
  
  function fn_hist_inv_clone'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'0: forall self: (), res_state: (). hist_inv_clone'0 self res_state = (self = res_state)
  
  predicate postcondition_clone'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4:
    forall args: t_B, res: t_B [postcondition_clone'0 () args res]. postcondition_clone'0 () args res
      -> (let self_ = args in inv_B res)
  
  function fn_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone'0 self args res
      = (postcondition_clone'0 self args res /\ resolve_clone'0 self)
  
  function fn_mut_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      = (postcondition_clone'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Product_A_B (self: t_Product_A_B) (return (x: t_Product_A_B)) =
    {[@expl:clone 'self' type invariant] inv_ref_Product_A_B self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- self.a ] s1 | s1 = clone_A {_5} (fun (_ret: t_A) -> [ &_3 <- _ret ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_8 <- self.b ] s1 | s1 = clone_B {_8} (fun (_ret: t_B) -> [ &_6 <- _ret ] s2) | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_0 <- { a = _3; b = _6 } ] s1 | s1 = bb4 ]
    | bb4 = return {_0} ]
    [ & _0: t_Product_A_B = Any.any_l ()
    | & self: t_Product_A_B = self
    | & _3: t_A = Any.any_l ()
    | & _5: t_A = Any.any_l ()
    | & _6: t_B = Any.any_l ()
    | & _8: t_B = Any.any_l () ])
    [ return (result: t_Product_A_B) -> {[@expl:clone result type invariant] inv_Product_A_B result}
      {[@expl:clone ensures] postcondition_clone () self.a result.a /\ postcondition_clone'0 () self.b result.b}
      (! return {result}) ]
end
module M_impl_PartialEq_for_Product_A_B__eq (* <Product<A, B> as std::cmp::PartialEq> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Product_A_B = { a: t_A; b: t_B }
  
  type tup2_ref_A_ref_A = { f0: t_A; f1: t_A }
  
  predicate inv_A (_1: t_A)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_eq (self: ()) (args: tup2_ref_A_ref_A)
  
  axiom precondition_fndef:
    forall args: tup2_ref_A_ref_A [precondition_eq () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_A self_
        /\ inv_ref_A rhs) -> precondition_eq () args
  
  type t_DeepModelTy
  
  function deep_model_A (self: t_A) : t_DeepModelTy
  
  function deep_model_ref_A [@inline:trivial] (self: t_A) : t_DeepModelTy = deep_model_A self
  
  meta "rewrite_def" function deep_model_ref_A
  
  predicate postcondition_once_eq (self: ()) (args: tup2_ref_A_ref_A) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_A_ref_A, res: bool [postcondition_once_eq () args res]. postcondition_once_eq () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = (deep_model_ref_A self_ = deep_model_ref_A rhs))
  
  let rec eq_A (self_: t_A) (rhs: t_A) (return (x: bool)) = {[@expl:eq requires] precondition_eq () { f0 = self_;
                                                                                                      f1 = rhs }}
    any [ return (result: bool) -> {postcondition_once_eq () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  type tup2_ref_B_ref_B = { f0'0: t_B; f1'0: t_B }
  
  predicate inv_B (_1: t_B)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_eq'0 (self: ()) (args: tup2_ref_B_ref_B)
  
  axiom precondition_fndef'0:
    forall args: tup2_ref_B_ref_B [precondition_eq'0 () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv_ref_B self_
        /\ inv_ref_B rhs) -> precondition_eq'0 () args
  
  type t_DeepModelTy'0
  
  function deep_model_B (self: t_B) : t_DeepModelTy'0
  
  function deep_model_ref_B [@inline:trivial] (self: t_B) : t_DeepModelTy'0 = deep_model_B self
  
  meta "rewrite_def" function deep_model_ref_B
  
  predicate postcondition_once_eq'0 (self: ()) (args: tup2_ref_B_ref_B) (result: bool)
  
  axiom postcondition_fndef'0:
    forall args: tup2_ref_B_ref_B, res: bool [postcondition_once_eq'0 () args res]. postcondition_once_eq'0 () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = (deep_model_ref_B self_ = deep_model_ref_B rhs))
  
  let rec eq_B (self_: t_B) (rhs: t_B) (return (x: bool)) = {[@expl:eq requires] precondition_eq'0 () { f0'0 = self_;
                                                                                                        f1'0 = rhs }}
    any
    [ return (result: bool) -> {postcondition_once_eq'0 () { f0'0 = self_; f1'0 = rhs } result} (! return {result}) ]
  
  predicate inv_Product_A_B (_1: t_Product_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Product_A_B [inv_Product_A_B x]. inv_Product_A_B x = (inv_A x.a /\ inv_B x.b)
  
  predicate invariant_ref_Product_A_B [@inline:trivial] (self: t_Product_A_B) = inv_Product_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Product_A_B
  
  predicate inv_ref_Product_A_B [@inline:trivial] (_1: t_Product_A_B) = invariant_ref_Product_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Product_A_B
  
  type t_Product_DeepModelTy_DeepModelTy = { a'0: t_DeepModelTy; b'0: t_DeepModelTy'0 }
  
  function deep_model_Product_A_B (self: t_Product_A_B) : t_Product_DeepModelTy_DeepModelTy =
    { a'0 = deep_model_A self.a; b'0 = deep_model_B self.b }
  
  function deep_model_ref_Product_A_B [@inline:trivial] (self: t_Product_A_B) : t_Product_DeepModelTy_DeepModelTy =
    deep_model_Product_A_B self
  
  meta "rewrite_def" function deep_model_ref_Product_A_B
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_Product_A_B (self: t_Product_A_B) (rhs: t_Product_A_B) (return (x: bool)) =
    {[@expl:eq 'self' type invariant] inv_ref_Product_A_B self}
    {[@expl:eq 'rhs' type invariant] inv_ref_Product_A_B rhs}
    (! bb0
    [ bb0 = s0 [ s0 = eq_A {self.a} {rhs.a} (fun (_ret: bool) -> [ &_4 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ]
    | bb2 = s0 [ s0 = eq_B {self.b} {rhs.b} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb5 ]
    | bb3 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_Product_A_B = self
    | & rhs: t_Product_A_B = rhs
    | & _4: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:eq ensures] result
      = (deep_model_ref_Product_A_B self = deep_model_ref_Product_A_B rhs)}
      (! return {result}) ]
end
module M_impl_Clone_for_Sum_A_B__clone (* <Sum<A, B> as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum_A_B = A t_A | B t_B
  
  let rec elim_B (input: t_Sum_A_B) (ret (b: t_B)) = any
    [ good (b: t_B) -> {B b = input} (! ret {b})
    | bad -> {forall b: t_B [B b: t_Sum_A_B]. B b <> input} (! {false} any) ]
  
  predicate inv_B (_1: t_B)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_clone (self: ()) (args: t_B)
  
  axiom precondition_fndef: forall args: t_B [precondition_clone () args]. (let self_ = args in inv_ref_B self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef:
    forall args: t_B, res: t_B [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_B res)
  
  let rec clone_B (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_B) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  let rec elim_A (input: t_Sum_A_B) (ret (f0: t_A)) = any
    [ good (f0: t_A) -> {A f0 = input} (! ret {f0})
    | bad -> {forall f0: t_A [A f0: t_Sum_A_B]. A f0 <> input} (! {false} any) ]
  
  predicate inv_A (_1: t_A)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_clone'0 (self: ()) (args: t_A)
  
  axiom precondition_fndef'0: forall args: t_A [precondition_clone'0 () args]. (let self_ = args in inv_ref_A self_)
      -> precondition_clone'0 () args
  
  predicate postcondition_once_clone'0 (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_once_clone'0 () args res]. postcondition_once_clone'0 () args res
      -> (let self_ = args in inv_A res)
  
  let rec clone_A (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition_clone'0 () self_}
    any [ return (result: t_A) -> {postcondition_once_clone'0 () self_ result} (! return {result}) ]
  
  predicate inv_Sum_A_B (_1: t_Sum_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum_A_B [inv_Sum_A_B x]. inv_Sum_A_B x
      = match x with
        | A f0 -> inv_A f0
        | B b -> inv_B b
        end
  
  predicate invariant_ref_Sum_A_B [@inline:trivial] (self: t_Sum_A_B) = inv_Sum_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Sum_A_B
  
  predicate inv_ref_Sum_A_B [@inline:trivial] (_1: t_Sum_A_B) = invariant_ref_Sum_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Sum_A_B
  
  type tup2_Sum_A_B_Sum_A_B = { f0: t_Sum_A_B; f1: t_Sum_A_B }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_A res)
  
  function fn_mut_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone'0 self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'2:
    forall args: t_A, res: t_A [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_A res)
  
  function fn_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone'0 self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate resolve_clone'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'0
  
  predicate postcondition_mut_clone'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut_clone'0 () args () res]. postcondition_mut_clone'0 () args () res
      -> (let self_ = args in inv_B res)
  
  function fn_mut_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone'0 self args res_state res /\ resolve_clone'0 res_state)
  
  predicate hist_inv_clone'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'0
  
  function hist_inv_trans_clone'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'0: forall self: (), b: (), c: (). hist_inv_clone'0 self b
      -> hist_inv_clone'0 b c -> hist_inv_clone'0 self c
  
  function hist_inv_refl_clone'0 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'0: forall self: (). hist_inv_clone'0 self self
  
  function postcondition_mut_hist_inv_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      -> hist_inv_clone'0 self res_state
  
  function fn_hist_inv_clone'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'0: forall self: (), res_state: (). hist_inv_clone'0 self res_state = (self = res_state)
  
  predicate postcondition_clone'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4:
    forall args: t_B, res: t_B [postcondition_clone'0 () args res]. postcondition_clone'0 () args res
      -> (let self_ = args in inv_B res)
  
  function fn_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone self args res
      = (postcondition_clone'0 self args res /\ resolve_clone'0 self)
  
  function fn_mut_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      = (postcondition_clone'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Sum_A_B (self: t_Sum_A_B) (return (x: t_Sum_A_B)) =
    {[@expl:clone 'self' type invariant] inv_ref_Sum_A_B self}
    (! bb0
    [ bb0 = any [ br0 (x0: t_A) -> {self = A x0} (! bb4) | br1 (x0: t_B) -> {self = B x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_B {self} (fun (rb: t_B) -> [ &b_1 <- rb ] s1)
      | s1 = [ &_11 <- b_1 ] s2
      | s2 = clone_B {_11} (fun (_ret: t_B) -> [ &_9 <- _ret ] s3)
      | s3 = bb7 ]
    | bb7 = s0 [ s0 = [ &_0 <- B _9 ] s1 | s1 = bb9 ]
    | bb4 = s0
      [ s0 = elim_A {self} (fun (r0: t_A) -> [ &v0_1 <- r0 ] s1)
      | s1 = [ &_7 <- v0_1 ] s2
      | s2 = clone_A {_7} (fun (_ret: t_A) -> [ &_5 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- A _5 ] s1 | s1 = bb9 ]
    | bb9 = return {_0} ]
    [ & _0: t_Sum_A_B = Any.any_l ()
    | & self: t_Sum_A_B = self
    | & v0_1: t_A = Any.any_l ()
    | & _5: t_A = Any.any_l ()
    | & _7: t_A = Any.any_l ()
    | & b_1: t_B = Any.any_l ()
    | & _9: t_B = Any.any_l ()
    | & _11: t_B = Any.any_l () ])
    [ return (result: t_Sum_A_B) -> {[@expl:clone result type invariant] inv_Sum_A_B result}
      {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = A v0_1; f1 = A v0_r} -> postcondition_clone () v0_1 v0_r
        | {f0 = B b_1; f1 = B b_r} -> postcondition_clone'0 () b_1 b_r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_impl_PartialEq_for_Sum_A_B__eq (* <Sum<A, B> as std::cmp::PartialEq> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum_A_B = A t_A | B t_B
  
  type tup2_ref_Sum_A_B_ref_Sum_A_B = { f0: t_Sum_A_B; f1: t_Sum_A_B }
  
  let rec elim_B (input: t_Sum_A_B) (ret (b: t_B)) = any
    [ good (b: t_B) -> {B b = input} (! ret {b})
    | bad -> {forall b: t_B [B b: t_Sum_A_B]. B b <> input} (! {false} any) ]
  
  type tup2_ref_B_ref_B = { f0'0: t_B; f1'0: t_B }
  
  predicate inv_B (_1: t_B)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_eq (self: ()) (args: tup2_ref_B_ref_B)
  
  axiom precondition_fndef:
    forall args: tup2_ref_B_ref_B [precondition_eq () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv_ref_B self_
        /\ inv_ref_B rhs) -> precondition_eq () args
  
  type t_DeepModelTy
  
  function deep_model_B (self: t_B) : t_DeepModelTy
  
  function deep_model_ref_B [@inline:trivial] (self: t_B) : t_DeepModelTy = deep_model_B self
  
  meta "rewrite_def" function deep_model_ref_B
  
  predicate postcondition_once_eq (self: ()) (args: tup2_ref_B_ref_B) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_B_ref_B, res: bool [postcondition_once_eq () args res]. postcondition_once_eq () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = (deep_model_ref_B self_ = deep_model_ref_B rhs))
  
  let rec eq_B (self_: t_B) (rhs: t_B) (return (x: bool)) = {[@expl:eq requires] precondition_eq () { f0'0 = self_;
                                                                                                      f1'0 = rhs }}
    any [ return (result: bool) -> {postcondition_once_eq () { f0'0 = self_; f1'0 = rhs } result} (! return {result}) ]
  
  let rec elim_A (input: t_Sum_A_B) (ret (f0'1: t_A)) = any
    [ good (f0'1: t_A) -> {A f0'1 = input} (! ret {f0'1})
    | bad -> {forall f0'1: t_A [A f0'1: t_Sum_A_B]. A f0'1 <> input} (! {false} any) ]
  
  type tup2_ref_A_ref_A = { f0'1: t_A; f1'1: t_A }
  
  predicate inv_A (_1: t_A)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_eq'0 (self: ()) (args: tup2_ref_A_ref_A)
  
  axiom precondition_fndef'0:
    forall args: tup2_ref_A_ref_A [precondition_eq'0 () args]. (let {f0'1 = self_; f1'1 = rhs} = args in inv_ref_A self_
        /\ inv_ref_A rhs) -> precondition_eq'0 () args
  
  type t_DeepModelTy'0
  
  function deep_model_A (self: t_A) : t_DeepModelTy'0
  
  function deep_model_ref_A [@inline:trivial] (self: t_A) : t_DeepModelTy'0 = deep_model_A self
  
  meta "rewrite_def" function deep_model_ref_A
  
  predicate postcondition_once_eq'0 (self: ()) (args: tup2_ref_A_ref_A) (result: bool)
  
  axiom postcondition_fndef'0:
    forall args: tup2_ref_A_ref_A, res: bool [postcondition_once_eq'0 () args res]. postcondition_once_eq'0 () args res
      -> (let {f0'1 = self_; f1'1 = rhs} = args in res = (deep_model_ref_A self_ = deep_model_ref_A rhs))
  
  let rec eq_A (self_: t_A) (rhs: t_A) (return (x: bool)) = {[@expl:eq requires] precondition_eq'0 () { f0'1 = self_;
                                                                                                        f1'1 = rhs }}
    any
    [ return (result: bool) -> {postcondition_once_eq'0 () { f0'1 = self_; f1'1 = rhs } result} (! return {result}) ]
  
  predicate inv_Sum_A_B (_1: t_Sum_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum_A_B [inv_Sum_A_B x]. inv_Sum_A_B x
      = match x with
        | A f0'2 -> inv_A f0'2
        | B b -> inv_B b
        end
  
  predicate invariant_ref_Sum_A_B [@inline:trivial] (self: t_Sum_A_B) = inv_Sum_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Sum_A_B
  
  predicate inv_ref_Sum_A_B [@inline:trivial] (_1: t_Sum_A_B) = invariant_ref_Sum_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Sum_A_B
  
  type t_Sum_DeepModelTy_DeepModelTy = A'0 t_DeepModelTy'0 | B'0 t_DeepModelTy
  
  function deep_model_Sum_A_B (self: t_Sum_A_B) : t_Sum_DeepModelTy_DeepModelTy = match self with
      | A a -> A'0 (deep_model_A a)
      | B b -> B'0 (deep_model_B b)
      end
  
  function deep_model_ref_Sum_A_B [@inline:trivial] (self: t_Sum_A_B) : t_Sum_DeepModelTy_DeepModelTy =
    deep_model_Sum_A_B self
  
  meta "rewrite_def" function deep_model_ref_Sum_A_B
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_Sum_A_B (self: t_Sum_A_B) (rhs: t_Sum_A_B) (return (x: bool)) =
    {[@expl:eq 'self' type invariant] inv_ref_Sum_A_B self}
    {[@expl:eq 'rhs' type invariant] inv_ref_Sum_A_B rhs}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- { f0 = self; f1 = rhs } ] s1
      | s1 = any [ br0 (x0: t_A) -> {_4.f0 = A x0} (! bb2) | br1 (x0: t_B) -> {_4.f0 = B x0} (! bb4) ] ]
    | bb4 = any [ br0 (x0: t_A) -> {_4.f1 = A x0} (! bb1) | br1 (x0: t_B) -> {_4.f1 = B x0} (! bb6) ]
    | bb6 = s0
      [ s0 = elim_B {_4.f0} (fun (rb: t_B) -> [ &b_1 <- rb ] s1)
      | s1 = elim_B {_4.f1} (fun (rb: t_B) -> [ &b_2 <- rb ] s2)
      | s2 = eq_B {b_1} {b_2} (fun (_ret: bool) -> [ &_17 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = any [ br0 -> {_17 = false} (! bb14) | br1 -> {_17} (! bb13) ]
    | bb13 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb16 ]
    | bb14 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb16 ]
    | bb2 = any [ br0 (x0: t_A) -> {_4.f1 = A x0} (! bb7) | br1 (x0: t_B) -> {_4.f1 = B x0} (! bb1) ]
    | bb1 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb16 ]
    | bb7 = s0
      [ s0 = elim_A {_4.f0} (fun (r0: t_A) -> [ &v0_1 <- r0 ] s1)
      | s1 = elim_A {_4.f1} (fun (r0: t_A) -> [ &v0_2 <- r0 ] s2)
      | s2 = eq_A {v0_1} {v0_2} (fun (_ret: bool) -> [ &_12 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = any [ br0 -> {_12 = false} (! bb10) | br1 -> {_12} (! bb9) ]
    | bb9 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb16 ]
    | bb10 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb16 ]
    | bb16 = return {_0} ]
    [ & _0: bool = Any.any_l ()
    | & self: t_Sum_A_B = self
    | & rhs: t_Sum_A_B = rhs
    | & _4: tup2_ref_Sum_A_B_ref_Sum_A_B = Any.any_l ()
    | & v0_1: t_A = Any.any_l ()
    | & v0_2: t_A = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & b_1: t_B = Any.any_l ()
    | & b_2: t_B = Any.any_l ()
    | & _17: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model_ref_Sum_A_B self = deep_model_ref_Sum_A_B rhs)}
      (! return {result}) ]
end
module M_impl_Clone_for_Sum2_A_B__clone (* <Sum2<A, B> as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_A
  
  type t_B
  
  type t_Sum2_A_B = X t_A | Y bool t_B
  
  let rec elim_Y (input: t_Sum2_A_B) (ret (a: bool) (x: t_B)) = any
    [ good (a: bool) (x: t_B) -> {Y a x = input} (! ret {a} {x})
    | bad -> {forall a: bool, x: t_B [Y a x: t_Sum2_A_B]. Y a x <> input} (! {false} any) ]
  
  let rec clone_bool (self_: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self_} (! return {result}) ]
  
  predicate inv_B (_1: t_B)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_clone (self: ()) (args: t_B)
  
  axiom precondition_fndef: forall args: t_B [precondition_clone () args]. (let self_ = args in inv_ref_B self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef:
    forall args: t_B, res: t_B [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_B res)
  
  let rec clone_B (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_B) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  let rec elim_X (input: t_Sum2_A_B) (ret (f0: t_A)) = any
    [ good (f0: t_A) -> {X f0 = input} (! ret {f0})
    | bad -> {forall f0: t_A [X f0: t_Sum2_A_B]. X f0 <> input} (! {false} any) ]
  
  predicate inv_A (_1: t_A)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_clone'0 (self: ()) (args: t_A)
  
  axiom precondition_fndef'0: forall args: t_A [precondition_clone'0 () args]. (let self_ = args in inv_ref_A self_)
      -> precondition_clone'0 () args
  
  predicate postcondition_once_clone'0 (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_once_clone'0 () args res]. postcondition_once_clone'0 () args res
      -> (let self_ = args in inv_A res)
  
  let rec clone_A (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition_clone'0 () self_}
    any [ return (result: t_A) -> {postcondition_once_clone'0 () self_ result} (! return {result}) ]
  
  predicate inv_Sum2_A_B (_1: t_Sum2_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum2_A_B [inv_Sum2_A_B x]. inv_Sum2_A_B x
      = match x with
        | X f0 -> inv_A f0
        | Y a x'0 -> inv_B x'0
        end
  
  predicate invariant_ref_Sum2_A_B [@inline:trivial] (self: t_Sum2_A_B) = inv_Sum2_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Sum2_A_B
  
  predicate inv_ref_Sum2_A_B [@inline:trivial] (_1: t_Sum2_A_B) = invariant_ref_Sum2_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Sum2_A_B
  
  type tup2_Sum2_A_B_Sum2_A_B = { f0: t_Sum2_A_B; f1: t_Sum2_A_B }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_A res)
  
  function fn_mut_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone'0 self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'2:
    forall args: t_A, res: t_A [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_A res)
  
  function fn_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone'0 self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate postcondition_once_clone'1 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once_clone'1
  
  predicate resolve_clone'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'0
  
  predicate postcondition_mut_clone'0 [@inline:trivial] (self: ()) (args: bool) (result_state: ()) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut_clone'0
  
  function fn_mut_once_clone'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_mut_once_clone_spec'0: forall self: (), args: bool, res: bool. postcondition_once_clone'1 self args res
      = (exists res_state: (). postcondition_mut_clone'0 self args res_state res /\ resolve_clone'0 res_state)
  
  predicate hist_inv_clone'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'0
  
  function hist_inv_trans_clone'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'0: forall self: (), b: (), c: (). hist_inv_clone'0 self b
      -> hist_inv_clone'0 b c -> hist_inv_clone'0 self c
  
  function hist_inv_refl_clone'0 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'0: forall self: (). hist_inv_clone'0 self self
  
  function postcondition_mut_hist_inv_clone'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut_clone'0 self args res_state res
      -> hist_inv_clone'0 self res_state
  
  function fn_hist_inv_clone'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'0: forall self: (), res_state: (). hist_inv_clone'0 self res_state = (self = res_state)
  
  predicate postcondition_clone'0 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_clone'0
  
  function fn_once_clone'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_once_clone_spec'0: forall self: (), args: bool, res: bool. postcondition_once_clone'1 self args res
      = (postcondition_clone'0 self args res /\ resolve_clone'0 self)
  
  function fn_mut_clone'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom fn_mut_clone_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut_clone'0 self args res_state res
      = (postcondition_clone'0 self args res /\ self = res_state)
  
  predicate resolve_clone'1 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'1
  
  predicate postcondition_mut_clone'1 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut_clone'1 () args () res]. postcondition_mut_clone'1 () args () res
      -> (let self_ = args in inv_B res)
  
  function fn_mut_once_clone'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_clone_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone'1 self args res_state res /\ resolve_clone'1 res_state)
  
  predicate hist_inv_clone'1 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'1
  
  function hist_inv_trans_clone'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'1: forall self: (), b: (), c: (). hist_inv_clone'1 self b
      -> hist_inv_clone'1 b c -> hist_inv_clone'1 self c
  
  function hist_inv_refl_clone'1 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'1: forall self: (). hist_inv_clone'1 self self
  
  function postcondition_mut_hist_inv_clone'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'1:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'1 self args res_state res
      -> hist_inv_clone'1 self res_state
  
  function fn_hist_inv_clone'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'1: forall self: (), res_state: (). hist_inv_clone'1 self res_state = (self = res_state)
  
  predicate postcondition_clone'1 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4:
    forall args: t_B, res: t_B [postcondition_clone'1 () args res]. postcondition_clone'1 () args res
      -> (let self_ = args in inv_B res)
  
  function fn_once_clone'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_clone_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once_clone self args res
      = (postcondition_clone'1 self args res /\ resolve_clone'1 self)
  
  function fn_mut_clone'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_clone_spec'1:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'1 self args res_state res
      = (postcondition_clone'1 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Sum2_A_B (self: t_Sum2_A_B) (return (x: t_Sum2_A_B)) =
    {[@expl:clone 'self' type invariant] inv_ref_Sum2_A_B self}
    (! bb0
    [ bb0 = any [ br0 (x0: t_A) -> {self = X x0} (! bb4) | br1 (x0: bool) (x1: t_B) -> {self = Y x0 x1} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Y {self} (fun (ra: bool) (rx: t_B) -> [ &a_1 <- ra ] s1)
      | s1 = elim_Y {self} (fun (ra: bool) (rx: t_B) -> [ &x_1 <- rx ] s2)
      | s2 = [ &_12 <- a_1 ] s3
      | s3 = clone_bool {_12} (fun (_ret: bool) -> [ &_10 <- _ret ] s4)
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_15 <- x_1 ] s1 | s1 = clone_B {_15} (fun (_ret: t_B) -> [ &_13 <- _ret ] s2) | s2 = bb8 ]
    | bb8 = s0 [ s0 = [ &_0 <- Y _10 _13 ] s1 | s1 = bb10 ]
    | bb4 = s0
      [ s0 = elim_X {self} (fun (r0: t_A) -> [ &v0_1 <- r0 ] s1)
      | s1 = [ &_7 <- v0_1 ] s2
      | s2 = clone_A {_7} (fun (_ret: t_A) -> [ &_5 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = [ &_0 <- X _5 ] s1 | s1 = bb10 ]
    | bb10 = return {_0} ]
    [ & _0: t_Sum2_A_B = Any.any_l ()
    | & self: t_Sum2_A_B = self
    | & v0_1: t_A = Any.any_l ()
    | & _5: t_A = Any.any_l ()
    | & _7: t_A = Any.any_l ()
    | & a_1: bool = Any.any_l ()
    | & x_1: t_B = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: t_B = Any.any_l ()
    | & _15: t_B = Any.any_l () ])
    [ return (result: t_Sum2_A_B) -> {[@expl:clone result type invariant] inv_Sum2_A_B result}
      {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = X v0_1; f1 = X v0_r} -> postcondition_clone () v0_1 v0_r
        | {f0 = Y a_1 x_1; f1 = Y a_r x_r} -> postcondition_clone'0 () a_1 a_r /\ postcondition_clone'1 () x_1 x_r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_impl_Clone_for_Product_A_B__clone__refines (* <Product<A, B> as std::clone::Clone> *)
  type t_A
  
  type t_B
  
  type t_Product_A_B = { a: t_A; b: t_B }
  
  predicate inv_A (_1: t_A)
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Product_A_B (_1: t_Product_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Product_A_B [inv_Product_A_B x]. inv_Product_A_B x = (inv_A x.a /\ inv_B x.b)
  
  predicate invariant_ref_Product_A_B [@inline:trivial] (self: t_Product_A_B) = inv_Product_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Product_A_B
  
  predicate inv_ref_Product_A_B [@inline:trivial] (_1: t_Product_A_B) = invariant_ref_Product_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Product_A_B
  
  predicate postcondition_once_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef:
    forall args: t_A, res: t_A [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_A res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_A res)
  
  function fn_mut_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b'0: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b'0: (), c: (). hist_inv_clone self b'0
      -> hist_inv_clone b'0 c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_A res)
  
  function fn_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_clone (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition_clone () args]. (let self_ = args in inv_ref_A self_)
      -> precondition_clone () args
  
  let rec clone_A (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_A) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  predicate postcondition_once_clone'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'2:
    forall args: t_B, res: t_B [postcondition_once_clone'0 () args res]. postcondition_once_clone'0 () args res
      -> (let self_ = args in inv_B res)
  
  predicate resolve_clone'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'0
  
  predicate postcondition_mut_clone'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut_clone'0 () args () res]. postcondition_mut_clone'0 () args () res
      -> (let self_ = args in inv_B res)
  
  function fn_mut_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone'0 self args res
      = (exists res_state: (). postcondition_mut_clone'0 self args res_state res /\ resolve_clone'0 res_state)
  
  predicate hist_inv_clone'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'0
  
  function hist_inv_trans_clone'0 (self: ()) (b'0: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'0: forall self: (), b'0: (), c: (). hist_inv_clone'0 self b'0
      -> hist_inv_clone'0 b'0 c -> hist_inv_clone'0 self c
  
  function hist_inv_refl_clone'0 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'0: forall self: (). hist_inv_clone'0 self self
  
  function postcondition_mut_hist_inv_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      -> hist_inv_clone'0 self res_state
  
  function fn_hist_inv_clone'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'0: forall self: (), res_state: (). hist_inv_clone'0 self res_state = (self = res_state)
  
  predicate postcondition_clone'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4:
    forall args: t_B, res: t_B [postcondition_clone'0 () args res]. postcondition_clone'0 () args res
      -> (let self_ = args in inv_B res)
  
  function fn_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone'0 self args res
      = (postcondition_clone'0 self args res /\ resolve_clone'0 self)
  
  function fn_mut_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      = (postcondition_clone'0 self args res /\ self = res_state)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_clone'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition_clone'0 () args]. (let self_ = args in inv_ref_B self_)
      -> precondition_clone'0 () args
  
  let rec clone_B (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition_clone'0 () self_}
    any [ return (result: t_B) -> {postcondition_once_clone'0 () self_ result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Product_A_B. inv_ref_Product_A_B self_
      -> inv_ref_Product_A_B self_
      /\ (forall result: t_Product_A_B. inv_Product_A_B result
          /\ postcondition_clone () self_.a result.a /\ postcondition_clone'0 () self_.b result.b
        -> inv_Product_A_B result)
end
module M_impl_Clone_for_Sum_A_B__clone__refines (* <Sum<A, B> as std::clone::Clone> *)
  type t_A
  
  type t_B
  
  type t_Sum_A_B = A t_A | B t_B
  
  predicate inv_A (_1: t_A)
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Sum_A_B (_1: t_Sum_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum_A_B [inv_Sum_A_B x]. inv_Sum_A_B x
      = match x with
        | A f0 -> inv_A f0
        | B b -> inv_B b
        end
  
  predicate invariant_ref_Sum_A_B [@inline:trivial] (self: t_Sum_A_B) = inv_Sum_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Sum_A_B
  
  predicate inv_ref_Sum_A_B [@inline:trivial] (_1: t_Sum_A_B) = invariant_ref_Sum_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Sum_A_B
  
  type tup2_Sum_A_B_Sum_A_B = { f0: t_Sum_A_B; f1: t_Sum_A_B }
  
  predicate postcondition_once_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef:
    forall args: t_A, res: t_A [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_A res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_A res)
  
  function fn_mut_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_A res)
  
  function fn_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_clone (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition_clone () args]. (let self_ = args in inv_ref_A self_)
      -> precondition_clone () args
  
  let rec clone_A (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_A) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  predicate postcondition_once_clone'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'2:
    forall args: t_B, res: t_B [postcondition_once_clone'0 () args res]. postcondition_once_clone'0 () args res
      -> (let self_ = args in inv_B res)
  
  predicate resolve_clone'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'0
  
  predicate postcondition_mut_clone'0 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut_clone'0 () args () res]. postcondition_mut_clone'0 () args () res
      -> (let self_ = args in inv_B res)
  
  function fn_mut_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone'0 self args res
      = (exists res_state: (). postcondition_mut_clone'0 self args res_state res /\ resolve_clone'0 res_state)
  
  predicate hist_inv_clone'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'0
  
  function hist_inv_trans_clone'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'0: forall self: (), b: (), c: (). hist_inv_clone'0 self b
      -> hist_inv_clone'0 b c -> hist_inv_clone'0 self c
  
  function hist_inv_refl_clone'0 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'0: forall self: (). hist_inv_clone'0 self self
  
  function postcondition_mut_hist_inv_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      -> hist_inv_clone'0 self res_state
  
  function fn_hist_inv_clone'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'0: forall self: (), res_state: (). hist_inv_clone'0 self res_state = (self = res_state)
  
  predicate postcondition_clone'0 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4:
    forall args: t_B, res: t_B [postcondition_clone'0 () args res]. postcondition_clone'0 () args res
      -> (let self_ = args in inv_B res)
  
  function fn_once_clone'0 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_clone_spec'0: forall self: (), args: t_B, res: t_B. postcondition_once_clone'0 self args res
      = (postcondition_clone'0 self args res /\ resolve_clone'0 self)
  
  function fn_mut_clone'0 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_clone_spec'0:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'0 self args res_state res
      = (postcondition_clone'0 self args res /\ self = res_state)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_clone'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition_clone'0 () args]. (let self_ = args in inv_ref_B self_)
      -> precondition_clone'0 () args
  
  let rec clone_B (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition_clone'0 () self_}
    any [ return (result: t_B) -> {postcondition_once_clone'0 () self_ result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Sum_A_B. inv_ref_Sum_A_B self_
      -> inv_ref_Sum_A_B self_
      /\ (forall result: t_Sum_A_B. inv_Sum_A_B result
          /\ match { f0 = self_; f1 = result } with
            | {f0 = A v0_1; f1 = A v0_r} -> postcondition_clone () v0_1 v0_r
            | {f0 = B b_1; f1 = B b_r} -> postcondition_clone'0 () b_1 b_r
            | _ -> false
            end -> inv_Sum_A_B result)
end
module M_impl_Clone_for_Sum2_A_B__clone__refines (* <Sum2<A, B> as std::clone::Clone> *)
  type t_A
  
  type t_B
  
  type t_Sum2_A_B = X t_A | Y bool t_B
  
  predicate inv_A (_1: t_A)
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Sum2_A_B (_1: t_Sum2_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum2_A_B [inv_Sum2_A_B x]. inv_Sum2_A_B x
      = match x with
        | X f0 -> inv_A f0
        | Y a x'0 -> inv_B x'0
        end
  
  predicate invariant_ref_Sum2_A_B [@inline:trivial] (self: t_Sum2_A_B) = inv_Sum2_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Sum2_A_B
  
  predicate inv_ref_Sum2_A_B [@inline:trivial] (_1: t_Sum2_A_B) = invariant_ref_Sum2_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Sum2_A_B
  
  type tup2_Sum2_A_B_Sum2_A_B = { f0: t_Sum2_A_B; f1: t_Sum2_A_B }
  
  predicate postcondition_once_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef:
    forall args: t_A, res: t_A [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_A res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_A) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: t_A, res: t_A [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_A res)
  
  function fn_mut_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_A) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: t_A, res: t_A [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_A res)
  
  function fn_once_clone (self: ()) (args: t_A) (res: t_A) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_A, res: t_A. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_A) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_A, res_state: (), res: t_A. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate invariant_ref_A [@inline:trivial] (self: t_A) = inv_A self
  
  meta "rewrite_def" predicate invariant_ref_A
  
  predicate inv_ref_A [@inline:trivial] (_1: t_A) = invariant_ref_A _1
  
  meta "rewrite_def" predicate inv_ref_A
  
  predicate precondition_clone (self: ()) (args: t_A)
  
  axiom precondition_fndef: forall args: t_A [precondition_clone () args]. (let self_ = args in inv_ref_A self_)
      -> precondition_clone () args
  
  let rec clone_A (self_: t_A) (return (x: t_A)) = {[@expl:clone requires] precondition_clone () self_}
    any [ return (result: t_A) -> {postcondition_once_clone () self_ result} (! return {result}) ]
  
  predicate postcondition_once_clone'0 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once_clone'0
  
  predicate resolve_clone'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'0
  
  predicate postcondition_mut_clone'0 [@inline:trivial] (self: ()) (args: bool) (result_state: ()) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut_clone'0
  
  function fn_mut_once_clone'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_mut_once_clone_spec'0: forall self: (), args: bool, res: bool. postcondition_once_clone'0 self args res
      = (exists res_state: (). postcondition_mut_clone'0 self args res_state res /\ resolve_clone'0 res_state)
  
  predicate hist_inv_clone'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'0
  
  function hist_inv_trans_clone'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'0: forall self: (), b: (), c: (). hist_inv_clone'0 self b
      -> hist_inv_clone'0 b c -> hist_inv_clone'0 self c
  
  function hist_inv_refl_clone'0 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'0: forall self: (). hist_inv_clone'0 self self
  
  function postcondition_mut_hist_inv_clone'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut_clone'0 self args res_state res
      -> hist_inv_clone'0 self res_state
  
  function fn_hist_inv_clone'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'0: forall self: (), res_state: (). hist_inv_clone'0 self res_state = (self = res_state)
  
  predicate postcondition_clone'0 [@inline:trivial] (self: ()) (args: bool) (result: bool) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_clone'0
  
  function fn_once_clone'0 (self: ()) (args: bool) (res: bool) : ()
  
  axiom fn_once_clone_spec'0: forall self: (), args: bool, res: bool. postcondition_once_clone'0 self args res
      = (postcondition_clone'0 self args res /\ resolve_clone'0 self)
  
  function fn_mut_clone'0 (self: ()) (args: bool) (res_state: ()) (res: bool) : ()
  
  axiom fn_mut_clone_spec'0:
    forall self: (), args: bool, res_state: (), res: bool. postcondition_mut_clone'0 self args res_state res
      = (postcondition_clone'0 self args res /\ self = res_state)
  
  let rec clone_bool (self_: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self_} (! return {result}) ]
  
  predicate postcondition_once_clone'1 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'2:
    forall args: t_B, res: t_B [postcondition_once_clone'1 () args res]. postcondition_once_clone'1 () args res
      -> (let self_ = args in inv_B res)
  
  predicate resolve_clone'1 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'1
  
  predicate postcondition_mut_clone'1 (self: ()) (args: t_B) (result_state: ()) (result: t_B)
  
  axiom postcondition_fndef'3:
    forall args: t_B, res: t_B [postcondition_mut_clone'1 () args () res]. postcondition_mut_clone'1 () args () res
      -> (let self_ = args in inv_B res)
  
  function fn_mut_once_clone'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_mut_once_clone_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once_clone'1 self args res
      = (exists res_state: (). postcondition_mut_clone'1 self args res_state res /\ resolve_clone'1 res_state)
  
  predicate hist_inv_clone'1 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'1
  
  function hist_inv_trans_clone'1 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'1: forall self: (), b: (), c: (). hist_inv_clone'1 self b
      -> hist_inv_clone'1 b c -> hist_inv_clone'1 self c
  
  function hist_inv_refl_clone'1 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'1: forall self: (). hist_inv_clone'1 self self
  
  function postcondition_mut_hist_inv_clone'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'1:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'1 self args res_state res
      -> hist_inv_clone'1 self res_state
  
  function fn_hist_inv_clone'1 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'1: forall self: (), res_state: (). hist_inv_clone'1 self res_state = (self = res_state)
  
  predicate postcondition_clone'1 (self: ()) (args: t_B) (result: t_B)
  
  axiom postcondition_fndef'4:
    forall args: t_B, res: t_B [postcondition_clone'1 () args res]. postcondition_clone'1 () args res
      -> (let self_ = args in inv_B res)
  
  function fn_once_clone'1 (self: ()) (args: t_B) (res: t_B) : ()
  
  axiom fn_once_clone_spec'1: forall self: (), args: t_B, res: t_B. postcondition_once_clone'1 self args res
      = (postcondition_clone'1 self args res /\ resolve_clone'1 self)
  
  function fn_mut_clone'1 (self: ()) (args: t_B) (res_state: ()) (res: t_B) : ()
  
  axiom fn_mut_clone_spec'1:
    forall self: (), args: t_B, res_state: (), res: t_B. postcondition_mut_clone'1 self args res_state res
      = (postcondition_clone'1 self args res /\ self = res_state)
  
  predicate invariant_ref_B [@inline:trivial] (self: t_B) = inv_B self
  
  meta "rewrite_def" predicate invariant_ref_B
  
  predicate inv_ref_B [@inline:trivial] (_1: t_B) = invariant_ref_B _1
  
  meta "rewrite_def" predicate inv_ref_B
  
  predicate precondition_clone'0 (self: ()) (args: t_B)
  
  axiom precondition_fndef'0: forall args: t_B [precondition_clone'0 () args]. (let self_ = args in inv_ref_B self_)
      -> precondition_clone'0 () args
  
  let rec clone_B (self_: t_B) (return (x: t_B)) = {[@expl:clone requires] precondition_clone'0 () self_}
    any [ return (result: t_B) -> {postcondition_once_clone'1 () self_ result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Sum2_A_B. inv_ref_Sum2_A_B self_
      -> inv_ref_Sum2_A_B self_
      /\ (forall result: t_Sum2_A_B. inv_Sum2_A_B result
          /\ match { f0 = self_; f1 = result } with
            | {f0 = X v0_1; f1 = X v0_r} -> postcondition_clone () v0_1 v0_r
            | {f0 = Y a_1 x_1; f1 = Y a_r x_r} -> postcondition_clone'0 () a_1 a_r /\ postcondition_clone'1 () x_1 x_r
            | _ -> false
            end -> inv_Sum2_A_B result)
end
module M_impl_PartialEq_for_Product_A_B__eq__refines (* <Product<A, B> as std::cmp::PartialEq> *)
  type t_A
  
  type t_B
  
  type t_Product_A_B = { a: t_A; b: t_B }
  
  predicate inv_A (_1: t_A)
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Product_A_B (_1: t_Product_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Product_A_B [inv_Product_A_B x]. inv_Product_A_B x = (inv_A x.a /\ inv_B x.b)
  
  predicate invariant_ref_Product_A_B [@inline:trivial] (self: t_Product_A_B) = inv_Product_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Product_A_B
  
  predicate inv_ref_Product_A_B [@inline:trivial] (_1: t_Product_A_B) = invariant_ref_Product_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Product_A_B
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type t_Product_DeepModelTy_DeepModelTy = { a'0: t_DeepModelTy; b'0: t_DeepModelTy'0 }
  
  function deep_model_A (self: t_A) : t_DeepModelTy
  
  function deep_model_B (self: t_B) : t_DeepModelTy'0
  
  function deep_model_Product_A_B (self: t_Product_A_B) : t_Product_DeepModelTy_DeepModelTy =
    { a'0 = deep_model_A self.a; b'0 = deep_model_B self.b }
  
  function deep_model_ref_Product_A_B [@inline:trivial] (self: t_Product_A_B) : t_Product_DeepModelTy_DeepModelTy =
    deep_model_Product_A_B self
  
  meta "rewrite_def" function deep_model_ref_Product_A_B
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Product_A_B. forall rhs: t_Product_A_B. inv_ref_Product_A_B self_
          /\ inv_ref_Product_A_B rhs
        -> inv_ref_Product_A_B self_
        /\ inv_ref_Product_A_B rhs
        /\ (forall result: bool. result = (deep_model_ref_Product_A_B self_ = deep_model_ref_Product_A_B rhs)
          -> result = (deep_model_ref_Product_A_B self_ = deep_model_ref_Product_A_B rhs))
end
module M_impl_PartialEq_for_Sum_A_B__eq__refines (* <Sum<A, B> as std::cmp::PartialEq> *)
  type t_A
  
  type t_B
  
  type t_Sum_A_B = A t_A | B t_B
  
  predicate inv_A (_1: t_A)
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Sum_A_B (_1: t_Sum_A_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_Sum_A_B [inv_Sum_A_B x]. inv_Sum_A_B x
      = match x with
        | A f0 -> inv_A f0
        | B b -> inv_B b
        end
  
  predicate invariant_ref_Sum_A_B [@inline:trivial] (self: t_Sum_A_B) = inv_Sum_A_B self
  
  meta "rewrite_def" predicate invariant_ref_Sum_A_B
  
  predicate inv_ref_Sum_A_B [@inline:trivial] (_1: t_Sum_A_B) = invariant_ref_Sum_A_B _1
  
  meta "rewrite_def" predicate inv_ref_Sum_A_B
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type t_Sum_DeepModelTy_DeepModelTy = A'0 t_DeepModelTy | B'0 t_DeepModelTy'0
  
  function deep_model_A (self: t_A) : t_DeepModelTy
  
  function deep_model_B (self: t_B) : t_DeepModelTy'0
  
  function deep_model_Sum_A_B (self: t_Sum_A_B) : t_Sum_DeepModelTy_DeepModelTy = match self with
      | A a -> A'0 (deep_model_A a)
      | B b -> B'0 (deep_model_B b)
      end
  
  function deep_model_ref_Sum_A_B [@inline:trivial] (self: t_Sum_A_B) : t_Sum_DeepModelTy_DeepModelTy =
    deep_model_Sum_A_B self
  
  meta "rewrite_def" function deep_model_ref_Sum_A_B
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Sum_A_B. forall rhs: t_Sum_A_B. inv_ref_Sum_A_B self_ /\ inv_ref_Sum_A_B rhs
        -> inv_ref_Sum_A_B self_
        /\ inv_ref_Sum_A_B rhs
        /\ (forall result: bool. result = (deep_model_ref_Sum_A_B self_ = deep_model_ref_Sum_A_B rhs)
          -> result = (deep_model_ref_Sum_A_B self_ = deep_model_ref_Sum_A_B rhs))
end
