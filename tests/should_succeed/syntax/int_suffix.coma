module M_foo
  use creusot.int.Int128
  use creusot.prelude.Any
  
  let rec new (value: Int128.t) (return (x: int)) = any
    [ return (result: int) -> {result = Int128.to_int value} (! return {result}) ]
  
  let rec into_inner_Int (self: int) (return (x: int)) = any
    [ return (result: int) -> {result = self} (! return {result}) ]
  
  let rec new_Int (x: int) (return (x'0: int)) = any [ return (result: int) -> {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo (return (x: int)) = (! bb0
    [ bb0 = s0
      [ s0 = new {(1: Int128.t)} (fun (_x: int) -> [ &_3 <- _x ] s1)
      | s1 = into_inner_Int {_3} (fun (_x: int) -> [ &_2 <- _x ] s2)
      | s2 = new_Int {_2} (fun (_x: int) -> [ &_ret <- _x ] s3)
      | s3 = return {_ret} ] ] [ & _ret: int = Any.any_l () | & _2: int = Any.any_l () | & _3: int = Any.any_l () ])
    [ return (result: int) -> {[@expl:foo ensures] result = 1} (! return {result}) ]
end
