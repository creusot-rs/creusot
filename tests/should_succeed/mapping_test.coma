module M_incr
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_T = { a: Int32.t }
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  function view_T (self: t_T) : Map.map int int
  
  axiom view_T_spec: forall self: t_T. forall i: int. Map.get (view_T self) i
        = (if 0 <= i /\ i < Int32.to_int self.a then 1 else 0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec incr (t: MutBorrow.t t_T) (return (x: ())) = {[@expl:incr requires #0] 0 <= Int32.to_int t.current.a}
    {[@expl:incr requires #1] Int32.to_int t.current.a < 1000}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_t <- t ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = Int32.add {t.current.a} {(1: Int32.t)}
          (fun (_ret: Int32.t) -> [ &t <- { t with current = { a = _ret } } ] s1)
      | s1 = -{resolve_ref_T t}- s2
      | s2 = {[@expl:assertion] view_T t.final = Map.set (view_T old_t.current) (Int32.to_int old_t.current.a) 1} s3
      | s3 = return {_0} ] ]
    [ & _0: () = Any.any_l () | & t: MutBorrow.t t_T = t | & old_t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: ()) -> {[@expl:incr ensures] view_T t.final
      = Map.set (view_T t.current) (Int32.to_int t.current.a) 1}
      (! return {result}) ]
end
module M_f
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T = { a: Int32.t }
  
  function view_T (self: t_T) : Map.map int int
  
  axiom view_T_spec: forall self: t_T. forall i: int. Map.get (view_T self) i
        = (if 0 <= i /\ i < Int32.to_int self.a then 1 else 0)
  
  let rec incr (t: MutBorrow.t t_T) (return (x: ())) = {[@expl:incr requires #0] 0 <= Int32.to_int t.current.a}
    {[@expl:incr requires #1] Int32.to_int t.current.a < 1000}
    any
    [ return (result: ()) -> {view_T t.final = Map.set (view_T t.current) (Int32.to_int t.current.a) 1}
      (! return {result}) ]
  
  predicate resolve_ref_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- { a = (42: Int32.t) } ] s1
      | s1 = {[@expl:assertion] Map.get (view_T x) 13 = 1} s2
      | s2 = {[@expl:assertion] Map.get (view_T x) 42 = 0} s3
      | s3 = MutBorrow.borrow_mut <t_T> {x} (fun (_ret: MutBorrow.t t_T) -> [ &_10 <- _ret ] [ &x <- _ret.final ] s4)
      | s4 = MutBorrow.borrow_final <t_T> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret: MutBorrow.t t_T) -> [ &_9 <- _ret ] [ &_10 <- { _10 with current = _ret.final } ] s5)
      | s5 = incr {_9} (fun (_ret: ()) -> [ &_8 <- _ret ] s6)
      | s6 = bb1 ]
    | bb1 = s0
      [ s0 = -{resolve_ref_T _10}- s1
      | s1 = {[@expl:assertion] Map.get (view_T x) 13 = 1} s2
      | s2 = {[@expl:assertion] Map.get (view_T x) 42 = 1} s3
      | s3 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _9: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
