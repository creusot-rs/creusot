module M_knapsack_full__max [#"knapsack_full.rs" 15 0 15 35]
  let%span sknapsack_full = "knapsack_full.rs" 14 10 14 31
  
  use creusot.int.UInt64
  use int.MinMax
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  let rec max[#"knapsack_full.rs" 15 0 15 35] (a:UInt64.t) (b:UInt64.t) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- UInt64.lt a'0 b'0 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ]  ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- b'0 ] s1 | s1 = bb3 ] 
    | bb2 = s0 [ s0 =  [ &_0 <- a'0 ] s1 | s1 = bb3 ] 
    | bb3 = return''0 {_0} ]
    ) [ & _0: UInt64.t = Any.any_l () | & a'0: UInt64.t = a | & b'0: UInt64.t = b | & _4: bool = Any.any_l () ] 
    [ return''0 (result:UInt64.t)-> {[@expl:max ensures] [%#sknapsack_full] UInt64.t'int result
      = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return' {result}) ]

end
module M_knapsack_full__sum_weights [#"knapsack_full.rs" 23 0 23 56]
  let%span sknapsack_full = "knapsack_full.rs" 21 11 21 33
  let%span sknapsack_full'0 = "knapsack_full.rs" 22 10 22 21
  let%span sknapsack_full'1 = "knapsack_full.rs" 20 10 20 19
  let%span sknapsack_full'2 = "knapsack_full.rs" 25 8 26 51
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Name
  
  type t_Item  =
    { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  constant s  : Seq.seq t_Item
  
  constant i  : int
  
  function sum_weights [#"knapsack_full.rs" 23 0 23 56] (s'0: Seq.seq t_Item) (i'0: int) : int
  
  goal vc_sum_weights: ([%#sknapsack_full] 0 <= i /\ i <= Seq.length s)
   -> (if i = Seq.length s then
    [@expl:sum_weights ensures] [%#sknapsack_full'0] 0 >= 0
  else
    (([@expl:sum_weights requires] [%#sknapsack_full] 0 <= i + 1 /\ i + 1 <= Seq.length s)
    /\ 0 <= ([%#sknapsack_full'1] Seq.length s - i)
    /\ ([%#sknapsack_full'1] Seq.length s - (i + 1)) < ([%#sknapsack_full'1] Seq.length s - i))
    /\ (([%#sknapsack_full'0] sum_weights s (i + 1) >= 0)
     -> ([@expl:sum_weights ensures] [%#sknapsack_full'0] UInt64.t'int (Seq.get s i).t_Item__weight
    + sum_weights s (i + 1)
    >= 0))
  )
end
module M_knapsack_full__sum_values [#"knapsack_full.rs" 33 0 33 55]
  let%span sknapsack_full = "knapsack_full.rs" 32 11 32 33
  let%span sknapsack_full'0 = "knapsack_full.rs" 31 10 31 19
  let%span sknapsack_full'1 = "knapsack_full.rs" 35 8 36 49
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Name
  
  type t_Item  =
    { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  constant s  : Seq.seq t_Item
  
  constant i  : int
  
  function sum_values [#"knapsack_full.rs" 33 0 33 55] (s'0: Seq.seq t_Item) (i'0: int) : int
  
  goal vc_sum_values: ([%#sknapsack_full] i >= 0 /\ i <= Seq.length s)
   -> (if i = Seq.length s then
    true
  else
    ([@expl:sum_values requires] [%#sknapsack_full] i + 1 >= 0 /\ i + 1 <= Seq.length s)
    /\ 0 <= ([%#sknapsack_full'0] Seq.length s - i)
    /\ ([%#sknapsack_full'0] Seq.length s - (i + 1)) < ([%#sknapsack_full'0] Seq.length s - i)
  )
end
module M_knapsack_full__subseq_rev [#"knapsack_full.rs" 44 0 44 67]
  let%span sknapsack_full = "knapsack_full.rs" 42 11 42 36
  let%span sknapsack_full'0 = "knapsack_full.rs" 43 11 43 36
  let%span sknapsack_full'1 = "knapsack_full.rs" 41 10 41 12
  let%span sknapsack_full'2 = "knapsack_full.rs" 46 8 50 9
  
  use seq.Seq
  use mach.int.Int
  
  type t_T
  
  constant s1  : Seq.seq t_T
  
  constant i1  : int
  
  constant s2  : Seq.seq t_T
  
  constant i2  : int
  
  predicate subseq_rev [#"knapsack_full.rs" 44 0 44 67] (s1'0: Seq.seq t_T) (i1'0: int) (s2'0: Seq.seq t_T) (i2'0: int)
  
  goal vc_subseq_rev: ([%#sknapsack_full] 0 <= i1 /\ i1 <= Seq.length s1)
   -> ([%#sknapsack_full'0] 0 <= i2 /\ i2 <= Seq.length s2)
   -> (if i2 = 0 then
    true
  else
    if i1 < Seq.length s1 then
      if Seq.get s1 i1 = Seq.get s2 (i2 - 1) then
        ((([@expl:subseq_rev requires #0] [%#sknapsack_full] 0 <= i1 + 1 /\ i1 + 1 <= Seq.length s1)
        && ([@expl:subseq_rev requires #1] [%#sknapsack_full'0] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
        /\ 0 <= ([%#sknapsack_full'1] i2) /\ ([%#sknapsack_full'1] i2 - 1) < ([%#sknapsack_full'1] i2))
        /\ (if subseq_rev s1 (i1 + 1) s2 (i2 - 1) then
          true
        else
          (([@expl:subseq_rev requires #0] [%#sknapsack_full] 0 <= i1 /\ i1 <= Seq.length s1)
          && ([@expl:subseq_rev requires #1] [%#sknapsack_full'0] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
          /\ 0 <= ([%#sknapsack_full'1] i2) /\ ([%#sknapsack_full'1] i2 - 1) < ([%#sknapsack_full'1] i2)
        )
      else
        (([@expl:subseq_rev requires #0] [%#sknapsack_full] 0 <= i1 /\ i1 <= Seq.length s1)
        && ([@expl:subseq_rev requires #1] [%#sknapsack_full'0] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
        /\ 0 <= ([%#sknapsack_full'1] i2) /\ ([%#sknapsack_full'1] i2 - 1) < ([%#sknapsack_full'1] i2)
    
    else
      (([@expl:subseq_rev requires #0] [%#sknapsack_full] 0 <= i1 /\ i1 <= Seq.length s1)
      && ([@expl:subseq_rev requires #1] [%#sknapsack_full'0] 0 <= i2 - 1 /\ i2 - 1 <= Seq.length s2))
      /\ 0 <= ([%#sknapsack_full'1] i2) /\ ([%#sknapsack_full'1] i2 - 1) < ([%#sknapsack_full'1] i2)
  
  )
end
module M_knapsack_full__m [#"knapsack_full.rs" 62 0 62 57]
  let%span sknapsack_full = "knapsack_full.rs" 56 11 56 37
  let%span sknapsack_full'0 = "knapsack_full.rs" 57 11 57 17
  let%span sknapsack_full'1 = "knapsack_full.rs" 58 10 58 21
  let%span sknapsack_full'2 = "knapsack_full.rs" 59 10 60 30
  let%span sknapsack_full'3 = "knapsack_full.rs" 55 10 55 11
  let%span sknapsack_full'4 = "knapsack_full.rs" 64 8 69 9
  let%span sknapsack_full'5 = "knapsack_full.rs" 42 11 42 36
  let%span sknapsack_full'6 = "knapsack_full.rs" 43 11 43 36
  let%span sknapsack_full'7 = "knapsack_full.rs" 41 10 41 12
  let%span sknapsack_full'8 = "knapsack_full.rs" 46 8 50 9
  let%span sknapsack_full'9 = "knapsack_full.rs" 21 11 21 33
  let%span sknapsack_full'10 = "knapsack_full.rs" 22 10 22 21
  let%span sknapsack_full'11 = "knapsack_full.rs" 20 10 20 19
  let%span sknapsack_full'12 = "knapsack_full.rs" 25 8 26 51
  let%span sknapsack_full'13 = "knapsack_full.rs" 32 11 32 33
  let%span sknapsack_full'14 = "knapsack_full.rs" 31 10 31 19
  let%span sknapsack_full'15 = "knapsack_full.rs" 35 8 36 49
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  
  type t_Name
  
  type t_Item  =
    { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate subseq_rev [#"knapsack_full.rs" 44 0 44 67] (s1: Seq.seq t_Item) (i1: int) (s2: Seq.seq t_Item) (i2: int)
  
  axiom subseq_rev_def: forall s1: Seq.seq t_Item, i1: int, s2: Seq.seq t_Item, i2: int. ([%#sknapsack_full'5] 0 <= i1
  /\ i1 <= Seq.length s1)
   -> ([%#sknapsack_full'6] 0 <= i2 /\ i2 <= Seq.length s2)
   -> subseq_rev s1 i1 s2 i2
  = ([%#sknapsack_full'8] if i2 = 0 then
    i1 = Seq.length s1
  else
    i1 < Seq.length s1 /\ Seq.get s1 i1 = Seq.get s2 (i2 - 1) /\ subseq_rev s1 (i1 + 1) s2 (i2 - 1)
    \/ subseq_rev s1 i1 s2 (i2 - 1)
  )
  
  function sum_weights [#"knapsack_full.rs" 23 0 23 56] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_weights_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'9] 0 <= i /\ i <= Seq.length s)
   -> sum_weights s i
  = ([%#sknapsack_full'12] if i = Seq.length s then
    0
  else
    UInt64.t'int (Seq.get s i).t_Item__weight + sum_weights s (i + 1)
  )
  
  axiom sum_weights_spec: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'9] 0 <= i /\ i <= Seq.length s)
   -> ([%#sknapsack_full'10] sum_weights s i >= 0)
  
  function sum_values [#"knapsack_full.rs" 33 0 33 55] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_values_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'13] i >= 0 /\ i <= Seq.length s)
   -> sum_values s i
  = ([%#sknapsack_full'15] if i = Seq.length s then
    0
  else
    UInt64.t'int (Seq.get s i).t_Item__value + sum_values s (i + 1)
  )
  
  constant items  : Seq.seq t_Item
  
  constant i  : int
  
  constant w  : int
  
  function m [#"knapsack_full.rs" 62 0 62 57] (items'0: Seq.seq t_Item) (i'0: int) (w'0: int) : int
  
  goal vc_m: ([%#sknapsack_full] 0 <= i /\ i <= Seq.length items)
   -> ([%#sknapsack_full'0] 0 <= w)
   -> (if i = 0 then
    let result = 0 in ([@expl:m ensures #0] [%#sknapsack_full'1] result >= 0)
    && ([@expl:m ensures #1] [%#sknapsack_full'2] forall s: Seq.seq t_Item, j: int. 0 <= j
    /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w  -> sum_values s j <= result)
  else
    if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
      ((([@expl:m requires #0] [%#sknapsack_full] 0 <= i - 1 /\ i - 1 <= Seq.length items)
      && ([@expl:m requires #1] [%#sknapsack_full'0] 0 <= w))
      /\ 0 <= ([%#sknapsack_full'3] i) /\ ([%#sknapsack_full'3] i - 1) < ([%#sknapsack_full'3] i))
      /\ (([%#sknapsack_full'1] m items (i - 1) w >= 0)
      && ([%#sknapsack_full'2] forall s: Seq.seq t_Item, j: int. 0 <= j
      /\ j <= Seq.length s /\ subseq_rev s j items (i - 1) /\ sum_weights s j <= w
       -> sum_values s j <= m items (i - 1) w)
       -> (let result = m items (i - 1) w in ([@expl:m ensures #0] [%#sknapsack_full'1] result >= 0)
      && ([@expl:m ensures #1] [%#sknapsack_full'2] forall s: Seq.seq t_Item, j: int. 0 <= j
      /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w  -> sum_values s j <= result)))
    else
      ((([@expl:m requires #0] [%#sknapsack_full] 0 <= i - 1 /\ i - 1 <= Seq.length items)
      && ([@expl:m requires #1] [%#sknapsack_full'0] 0 <= w))
      /\ 0 <= ([%#sknapsack_full'3] i) /\ ([%#sknapsack_full'3] i - 1) < ([%#sknapsack_full'3] i))
      /\ (([%#sknapsack_full'1] m items (i - 1) w >= 0)
      && ([%#sknapsack_full'2] forall s: Seq.seq t_Item, j: int. 0 <= j
      /\ j <= Seq.length s /\ subseq_rev s j items (i - 1) /\ sum_weights s j <= w
       -> sum_values s j <= m items (i - 1) w)
       -> ((([@expl:m requires #0] [%#sknapsack_full] 0 <= i - 1 /\ i - 1 <= Seq.length items)
      && ([@expl:m requires #1] [%#sknapsack_full'0] 0 <= w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight))
      /\ 0 <= ([%#sknapsack_full'3] i) /\ ([%#sknapsack_full'3] i - 1) < ([%#sknapsack_full'3] i))
      /\ (([%#sknapsack_full'1] m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight) >= 0)
      && ([%#sknapsack_full'2] forall s: Seq.seq t_Item, j: int. 0 <= j
      /\ j <= Seq.length s
      /\ subseq_rev s j items (i - 1) /\ sum_weights s j <= w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight
       -> sum_values s j <= m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight))
       -> (let result = MinMax.max (m items (i - 1) w) (m items (i - 1) (w
      - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
      + UInt64.t'int (Seq.get items (i - 1)).t_Item__value) in ([@expl:m ensures #0] [%#sknapsack_full'1] result >= 0)
      && ([@expl:m ensures #1] [%#sknapsack_full'2] forall s: Seq.seq t_Item, j: int. 0 <= j
      /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w  -> sum_values s j <= result))))
  
  )
end
module M_knapsack_full__knapsack01_dyn [#"knapsack_full.rs" 81 0 81 91]
  let%span sknapsack_full = "knapsack_full.rs" 82 51 82 52
  let%span sknapsack_full'0 = "knapsack_full.rs" 82 35 82 36
  let%span sknapsack_full'1 = "knapsack_full.rs" 82 69 82 70
  let%span sknapsack_full'2 = "knapsack_full.rs" 91 13 91 14
  let%span sknapsack_full'3 = "knapsack_full.rs" 91 4 91 7
  let%span sknapsack_full'4 = "knapsack_full.rs" 91 4 91 7
  let%span sknapsack_full'5 = "knapsack_full.rs" 89 16 90 57
  let%span sknapsack_full'6 = "knapsack_full.rs" 87 16 88 61
  let%span sknapsack_full'7 = "knapsack_full.rs" 85 16 86 59
  let%span sknapsack_full'8 = "knapsack_full.rs" 84 16 84 53
  let%span sknapsack_full'9 = "knapsack_full.rs" 91 4 91 7
  let%span sknapsack_full'10 = "knapsack_full.rs" 91 4 91 7
  let%span sknapsack_full'11 = "knapsack_full.rs" 106 17 106 18
  let%span sknapsack_full'12 = "knapsack_full.rs" 106 8 106 11
  let%span sknapsack_full'13 = "knapsack_full.rs" 106 8 106 11
  let%span sknapsack_full'14 = "knapsack_full.rs" 102 20 103 57
  let%span sknapsack_full'15 = "knapsack_full.rs" 100 20 101 69
  let%span sknapsack_full'16 = "knapsack_full.rs" 97 20 99 65
  let%span sknapsack_full'17 = "knapsack_full.rs" 95 20 96 63
  let%span sknapsack_full'18 = "knapsack_full.rs" 94 20 94 57
  let%span sknapsack_full'19 = "knapsack_full.rs" 106 8 106 11
  let%span sknapsack_full'20 = "knapsack_full.rs" 106 8 106 11
  let%span sknapsack_full'21 = "knapsack_full.rs" 107 27 107 28
  let%span sknapsack_full'22 = "knapsack_full.rs" 132 16 136 58
  let%span sknapsack_full'23 = "knapsack_full.rs" 127 16 131 52
  let%span sknapsack_full'24 = "knapsack_full.rs" 122 16 126 76
  let%span sknapsack_full'25 = "knapsack_full.rs" 121 16 121 43
  let%span sknapsack_full'26 = "knapsack_full.rs" 120 16 120 34
  let%span sknapsack_full'27 = "knapsack_full.rs" 119 16 119 27
  let%span sknapsack_full'28 = "knapsack_full.rs" 137 10 137 11
  let%span sknapsack_full'29 = "knapsack_full.rs" 138 13 138 14
  let%span sknapsack_full'30 = "knapsack_full.rs" 140 26 140 27
  let%span sknapsack_full'31 = "knapsack_full.rs" 81 28 81 33
  let%span sknapsack_full'32 = "knapsack_full.rs" 73 11 73 34
  let%span sknapsack_full'33 = "knapsack_full.rs" 74 11 74 33
  let%span sknapsack_full'34 = "knapsack_full.rs" 75 11 75 79
  let%span sknapsack_full'35 = "knapsack_full.rs" 81 75 81 91
  let%span sknapsack_full'36 = "knapsack_full.rs" 76 10 76 60
  let%span sknapsack_full'37 = "knapsack_full.rs" 77 10 77 54
  let%span sknapsack_full'38 = "knapsack_full.rs" 78 10 79 64
  let%span sknapsack_full'39 = "knapsack_full.rs" 56 11 56 37
  let%span sknapsack_full'40 = "knapsack_full.rs" 57 11 57 17
  let%span sknapsack_full'41 = "knapsack_full.rs" 58 10 58 21
  let%span sknapsack_full'42 = "knapsack_full.rs" 59 10 60 30
  let%span sknapsack_full'43 = "knapsack_full.rs" 55 10 55 11
  let%span sknapsack_full'44 = "knapsack_full.rs" 64 8 69 9
  let%span sknapsack_full'45 = "knapsack_full.rs" 14 10 14 31
  let%span sknapsack_full'46 = "knapsack_full.rs" 42 11 42 36
  let%span sknapsack_full'47 = "knapsack_full.rs" 43 11 43 36
  let%span sknapsack_full'48 = "knapsack_full.rs" 41 10 41 12
  let%span sknapsack_full'49 = "knapsack_full.rs" 46 8 50 9
  let%span sknapsack_full'50 = "knapsack_full.rs" 21 11 21 33
  let%span sknapsack_full'51 = "knapsack_full.rs" 22 10 22 21
  let%span sknapsack_full'52 = "knapsack_full.rs" 20 10 20 19
  let%span sknapsack_full'53 = "knapsack_full.rs" 25 8 26 51
  let%span sknapsack_full'54 = "knapsack_full.rs" 32 11 32 33
  let%span sknapsack_full'55 = "knapsack_full.rs" 31 10 31 19
  let%span sknapsack_full'56 = "knapsack_full.rs" 35 8 36 49
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 178 22 178 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 179 22 179 70
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 80 16 80 17
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 81 26 81 48
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span svec'4 = "../../creusot-contracts/src/std/vec.rs" 159 16 159 17
  let%span svec'5 = "../../creusot-contracts/src/std/vec.rs" 160 27 160 46
  let%span svec'6 = "../../creusot-contracts/src/std/vec.rs" 161 26 161 54
  let%span svec'7 = "../../creusot-contracts/src/std/vec.rs" 150 27 150 46
  let%span svec'8 = "../../creusot-contracts/src/std/vec.rs" 151 26 151 54
  let%span svec'9 = "../../creusot-contracts/src/std/vec.rs" 152 26 152 57
  let%span svec'10 = "../../creusot-contracts/src/std/vec.rs" 153 26 153 62
  let%span svec'11 = "../../creusot-contracts/src/std/vec.rs" 154 26 154 55
  let%span svec'12 = "../../creusot-contracts/src/std/vec.rs" 76 26 76 44
  let%span svec'13 = "../../creusot-contracts/src/std/vec.rs" 84 16 84 17
  let%span svec'14 = "../../creusot-contracts/src/std/vec.rs" 86 35 86 36
  let%span svec'15 = "../../creusot-contracts/src/std/vec.rs" 85 26 85 56
  let%span svec'16 = "../../creusot-contracts/src/std/vec.rs" 63 20 63 41
  let%span siter = "../../creusot-contracts/src/std/iter.rs" 210 18 210 32
  let%span siter'0 = "../../creusot-contracts/src/std/iter.rs" 94 26 97 17
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 29 8 29 31
  let%span srange = "../../creusot-contracts/src/std/iter/range.rs" 25 12 29 70
  let%span srange'0 = "../../creusot-contracts/src/std/iter/range.rs" 93 12 97 76
  let%span srange'1 = "../../creusot-contracts/src/std/iter/range.rs" 34 14 34 47
  let%span srange'2 = "../../creusot-contracts/src/std/iter/range.rs" 38 15 38 32
  let%span srange'3 = "../../creusot-contracts/src/std/iter/range.rs" 39 15 39 32
  let%span srange'4 = "../../creusot-contracts/src/std/iter/range.rs" 40 14 40 42
  let%span srange'5 = "../../creusot-contracts/src/std/iter/range.rs" 17 12 17 78
  let%span srange'6 = "../../creusot-contracts/src/std/iter/range.rs" 103 14 103 47
  let%span srange'7 = "../../creusot-contracts/src/std/iter/range.rs" 104 27 104 29
  let%span srange'8 = "../../creusot-contracts/src/std/iter/range.rs" 108 15 108 32
  let%span srange'9 = "../../creusot-contracts/src/std/iter/range.rs" 109 15 109 32
  let%span srange'10 = "../../creusot-contracts/src/std/iter/range.rs" 110 14 110 42
  let%span srange'11 = "../../creusot-contracts/src/std/iter/range.rs" 111 91 111 93
  let%span srange'12 = "../../creusot-contracts/src/std/iter/range.rs" 71 10 71 43
  let%span srange'13 = "../../creusot-contracts/src/std/iter/range.rs" 74 8 75 74
  let%span srange'14 = "../../creusot-contracts/src/std/iter/range.rs" 85 12 85 57
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 239 26 239 53
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 240 26 240 49
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 241 26 241 91
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 225 14 225 86
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 110 20 110 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 117 20 117 37
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 124 20 124 88
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 685 20 685 91
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use int.MinMax
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec'3] Seq.length (view self) <= UInt64.t'int v_MAX
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: int) : UInt64.t =
    [%#sindex] Seq.get (view self) ix
  
  let rec from_elem (elem:UInt64.t) (n:UInt64.t) (return'  (x:t_Vec))= any
    [ return''0 (result:t_Vec)-> {[%#svec] Seq.length (view result) = UInt64.t'int n}
      {[%#svec'0] forall i: int. 0 <= i /\ i < UInt64.t'int n  -> index_logic result i = elem}
      (! return' {result}) ]
  
  
  type t_RawVec'0  =
    { t_RawVec__inner'0: t_RawVecInner; t_RawVec__qy95zmarker'0: () }
  
  type t_Vec'0  =
    { t_Vec__buf'0: t_RawVec'0; t_Vec__len'0: UInt64.t }
  
  type t_Name
  
  type t_Item  =
    { t_Item__name: t_Name; t_Item__weight: UInt64.t; t_Item__value: UInt64.t }
  
  predicate inv (_0: t_Name)
  
  predicate inv'0 (_0: t_Item)
  
  axiom inv_axiom [@rewrite]: forall x: t_Item [inv'0 x]. inv'0 x
  = match x with
    | {t_Item__name = name ; t_Item__weight = weight ; t_Item__value = value} -> inv name
    end
  
  predicate invariant' (self: t_Item) =
    [%#sboxed] inv'0 self
  
  predicate inv'1 (_0: t_Item)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Item [inv'1 x]. inv'1 x = invariant' x
  
  predicate invariant''0 (self: Seq.seq t_Item) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'2 (_0: Seq.seq t_Item)
  
  axiom inv_axiom'1 [@rewrite]: forall x: Seq.seq t_Item [inv'2 x]. inv'2 x = invariant''0 x
  
  function view'0 (self: t_Vec'0) : Seq.seq t_Item
  
  axiom view_spec'0: forall self: t_Vec'0. [%#svec'3] Seq.length (view'0 self) <= UInt64.t'int v_MAX
  
  predicate invariant''1 (self: t_Vec'0) =
    [%#svec'16] inv'2 (view'0 self)
  
  predicate inv'3 (_0: t_Vec'0)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Vec'0 [inv'3 x]. inv'3 x = invariant''1 x
  
  predicate invariant''2 (self: t_Vec'0) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 (_0: t_Vec'0)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Vec'0 [inv'4 x]. inv'4 x = invariant''2 x
  
  function view'1 (self: t_Vec'0) : Seq.seq t_Item =
    [%#smodel] view'0 self
  
  let rec len (self_:t_Vec'0) (return'  (x:UInt64.t))= {[@expl:len 'self_' type invariant] [%#svec'1] inv'4 self_}
    any
    [ return''0 (result:UInt64.t)-> {[%#svec'2] UInt64.t'int result = Seq.length (view'1 self_)} (! return' {result}) ]
  
  
  type t_RawVec'1  =
    { t_RawVec__inner'1: t_RawVecInner; t_RawVec__qy95zmarker'1: () }
  
  type t_Vec'1  =
    { t_Vec__buf'1: t_RawVec'1; t_Vec__len'1: UInt64.t }
  
  function view'2 (self: t_Vec'1) : Seq.seq t_Vec
  
  axiom view_spec'1: forall self: t_Vec'1. [%#svec'3] Seq.length (view'2 self) <= UInt64.t'int v_MAX
  
  function index_logic'0 [@inline:trivial] (self: t_Vec'1) (ix: int) : t_Vec =
    [%#sindex] Seq.get (view'2 self) ix
  
  let rec from_elem'0 (elem:t_Vec) (n:UInt64.t) (return'  (x:t_Vec'1))= any
    [ return''0 (result:t_Vec'1)-> {[%#svec] Seq.length (view'2 result) = UInt64.t'int n}
      {[%#svec'0] forall i: int. 0 <= i /\ i < UInt64.t'int n  -> index_logic'0 result i = elem}
      (! return' {result}) ]
  
  
  type t_Range  =
    { t_Range__start: UInt64.t; t_Range__end: UInt64.t }
  
  let rec into_iter (self_:t_Range) (return'  (x:t_Range))= any
    [ return''0 (result:t_Range)-> {[%#siter] result = self_} (! return' {result}) ]
  
  
  predicate subseq_rev [#"knapsack_full.rs" 44 0 44 67] (s1: Seq.seq t_Item) (i1: int) (s2: Seq.seq t_Item) (i2: int)
  
  axiom subseq_rev_def: forall s1: Seq.seq t_Item, i1: int, s2: Seq.seq t_Item, i2: int. ([%#sknapsack_full'46] 0 <= i1
  /\ i1 <= Seq.length s1)
   -> ([%#sknapsack_full'47] 0 <= i2 /\ i2 <= Seq.length s2)
   -> subseq_rev s1 i1 s2 i2
  = ([%#sknapsack_full'49] if i2 = 0 then
    i1 = Seq.length s1
  else
    i1 < Seq.length s1 /\ Seq.get s1 i1 = Seq.get s2 (i2 - 1) /\ subseq_rev s1 (i1 + 1) s2 (i2 - 1)
    \/ subseq_rev s1 i1 s2 (i2 - 1)
  )
  
  function sum_weights [#"knapsack_full.rs" 23 0 23 56] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_weights_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'50] 0 <= i /\ i <= Seq.length s)
   -> sum_weights s i
  = ([%#sknapsack_full'53] if i = Seq.length s then
    0
  else
    UInt64.t'int (Seq.get s i).t_Item__weight + sum_weights s (i + 1)
  )
  
  axiom sum_weights_spec: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'50] 0 <= i /\ i <= Seq.length s)
   -> ([%#sknapsack_full'51] sum_weights s i >= 0)
  
  function sum_values [#"knapsack_full.rs" 33 0 33 55] (s: Seq.seq t_Item) (i: int) : int
  
  axiom sum_values_def: forall s: Seq.seq t_Item, i: int. ([%#sknapsack_full'54] i >= 0 /\ i <= Seq.length s)
   -> sum_values s i
  = ([%#sknapsack_full'56] if i = Seq.length s then
    0
  else
    UInt64.t'int (Seq.get s i).t_Item__value + sum_values s (i + 1)
  )
  
  function m [#"knapsack_full.rs" 62 0 62 57] (items: Seq.seq t_Item) (i: int) (w: int) : int
  
  axiom m_def: forall items: Seq.seq t_Item, i: int, w: int. ([%#sknapsack_full'39] 0 <= i /\ i <= Seq.length items)
   -> ([%#sknapsack_full'40] 0 <= w)
   -> m items i w
  = ([%#sknapsack_full'44] if i = 0 then
    0
  else
    if UInt64.t'int (Seq.get items (i - 1)).t_Item__weight > w then
      m items (i - 1) w
    else
      MinMax.max (m items (i - 1) w) (m items (i - 1) (w - UInt64.t'int (Seq.get items (i - 1)).t_Item__weight)
      + UInt64.t'int (Seq.get items (i - 1)).t_Item__value)
  
  )
  
  axiom m_spec: forall items: Seq.seq t_Item, i: int, w: int. ([%#sknapsack_full'39] 0 <= i /\ i <= Seq.length items)
   -> ([%#sknapsack_full'40] 0 <= w)  -> ([%#sknapsack_full'41] m items i w >= 0)
  
  axiom m_spec'0: forall items: Seq.seq t_Item, i: int, w: int. ([%#sknapsack_full'39] 0 <= i /\ i <= Seq.length items)
   -> ([%#sknapsack_full'40] 0 <= w)
   -> ([%#sknapsack_full'42] forall s: Seq.seq t_Item, j: int. 0 <= j
  /\ j <= Seq.length s /\ subseq_rev s j items i /\ sum_weights s j <= w  -> sum_values s j <= m items i w)
  
  function deep_model (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  predicate produces (self: t_Range) (visited: Seq.seq UInt64.t) (o: t_Range) =
    [%#srange] self.t_Range__end = o.t_Range__end
    /\ deep_model self.t_Range__start <= deep_model o.t_Range__start
    /\ (Seq.length visited > 0  -> deep_model o.t_Range__start <= deep_model o.t_Range__end)
    /\ Seq.length visited = deep_model o.t_Range__start - deep_model self.t_Range__start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model self.t_Range__start + i)
  
  function produces_trans (a: t_Range) (ab: Seq.seq UInt64.t) (b: t_Range) (bc: Seq.seq UInt64.t) (c: t_Range) : ()
  
  axiom produces_trans_spec: forall a: t_Range, ab: Seq.seq UInt64.t, b: t_Range, bc: Seq.seq UInt64.t, c: t_Range. ([%#srange'2] produces a ab b)
   -> ([%#srange'3] produces b bc c)  -> ([%#srange'4] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Range) : ()
  
  axiom produces_refl_spec: forall self: t_Range. [%#srange'1] produces self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate inv'5 (_0: t_Range)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Range [inv'5 x]. inv'5 x = true
  
  predicate inv'6 (_0: Seq.seq UInt64.t)
  
  axiom inv_axiom'5 [@rewrite]: forall x: Seq.seq UInt64.t [inv'6 x]. inv'6 x = true
  
  type t_Option  =
    | C_None
    | C_Some UInt64.t
  
  predicate resolve (self: MutBorrow.t t_Range) =
    [%#sresolve] self.final = self.current
  
  predicate completed (self: MutBorrow.t t_Range) =
    [%#srange'5] resolve self /\ deep_model (self.current).t_Range__start >= deep_model (self.current).t_Range__end
  
  let rec next (self_:MutBorrow.t t_Range) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#siter'0] match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'0 (_0: MutBorrow.t t_Range) =
    resolve _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:UInt64.t))= any
    [ good (field_0:UInt64.t)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: UInt64.t [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  predicate invariant''3 (self: t_Item) =
    [%#sinvariant] inv'0 self
  
  predicate inv'7 (_0: t_Item)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Item [inv'7 x]. inv'7 x = invariant''3 x
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Item) (out: t_Item) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  let rec index (self_:t_Vec'0) (ix:UInt64.t) (return'  (x:t_Item))= {[@expl:index 'self_' type invariant] [%#svec'4] inv'4 self_}
    {[@expl:index requires] [%#svec'5] in_bounds ix (view'1 self_)}
    any
    [ return''0 (result:t_Item)-> {inv'7 result} {[%#svec'6] has_value ix (view'1 self_) result} (! return' {result}) ]
  
  
  type t_RangeInclusive  =
    { t_RangeInclusive__start: UInt64.t; t_RangeInclusive__end: UInt64.t; t_RangeInclusive__exhausted: bool }
  
  function start_log (self: t_RangeInclusive) : UInt64.t
  
  function end_log (self: t_RangeInclusive) : UInt64.t
  
  predicate is_empty_log (self: t_RangeInclusive)
  
  axiom is_empty_log_spec: forall self: t_RangeInclusive. [%#sops'2] not is_empty_log self
   -> deep_model (start_log self) <= deep_model (end_log self)
  
  let rec new (start:UInt64.t) (end':UInt64.t) (return'  (x:t_RangeInclusive))= any
    [ return''0 (result:t_RangeInclusive)-> {[%#sops] start_log result = start}
      {[%#sops'0] end_log result = end'}
      {[%#sops'1] deep_model start <= deep_model end'  -> not is_empty_log result}
      (! return' {result}) ]
  
  
  let rec into_iter'0 (self_:t_RangeInclusive) (return'  (x:t_RangeInclusive))= any
    [ return''0 (result:t_RangeInclusive)-> {[%#siter] result = self_} (! return' {result}) ]
  
  
  function range_inclusive_len (r: t_RangeInclusive) : int =
    [%#srange'13] if is_empty_log r then 0 else deep_model (end_log r) - deep_model (start_log r) + 1
  
  axiom range_inclusive_len_spec: forall r: t_RangeInclusive. [%#srange'12] is_empty_log r = (range_inclusive_len r = 0)
  
  predicate produces'0 (self: t_RangeInclusive) (visited: Seq.seq UInt64.t) (o: t_RangeInclusive) =
    [%#srange'0] Seq.length visited = range_inclusive_len self - range_inclusive_len o
    /\ (is_empty_log self  -> is_empty_log o)
    /\ (is_empty_log o \/ end_log self = end_log o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
     -> deep_model (Seq.get visited i) = deep_model (start_log self) + i)
  
  function produces_trans'0 (a: t_RangeInclusive) (ab: Seq.seq UInt64.t) (b: t_RangeInclusive) (bc: Seq.seq UInt64.t) (c: t_RangeInclusive) : ()
  
   =
    [%#srange'11] ()
  
  axiom produces_trans_spec'0: forall a: t_RangeInclusive, ab: Seq.seq UInt64.t, b: t_RangeInclusive, bc: Seq.seq UInt64.t, c: t_RangeInclusive. ([%#srange'8] produces'0 a ab b)
   -> ([%#srange'9] produces'0 b bc c)  -> ([%#srange'10] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self: t_RangeInclusive) : () =
    [%#srange'7] ()
  
  axiom produces_refl_spec'0: forall self: t_RangeInclusive. [%#srange'6] produces'0 self (Seq.empty: Seq.seq UInt64.t) self
  
  predicate inv'8 (_0: t_RangeInclusive)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_RangeInclusive [inv'8 x]. inv'8 x = true
  
  predicate completed'0 (self: MutBorrow.t t_RangeInclusive) =
    [%#srange'14] is_empty_log self.current /\ is_empty_log self.final
  
  let rec next'0 (self_:MutBorrow.t t_RangeInclusive) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#siter'0] match result with
        | C_None -> completed'0 self_
        | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_RangeInclusive) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_RangeInclusive) =
    resolve'1 _0
  
  predicate in_bounds'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  function view'3 (self: t_Vec'1) : Seq.seq t_Vec =
    [%#smodel] view'2 self
  
  predicate has_value'0 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq t_Vec) (out: t_Vec) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  let rec index'0 (self_:t_Vec'1) (ix:UInt64.t) (return'  (x:t_Vec))= {[@expl:index requires] [%#svec'5] in_bounds'0 ix (view'3 self_)}
    any [ return''0 (result:t_Vec)-> {[%#svec'6] has_value'0 ix (view'3 self_) result} (! return' {result}) ] 
  
  predicate in_bounds'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  function view'4 (self: t_Vec) : Seq.seq UInt64.t =
    [%#smodel] view self
  
  predicate has_value'1 [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  let rec index'1 (self_:t_Vec) (ix:UInt64.t) (return'  (x:UInt64.t))= {[@expl:index requires] [%#svec'5] in_bounds'1 ix (view'4 self_)}
    any [ return''0 (result:UInt64.t)-> {[%#svec'6] has_value'1 ix (view'4 self_) result} (! return' {result}) ] 
  
  let rec max (a:UInt64.t) (b:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sknapsack_full'45] UInt64.t'int result
      = MinMax.max (UInt64.t'int a) (UInt64.t'int b)}
      (! return' {result}) ]
  
  
  function view'5 (self: MutBorrow.t t_Vec'1) : Seq.seq t_Vec =
    [%#smodel'0] view'2 self.current
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq t_Vec) (fin: Seq.seq t_Vec) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  let rec index_mut (self_:MutBorrow.t t_Vec'1) (ix:UInt64.t) (return'  (x:MutBorrow.t t_Vec))= {[@expl:index_mut requires] [%#svec'7] in_bounds'0 ix (view'5 self_)}
    any
    [ return''0 (result:MutBorrow.t t_Vec)-> {[%#svec'8] has_value'0 ix (view'5 self_) result.current}
      {[%#svec'9] has_value'0 ix (view'2 self_.final) result.final}
      {[%#svec'10] resolve_elswhere ix (view'5 self_) (view'2 self_.final)}
      {[%#svec'11] Seq.length (view'2 self_.final) = Seq.length (view'5 self_)}
      (! return' {result}) ]
  
  
  function view'6 (self: MutBorrow.t t_Vec) : Seq.seq UInt64.t =
    [%#smodel'0] view self.current
  
  predicate resolve_elswhere'0 [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  let rec index_mut'0 (self_:MutBorrow.t t_Vec) (ix:UInt64.t) (return'  (x:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#svec'7] in_bounds'1 ix (view'6 self_)}
    any
    [ return''0 (result:MutBorrow.t UInt64.t)-> {[%#svec'8] has_value'1 ix (view'6 self_) result.current}
      {[%#svec'9] has_value'1 ix (view self_.final) result.final}
      {[%#svec'10] resolve_elswhere'0 ix (view'6 self_) (view self_.final)}
      {[%#svec'11] Seq.length (view self_.final) = Seq.length (view'6 self_)}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self: MutBorrow.t UInt64.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t UInt64.t) =
    resolve'3 _0
  
  predicate resolve'5 (self: MutBorrow.t t_Vec) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_Vec) =
    resolve'5 _0
  
  type t_RawVec'2  =
    { t_RawVec__inner'2: t_RawVecInner; t_RawVec__qy95zmarker'2: () }
  
  type t_Vec'2  =
    { t_Vec__buf'2: t_RawVec'2; t_Vec__len'2: UInt64.t }
  
  predicate invariant''4 (self: t_Item) =
    [%#sboxed] inv'7 self
  
  predicate inv'9 (_0: t_Item)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Item [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate invariant''5 (self: Seq.seq t_Item) =
    [%#sseq] forall i: int. 0 <= i /\ i < Seq.length self  -> inv'9 (Seq.get self i)
  
  predicate inv'10 (_0: Seq.seq t_Item)
  
  axiom inv_axiom'9 [@rewrite]: forall x: Seq.seq t_Item [inv'10 x]. inv'10 x = invariant''5 x
  
  function view'7 (self: t_Vec'2) : Seq.seq t_Item
  
  axiom view_spec'2: forall self: t_Vec'2. [%#svec'3] Seq.length (view'7 self) <= UInt64.t'int v_MAX
  
  predicate invariant''6 (self: t_Vec'2) =
    [%#svec'16] inv'10 (view'7 self)
  
  predicate inv'11 (_0: t_Vec'2)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Vec'2 [inv'11 x]. inv'11 x = invariant''6 x
  
  let rec with_capacity (capacity:UInt64.t) (return'  (x:t_Vec'2))= any
    [ return''0 (result:t_Vec'2)-> {inv'11 result} {[%#svec'12] Seq.length (view'7 result) = 0} (! return' {result}) ]
  
  
  function index_logic'1 [@inline:trivial] (self: t_Vec'2) (ix: int) : t_Item =
    [%#sindex] Seq.get (view'7 self) ix
  
  predicate invariant''7 (self: MutBorrow.t t_Vec'2) =
    [%#sinvariant'0] inv'11 self.current /\ inv'11 self.final
  
  predicate inv'12 (_0: MutBorrow.t t_Vec'2)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Vec'2 [inv'12 x]. inv'12 x = invariant''7 x
  
  function view'8 (self: MutBorrow.t t_Vec'2) : Seq.seq t_Item =
    [%#smodel'0] view'7 self.current
  
  let rec push (self_:MutBorrow.t t_Vec'2) (v:t_Item) (return'  (x:()))= {[@expl:push 'self_' type invariant] [%#svec'13] inv'12 self_}
    {[@expl:push 'v' type invariant] [%#svec'14] inv'7 v}
    any [ return''0 (result:())-> {[%#svec'15] view'7 self_.final = Seq.snoc (view'8 self_) v} (! return' {result}) ] 
  
  function index_logic'2 [@inline:trivial] (self: t_Vec'0) (ix: int) : t_Item =
    [%#sindex] Seq.get (view'0 self) ix
  
  meta "compute_max_steps" 1000000
  
  let rec knapsack01_dyn[#"knapsack_full.rs" 81 0 81 91] (items:t_Vec'0) (max_weight:UInt64.t) (return'  (x:t_Vec'2))= {[@expl:knapsack01_dyn 'items' type invariant] [%#sknapsack_full'31] inv'4 items}
    {[@expl:knapsack01_dyn requires #0] [%#sknapsack_full'32] Seq.length (view'1 items) < 10000000}
    {[@expl:knapsack01_dyn requires #1] [%#sknapsack_full'33] UInt64.t'int max_weight < 10000000}
    {[@expl:knapsack01_dyn requires #2] [%#sknapsack_full'34] forall i: int. 0 <= i /\ i < Seq.length (view'1 items)
     -> UInt64.t'int (index_logic'2 items i).t_Item__value <= 10000000}
    (! bb0
    [ bb0 = s0
      [ s0 = UInt64.add {max_weight'0} {[%#sknapsack_full] (1: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_11 <- _ret ] s1)
      | s1 = from_elem {[%#sknapsack_full'0] (0: UInt64.t)} {_11} (fun (_ret:t_Vec) ->  [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = len {items'0} (fun (_ret:UInt64.t) ->  [ &_14 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = UInt64.add {_14} {[%#sknapsack_full'1] (1: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_13 <- _ret ] s1)
      | s1 = from_elem'0 {_10} {_13} (fun (_ret:t_Vec'1) ->  [ &best_value <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = len {items'0} (fun (_ret:UInt64.t) ->  [ &_19 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 =  [ &_18 <- { t_Range__start = ([%#sknapsack_full'2] (0: UInt64.t)); t_Range__end = _19 } ] s1
      | s1 = into_iter {_18} (fun (_ret:t_Range) ->  [ &iter <- _ret ] s2)
      | s2 = bb5 ]
    
    | bb5 = s0 [ s0 =  [ &iter_old <- [%#sknapsack_full'3] iter ] s1 | s1 = bb6 ] 
    | bb6 = s0 [ s0 =  [ &produced <- [%#sknapsack_full'4] Seq.empty: Seq.seq UInt64.t ] s1 | s1 = bb8 ] 
    | bb8 = bb8'0
      [ bb8'0 = {[@expl:for invariant] [%#sknapsack_full'9] inv'6 produced}
        {[@expl:for invariant] [%#sknapsack_full'9] inv'5 iter}
        {[@expl:for invariant] [%#sknapsack_full'9] produces iter_old produced iter}
        {[@expl:loop invariant #0] [%#sknapsack_full'8] Seq.length (view'1 items'0) + 1
        = Seq.length (view'2 best_value)}
        {[@expl:loop invariant #1] [%#sknapsack_full'7] forall i'0: int. 0 <= i'0
        /\ i'0 < Seq.length (view'2 best_value)
         -> UInt64.t'int max_weight'0 + 1 = Seq.length (view (index_logic'0 best_value i'0))}
        {[@expl:loop invariant #2] [%#sknapsack_full'6] forall ii: int, ww: int. 0 <= ii
        /\ ii <= Seq.length produced /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
         -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'1 items'0) ii ww}
        {[@expl:loop invariant #3] [%#sknapsack_full'5] forall ii: int, ww: int. 0 <= ii
        /\ ii <= Seq.length (view'1 items'0) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
         -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
        (! s0) [ s0 = bb13 ] 
        [ bb13 = s0
          [ s0 = MutBorrow.borrow_mut <t_Range> {iter}
              (fun (_ret:MutBorrow.t t_Range) ->  [ &_36 <- _ret ]  [ &iter <- _ret.final ] s1)
          | s1 = MutBorrow.borrow_final <t_Range> {_36.current} {MutBorrow.get_id _36}
              (fun (_ret:MutBorrow.t t_Range) ->  [ &_35 <- _ret ]  [ &_36 <- { _36 with current = _ret.final } ] s2)
          | s2 = next {_35} (fun (_ret:t_Option) ->  [ &_34 <- _ret ] s3)
          | s3 = bb14 ]
        
        | bb14 = s0
          [ s0 = -{resolve'0 _36}- s1
          | s1 = any [ br0 -> {_34 = C_None} (! bb17) | br1 (x0:UInt64.t)-> {_34 = C_Some x0} (! bb18) ]  ]
        
        | bb18 = s0
          [ s0 = v_Some {_34} (fun (r0:UInt64.t) ->  [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 =  [ &_39 <- [%#sknapsack_full'10] Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = bb19 ]
        
        | bb19 = s0
          [ s0 =  [ &produced <- _39 ] s1
          | s1 =  [ &i <- __creusot_proc_iter_elem ] s2
          | s2 = index {items'0} {i} (fun (_ret:t_Item) ->  [ &_43 <- _ret ] s3)
          | s3 = bb20 ]
        
        | bb20 = s0
          [ s0 =  [ &it <- _43 ] s1
          | s1 = new {[%#sknapsack_full'11] (0: UInt64.t)} {max_weight'0}
              (fun (_ret:t_RangeInclusive) ->  [ &_47 <- _ret ] s2)
          | s2 = bb21 ]
        
        | bb21 = s0 [ s0 = into_iter'0 {_47} (fun (_ret:t_RangeInclusive) ->  [ &iter'0 <- _ret ] s1) | s1 = bb22 ] 
        | bb22 = s0 [ s0 =  [ &iter_old'0 <- [%#sknapsack_full'12] iter'0 ] s1 | s1 = bb23 ] 
        | bb23 = s0 [ s0 =  [ &produced'0 <- [%#sknapsack_full'13] Seq.empty: Seq.seq UInt64.t ] s1 | s1 = bb25 ] 
        | bb25 = bb25'0
          [ bb25'0 = {[@expl:for invariant] [%#sknapsack_full'19] inv'6 produced'0}
            {[@expl:for invariant] [%#sknapsack_full'19] inv'8 iter'0}
            {[@expl:for invariant] [%#sknapsack_full'19] produces'0 iter_old'0 produced'0 iter'0}
            {[@expl:loop invariant #0] [%#sknapsack_full'18] Seq.length (view'1 items'0) + 1
            = Seq.length (view'2 best_value)}
            {[@expl:loop invariant #1] [%#sknapsack_full'17] forall i'0: int. 0 <= i'0
            /\ i'0 < Seq.length (view'2 best_value)
             -> UInt64.t'int max_weight'0 + 1 = Seq.length (view (index_logic'0 best_value i'0))}
            {[@expl:loop invariant #2] [%#sknapsack_full'16] forall ii: int, ww: int. 0 <= ii
            /\ ii <= UInt64.t'int i /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
             -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) = m (view'1 items'0) ii ww}
            {[@expl:loop invariant #3] [%#sknapsack_full'15] forall ww: int. 0 <= ww /\ ww <= Seq.length produced'0 - 1
             -> UInt64.t'int (Seq.get (view (index_logic'0 best_value (UInt64.t'int i + 1))) ww)
            = m (view'1 items'0) (UInt64.t'int i + 1) ww}
            {[@expl:loop invariant #4] [%#sknapsack_full'14] forall ii: int, ww: int. 0 <= ii
            /\ ii <= Seq.length (view'1 items'0) /\ 0 <= ww /\ ww <= UInt64.t'int max_weight'0
             -> UInt64.t'int (Seq.get (view (index_logic'0 best_value ii)) ww) <= 10000000 * ii}
            (! s0) [ s0 = bb31 ] 
            [ bb31 = s0
              [ s0 = MutBorrow.borrow_mut <t_RangeInclusive> {iter'0}
                  (fun (_ret:MutBorrow.t t_RangeInclusive) ->  [ &_64 <- _ret ]  [ &iter'0 <- _ret.final ] s1)
              | s1 = MutBorrow.borrow_final <t_RangeInclusive> {_64.current} {MutBorrow.get_id _64}
                  (fun (_ret:MutBorrow.t t_RangeInclusive) ->
                     [ &_63 <- _ret ] 
                     [ &_64 <- { _64 with current = _ret.final } ] 
                    s2)
              | s2 = next'0 {_63} (fun (_ret:t_Option) ->  [ &_62 <- _ret ] s3)
              | s3 = bb32 ]
            
            | bb32 = s0
              [ s0 = -{resolve'2 _64}- s1
              | s1 = any [ br0 -> {_62 = C_None} (! bb8'0) | br1 (x0:UInt64.t)-> {_62 = C_Some x0} (! bb36) ]  ]
            
            | bb36 = s0
              [ s0 = v_Some {_62} (fun (r0:UInt64.t) ->  [ &__creusot_proc_iter_elem'0 <- r0 ] s1)
              | s1 =  [ &_67 <- [%#sknapsack_full'20] Seq.(++) produced'0 (Seq.singleton __creusot_proc_iter_elem'0) ] 
                s2
              | s2 = bb37 ]
            
            | bb37 = s0
              [ s0 =  [ &produced'0 <- _67 ] s1
              | s1 =  [ &w <- __creusot_proc_iter_elem'0 ] s2
              | s2 =  [ &_71 <- UInt64.gt it.t_Item__weight w ] s3
              | s3 = any [ br0 -> {_71 = false} (! bb41) | br1 -> {_71} (! bb38) ]  ]
            
            | bb38 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret:t_Vec) ->  [ &_76 <- _ret ] s1) | s1 = bb39 ] 
            | bb39 = s0 [ s0 = index'1 {_76} {w} (fun (_ret:UInt64.t) ->  [ &_74 <- _ret ] s1) | s1 = bb40 ] 
            | bb40 = s0 [ s0 =  [ &_70 <- _74 ] s1 | s1 = bb47 ] 
            | bb41 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret:t_Vec) ->  [ &_83 <- _ret ] s1) | s1 = bb42 ] 
            | bb42 = s0 [ s0 = index'1 {_83} {w} (fun (_ret:UInt64.t) ->  [ &_81 <- _ret ] s1) | s1 = bb43 ] 
            | bb43 = s0 [ s0 = index'0 {best_value} {i} (fun (_ret:t_Vec) ->  [ &_91 <- _ret ] s1) | s1 = bb44 ] 
            | bb44 = s0
              [ s0 = UInt64.sub {w} {it.t_Item__weight} (fun (_ret:UInt64.t) ->  [ &_94 <- _ret ] s1)
              | s1 = index'1 {_91} {_94} (fun (_ret:UInt64.t) ->  [ &_89 <- _ret ] s2)
              | s2 = bb45 ]
            
            | bb45 = s0
              [ s0 = UInt64.add {_89} {it.t_Item__value} (fun (_ret:UInt64.t) ->  [ &_87 <- _ret ] s1)
              | s1 = max {_81} {_87} (fun (_ret:UInt64.t) ->  [ &_70 <- _ret ] s2)
              | s2 = bb47 ]
            
            | bb47 = s0
              [ s0 = MutBorrow.borrow_mut <t_Vec'1> {best_value}
                  (fun (_ret:MutBorrow.t t_Vec'1) ->  [ &_101 <- _ret ]  [ &best_value <- _ret.final ] s1)
              | s1 = UInt64.add {i} {[%#sknapsack_full'21] (1: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_102 <- _ret ] s2)
              | s2 = index_mut {_101} {_102} (fun (_ret:MutBorrow.t t_Vec) ->  [ &_100 <- _ret ] s3)
              | s3 = bb48 ]
            
            | bb48 = s0
              [ s0 = MutBorrow.borrow_final <t_Vec> {_100.current} {MutBorrow.get_id _100}
                  (fun (_ret:MutBorrow.t t_Vec) ->
                     [ &_99 <- _ret ] 
                     [ &_100 <- { _100 with current = _ret.final } ] 
                    s1)
              | s1 = index_mut'0 {_99} {w} (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_98 <- _ret ] s2)
              | s2 = bb49 ]
            
            | bb49 = s0
              [ s0 =  [ &_98 <- { _98 with current = _70 } ] s1
              | s1 = -{resolve'4 _98}- s2
              | s2 = -{resolve'6 _100}- s3
              | s3 = bb25'0 ]
             ]
           ]
         ]
       ]
    
    | bb17 = s0 [ s0 = len {items'0} (fun (_ret:UInt64.t) ->  [ &_108 <- _ret ] s1) | s1 = bb50 ] 
    | bb50 = s0 [ s0 = with_capacity {_108} (fun (_ret:t_Vec'2) ->  [ &result <- _ret ] s1) | s1 = bb51 ] 
    | bb51 = s0
      [ s0 =  [ &left_weight <- max_weight'0 ] s1
      | s1 = len {items'0} (fun (_ret:UInt64.t) ->  [ &j <- _ret ] s2)
      | s2 = bb53 ]
    
    | bb53 = bb53'0
      [ bb53'0 = {[@expl:loop invariant #0] [%#sknapsack_full'27] inv'11 result}
        {[@expl:loop invariant #1] [%#sknapsack_full'26] UInt64.t'int j <= Seq.length (view'1 items'0)}
        {[@expl:loop invariant #2] [%#sknapsack_full'25] UInt64.t'int left_weight <= UInt64.t'int max_weight'0}
        {[@expl:loop invariant #3] [%#sknapsack_full'24] forall r: Seq.seq t_Item. Seq.length (view'7 result)
        <= Seq.length r
        /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'7 result)  -> index_logic'1 result i'0 = Seq.get r i'0)
        /\ sum_values r (Seq.length (view'7 result)) = m (view'1 items'0) (UInt64.t'int j) (UInt64.t'int left_weight)
         -> sum_values r 0 = m (view'1 items'0) (Seq.length (view'1 items'0)) (UInt64.t'int max_weight'0)}
        {[@expl:loop invariant #4] [%#sknapsack_full'23] forall r: Seq.seq t_Item. Seq.length (view'7 result)
        <= Seq.length r
        /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'7 result)  -> index_logic'1 result i'0 = Seq.get r i'0)
        /\ sum_weights r (Seq.length (view'7 result)) <= UInt64.t'int left_weight
         -> sum_weights r 0 <= UInt64.t'int max_weight'0}
        {[@expl:loop invariant #5] [%#sknapsack_full'22] forall r: Seq.seq t_Item. Seq.length (view'7 result)
        <= Seq.length r
        /\ (forall i'0: int. 0 <= i'0 /\ i'0 < Seq.length (view'7 result)  -> index_logic'1 result i'0 = Seq.get r i'0)
        /\ subseq_rev r (Seq.length (view'7 result)) (view'1 items'0) (UInt64.t'int j)
         -> subseq_rev r 0 (view'1 items'0) (Seq.length (view'1 items'0))}
        (! s0) [ s0 = bb58 ] 
        [ bb58 = s0
          [ s0 =  [ &_121 <- UInt64.lt ([%#sknapsack_full'28] (0: UInt64.t)) j ] s1
          | s1 = any [ br0 -> {_121 = false} (! bb69) | br1 -> {_121} (! bb59) ]  ]
        
        | bb59 = s0
          [ s0 = UInt64.sub {j} {[%#sknapsack_full'29] (1: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &j <- _ret ] s1)
          | s1 = index {items'0} {j} (fun (_ret:t_Item) ->  [ &_124 <- _ret ] s2)
          | s2 = bb60 ]
        
        | bb60 = s0
          [ s0 =  [ &it'0 <- _124 ] s1
          | s1 = UInt64.add {j} {[%#sknapsack_full'30] (1: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_133 <- _ret ] s2)
          | s2 = index'0 {best_value} {_133} (fun (_ret:t_Vec) ->  [ &_131 <- _ret ] s3)
          | s3 = bb61 ]
        
        | bb61 = s0 [ s0 = index'1 {_131} {left_weight} (fun (_ret:UInt64.t) ->  [ &_129 <- _ret ] s1) | s1 = bb62 ] 
        | bb62 = s0 [ s0 = index'0 {best_value} {j} (fun (_ret:t_Vec) ->  [ &_139 <- _ret ] s1) | s1 = bb63 ] 
        | bb63 = s0 [ s0 = index'1 {_139} {left_weight} (fun (_ret:UInt64.t) ->  [ &_137 <- _ret ] s1) | s1 = bb64 ] 
        | bb64 = s0
          [ s0 =  [ &_127 <- _129 <> _137 ] s1
          | s1 = any [ br0 -> {_127 = false} (! bb53'0) | br1 -> {_127} (! bb65) ]  ]
        
        | bb65 = s0
          [ s0 = {inv'11 result}
            MutBorrow.borrow_mut <t_Vec'2> {result}
              (fun (_ret:MutBorrow.t t_Vec'2) ->  [ &_144 <- _ret ] -{inv'11 _ret.final}-  [ &result <- _ret.final ] s1)
          | s1 = push {_144} {it'0} (fun (_ret:()) ->  [ &_143 <- _ret ] s2)
          | s2 = bb66 ]
        
        | bb66 = s0
          [ s0 = UInt64.sub {left_weight} {it'0.t_Item__weight} (fun (_ret:UInt64.t) ->  [ &left_weight <- _ret ] s1)
          | s1 = bb53'0 ]
         ]
       ]
    
    | bb69 = s0 [ s0 =  [ &_0 <- result ] s1 | s1 = bb71 ] 
    | bb71 = return''0 {_0} ]
    )
    [ & _0: t_Vec'2 = Any.any_l ()
    | & items'0: t_Vec'0 = items
    | & max_weight'0: UInt64.t = max_weight
    | & best_value: t_Vec'1 = Any.any_l ()
    | & _10: t_Vec = Any.any_l ()
    | & _11: UInt64.t = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: UInt64.t = Any.any_l ()
    | & iter: t_Range = Any.any_l ()
    | & _18: t_Range = Any.any_l ()
    | & _19: UInt64.t = Any.any_l ()
    | & iter_old: t_Range = Any.any_l ()
    | & produced: Seq.seq UInt64.t = Any.any_l ()
    | & _34: t_Option = Any.any_l ()
    | & _35: MutBorrow.t t_Range = Any.any_l ()
    | & _36: MutBorrow.t t_Range = Any.any_l ()
    | & __creusot_proc_iter_elem: UInt64.t = Any.any_l ()
    | & _39: Seq.seq UInt64.t = Any.any_l ()
    | & i: UInt64.t = Any.any_l ()
    | & it: t_Item = Any.any_l ()
    | & _43: t_Item = Any.any_l ()
    | & iter'0: t_RangeInclusive = Any.any_l ()
    | & _47: t_RangeInclusive = Any.any_l ()
    | & iter_old'0: t_RangeInclusive = Any.any_l ()
    | & produced'0: Seq.seq UInt64.t = Any.any_l ()
    | & _62: t_Option = Any.any_l ()
    | & _63: MutBorrow.t t_RangeInclusive = Any.any_l ()
    | & _64: MutBorrow.t t_RangeInclusive = Any.any_l ()
    | & __creusot_proc_iter_elem'0: UInt64.t = Any.any_l ()
    | & _67: Seq.seq UInt64.t = Any.any_l ()
    | & w: UInt64.t = Any.any_l ()
    | & _70: UInt64.t = Any.any_l ()
    | & _71: bool = Any.any_l ()
    | & _74: UInt64.t = Any.any_l ()
    | & _76: t_Vec = Any.any_l ()
    | & _81: UInt64.t = Any.any_l ()
    | & _83: t_Vec = Any.any_l ()
    | & _87: UInt64.t = Any.any_l ()
    | & _89: UInt64.t = Any.any_l ()
    | & _91: t_Vec = Any.any_l ()
    | & _94: UInt64.t = Any.any_l ()
    | & _98: MutBorrow.t UInt64.t = Any.any_l ()
    | & _99: MutBorrow.t t_Vec = Any.any_l ()
    | & _100: MutBorrow.t t_Vec = Any.any_l ()
    | & _101: MutBorrow.t t_Vec'1 = Any.any_l ()
    | & _102: UInt64.t = Any.any_l ()
    | & result: t_Vec'2 = Any.any_l ()
    | & _108: UInt64.t = Any.any_l ()
    | & left_weight: UInt64.t = Any.any_l ()
    | & j: UInt64.t = Any.any_l ()
    | & _121: bool = Any.any_l ()
    | & it'0: t_Item = Any.any_l ()
    | & _124: t_Item = Any.any_l ()
    | & _127: bool = Any.any_l ()
    | & _129: UInt64.t = Any.any_l ()
    | & _131: t_Vec = Any.any_l ()
    | & _133: UInt64.t = Any.any_l ()
    | & _137: UInt64.t = Any.any_l ()
    | & _139: t_Vec = Any.any_l ()
    | & _143: () = Any.any_l ()
    | & _144: MutBorrow.t t_Vec'2 = Any.any_l () ]
    
    [ return''0 (result:t_Vec'2)-> {[@expl:knapsack01_dyn result type invariant] [%#sknapsack_full'35] inv'11 result}
      {[@expl:knapsack01_dyn ensures #0] [%#sknapsack_full'36] sum_weights (view'7 result) (Seq.length (view'7 result))
      <= UInt64.t'int max_weight}
      {[@expl:knapsack01_dyn ensures #1] [%#sknapsack_full'37] subseq_rev (view'7 result) 0 (view'1 items) (Seq.length (view'1 items))}
      {[@expl:knapsack01_dyn ensures #2] [%#sknapsack_full'38] forall s: Seq.seq t_Item. subseq_rev s 0 (view'1 items) (Seq.length (view'1 items))
      /\ sum_weights s (Seq.length s) <= UInt64.t'int max_weight
       -> sum_values s (Seq.length s) <= sum_values (view'7 result) (Seq.length (view'7 result))}
      (! return' {result}) ]

end
