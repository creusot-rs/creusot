module M_f
  use creusot.prelude.Any
  
  type t_S__private
  
  predicate inv__private (x: t_S__private)
  
  predicate resolve__private (x: t_S__private)
  
  type t_A
  
  type t_S_A_B = { a: t_A; t_S__private: t_S__private }
  
  predicate inv_A (_1: t_A)
  
  predicate inv_S_A_B (_1: t_S_A_B)
  
  axiom inv_axiom: forall x: t_S_A_B [inv_S_A_B x]. inv_S_A_B x -> inv_A x.a /\ inv__private x.t_S__private
  
  predicate resolve_A (_1: t_A)
  
  predicate resolve_S_A_B (_1: t_S_A_B)
  
  axiom resolve_axiom [@rewrite]: forall x: t_S_A_B [resolve_S_A_B x]. resolve_S_A_B x
      = (resolve_A x.a /\ resolve__private x.t_S__private)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f_A (x: t_S_A_B) (return (x'0: t_A)) = {[@expl:f 'x' type invariant] inv_S_A_B x}
    (! bb0
    [ bb0 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv__private x.t_S__private} any) ]
      | s1 = -{resolve__private x.t_S__private}- s2
      | s2 = [ &_ret <- x.a ] s3
      | s3 = return {_ret} ] ] [ & _ret: t_A = Any.any_l () | & x: t_S_A_B = x ])
    [ return (result: t_A) -> {[@expl:f result type invariant] inv_A result}
      {[@expl:f ensures] resolve_A x.a -> resolve_S_A_B x}
      (! return {result}) ]
end
module M_g
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_S__private
  
  type t_S_i32_B = { a: Int32.t; t_S__private: t_S__private }
  
  predicate invariant_S_i32_B (self: t_S_i32_B) = Int.mod (Int32.to_int self.a) 2 = 0
  
  predicate inv__private (x: t_S__private)
  
  predicate inv_S_i32_B (_1: t_S_i32_B)
  
  axiom inv_axiom [@rewrite]: forall x: t_S_i32_B [inv_S_i32_B x]. inv_S_i32_B x
      = (invariant_S_i32_B x /\ inv__private x.t_S__private)
  
  predicate invariant_ref_S_i32_B [@inline:trivial] (self: MutBorrow.t t_S_i32_B) =
    inv_S_i32_B self.current /\ inv_S_i32_B self.final
  
  meta "rewrite_def" predicate invariant_ref_S_i32_B
  
  predicate inv_ref_S_i32_B [@inline:trivial] (_1: MutBorrow.t t_S_i32_B) = invariant_ref_S_i32_B _1
  
  meta "rewrite_def" predicate inv_ref_S_i32_B
  
  predicate resolve_ref_S_i32_B [@inline:trivial] (_1: MutBorrow.t t_S_i32_B) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_S_i32_B
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec g_B (x: MutBorrow.t t_S_i32_B) (return (x'0: ())) = {[@expl:g 'x' type invariant] inv_ref_S_i32_B x}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- { x with current = { x.current with a = (34: Int32.t) } } ] s1
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_ref_S_i32_B x} any) ]
      | s2 = -{resolve_ref_S_i32_B x}- s3
      | s3 = return {_ret} ] ] [ & _ret: () = Any.any_l () | & x: MutBorrow.t t_S_i32_B = x ])
    [ return (result: ()) -> (! return {result}) ]
end
