module M_implementation__impl_PartialEq_for_Elem_T__eq (* <implementation::Elem<T> as std::cmp::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  let rec addr_eq_Node_T (p: Opaque.ptr) (q: Opaque.ptr) (return (x: bool)) = any
    [ return (result: bool) -> {result = (Ptr.addr_logic_u64 p = Ptr.addr_logic_u64 q)} (! return {result}) ]
  
  function deep_model_Elem_T [@inline:trivial] (self: t_Elem_T) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Elem_T
  
  function deep_model_ref_Elem_T [@inline:trivial] (self: t_Elem_T) : UInt64.t = deep_model_Elem_T self
  
  meta "rewrite_def" function deep_model_ref_Elem_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_Elem_T (self: t_Elem_T) (other: t_Elem_T) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = addr_eq_Node_T {self.f0} {other.f0} (fun (_ret: bool) -> [ &_0 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = return {_0} ] [ & _0: bool = Any.any_l () | & self: t_Elem_T = self | & other: t_Elem_T = other ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model_ref_Elem_T self = deep_model_ref_Elem_T other)}
      (! return {result}) ]
end
module M_implementation__impl_Clone_for_Elem_T__clone (* <implementation::Elem<T> as std::clone::Clone> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Elem_T (self: t_Elem_T) (return (x: t_Elem_T)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- { f0 = self.f0 } ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Elem_T = Any.any_l () | & self: t_Elem_T = self ])
    [ return (result: t_Elem_T) -> {[@expl:clone ensures] self = result} (! return {result}) ]
end
module M_implementation__impl_UF_T__roots_map (* implementation::UF<T> *)
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  type t_FMap_Elem_T_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem_T;
    perms: t_FMap_Elem_T_PtrOwn_Node_T;
    payloads: Map.map t_Elem_T t_T;
    roots: Map.map t_Elem_T t_Elem_T }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem_T [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_T
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : Map.map t_Elem_T t_Option_PtrOwn_Node_T
  
  function get_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Elem_T_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Elem_T
  
  predicate contains_Elem_T'0 [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) =
    get_Elem_T self k <> None
  
  meta "rewrite_def" predicate contains_Elem_T'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Elem_T self k)
  
  meta "rewrite_def" function lookup_Elem_T
  
  function index_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) : t_PtrOwn_Node_T
   = lookup_Elem_T self key
  
  meta "rewrite_def" function index_FMap_Elem_T_PtrOwn_Node_T
  
  function index_Mapping_Elem_T_Elem_T [@inline:trivial] (self: Map.map t_Elem_T t_Elem_T) (a: t_Elem_T) : t_Elem_T =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_Elem_T
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T_T [@inline:trivial] (self: Map.map t_Elem_T t_T) (a: t_Elem_T) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem_T. contains_Elem_T self.f0'0.domain e
      -> contains_Elem_T'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem_T self.f0'0.domain (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
      /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
        = index_Mapping_Elem_T_Elem_T self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem_T self.f0'0.domain e2
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e <> e
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e = index_Mapping_Elem_T_Elem_T self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_T_Elem_T self.f0'0.roots e = e
        /\ index_Mapping_Elem_T_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem_T [@inline:trivial] (_1: t_Elem_T) = true
  
  meta "rewrite_def" predicate inv_Elem_T
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self)) /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. contains_Elem_T'0 self k
      -> inv_Elem_T k /\ inv_PtrOwn_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_FMap_Elem_T_PtrOwn_Node_T (_1: t_FMap_Elem_T_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_T_PtrOwn_Node_T [inv_FMap_Elem_T_PtrOwn_Node_T x]. inv_FMap_Elem_T_PtrOwn_Node_T x
      = invariant_FMap_Elem_T_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_T_PtrOwn_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem_T = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem_T) = contains_Elem_T (domain_T self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UF_T
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem_T t_Elem_T
  
  goal vc_roots_map_T: inv_UF_T self
    -> (let result = self.f0'0.roots in [@expl:roots_map ensures] forall e: t_Elem_T. in_domain_T self e
      -> in_domain_T self (index_Mapping_Elem_T_Elem_T result e)
      /\ index_Mapping_Elem_T_Elem_T result e
      = index_Mapping_Elem_T_Elem_T result (index_Mapping_Elem_T_Elem_T result e))
end
module M_implementation__new
  use set.Fset
  use creusot.prelude.Opaque
  use map.Map
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  type t_FMap_Elem_T_PtrOwn_Node_T
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : Map.map t_Elem_T t_Option_PtrOwn_Node_T
  
  function get_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Elem_T_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Elem_T
  
  predicate contains_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) =
    get_Elem_T self k <> None
  
  meta "rewrite_def" predicate contains_Elem_T
  
  predicate inv_Elem_T [@inline:trivial] (_1: t_Elem_T) = true
  
  meta "rewrite_def" predicate inv_Elem_T
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_T
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem_T
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'1 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self)) /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Elem_T self k)
  
  meta "rewrite_def" function lookup_Elem_T
  
  function index_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) : t_PtrOwn_Node_T
   = lookup_Elem_T self key
  
  meta "rewrite_def" function index_FMap_Elem_T_PtrOwn_Node_T
  
  predicate invariant_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. contains_Elem_T self k
      -> inv_Elem_T k /\ inv_PtrOwn_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_FMap_Elem_T_PtrOwn_Node_T (_1: t_FMap_Elem_T_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_T_PtrOwn_Node_T [inv_FMap_Elem_T_PtrOwn_Node_T x]. inv_FMap_Elem_T_PtrOwn_Node_T x
      = invariant_FMap_Elem_T_PtrOwn_Node_T x
  
  predicate invariant_Ghost_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_Ghost_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_Ghost_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_FMap_Elem_T_PtrOwn_Node_T
  
  predicate ext_eq_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (other: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. get_Elem_T self k = get_Elem_T other k
  
  axiom ext_eq_Elem_T_spec:
    forall self: t_FMap_Elem_T_PtrOwn_Node_T, other: t_FMap_Elem_T_PtrOwn_Node_T. ext_eq_Elem_T self other
      = (self = other)
  
  function len_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : int
  
  axiom len_Elem_T_spec: forall self: t_FMap_Elem_T_PtrOwn_Node_T. len_Elem_T self >= 0
  
  constant empty_Elem_T : t_FMap_Elem_T_PtrOwn_Node_T
  
  axiom empty_Elem_T_spec: len_Elem_T empty_Elem_T = 0
  
  axiom empty_Elem_T_spec'0: view_FMap_Elem_T_PtrOwn_Node_T empty_Elem_T = Const.const (None)
  
  predicate is_empty_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) = ext_eq_Elem_T self empty_Elem_T
  
  let rec new_Elem_T (return (x: t_FMap_Elem_T_PtrOwn_Node_T)) = any
    [ return (result: t_FMap_Elem_T_PtrOwn_Node_T) -> {inv_Ghost_FMap_Elem_T_PtrOwn_Node_T result}
      {is_empty_Elem_T result}
      (! return {result}) ]
  
  let rec into_inner_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T)
    (return (x: t_FMap_Elem_T_PtrOwn_Node_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_FMap_Elem_T_PtrOwn_Node_T self}
    any
    [ return (result: t_FMap_Elem_T_PtrOwn_Node_T) -> {inv_FMap_Elem_T_PtrOwn_Node_T result}
      {result = self}
      (! return {result}) ]
  
  predicate index_Mapping_Mapping_Elem_T_T_bool [@inline:trivial] (self: Map.map (Map.map t_Elem_T t_T) bool) (a: Map.map t_Elem_T t_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Mapping_Elem_T_T_bool
  
  function such_that_Mapping_Elem_T_T (p: Map.map (Map.map t_Elem_T t_T) bool) : Map.map t_Elem_T t_T
  
  axiom such_that_Mapping_Elem_T_T_spec:
    forall p: Map.map (Map.map t_Elem_T t_T) bool. (exists x: Map.map t_Elem_T t_T. index_Mapping_Mapping_Elem_T_T_bool p x)
      -> index_Mapping_Mapping_Elem_T_T_bool p (such_that_Mapping_Elem_T_T p)
  
  predicate index_Mapping_Mapping_Elem_T_Elem_T_bool [@inline:trivial] (self: Map.map (Map.map t_Elem_T t_Elem_T) bool) (a: Map.map t_Elem_T t_Elem_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Mapping_Elem_T_Elem_T_bool
  
  function such_that_Mapping_Elem_T_Elem_T (p: Map.map (Map.map t_Elem_T t_Elem_T) bool) : Map.map t_Elem_T t_Elem_T
  
  axiom such_that_Mapping_Elem_T_Elem_T_spec:
    forall p: Map.map (Map.map t_Elem_T t_Elem_T) bool. (exists x: Map.map t_Elem_T t_Elem_T. index_Mapping_Mapping_Elem_T_Elem_T_bool p x)
      -> index_Mapping_Mapping_Elem_T_Elem_T_bool p (such_that_Mapping_Elem_T_Elem_T p)
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem_T;
    perms: t_FMap_Elem_T_PtrOwn_Node_T;
    payloads: Map.map t_Elem_T t_T;
    roots: Map.map t_Elem_T t_Elem_T }
  
  type t_UF_T = { f0'1: t_UFInner_T }
  
  predicate contains_Elem_T'0 [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_T'0
  
  function index_Mapping_Elem_T_Elem_T [@inline:trivial] (self: Map.map t_Elem_T t_Elem_T) (a: t_Elem_T) : t_Elem_T =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_Elem_T
  
  function index_Mapping_Elem_T_T [@inline:trivial] (self: Map.map t_Elem_T t_T) (a: t_Elem_T) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem_T. contains_Elem_T'0 self.f0'1.domain e
      -> contains_Elem_T self.f0'1.perms e
      /\ ptr_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'1.perms e) = e.f0
      /\ contains_Elem_T'0 self.f0'1.domain (index_Mapping_Elem_T_Elem_T self.f0'1.roots e)
      /\ index_Mapping_Elem_T_Elem_T self.f0'1.roots (index_Mapping_Elem_T_Elem_T self.f0'1.roots e)
        = index_Mapping_Elem_T_Elem_T self.f0'1.roots e
      /\ match val_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'1.perms e) with
        | Link e2 -> contains_Elem_T'0 self.f0'1.domain e2
        /\ index_Mapping_Elem_T_Elem_T self.f0'1.roots e <> e
        /\ index_Mapping_Elem_T_Elem_T self.f0'1.roots e = index_Mapping_Elem_T_Elem_T self.f0'1.roots e2
        | Root _ payload -> index_Mapping_Elem_T_Elem_T self.f0'1.roots e = e
        /\ index_Mapping_Elem_T_T self.f0'1.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_T_PtrOwn_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'1)
  
  predicate invariant_Ghost_UF_T [@inline:trivial] (self: t_UF_T) = inv_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_UF_T
  
  predicate inv_Ghost_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_Ghost_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_UF_T
  
  let rec new_UF_T (x: t_UF_T) (return (x'0: t_UF_T)) = {[@expl:new 'x' type invariant] inv_UF_T x}
    any [ return (result: t_UF_T) -> {inv_Ghost_UF_T result} {result = x} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem_T = self.f0'1.domain
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_T (return (x: t_UF_T)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- Fset.empty: Fset.fset t_Elem_T ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new_Elem_T (fun (_ret: t_FMap_Elem_T_PtrOwn_Node_T) -> [ &_7 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = into_inner_FMap_Elem_T_PtrOwn_Node_T {_7} (fun (_ret: t_FMap_Elem_T_PtrOwn_Node_T) -> [ &_6 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_8 <- such_that_Mapping_Elem_T_T (fun (__0: Map.map t_Elem_T t_T) -> true) ] s1 | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_10 <- such_that_Mapping_Elem_T_Elem_T (fun (__0: Map.map t_Elem_T t_Elem_T) -> true) ] s1 | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_3 <- { domain = _4; perms = _6; payloads = _8; roots = _10 } ] s1
      | s1 = [ &_2 <- { f0'1 = _3 } ] s2
      | s2 = new_UF_T {_2} (fun (_ret: t_UF_T) -> [ &_0 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: t_UF_T = Any.any_l ()
    | & _2: t_UF_T = Any.any_l ()
    | & _3: t_UFInner_T = Any.any_l ()
    | & _4: Fset.fset t_Elem_T = Any.any_l ()
    | & _6: t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _7: t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _8: Map.map t_Elem_T t_T = Any.any_l ()
    | & _10: Map.map t_Elem_T t_Elem_T = Any.any_l () ])
    [ return (result: t_UF_T) -> {[@expl:new result type invariant] inv_Ghost_UF_T result}
      {[@expl:new ensures] Fset.is_empty (domain_T result)}
      (! return {result}) ]
end
module M_implementation__make
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec new (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {result.f0 = (0: UInt64.t)} (! return {result}) ]
  
  type t_T
  
  type t_Elem_T = { f0'0: Opaque.ptr }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem_T
  
  type t_PtrOwn_Node_T
  
  type tup2_ptr_Node_T_Ghost_PtrOwn_Node_T = { f0'1: Opaque.ptr; f1'1: t_PtrOwn_Node_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self)) /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_Ghost_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_PtrOwn_Node_T
  
  predicate inv_Ghost_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_Ghost_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_PtrOwn_Node_T
  
  predicate inv_tup2_ptr_Node_T_Ghost_PtrOwn_Node_T [@inline:trivial] (_1: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T) =
    inv_Ghost_PtrOwn_Node_T _1.f1'1
  
  meta "rewrite_def" predicate inv_tup2_ptr_Node_T_Ghost_PtrOwn_Node_T
  
  let rec new_Node_T (v: t_Node_T) (return (x: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T)) =
    {[@expl:new 'v' type invariant] inv_Node_T v}
    any
    [ return (result: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T) -> {inv_tup2_ptr_Node_T_Ghost_PtrOwn_Node_T result}
      {ptr_Node_T result.f1'1 = result.f0'1 /\ val_Node_T result.f1'1 = v}
      (! return {result}) ]
  
  let rec into_inner_PtrOwn_Node_T (self: t_PtrOwn_Node_T) (return (x: t_PtrOwn_Node_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_PtrOwn_Node_T self}
    any [ return (result: t_PtrOwn_Node_T) -> {inv_PtrOwn_Node_T result} {result = self} (! return {result}) ]
  
  type t_FMap_Elem_T_PtrOwn_Node_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem_T;
    perms: t_FMap_Elem_T_PtrOwn_Node_T;
    payloads: Map.map t_Elem_T t_T;
    roots: Map.map t_Elem_T t_Elem_T }
  
  type t_UF_T = { f0'2: t_UFInner_T }
  
  predicate contains_Elem_T [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : Map.map t_Elem_T t_Option_PtrOwn_Node_T
  
  function get_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Elem_T_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Elem_T
  
  predicate contains_Elem_T'0 [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) =
    get_Elem_T self k <> None
  
  meta "rewrite_def" predicate contains_Elem_T'0
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Elem_T self k)
  
  meta "rewrite_def" function lookup_Elem_T
  
  function index_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) : t_PtrOwn_Node_T
   = lookup_Elem_T self key
  
  meta "rewrite_def" function index_FMap_Elem_T_PtrOwn_Node_T
  
  function index_Mapping_Elem_T_Elem_T [@inline:trivial] (self: Map.map t_Elem_T t_Elem_T) (a: t_Elem_T) : t_Elem_T =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_Elem_T
  
  function index_Mapping_Elem_T_T [@inline:trivial] (self: Map.map t_Elem_T t_T) (a: t_Elem_T) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem_T. contains_Elem_T self.f0'2.domain e
      -> contains_Elem_T'0 self.f0'2.perms e
      /\ ptr_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'2.perms e) = e.f0'0
      /\ contains_Elem_T self.f0'2.domain (index_Mapping_Elem_T_Elem_T self.f0'2.roots e)
      /\ index_Mapping_Elem_T_Elem_T self.f0'2.roots (index_Mapping_Elem_T_Elem_T self.f0'2.roots e)
        = index_Mapping_Elem_T_Elem_T self.f0'2.roots e
      /\ match val_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'2.perms e) with
        | Link e2 -> contains_Elem_T self.f0'2.domain e2
        /\ index_Mapping_Elem_T_Elem_T self.f0'2.roots e <> e
        /\ index_Mapping_Elem_T_Elem_T self.f0'2.roots e = index_Mapping_Elem_T_Elem_T self.f0'2.roots e2
        | Root _ payload -> index_Mapping_Elem_T_Elem_T self.f0'2.roots e = e
        /\ index_Mapping_Elem_T_T self.f0'2.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem_T [@inline:trivial] (_1: t_Elem_T) = true
  
  meta "rewrite_def" predicate inv_Elem_T
  
  predicate invariant_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. contains_Elem_T'0 self k
      -> inv_Elem_T k /\ inv_PtrOwn_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_FMap_Elem_T_PtrOwn_Node_T (_1: t_FMap_Elem_T_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_T_PtrOwn_Node_T [inv_FMap_Elem_T_PtrOwn_Node_T x]. inv_FMap_Elem_T_PtrOwn_Node_T x
      = invariant_FMap_Elem_T_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_T_PtrOwn_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'2)
  
  predicate invariant_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UF_T
  
  predicate inv_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_UF_T
  
  predicate invariant_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_T
  
  predicate inv_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_T
  
  let rec into_inner_ref_UF_T (self: MutBorrow.t t_UF_T) (return (x: MutBorrow.t t_UF_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_ref_UF_T self}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_ref_UF_T result} {result = self} (! return {result}) ]
  
  type tup2_PtrOwn_Node_T_ref_UF_T = { f0'3: t_PtrOwn_Node_T; f1'3: MutBorrow.t t_UF_T }
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 t_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'4 -> inv_ref_PtrOwn_Node_T f0'4
        end
  
  function map_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) (f: Map.map t_PtrOwn_Node_T t_PtrOwn_Node_T) : t_Option_ref_PtrOwn_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {result = map_Option_PtrOwn_Node_T (get_Elem_T self key) (fun (v: t_PtrOwn_Node_T) -> v)}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_ref_PtrOwn_Node_T) (ret (f0'4: t_PtrOwn_Node_T)) = any
    [ good (f0'4: t_PtrOwn_Node_T) -> {Some'0 f0'4 = input} (! ret {f0'4})
    | bad -> {forall f0'4: t_PtrOwn_Node_T [Some'0 f0'4: t_Option_ref_PtrOwn_Node_T]. Some'0 f0'4 <> input}
      (! {false}
      any) ]
  
  predicate invariant_ref_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_PtrOwn_Node_T self.current /\ inv_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T'0
  
  predicate inv_ref_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_ref_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T'0
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  let rec disjoint_lemma_Node_T (own1: MutBorrow.t t_PtrOwn_Node_T) (own2: t_PtrOwn_Node_T) (return (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] inv_ref_PtrOwn_Node_T'0 own1}
    {[@expl:disjoint_lemma 'own2' type invariant] inv_ref_PtrOwn_Node_T own2}
    {[@expl:disjoint_lemma requires] size_of_Node_T <> 0}
    any
    [ return (result: ()) -> {Ptr.addr_logic_u64 (ptr_Node_T own1.current) <> Ptr.addr_logic_u64 (ptr_Node_T own2)}
      {own1.current = own1.final}
      (! return {result}) ]
  
  predicate resolve_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self.current /\ inv_FMap_Elem_T_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0
  
  predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T'0
  
  predicate inv_Option_PtrOwn_Node_T (_1: t_Option_PtrOwn_Node_T)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_PtrOwn_Node_T [inv_Option_PtrOwn_Node_T x]. inv_Option_PtrOwn_Node_T x
      = match x with
        | None -> true
        | Some f0'4 -> inv_PtrOwn_Node_T f0'4
        end
  
  function len_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : int
  
  axiom len_Elem_T_spec: forall self: t_FMap_Elem_T_PtrOwn_Node_T. len_Elem_T self >= 0
  
  function insert_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) (v: t_PtrOwn_Node_T) : t_FMap_Elem_T_PtrOwn_Node_T
  
  axiom insert_Elem_T_spec:
    forall self: t_FMap_Elem_T_PtrOwn_Node_T, k: t_Elem_T, v: t_PtrOwn_Node_T. view_FMap_Elem_T_PtrOwn_Node_T (insert_Elem_T self k v)
      = Map.set (view_FMap_Elem_T_PtrOwn_Node_T self) k (Some v)
  
  axiom insert_Elem_T_spec'0:
    forall self: t_FMap_Elem_T_PtrOwn_Node_T, k: t_Elem_T, v: t_PtrOwn_Node_T. len_Elem_T (insert_Elem_T self k v)
      = (if contains_Elem_T'0 self k then len_Elem_T self else len_Elem_T self + 1)
  
  let rec insert_ghost_Elem_T (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) (value: t_PtrOwn_Node_T)
    (return (x: t_Option_PtrOwn_Node_T)) =
    {[@expl:insert_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T'0 self}
    {[@expl:insert_ghost 'value' type invariant] inv_PtrOwn_Node_T value}
    any
    [ return (result: t_Option_PtrOwn_Node_T) -> {inv_Option_PtrOwn_Node_T result}
      {self.final = insert_Elem_T self.current key value}
      {result = get_Elem_T self.current key}
      (! return {result}) ]
  
  predicate resolve_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  predicate resolve_Option_PtrOwn_Node_T (_1: t_Option_PtrOwn_Node_T)
  
  axiom resolve_axiom [@rewrite]:
    forall x: t_Option_PtrOwn_Node_T [resolve_Option_PtrOwn_Node_T x]. resolve_Option_PtrOwn_Node_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_PtrOwn_Node_T x0
        end
  
  function insert_Elem_T'0 [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) : Fset.fset t_Elem_T =
    Fset.add e self
  
  meta "rewrite_def" function insert_Elem_T'0
  
  predicate resolve_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UF_T
  
  let rec new_unit (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem_T = self.f0'2.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem_T) = contains_Elem_T (domain_T self) e
  
  function fin_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) : t_UF_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UF_T
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem_T t_Elem_T = self.f0'2.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem_T. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_T_Elem_T (roots_map_T self) e)
        /\ index_Mapping_Elem_T_Elem_T (roots_map_T self) e
        = index_Mapping_Elem_T_Elem_T (roots_map_T self) (index_Mapping_Elem_T_Elem_T (roots_map_T self) e))
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem_T t_T = self.f0'2.payloads
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec make_T (uf: MutBorrow.t t_UF_T) (payload: t_T) (return (x: t_Elem_T)) =
    {[@expl:make 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:make 'payload' type invariant] inv_T payload}
    (! bb0
    [ bb0 = s0 [ s0 = [ &payload_snap <- payload ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = new (fun (_ret: t_PeanoInt) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &_12 <- Root _13 payload ] s1 | s1 = bb3 ]
    | bb3 = s0
      [ s0 = new_Node_T {_12} (fun (_ret: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T) -> [ &_11 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &ptr <- _11.f0'1 ] s1
      | s1 = [ &perm <- _11.f1'1 ] s2
      | s2 = [ &elt <- { f0'0 = ptr } ] s3
      | s3 = into_inner_PtrOwn_Node_T {perm} (fun (_ret: t_PtrOwn_Node_T) -> [ &_23 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0 [ s0 = into_inner_ref_UF_T {uf} (fun (_ret: MutBorrow.t t_UF_T) -> [ &_25 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_22 <- { f0'3 = _23; f1'3 = _25 } ] s1
      | s1 = [ &perm'0 <- _22.f0'3 ] s2
      | s2 = [ &uf'0 <- _22.f1'3 ] s3
      | s3 = [ &_31 <- elt ] s4
      | s4 = get_ghost_Elem_T {uf'0.current.f0'2.perms} {_31}
          (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_28 <- _ret ] s5)
      | s5 = bb7 ]
    | bb7 = any [ br0 -> {_28 = None'0} (! bb13) | br1 (x0: t_PtrOwn_Node_T) -> {_28 = Some'0 x0} (! bb10) ]
    | bb10 = s0
      [ s0 = elim_Some {_28} (fun (r0: t_PtrOwn_Node_T) -> [ &other_perm <- r0 ] s1)
      | s1 = {inv_PtrOwn_Node_T perm'0}
        MutBorrow.borrow_mut <t_PtrOwn_Node_T> {perm'0}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_35 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &perm'0 <- _ret.final ] s2)
      | s2 = {inv_PtrOwn_Node_T _35.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {_35.current} {MutBorrow.get_id _35}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_34 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &_35 <- { _35 with current = _ret.final } ] s3)
      | s3 = disjoint_lemma_Node_T {_34} {other_perm} (fun (_ret: ()) -> [ &_27 <- _ret ] s4)
      | s4 = bb12 ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T'0 _35} s1
      | s1 = -{resolve_ref_PtrOwn_Node_T _35}- s2
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = {inv_FMap_Elem_T_PtrOwn_Node_T uf'0.current.f0'2.perms}
        MutBorrow.borrow_final <t_FMap_Elem_T_PtrOwn_Node_T> {uf'0.current.f0'2.perms}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id uf'0) 1) 2}
          (fun (_ret: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) ->
            [ &_38 <- _ret ] -{inv_FMap_Elem_T_PtrOwn_Node_T _ret.final}-
            [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with perms = _ret.final } } } ] s1)
      | s1 = insert_ghost_Elem_T {_38} {elt} {perm'0} (fun (_ret: t_Option_PtrOwn_Node_T) -> [ &_37 <- _ret ] s2)
      | s2 = {[@expl:type invariant] inv_Option_PtrOwn_Node_T _37} s3
      | s3 = -{resolve_Option_PtrOwn_Node_T _37}- s4
      | s4 = bb14 ]
    | bb14 = s0 [ s0 = [ &_41 <- insert_Elem_T'0 uf'0.current.f0'2.domain elt ] s1 | s1 = bb15 ]
    | bb15 = s0
      [ s0 = [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with domain = _41 } } } ] s1
      | s1 = [ &_43 <- Map.set uf'0.current.f0'2.payloads elt payload_snap ] s2
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with payloads = _43 } } } ] s1
      | s1 = [ &_45 <- Map.set uf'0.current.f0'2.roots elt elt ] s2
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with roots = _45 } } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_UF_T uf'0} s2
      | s2 = -{resolve_ref_UF_T uf'0}- s3
      | s3 = new_unit {_19} (fun (_ret: ()) -> [ &_18 <- _ret ] s4)
      | s4 = bb18 ]
    | bb18 = s0 [ s0 = [ &_0 <- elt ] s1 | s1 = bb19 ]
    | bb19 = return {_0} ]
    [ & _0: t_Elem_T = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & payload: t_T = payload
    | & payload_snap: t_T = Any.any_l ()
    | & ptr: Opaque.ptr = Any.any_l ()
    | & perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _11: tup2_ptr_Node_T_Ghost_PtrOwn_Node_T = Any.any_l ()
    | & _12: t_Node_T = Any.any_l ()
    | & _13: t_PeanoInt = Any.any_l ()
    | & elt: t_Elem_T = Any.any_l ()
    | & _18: () = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & perm'0: t_PtrOwn_Node_T = Any.any_l ()
    | & uf'0: MutBorrow.t t_UF_T = Any.any_l ()
    | & _22: tup2_PtrOwn_Node_T_ref_UF_T = Any.any_l ()
    | & _23: t_PtrOwn_Node_T = Any.any_l ()
    | & _25: MutBorrow.t t_UF_T = Any.any_l ()
    | & _27: () = Any.any_l ()
    | & _28: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _31: t_Elem_T = Any.any_l ()
    | & other_perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _34: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _35: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _37: t_Option_PtrOwn_Node_T = Any.any_l ()
    | & _38: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _41: Fset.fset t_Elem_T = Any.any_l ()
    | & _43: Map.map t_Elem_T t_T = Any.any_l ()
    | & _45: Map.map t_Elem_T t_Elem_T = Any.any_l () ])
    [ return (result: t_Elem_T) -> {[@expl:make ensures #0] not in_domain_T uf.current result}
      {[@expl:make ensures #1] domain_T (fin_Ghost_ref_UF_T uf) = insert_Elem_T'0 (domain_T uf.current) result}
      {[@expl:make ensures #2] roots_map_T (fin_Ghost_ref_UF_T uf) = Map.set (roots_map_T uf.current) result result}
      {[@expl:make ensures #3] payloads_map_T (fin_Ghost_ref_UF_T uf)
      = Map.set (payloads_map_T uf.current) result payload}
      (! return {result}) ]
end
module M_implementation__find
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  type t_FMap_Elem_T_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem_T;
    perms: t_FMap_Elem_T_PtrOwn_Node_T;
    payloads: Map.map t_Elem_T t_T;
    roots: Map.map t_Elem_T t_Elem_T }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem_T [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_T
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : Map.map t_Elem_T t_Option_PtrOwn_Node_T
  
  function get_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Elem_T_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Elem_T
  
  predicate contains_Elem_T'0 [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) =
    get_Elem_T self k <> None
  
  meta "rewrite_def" predicate contains_Elem_T'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Elem_T self k)
  
  meta "rewrite_def" function lookup_Elem_T
  
  function index_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) : t_PtrOwn_Node_T
   = lookup_Elem_T self key
  
  meta "rewrite_def" function index_FMap_Elem_T_PtrOwn_Node_T
  
  function index_Mapping_Elem_T_Elem_T [@inline:trivial] (self: Map.map t_Elem_T t_Elem_T) (a: t_Elem_T) : t_Elem_T =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_Elem_T
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T_T [@inline:trivial] (self: Map.map t_Elem_T t_T) (a: t_Elem_T) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem_T. contains_Elem_T self.f0'0.domain e
      -> contains_Elem_T'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem_T self.f0'0.domain (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
      /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
        = index_Mapping_Elem_T_Elem_T self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem_T self.f0'0.domain e2
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e <> e
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e = index_Mapping_Elem_T_Elem_T self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_T_Elem_T self.f0'0.roots e = e
        /\ index_Mapping_Elem_T_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem_T [@inline:trivial] (_1: t_Elem_T) = true
  
  meta "rewrite_def" predicate inv_Elem_T
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self)) /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. contains_Elem_T'0 self k
      -> inv_Elem_T k /\ inv_PtrOwn_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_FMap_Elem_T_PtrOwn_Node_T (_1: t_FMap_Elem_T_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_T_PtrOwn_Node_T [inv_FMap_Elem_T_PtrOwn_Node_T x]. inv_FMap_Elem_T_PtrOwn_Node_T x
      = invariant_FMap_Elem_T_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_T_PtrOwn_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UF_T
  
  predicate inv_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_UF_T
  
  predicate invariant_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_T
  
  predicate inv_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_T
  
  predicate invariant_ref_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_Ghost_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UF_T
  
  predicate inv_ref_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UF_T
  
  predicate invariant_ref_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_UF_T
  
  predicate inv_ref_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UF_T
  
  let rec deref_Ghost_ref_UF_T (self: MutBorrow.t t_UF_T) (return (x: MutBorrow.t t_UF_T)) =
    {[@expl:deref 'self' type invariant] inv_ref_Ghost_ref_UF_T self}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_ref_ref_UF_T result} {result = self} (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 t_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_ref_PtrOwn_Node_T f0'2
        end
  
  function map_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) (f: Map.map t_PtrOwn_Node_T t_PtrOwn_Node_T) : t_Option_ref_PtrOwn_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {result = map_Option_PtrOwn_Node_T (get_Elem_T self key) (fun (v: t_PtrOwn_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T (self_: t_Option_ref_PtrOwn_Node_T) (return (x: t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T result} {Some'0 result = self_} (! return {result}) ]
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_ref_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_Ghost_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T
  
  let rec new_ref_PtrOwn_Node_T (x: t_PtrOwn_Node_T) (return (x'0: t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T x}
    any [ return (result: t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T result} {result = x} (! return {result}) ]
  
  let rec as_ref_Node_T (ptr: Opaque.ptr) (own: t_PtrOwn_Node_T) (return (x: t_Node_T)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T own}
    {[@expl:as_ref requires] ptr = ptr_Node_T own}
    any [ return (result: t_Node_T) -> {inv_ref_Node_T result} {result = val_Node_T own} (! return {result}) ]
  
  let rec elim_Link (input: t_Node_T) (ret (f0'2: t_Elem_T)) = any
    [ good (f0'2: t_Elem_T) -> {Link f0'2 = input} (! ret {f0'2})
    | bad -> {forall f0'2: t_Elem_T [Link f0'2: t_Node_T]. Link f0'2 <> input} (! {false} any) ]
  
  predicate invariant_ref_Ghost_ref_UF_T'0 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_Ghost_ref_UF_T self.current /\ inv_Ghost_ref_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UF_T'0
  
  predicate inv_ref_Ghost_ref_UF_T'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_ref_Ghost_ref_UF_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UF_T'0
  
  predicate invariant_ref_ref_UF_T'0 [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_ref_UF_T self.current /\ inv_ref_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UF_T'0
  
  predicate inv_ref_ref_UF_T'0 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = invariant_ref_ref_UF_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_ref_UF_T'0
  
  let rec deref_mut_Ghost_ref_UF_T (self: MutBorrow.t (MutBorrow.t t_UF_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UF_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UF_T'0 self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UF_T)) -> {inv_ref_ref_UF_T'0 result}
      {result = self}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UF_T
  
  predicate resolve_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UF_T
  
  let rec new_ref_UF_T (x: MutBorrow.t t_UF_T) (return (x'0: MutBorrow.t t_UF_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UF_T x}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_Ghost_ref_UF_T result} {result = x} (! return {result}) ]
  
  predicate invariant_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_UFInner_T self.current /\ inv_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UFInner_T
  
  predicate inv_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_UFInner_T
  
  predicate invariant_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) = inv_ref_UFInner_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UFInner_T
  
  predicate inv_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UFInner_T
  
  let rec new_ref_UFInner_T (x: MutBorrow.t t_UFInner_T) (return (x'0: MutBorrow.t t_UFInner_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UFInner_T x}
    any
    [ return (result: MutBorrow.t t_UFInner_T) -> {inv_Ghost_ref_UFInner_T result} {result = x} (! return {result}) ]
  
  predicate invariant_ref_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_Ghost_ref_UFInner_T self.current /\ inv_Ghost_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UFInner_T
  
  predicate inv_ref_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UFInner_T
  
  predicate invariant_ref_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_ref_UFInner_T self.current /\ inv_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UFInner_T
  
  predicate inv_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UFInner_T
  
  let rec deref_mut_Ghost_ref_UFInner_T (self: MutBorrow.t (MutBorrow.t t_UFInner_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UFInner_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UFInner_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> {inv_ref_ref_UFInner_T result}
      {result = self}
      (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T'0 = None'1 | Some'1 (MutBorrow.t t_PtrOwn_Node_T)
  
  predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self.current /\ inv_FMap_Elem_T_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0
  
  predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T'0
  
  predicate invariant_ref_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_PtrOwn_Node_T self.current /\ inv_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T'0
  
  predicate inv_ref_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_ref_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T'0
  
  predicate inv_Option_ref_PtrOwn_Node_T'0 (_1: t_Option_ref_PtrOwn_Node_T'0)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T'0 [inv_Option_ref_PtrOwn_Node_T'0 x]. inv_Option_ref_PtrOwn_Node_T'0 x
      = match x with
        | None'1 -> true
        | Some'1 f0'2 -> inv_ref_PtrOwn_Node_T'0 f0'2
        end
  
  function len_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : int
  
  axiom len_Elem_T_spec: forall self: t_FMap_Elem_T_PtrOwn_Node_T. len_Elem_T self >= 0
  
  let rec get_mut_ghost_Elem_T (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T)
    (return (x: t_Option_ref_PtrOwn_Node_T'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T'0 self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T'0) -> {inv_Option_ref_PtrOwn_Node_T'0 result}
      {if contains_Elem_T'0 self.current key then
        match result with
          | None'1 -> false
          | Some'1 r -> contains_Elem_T'0 self.final key
          /\ index_FMap_Elem_T_PtrOwn_Node_T self.current key = r.current
          /\ index_FMap_Elem_T_PtrOwn_Node_T self.final key = r.final
          end
      else
        result = None'1 /\ self.current = self.final
      }
      {forall k: t_Elem_T. k <> key -> get_Elem_T self.current k = get_Elem_T self.final k}
      {len_Elem_T self.current = len_Elem_T self.final}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T'0 (self_: t_Option_ref_PtrOwn_Node_T'0) (return (x: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T'0 self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T'0 result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UFInner_T
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_ref_PtrOwn_Node_T'0 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T'0
  
  predicate inv_Ghost_ref_PtrOwn_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_Ghost_ref_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T'0
  
  let rec new_ref_PtrOwn_Node_T'0 (x: MutBorrow.t t_PtrOwn_Node_T) (return (x'0: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T'0 x}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T'0 result}
      {result = x}
      (! return {result}) ]
  
  predicate invariant_ref_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_Node_T) =
    inv_Node_T self.current /\ inv_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_T'0
  
  predicate inv_ref_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_Node_T) = invariant_ref_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_Node_T'0
  
  function fin_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) : t_PtrOwn_Node_T =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_PtrOwn_Node_T
  
  let rec as_mut_Node_T (ptr: Opaque.ptr) (own: MutBorrow.t t_PtrOwn_Node_T) (return (x: MutBorrow.t t_Node_T)) =
    {[@expl:as_mut 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T'0 own}
    {[@expl:as_mut requires] ptr = ptr_Node_T own.current}
    any
    [ return (result: MutBorrow.t t_Node_T) -> {inv_ref_Node_T'0 result}
      {result.current = val_Node_T own.current}
      {ptr_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = ptr_Node_T own.current}
      {val_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = result.final}
      (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Node_T (_1: t_Node_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_T [resolve_Node_T x]. resolve_Node_T x
      = match x with
        | Root x0 x1 -> resolve_T x1
        | Link x0 -> true
        end
  
  predicate resolve_ref_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_T
  
  predicate resolve_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UFInner_T
  
  predicate resolve_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = resolve_ref_UFInner_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UFInner_T
  
  predicate resolve_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = resolve_ref_UF_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UF_T
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem_T = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem_T) = contains_Elem_T (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem_T t_Elem_T = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem_T. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_T_Elem_T (roots_map_T self) e)
        /\ index_Mapping_Elem_T_Elem_T (roots_map_T self) e
        = index_Mapping_Elem_T_Elem_T (roots_map_T self) (index_Mapping_Elem_T_Elem_T (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem_T) : t_Elem_T = index_Mapping_Elem_T_Elem_T (roots_map_T self) e
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem_T t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UF_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find_T (uf: MutBorrow.t t_UF_T) (elem: t_Elem_T) (return (x: t_Elem_T)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:find requires] in_domain_T uf.current elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref_Ghost_ref_UF_T {uf} (fun (_ret: MutBorrow.t t_UF_T) -> [ &_9 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_12 <- elem ] s1
      | s1 = get_ghost_Elem_T {_9.current.f0'0.perms} {_12}
          (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_7 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap_ref_PtrOwn_Node_T {_7} (fun (_ret: t_PtrOwn_Node_T) -> [ &__temp <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new_ref_PtrOwn_Node_T {__temp} (fun (_ret: t_PtrOwn_Node_T) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = as_ref_Node_T {elem.f0} {perm} (fun (_ret: t_Node_T) -> [ &_15 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_15 = Root x0 x1} (! bb7) | br1 (x0: t_Elem_T) -> {_15 = Link x0} (! bb8) ]
    | bb8 = s0
      [ s0 = elim_Link {_15} (fun (r0: t_Elem_T) -> [ &e <- r0 ] s1)
      | s1 = {inv_Ghost_ref_UF_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_26 <- _ret ] -{inv_Ghost_ref_UF_T _ret.final}-
            [ &uf <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_ref_UF_T {_26} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_25 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = {inv_UF_T _25.current.current}
        MutBorrow.borrow_mut <t_UF_T> {_25.current.current}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_24 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_25 <- { _25 with current = { _25.current with current = _ret.final } } ] s1)
      | s1 = {inv_UF_T _24.current}
        MutBorrow.borrow_final <t_UF_T> {_24.current} {MutBorrow.get_id _24}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_23 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_24 <- { _24 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_ref_UF_T'0 _25} s3
      | s3 = -{resolve_ref_ref_UF_T _25}- s4
      | s4 = {[@expl:type invariant] inv_ref_UF_T _24} s5
      | s5 = -{resolve_ref_UF_T _24}- s6
      | s6 = {inv_UF_T _23.current}
        MutBorrow.borrow_final <t_UF_T> {_23.current} {MutBorrow.get_id _23}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_22 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_23 <- { _23 with current = _ret.final } ] s7)
      | s7 = new_ref_UF_T {_22} (fun (_ret: MutBorrow.t t_UF_T) -> [ &_21 <- _ret ] s8)
      | s8 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_ref_UF_T _23} s1
      | s1 = -{resolve_ref_UF_T _23}- s2
      | s2 = find_T {_21} {e} (fun (_ret: t_Elem_T) -> [ &root <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Ghost_ref_UF_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_30 <- _ret ] -{inv_Ghost_ref_UF_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UF_T {_30} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_29 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = {inv_UFInner_T _29.current.current.f0'0}
        MutBorrow.borrow_mut <t_UFInner_T> {_29.current.current.f0'0}
          (fun (_ret: MutBorrow.t t_UFInner_T) ->
            [ &__temp'0 <- _ret ] -{inv_UFInner_T _ret.final}-
            [ &_29 <- { _29 with current = { _29.current with current = { f0'0 = _ret.final } } } ] s1)
      | s1 = new_ref_UFInner_T {__temp'0} (fun (_ret: MutBorrow.t t_UFInner_T) -> [ &uf'0 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_37 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_37}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_36 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = [ &_39 <- elem ] s1
      | s1 = {inv_FMap_Elem_T_PtrOwn_Node_T _36.current.current.perms}
        MutBorrow.borrow_mut <t_FMap_Elem_T_PtrOwn_Node_T> {_36.current.current.perms}
          (fun (_ret: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) ->
            [ &_35 <- _ret ] -{inv_FMap_Elem_T_PtrOwn_Node_T _ret.final}-
            [ &_36 <- { _36 with current = { _36.current with current = { _36.current.current with perms = _ret.final } } } ]
            s2)
      | s2 = get_mut_ghost_Elem_T {_35} {_39} (fun (_ret: t_Option_ref_PtrOwn_Node_T'0) -> [ &_34 <- _ret ] s3)
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = unwrap_ref_PtrOwn_Node_T'0 {_34} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &__temp'1 <- _ret ] s1)
      | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv_ref_ref_UFInner_T _36} s1
      | s1 = -{resolve_ref_ref_UFInner_T _36}- s2
      | s2 = new_ref_PtrOwn_Node_T'0 {__temp'1} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &mut_perm <- _ret ] s3)
      | s3 = bb18 ]
    | bb18 = s0
      [ s0 = [ &_43 <- Link root ] s1
      | s1 = [ &_46 <- elem.f0 ] s2
      | s2 = as_mut_Node_T {_46} {mut_perm} (fun (_ret: MutBorrow.t t_Node_T) -> [ &_45 <- _ret ] s3)
      | s3 = bb20 ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv_Node_T _45.current} s1
      | s1 = -{resolve_Node_T _45.current}- s2
      | s2 = [ &_45 <- { _45 with current = _43 } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_T'0 _45} s4
      | s4 = -{resolve_ref_Node_T _45}- s5
      | s5 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s6
      | s6 = -{resolve_Ghost_ref_UFInner_T uf'0}- s7
      | s7 = {[@expl:type invariant] inv_ref_ref_UF_T'0 _29} s8
      | s8 = -{resolve_ref_ref_UF_T _29}- s9
      | s9 = {[@expl:type invariant] inv_Ghost_ref_UF_T uf} s10
      | s10 = -{resolve_Ghost_ref_UF_T uf}- s11
      | s11 = bb22 ]
    | bb22 = s0 [ s0 = [ &_0 <- root ] s1 | s1 = bb23 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_ref_UF_T uf} s1 | s1 = -{resolve_Ghost_ref_UF_T uf}- s2 | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_0 <- elem ] s1 | s1 = bb23 ]
    | bb23 = return {_0} ]
    [ & _0: t_Elem_T = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & elem: t_Elem_T = elem
    | & __temp: t_PtrOwn_Node_T = Any.any_l ()
    | & _7: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _9: MutBorrow.t t_UF_T = Any.any_l ()
    | & _12: t_Elem_T = Any.any_l ()
    | & perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _15: t_Node_T = Any.any_l ()
    | & e: t_Elem_T = Any.any_l ()
    | & root: t_Elem_T = Any.any_l ()
    | & _21: MutBorrow.t t_UF_T = Any.any_l ()
    | & _22: MutBorrow.t t_UF_T = Any.any_l ()
    | & _23: MutBorrow.t t_UF_T = Any.any_l ()
    | & _24: MutBorrow.t t_UF_T = Any.any_l ()
    | & _25: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _26: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & __temp'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _29: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _30: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & __temp'1: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _34: t_Option_ref_PtrOwn_Node_T'0 = Any.any_l ()
    | & _35: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _36: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _37: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _39: t_Elem_T = Any.any_l ()
    | & mut_perm: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _43: t_Node_T = Any.any_l ()
    | & _45: MutBorrow.t t_Node_T = Any.any_l ()
    | & _46: Opaque.ptr = Any.any_l () ])
    [ return (result: t_Elem_T) -> {[@expl:find ensures #0] result = root_T uf.current elem}
      {[@expl:find ensures #1] unchanged_T uf}
      (! return {result}) ]
end
module M_implementation__get
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  type t_FMap_Elem_T_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem_T;
    perms: t_FMap_Elem_T_PtrOwn_Node_T;
    payloads: Map.map t_Elem_T t_T;
    roots: Map.map t_Elem_T t_Elem_T }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem_T [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_T
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : Map.map t_Elem_T t_Option_PtrOwn_Node_T
  
  function get_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Elem_T_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Elem_T
  
  predicate contains_Elem_T'0 [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) =
    get_Elem_T self k <> None
  
  meta "rewrite_def" predicate contains_Elem_T'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Elem_T self k)
  
  meta "rewrite_def" function lookup_Elem_T
  
  function index_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) : t_PtrOwn_Node_T
   = lookup_Elem_T self key
  
  meta "rewrite_def" function index_FMap_Elem_T_PtrOwn_Node_T
  
  function index_Mapping_Elem_T_Elem_T [@inline:trivial] (self: Map.map t_Elem_T t_Elem_T) (a: t_Elem_T) : t_Elem_T =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_Elem_T
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T_T [@inline:trivial] (self: Map.map t_Elem_T t_T) (a: t_Elem_T) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem_T. contains_Elem_T self.f0'0.domain e
      -> contains_Elem_T'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem_T self.f0'0.domain (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
      /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
        = index_Mapping_Elem_T_Elem_T self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem_T self.f0'0.domain e2
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e <> e
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e = index_Mapping_Elem_T_Elem_T self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_T_Elem_T self.f0'0.roots e = e
        /\ index_Mapping_Elem_T_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem_T [@inline:trivial] (_1: t_Elem_T) = true
  
  meta "rewrite_def" predicate inv_Elem_T
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self)) /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. contains_Elem_T'0 self k
      -> inv_Elem_T k /\ inv_PtrOwn_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_FMap_Elem_T_PtrOwn_Node_T (_1: t_FMap_Elem_T_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_T_PtrOwn_Node_T [inv_FMap_Elem_T_PtrOwn_Node_T x]. inv_FMap_Elem_T_PtrOwn_Node_T x
      = invariant_FMap_Elem_T_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_T_PtrOwn_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_UF_T
  
  predicate inv_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_UF_T
  
  predicate invariant_Ghost_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_T
  
  predicate inv_Ghost_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_T
  
  predicate invariant_ref_Ghost_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_Ghost_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UF_T
  
  predicate inv_ref_Ghost_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_ref_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UF_T
  
  predicate invariant_ref_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_UF_T
  
  predicate inv_ref_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_ref_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UF_T
  
  let rec deref_Ghost_ref_UF_T (self: t_UF_T) (return (x: t_UF_T)) =
    {[@expl:deref 'self' type invariant] inv_ref_Ghost_ref_UF_T self}
    any [ return (result: t_UF_T) -> {inv_ref_ref_UF_T result} {result = self} (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 t_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_ref_PtrOwn_Node_T f0'2
        end
  
  function map_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) (f: Map.map t_PtrOwn_Node_T t_PtrOwn_Node_T) : t_Option_ref_PtrOwn_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {result = map_Option_PtrOwn_Node_T (get_Elem_T self key) (fun (v: t_PtrOwn_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T (self_: t_Option_ref_PtrOwn_Node_T) (return (x: t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T result} {Some'0 result = self_} (! return {result}) ]
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_ref_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_Ghost_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T
  
  let rec new_ref_PtrOwn_Node_T (x: t_PtrOwn_Node_T) (return (x'0: t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T x}
    any [ return (result: t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T result} {result = x} (! return {result}) ]
  
  let rec as_ref_Node_T (ptr: Opaque.ptr) (own: t_PtrOwn_Node_T) (return (x: t_Node_T)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T own}
    {[@expl:as_ref requires] ptr = ptr_Node_T own}
    any [ return (result: t_Node_T) -> {inv_ref_Node_T result} {result = val_Node_T own} (! return {result}) ]
  
  let rec elim_Root (input: t_Node_T) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [Root rank payload: t_Node_T]. Root rank payload <> input}
      (! {false}
      any) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem_T = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem_T) = contains_Elem_T (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem_T t_Elem_T = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem_T. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_T_Elem_T (roots_map_T self) e)
        /\ index_Mapping_Elem_T_Elem_T (roots_map_T self) e
        = index_Mapping_Elem_T_Elem_T (roots_map_T self) (index_Mapping_Elem_T_Elem_T (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem_T) : t_Elem_T = index_Mapping_Elem_T_Elem_T (roots_map_T self) e
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem_T t_T = self.f0'0.payloads
  
  function payload_T (self: t_UF_T) (e: t_Elem_T) : t_T = index_Mapping_Elem_T_T (payloads_map_T self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_T (uf: t_UF_T) (elem: t_Elem_T) (return (x: t_T)) =
    {[@expl:get 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:get requires #0] in_domain_T uf elem}
    {[@expl:get requires #1] root_T uf elem = elem}
    (! bb0
    [ bb0 = s0 [ s0 = deref_Ghost_ref_UF_T {uf} (fun (_ret: t_UF_T) -> [ &_10 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_13 <- elem ] s1
      | s1 = get_ghost_Elem_T {_10.f0'0.perms} {_13} (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_8 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap_ref_PtrOwn_Node_T {_8} (fun (_ret: t_PtrOwn_Node_T) -> [ &_7 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new_ref_PtrOwn_Node_T {_7} (fun (_ret: t_PtrOwn_Node_T) -> [ &perm <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = as_ref_Node_T {elem.f0} {perm} (fun (_ret: t_Node_T) -> [ &_14 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = any
      [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_14 = Root x0 x1} (! bb8) | br1 (x0: t_Elem_T) -> {_14 = Link x0} (! bb6) ]
    | bb6 = {false} any
    | bb8 = s0
      [ s0 = elim_Root {_14} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &payload <- rpayload ] s1)
      | s1 = [ &_0 <- payload ] s2
      | s2 = return {_0} ] ]
    [ & _0: t_T = Any.any_l ()
    | & uf: t_UF_T = uf
    | & elem: t_Elem_T = elem
    | & perm: t_PtrOwn_Node_T = Any.any_l ()
    | & _7: t_PtrOwn_Node_T = Any.any_l ()
    | & _8: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _10: t_UF_T = Any.any_l ()
    | & _13: t_Elem_T = Any.any_l ()
    | & _14: t_Node_T = Any.any_l ()
    | & payload: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:get result type invariant] inv_ref_T result}
      {[@expl:get ensures] result = payload_T uf elem}
      (! return {result}) ]
end
module M_implementation__link
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  type t_FMap_Elem_T_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem_T;
    perms: t_FMap_Elem_T_PtrOwn_Node_T;
    payloads: Map.map t_Elem_T t_T;
    roots: Map.map t_Elem_T t_Elem_T }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem_T [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_T
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : Map.map t_Elem_T t_Option_PtrOwn_Node_T
  
  function get_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Elem_T_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Elem_T
  
  predicate contains_Elem_T'0 [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) =
    get_Elem_T self k <> None
  
  meta "rewrite_def" predicate contains_Elem_T'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Elem_T self k)
  
  meta "rewrite_def" function lookup_Elem_T
  
  function index_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) : t_PtrOwn_Node_T
   = lookup_Elem_T self key
  
  meta "rewrite_def" function index_FMap_Elem_T_PtrOwn_Node_T
  
  function index_Mapping_Elem_T_Elem_T [@inline:trivial] (self: Map.map t_Elem_T t_Elem_T) (a: t_Elem_T) : t_Elem_T =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_Elem_T
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T_T [@inline:trivial] (self: Map.map t_Elem_T t_T) (a: t_Elem_T) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem_T. contains_Elem_T self.f0'0.domain e
      -> contains_Elem_T'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem_T self.f0'0.domain (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
      /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
        = index_Mapping_Elem_T_Elem_T self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem_T self.f0'0.domain e2
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e <> e
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e = index_Mapping_Elem_T_Elem_T self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_T_Elem_T self.f0'0.roots e = e
        /\ index_Mapping_Elem_T_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem_T [@inline:trivial] (_1: t_Elem_T) = true
  
  meta "rewrite_def" predicate inv_Elem_T
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self)) /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. contains_Elem_T'0 self k
      -> inv_Elem_T k /\ inv_PtrOwn_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_FMap_Elem_T_PtrOwn_Node_T (_1: t_FMap_Elem_T_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_T_PtrOwn_Node_T [inv_FMap_Elem_T_PtrOwn_Node_T x]. inv_FMap_Elem_T_PtrOwn_Node_T x
      = invariant_FMap_Elem_T_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_T_PtrOwn_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UF_T
  
  predicate inv_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_UF_T
  
  predicate invariant_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_T
  
  predicate inv_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_T
  
  predicate invariant_ref_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_Ghost_ref_UF_T self.current /\ inv_Ghost_ref_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UF_T
  
  predicate inv_ref_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_ref_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UF_T
  
  predicate invariant_ref_ref_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_ref_UF_T self.current /\ inv_ref_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UF_T
  
  predicate inv_ref_ref_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = invariant_ref_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UF_T
  
  let rec deref_mut_Ghost_ref_UF_T (self: MutBorrow.t (MutBorrow.t t_UF_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UF_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UF_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UF_T)) -> {inv_ref_ref_UF_T result}
      {result = self}
      (! return {result}) ]
  
  predicate invariant_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_UFInner_T self.current /\ inv_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UFInner_T
  
  predicate inv_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_UFInner_T
  
  predicate invariant_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) = inv_ref_UFInner_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UFInner_T
  
  predicate inv_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UFInner_T
  
  let rec new_ref_UFInner_T (x: MutBorrow.t t_UFInner_T) (return (x'0: MutBorrow.t t_UFInner_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UFInner_T x}
    any
    [ return (result: MutBorrow.t t_UFInner_T) -> {inv_Ghost_ref_UFInner_T result} {result = x} (! return {result}) ]
  
  function deep_model_Elem_T [@inline:trivial] (self: t_Elem_T) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Elem_T
  
  function deep_model_ref_Elem_T [@inline:trivial] (self: t_Elem_T) : UInt64.t = deep_model_Elem_T self
  
  meta "rewrite_def" function deep_model_ref_Elem_T
  
  let rec eq_Elem_T (self: t_Elem_T) (other: t_Elem_T) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Elem_T self = deep_model_ref_Elem_T other)}
      (! return {result}) ]
  
  let rec into_ghost_bool (self: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self} (! return {result}) ]
  
  let rec into_inner_bool (self: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self} (! return {result}) ]
  
  predicate invariant_ref_Ghost_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_Ghost_ref_UFInner_T self.current /\ inv_Ghost_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UFInner_T
  
  predicate inv_ref_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_Ghost_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UFInner_T
  
  predicate invariant_ref_ref_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_ref_UFInner_T self.current /\ inv_ref_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UFInner_T
  
  predicate inv_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_ref_ref_UFInner_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UFInner_T
  
  let rec deref_mut_Ghost_ref_UFInner_T (self: MutBorrow.t (MutBorrow.t t_UFInner_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UFInner_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UFInner_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> {inv_ref_ref_UFInner_T result}
      {result = self}
      (! return {result}) ]
  
  type tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T = {
    f0'2: MutBorrow.t t_PtrOwn_Node_T;
    f1'2: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T }
  
  predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self.current /\ inv_FMap_Elem_T_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate invariant_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_PtrOwn_Node_T self.current /\ inv_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T
  
  predicate inv_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T
  
  predicate inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) =
    inv_ref_PtrOwn_Node_T _1.f0'2 /\ inv_ref_FMap_Elem_T_PtrOwn_Node_T _1.f1'2
  
  meta "rewrite_def" predicate inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T
  
  function len_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : int
  
  axiom len_Elem_T_spec: forall self: t_FMap_Elem_T_PtrOwn_Node_T. len_Elem_T self >= 0
  
  function remove_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_FMap_Elem_T_PtrOwn_Node_T
  
  axiom remove_Elem_T_spec:
    forall self: t_FMap_Elem_T_PtrOwn_Node_T, k: t_Elem_T. view_FMap_Elem_T_PtrOwn_Node_T (remove_Elem_T self k)
      = Map.set (view_FMap_Elem_T_PtrOwn_Node_T self) k (None)
  
  axiom remove_Elem_T_spec'0: forall self: t_FMap_Elem_T_PtrOwn_Node_T, k: t_Elem_T. len_Elem_T (remove_Elem_T self k)
      = (if contains_Elem_T'0 self k then len_Elem_T self - 1 else len_Elem_T self)
  
  function insert_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) (v: t_PtrOwn_Node_T) : t_FMap_Elem_T_PtrOwn_Node_T
  
  axiom insert_Elem_T_spec:
    forall self: t_FMap_Elem_T_PtrOwn_Node_T, k: t_Elem_T, v: t_PtrOwn_Node_T. view_FMap_Elem_T_PtrOwn_Node_T (insert_Elem_T self k v)
      = Map.set (view_FMap_Elem_T_PtrOwn_Node_T self) k (Some v)
  
  axiom insert_Elem_T_spec'0:
    forall self: t_FMap_Elem_T_PtrOwn_Node_T, k: t_Elem_T, v: t_PtrOwn_Node_T. len_Elem_T (insert_Elem_T self k v)
      = (if contains_Elem_T'0 self k then len_Elem_T self else len_Elem_T self + 1)
  
  let rec split_mut_ghost_Elem_T (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T)
    (return (x: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T)) =
    {[@expl:split_mut_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T self}
    {[@expl:split_mut_ghost requires] contains_Elem_T'0 self.current key}
    any
    [ return (result: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) ->
    {inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T result}
      {result.f1'2.current = remove_Elem_T self.current key}
      {index_FMap_Elem_T_PtrOwn_Node_T self.current key = result.f0'2.current
      /\ self.final = insert_Elem_T result.f1'2.final key result.f0'2.final}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UFInner_T
  
  predicate resolve_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMap_Elem_T_PtrOwn_Node_T
  
  type t_Option_ref_PtrOwn_Node_T = None'0 | Some'0 t_PtrOwn_Node_T
  
  predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0 [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_FMap_Elem_T_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0
  
  predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T'0 [@inline:trivial] (_1: t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_ref_FMap_Elem_T_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_T_PtrOwn_Node_T'0
  
  predicate invariant_ref_PtrOwn_Node_T'0 [@inline:trivial] (self: t_PtrOwn_Node_T) = inv_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_PtrOwn_Node_T'0
  
  predicate inv_ref_PtrOwn_Node_T'0 [@inline:trivial] (_1: t_PtrOwn_Node_T) = invariant_ref_PtrOwn_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_PtrOwn_Node_T'0
  
  predicate inv_Option_ref_PtrOwn_Node_T (_1: t_Option_ref_PtrOwn_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T [inv_Option_ref_PtrOwn_Node_T x]. inv_Option_ref_PtrOwn_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'3 -> inv_ref_PtrOwn_Node_T'0 f0'3
        end
  
  function map_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) (f: Map.map t_PtrOwn_Node_T t_PtrOwn_Node_T) : t_Option_ref_PtrOwn_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem_T (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T)
    (return (x: t_Option_ref_PtrOwn_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T'0 self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T) -> {inv_Option_ref_PtrOwn_Node_T result}
      {result = map_Option_PtrOwn_Node_T (get_Elem_T self key) (fun (v: t_PtrOwn_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T (self_: t_Option_ref_PtrOwn_Node_T) (return (x: t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T'0 result} {Some'0 result = self_} (! return {result}) ]
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  let rec disjoint_lemma_Node_T (own1: MutBorrow.t t_PtrOwn_Node_T) (own2: t_PtrOwn_Node_T) (return (x: ())) =
    {[@expl:disjoint_lemma 'own1' type invariant] inv_ref_PtrOwn_Node_T own1}
    {[@expl:disjoint_lemma 'own2' type invariant] inv_ref_PtrOwn_Node_T'0 own2}
    {[@expl:disjoint_lemma requires] size_of_Node_T <> 0}
    any
    [ return (result: ()) -> {Ptr.addr_logic_u64 (ptr_Node_T own1.current) <> Ptr.addr_logic_u64 (ptr_Node_T own2)}
      {own1.current = own1.final}
      (! return {result}) ]
  
  predicate resolve_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_PtrOwn_Node_T
  
  predicate resolve_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UFInner_T
  
  predicate resolve_Ghost_ref_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = resolve_ref_UFInner_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UFInner_T
  
  predicate resolve_ref_ref_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UF_T
  
  predicate resolve_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UF_T
  
  predicate resolve_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = resolve_ref_UF_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_UF_T
  
  let rec new_unit (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  predicate invariant_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) =
    inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T
  
  let rec new_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T
    (x: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T)
    (return (x'0: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T x}
    any
    [ return (result: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) ->
    {inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T result}
      {result = x}
      (! return {result}) ]
  
  type tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T = {
    f0'3: MutBorrow.t t_PtrOwn_Node_T;
    f1'3: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T }
  
  predicate invariant_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) =
    inv_ref_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_PtrOwn_Node_T) =
    invariant_Ghost_ref_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_PtrOwn_Node_T
  
  predicate invariant_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    inv_ref_FMap_Elem_T_PtrOwn_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    invariant_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T) =
    inv_Ghost_ref_PtrOwn_Node_T _1.f0'3 /\ inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T _1.f1'3
  
  meta "rewrite_def" predicate inv_tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T
  
  let rec split_ref_PtrOwn_Node_T (self: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T)
    (return (x: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T)) =
    {[@expl:split 'self' type invariant] inv_Ghost_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T self}
    any
    [ return (result: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T) ->
    {inv_tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T result}
      {self.f0'2 = result.f0'3}
      {self.f1'2 = result.f1'3}
      (! return {result}) ]
  
  predicate invariant_ref_Node_T'0 [@inline:trivial] (self: MutBorrow.t t_Node_T) =
    inv_Node_T self.current /\ inv_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_T'0
  
  predicate inv_ref_Node_T'0 [@inline:trivial] (_1: MutBorrow.t t_Node_T) = invariant_ref_Node_T'0 _1
  
  meta "rewrite_def" predicate inv_ref_Node_T'0
  
  function fin_Ghost_ref_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t t_PtrOwn_Node_T) : t_PtrOwn_Node_T =
    self.final
  
  meta "rewrite_def" function fin_Ghost_ref_PtrOwn_Node_T
  
  let rec as_mut_Node_T (ptr: Opaque.ptr) (own: MutBorrow.t t_PtrOwn_Node_T) (return (x: MutBorrow.t t_Node_T)) =
    {[@expl:as_mut 'own' type invariant] inv_Ghost_ref_PtrOwn_Node_T own}
    {[@expl:as_mut requires] ptr = ptr_Node_T own.current}
    any
    [ return (result: MutBorrow.t t_Node_T) -> {inv_ref_Node_T'0 result}
      {result.current = val_Node_T own.current}
      {ptr_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = ptr_Node_T own.current}
      {val_Node_T (fin_Ghost_ref_PtrOwn_Node_T own) = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_T
  
  predicate invariant_ref_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) =
    inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T self.current /\ inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_ref_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) =
    invariant_ref_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate invariant_ref_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) =
    inv_ref_FMap_Elem_T_PtrOwn_Node_T self.current /\ inv_ref_FMap_Elem_T_PtrOwn_Node_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_ref_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) =
    invariant_ref_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_FMap_Elem_T_PtrOwn_Node_T
  
  let rec deref_mut_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T (self: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T))
    (return (x: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) ->
    {inv_ref_ref_FMap_Elem_T_PtrOwn_Node_T result}
      {result = self}
      (! return {result}) ]
  
  type t_Option_ref_PtrOwn_Node_T'0 = None'1 | Some'1 (MutBorrow.t t_PtrOwn_Node_T)
  
  predicate inv_Option_ref_PtrOwn_Node_T'0 (_1: t_Option_ref_PtrOwn_Node_T'0)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_ref_PtrOwn_Node_T'0 [inv_Option_ref_PtrOwn_Node_T'0 x]. inv_Option_ref_PtrOwn_Node_T'0 x
      = match x with
        | None'1 -> true
        | Some'1 f0'4 -> inv_ref_PtrOwn_Node_T f0'4
        end
  
  let rec get_mut_ghost_Elem_T (self: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T)
    (return (x: t_Option_ref_PtrOwn_Node_T'0)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T self}
    any
    [ return (result: t_Option_ref_PtrOwn_Node_T'0) -> {inv_Option_ref_PtrOwn_Node_T'0 result}
      {if contains_Elem_T'0 self.current key then
        match result with
          | None'1 -> false
          | Some'1 r -> contains_Elem_T'0 self.final key
          /\ index_FMap_Elem_T_PtrOwn_Node_T self.current key = r.current
          /\ index_FMap_Elem_T_PtrOwn_Node_T self.final key = r.final
          end
      else
        result = None'1 /\ self.current = self.final
      }
      {forall k: t_Elem_T. k <> key -> get_Elem_T self.current k = get_Elem_T self.final k}
      {len_Elem_T self.current = len_Elem_T self.final}
      (! return {result}) ]
  
  let rec unwrap_ref_PtrOwn_Node_T'0 (self_: t_Option_ref_PtrOwn_Node_T'0) (return (x: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_PtrOwn_Node_T'0 self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_ref_PtrOwn_Node_T result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_FMap_Elem_T_PtrOwn_Node_T
  
  let rec new_ref_PtrOwn_Node_T (x: MutBorrow.t t_PtrOwn_Node_T) (return (x'0: MutBorrow.t t_PtrOwn_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_PtrOwn_Node_T x}
    any
    [ return (result: MutBorrow.t t_PtrOwn_Node_T) -> {inv_Ghost_ref_PtrOwn_Node_T result}
      {result = x}
      (! return {result}) ]
  
  let rec elim_Root (input: t_Node_T) (ret (rank: t_PeanoInt) (payload: t_T)) = any
    [ good (rank: t_PeanoInt) (payload: t_T) -> {Root rank payload = input} (! ret {rank} {payload})
    | bad -> {forall rank: t_PeanoInt, payload: t_T [Root rank payload: t_Node_T]. Root rank payload <> input}
      (! {false}
      any) ]
  
  predicate resolve_ref_PeanoInt [@inline:trivial] (_1: MutBorrow.t t_PeanoInt) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_PeanoInt
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'1
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: MutBorrow.t t_PeanoInt) : UInt64.t =
    deep_model_PeanoInt self.current
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  function deep_model_ref_ref_PeanoInt [@inline:trivial] (self: MutBorrow.t t_PeanoInt) : UInt64.t =
    deep_model_ref_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_ref_PeanoInt
  
  let rec lt_ref_PeanoInt (self_: MutBorrow.t t_PeanoInt) (other: MutBorrow.t t_PeanoInt) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = UInt64.lt (deep_model_ref_ref_PeanoInt self_) (deep_model_ref_ref_PeanoInt other)}
      (! return {result}) ]
  
  predicate resolve_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) =
    resolve_ref_FMap_Elem_T_PtrOwn_Node_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Node_T (_1: t_Node_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_T [resolve_Node_T x]. resolve_Node_T x
      = match x with
        | Root x0 x1 -> resolve_T x1
        | Link x0 -> true
        end
  
  let rec eq_ref_PeanoInt (self_: MutBorrow.t t_PeanoInt) (rhs: MutBorrow.t t_PeanoInt) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_ref_PeanoInt self_ = deep_model_ref_ref_PeanoInt rhs)}
      (! return {result}) ]
  
  let rec incr (self: t_PeanoInt) (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {UInt64.t'int result.f0'1 = UInt64.t'int self.f0'1 + 1} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem_T = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem_T) = contains_Elem_T (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem_T t_Elem_T = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem_T. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_T_Elem_T (roots_map_T self) e)
        /\ index_Mapping_Elem_T_Elem_T (roots_map_T self) e
        = index_Mapping_Elem_T_Elem_T (roots_map_T self) (index_Mapping_Elem_T_Elem_T (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem_T) : t_Elem_T = index_Mapping_Elem_T_Elem_T (roots_map_T self) e
  
  predicate domain_unchanged_T (self: MutBorrow.t t_UF_T) = domain_T self.current = domain_T self.final
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem_T t_T = self.f0'0.payloads
  
  predicate payloads_unchanged_T (self: MutBorrow.t t_UF_T) = payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) : t_UF_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UF_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec link_T (uf: MutBorrow.t t_UF_T) (x: t_Elem_T) (y: t_Elem_T) (return (x'0: t_Elem_T)) =
    {[@expl:link 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:link requires #0] in_domain_T uf.current x /\ in_domain_T uf.current y}
    {[@expl:link requires #1] root_T uf.current x = x /\ root_T uf.current y = y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Ghost_ref_UF_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_12 <- _ret ] -{inv_Ghost_ref_UF_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UF_T {_12} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_11 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_UFInner_T _11.current.current.f0'0}
        MutBorrow.borrow_mut <t_UFInner_T> {_11.current.current.f0'0}
          (fun (_ret: MutBorrow.t t_UFInner_T) ->
            [ &__temp <- _ret ] -{inv_UFInner_T _ret.final}-
            [ &_11 <- { _11 with current = { _11.current with current = { f0'0 = _ret.final } } } ] s1)
      | s1 = new_ref_UFInner_T {__temp} (fun (_ret: MutBorrow.t t_UFInner_T) -> [ &uf'0 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = eq_Elem_T {x} {y} (fun (_ret: bool) -> [ &_16 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_16 = false} (! bb16) | br1 -> {_16} (! bb4) ]
    | bb4 = s0 [ s0 = [ &_24 <- x <> y ] s1 | s1 = bb5 ]
    | bb5 = s0 [ s0 = into_ghost_bool {_24} (fun (_ret: bool) -> [ &_23 <- _ret ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = into_inner_bool {_23} (fun (_ret: bool) -> [ &_22 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = any [ br0 -> {_22 = false} (! bb14) | br1 -> {_22} (! bb8) ]
    | bb8 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_31 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_31}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_30 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_33 <- x ] s1
      | s1 = {inv_FMap_Elem_T_PtrOwn_Node_T _30.current.current.perms}
        MutBorrow.borrow_mut <t_FMap_Elem_T_PtrOwn_Node_T> {_30.current.current.perms}
          (fun (_ret: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) ->
            [ &_29 <- _ret ] -{inv_FMap_Elem_T_PtrOwn_Node_T _ret.final}-
            [ &_30 <- { _30 with current = { _30.current with current = { _30.current.current with perms = _ret.final } } } ]
            s2)
      | s2 = split_mut_ghost_Elem_T {_29} {_33}
          (fun (_ret: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) -> [ &_28 <- _ret ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = [ &perm_x <- _28.f0'2 ] s1
      | s1 = [ &m <- _28.f1'2 ] s2
      | s2 = {[@expl:type invariant] inv_ref_ref_UFInner_T _30} s3
      | s3 = -{resolve_ref_ref_UFInner_T _30}- s4
      | s4 = {[@expl:type invariant] inv_ref_FMap_Elem_T_PtrOwn_Node_T m} s5
      | s5 = -{resolve_ref_FMap_Elem_T_PtrOwn_Node_T m}- s6
      | s6 = [ &_41 <- y ] s7
      | s7 = get_ghost_Elem_T {m.current} {_41} (fun (_ret: t_Option_ref_PtrOwn_Node_T) -> [ &_38 <- _ret ] s8)
      | s8 = bb11 ]
    | bb11 = s0 [ s0 = unwrap_ref_PtrOwn_Node_T {_38} (fun (_ret: t_PtrOwn_Node_T) -> [ &_37 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_PtrOwn_Node_T perm_x.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {perm_x.current} {MutBorrow.get_id perm_x}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_35 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &perm_x <- { perm_x with current = _ret.final } ] s1)
      | s1 = disjoint_lemma_Node_T {_35} {_37} (fun (_ret: ()) -> [ &_34 <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T perm_x} s1
      | s1 = -{resolve_ref_PtrOwn_Node_T perm_x}- s2
      | s2 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s3
      | s3 = -{resolve_Ghost_ref_UFInner_T uf'0}- s4
      | s4 = {[@expl:type invariant] inv_ref_ref_UF_T _11} s5
      | s5 = -{resolve_ref_ref_UF_T _11}- s6
      | s6 = {[@expl:type invariant] inv_Ghost_ref_UF_T uf} s7
      | s7 = -{resolve_Ghost_ref_UF_T uf}- s8
      | s8 = {false} any ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s1
      | s1 = -{resolve_Ghost_ref_UFInner_T uf'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_ref_UF_T _11} s3
      | s3 = -{resolve_ref_ref_UF_T _11}- s4
      | s4 = {[@expl:type invariant] inv_Ghost_ref_UF_T uf} s5
      | s5 = -{resolve_Ghost_ref_UF_T uf}- s6
      | s6 = new_unit {_21} (fun (_ret: ()) -> [ &_20 <- _ret ] s7)
      | s7 = bb15 ]
    | bb15 = s0 [ s0 = [ &_0 <- x ] s1 | s1 = bb54 ]
    | bb16 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_50 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_50}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_49 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_52 <- x ] s1
      | s1 = {inv_FMap_Elem_T_PtrOwn_Node_T _49.current.current.perms}
        MutBorrow.borrow_mut <t_FMap_Elem_T_PtrOwn_Node_T> {_49.current.current.perms}
          (fun (_ret: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) ->
            [ &_48 <- _ret ] -{inv_FMap_Elem_T_PtrOwn_Node_T _ret.final}-
            [ &_49 <- { _49 with current = { _49.current with current = { _49.current.current with perms = _ret.final } } } ]
            s2)
      | s2 = split_mut_ghost_Elem_T {_48} {_52}
          (fun (_ret: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) -> [ &_47 <- _ret ] s3)
      | s3 = bb18 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_ref_UFInner_T _49} s1
      | s1 = -{resolve_ref_ref_UFInner_T _49}- s2
      | s2 = new_tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T {_47}
          (fun (_ret: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T) -> [ &_46 <- _ret ] s3)
      | s3 = bb19 ]
    | bb19 = s0
      [ s0 = split_ref_PtrOwn_Node_T {_46}
          (fun (_ret: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T) -> [ &_45 <- _ret ] s1)
      | s1 = bb20 ]
    | bb20 = s0
      [ s0 = [ &perm_x'0 <- _45.f0'3 ] s1
      | s1 = [ &m'0 <- _45.f1'3 ] s2
      | s2 = [ &_55 <- x.f0 ] s3
      | s3 = as_mut_Node_T {_55} {perm_x'0} (fun (_ret: MutBorrow.t t_Node_T) -> [ &_54 <- _ret ] s4)
      | s4 = bb21 ]
    | bb21 = s0
      [ s0 = {inv_Node_T _54.current}
        MutBorrow.borrow_final <t_Node_T> {_54.current} {MutBorrow.get_id _54}
          (fun (_ret: MutBorrow.t t_Node_T) ->
            [ &bx <- _ret ] -{inv_Node_T _ret.final}-
            [ &_54 <- { _54 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 _54} s2
      | s2 = -{resolve_ref_Node_T _54}- s3
      | s3 = [ &_60 <- y.f0 ] s4
      | s4 = {inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T m'0}
        MutBorrow.borrow_mut <MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T> {m'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) ->
            [ &_69 <- _ret ] -{inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T _ret.final}-
            [ &m'0 <- _ret.final ] s5)
      | s5 = deref_mut_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T {_69}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T)) -> [ &_68 <- _ret ] s6)
      | s6 = bb22 ]
    | bb22 = s0
      [ s0 = [ &_71 <- y ] s1
      | s1 = {inv_FMap_Elem_T_PtrOwn_Node_T _68.current.current}
        MutBorrow.borrow_mut <t_FMap_Elem_T_PtrOwn_Node_T> {_68.current.current}
          (fun (_ret: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) ->
            [ &_67 <- _ret ] -{inv_FMap_Elem_T_PtrOwn_Node_T _ret.final}-
            [ &_68 <- { _68 with current = { _68.current with current = _ret.final } } ] s2)
      | s2 = get_mut_ghost_Elem_T {_67} {_71} (fun (_ret: t_Option_ref_PtrOwn_Node_T'0) -> [ &_66 <- _ret ] s3)
      | s3 = bb23 ]
    | bb23 = s0
      [ s0 = unwrap_ref_PtrOwn_Node_T'0 {_66} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &_65 <- _ret ] s1)
      | s1 = bb24 ]
    | bb24 = s0
      [ s0 = {inv_PtrOwn_Node_T _65.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {_65.current} {MutBorrow.get_id _65}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_64 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &_65 <- { _65 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_ref_FMap_Elem_T_PtrOwn_Node_T _68} s2
      | s2 = -{resolve_ref_ref_FMap_Elem_T_PtrOwn_Node_T _68}- s3
      | s3 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T _65} s4
      | s4 = -{resolve_ref_PtrOwn_Node_T _65}- s5
      | s5 = {inv_PtrOwn_Node_T _64.current}
        MutBorrow.borrow_final <t_PtrOwn_Node_T> {_64.current} {MutBorrow.get_id _64}
          (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) ->
            [ &_63 <- _ret ] -{inv_PtrOwn_Node_T _ret.final}-
            [ &_64 <- { _64 with current = _ret.final } ] s6)
      | s6 = new_ref_PtrOwn_Node_T {_63} (fun (_ret: MutBorrow.t t_PtrOwn_Node_T) -> [ &_62 <- _ret ] s7)
      | s7 = bb25 ]
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv_ref_PtrOwn_Node_T _64} s1
      | s1 = -{resolve_ref_PtrOwn_Node_T _64}- s2
      | s2 = as_mut_Node_T {_60} {_62} (fun (_ret: MutBorrow.t t_Node_T) -> [ &_59 <- _ret ] s3)
      | s3 = bb26 ]
    | bb26 = s0
      [ s0 = {inv_Node_T _59.current}
        MutBorrow.borrow_final <t_Node_T> {_59.current} {MutBorrow.get_id _59}
          (fun (_ret: MutBorrow.t t_Node_T) ->
            [ &by' <- _ret ] -{inv_Node_T _ret.final}-
            [ &_59 <- { _59 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 _59} s2
      | s2 = -{resolve_ref_Node_T _59}- s3
      | s3 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {bx.current = Root x0 x1} (! bb29)
        | br1 (x0: t_Elem_T) -> {bx.current = Link x0} (! bb27) ] ]
    | bb27 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s1
      | s1 = -{resolve_ref_Node_T by'}- s2
      | s2 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s3
      | s3 = -{resolve_ref_Node_T bx}- s4
      | s4 = {false} any ]
    | bb29 = s0
      [ s0 = elim_Root {bx.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &rx <- _ret ] [ &bx <- { bx with current = Root _ret.final rpayload } ] s1))
      | s1 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {by'.current = Root x0 x1} (! bb32)
        | br1 (x0: t_Elem_T) -> {by'.current = Link x0} (! bb30) ] ]
    | bb30 = s0
      [ s0 = -{resolve_ref_PeanoInt rx}- s1
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s2
      | s2 = -{resolve_ref_Node_T by'}- s3
      | s3 = {false} any ]
    | bb32 = s0
      [ s0 = elim_Root {by'.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_ret: MutBorrow.t t_PeanoInt) ->
                [ &ry <- _ret ] [ &by' <- { by' with current = Root _ret.final rpayload } ] s1))
      | s1 = MutBorrow.borrow_final <t_PeanoInt> {ry.current} {MutBorrow.get_id ry}
          (fun (_ret: MutBorrow.t t_PeanoInt) -> [ &_81 <- _ret ] [ &ry <- { ry with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_PeanoInt _81}- s3
      | s3 = lt_ref_PeanoInt {rx} {_81} (fun (_ret: bool) -> [ &_78 <- _ret ] s4)
      | s4 = bb33 ]
    | bb33 = any [ br0 -> {_78 = false} (! bb41) | br1 -> {_78} (! bb34) ]
    | bb34 = s0
      [ s0 = -{resolve_ref_PeanoInt ry}- s1
      | s1 = -{resolve_ref_PeanoInt rx}- s2
      | s2 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s3
      | s3 = -{resolve_ref_Node_T by'}- s4
      | s4 = {[@expl:type invariant] inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T m'0} s5
      | s5 = -{resolve_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T m'0}- s6
      | s6 = [ &_82 <- Link y ] s7
      | s7 = bb35 ]
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv_Node_T bx.current} s1
      | s1 = -{resolve_Node_T bx.current}- s2
      | s2 = [ &bx <- { bx with current = _82 } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s4
      | s4 = -{resolve_ref_Node_T bx}- s5
      | s5 = bb37 ]
    | bb37 = s0
      [ s0 = [ &_86 <- fun (z: t_Elem_T) -> if index_Mapping_Elem_T_Elem_T uf'0.current.roots z = x then
          y
        else
          index_Mapping_Elem_T_Elem_T uf'0.current.roots z
         ] s1
      | s1 = bb38 ]
    | bb38 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_89 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_89}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_88 <- _ret ] s2)
      | s2 = bb39 ]
    | bb39 = s0
      [ s0 = [ &_88 <- { _88 with current = { _88.current with current = { _88.current.current with roots = _86 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _88} s2
      | s2 = -{resolve_ref_ref_UFInner_T _88}- s3
      | s3 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s4
      | s4 = -{resolve_Ghost_ref_UFInner_T uf'0}- s5
      | s5 = {[@expl:type invariant] inv_ref_ref_UF_T _11} s6
      | s6 = -{resolve_ref_ref_UF_T _11}- s7
      | s7 = {[@expl:type invariant] inv_Ghost_ref_UF_T uf} s8
      | s8 = -{resolve_Ghost_ref_UF_T uf}- s9
      | s9 = new_unit {_85} (fun (_ret: ()) -> [ &_84 <- _ret ] s10)
      | s10 = bb40 ]
    | bb40 = s0 [ s0 = [ &_0 <- y ] s1 | s1 = bb54 ]
    | bb41 = s0
      [ s0 = -{resolve_ref_PeanoInt ry}- s1
      | s1 = eq_ref_PeanoInt {rx} {ry} (fun (_ret: bool) -> [ &_91 <- _ret ] s2)
      | s2 = bb42 ]
    | bb42 = any [ br0 -> {_91 = false} (! bb45) | br1 -> {_91} (! bb43) ]
    | bb43 = s0
      [ s0 = -{resolve_ref_PeanoInt rx}- s1
      | s1 = incr {rx.current} (fun (_ret: t_PeanoInt) -> [ &_94 <- _ret ] s2)
      | s2 = bb44 ]
    | bb44 = s0 [ s0 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s1 | s1 = -{resolve_ref_Node_T bx}- s2 | s2 = bb46 ]
    | bb45 = s0
      [ s0 = -{resolve_ref_PeanoInt rx}- s1
      | s1 = {[@expl:type invariant] inv_ref_Node_T'0 bx} s2
      | s2 = -{resolve_ref_Node_T bx}- s3
      | s3 = bb46 ]
    | bb46 = s0 [ s0 = [ &_96 <- Link x ] s1 | s1 = bb47 ]
    | bb47 = s0
      [ s0 = {[@expl:type invariant] inv_Node_T by'.current} s1
      | s1 = -{resolve_Node_T by'.current}- s2
      | s2 = [ &by' <- { by' with current = _96 } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_T'0 by'} s4
      | s4 = -{resolve_ref_Node_T by'}- s5
      | s5 = {[@expl:type invariant] inv_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T m'0} s6
      | s6 = -{resolve_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T m'0}- s7
      | s7 = bb49 ]
    | bb49 = s0
      [ s0 = [ &_100 <- fun (z: t_Elem_T) -> if index_Mapping_Elem_T_Elem_T uf'0.current.roots z = y then
          x
        else
          index_Mapping_Elem_T_Elem_T uf'0.current.roots z
         ] s1
      | s1 = bb50 ]
    | bb50 = s0
      [ s0 = {inv_Ghost_ref_UFInner_T uf'0}
        MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_103 <- _ret ] -{inv_Ghost_ref_UFInner_T _ret.final}-
            [ &uf'0 <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UFInner_T {_103}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_102 <- _ret ] s2)
      | s2 = bb51 ]
    | bb51 = s0
      [ s0 =
        [ &_102 <- { _102 with current = { _102.current with current = { _102.current.current with roots = _100 } } } ]
        s1
      | s1 = {[@expl:type invariant] inv_ref_ref_UFInner_T _102} s2
      | s2 = -{resolve_ref_ref_UFInner_T _102}- s3
      | s3 = {[@expl:type invariant] inv_Ghost_ref_UFInner_T uf'0} s4
      | s4 = -{resolve_Ghost_ref_UFInner_T uf'0}- s5
      | s5 = {[@expl:type invariant] inv_ref_ref_UF_T _11} s6
      | s6 = -{resolve_ref_ref_UF_T _11}- s7
      | s7 = {[@expl:type invariant] inv_Ghost_ref_UF_T uf} s8
      | s8 = -{resolve_Ghost_ref_UF_T uf}- s9
      | s9 = new_unit {_99} (fun (_ret: ()) -> [ &_98 <- _ret ] s10)
      | s10 = bb52 ]
    | bb52 = s0 [ s0 = [ &_0 <- x ] s1 | s1 = bb54 ]
    | bb54 = return {_0} ]
    [ & _0: t_Elem_T = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & x: t_Elem_T = x
    | & y: t_Elem_T = y
    | & __temp: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _11: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _12: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _20: () = Any.any_l ()
    | & _21: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _23: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & perm_x: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & m: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _28: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _29: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _30: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _31: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _33: t_Elem_T = Any.any_l ()
    | & _34: () = Any.any_l ()
    | & _35: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _37: t_PtrOwn_Node_T = Any.any_l ()
    | & _38: t_Option_ref_PtrOwn_Node_T = Any.any_l ()
    | & _41: t_Elem_T = Any.any_l ()
    | & perm_x'0: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & m'0: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _45: tup2_Ghost_ref_PtrOwn_Node_T_Ghost_ref_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _46: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _47: tup2_ref_PtrOwn_Node_T_ref_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _48: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _49: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _50: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _52: t_Elem_T = Any.any_l ()
    | & bx: MutBorrow.t t_Node_T = Any.any_l ()
    | & _54: MutBorrow.t t_Node_T = Any.any_l ()
    | & _55: Opaque.ptr = Any.any_l ()
    | & by': MutBorrow.t t_Node_T = Any.any_l ()
    | & _59: MutBorrow.t t_Node_T = Any.any_l ()
    | & _60: Opaque.ptr = Any.any_l ()
    | & _62: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _63: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _64: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _65: MutBorrow.t t_PtrOwn_Node_T = Any.any_l ()
    | & _66: t_Option_ref_PtrOwn_Node_T'0 = Any.any_l ()
    | & _67: MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T = Any.any_l ()
    | & _68: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) = Any.any_l ()
    | & _69: MutBorrow.t (MutBorrow.t t_FMap_Elem_T_PtrOwn_Node_T) = Any.any_l ()
    | & _71: t_Elem_T = Any.any_l ()
    | & rx: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & ry: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _78: bool = Any.any_l ()
    | & _81: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _82: t_Node_T = Any.any_l ()
    | & _84: () = Any.any_l ()
    | & _85: () = Any.any_l ()
    | & _86: Map.map t_Elem_T t_Elem_T = Any.any_l ()
    | & _88: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _89: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _91: bool = Any.any_l ()
    | & _94: t_PeanoInt = Any.any_l ()
    | & _96: t_Node_T = Any.any_l ()
    | & _98: () = Any.any_l ()
    | & _99: () = Any.any_l ()
    | & _100: Map.map t_Elem_T t_Elem_T = Any.any_l ()
    | & _102: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _103: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l () ])
    [ return (result: t_Elem_T) -> {[@expl:link ensures #0] domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {[@expl:link ensures #1] result = root_T uf.current x \/ result = root_T uf.current y}
      {[@expl:link ensures #2] result = root_T (fin_Ghost_ref_UF_T uf) result}
      {[@expl:link ensures #3] forall z: t_Elem_T. in_domain_T uf.current z
        -> root_T (fin_Ghost_ref_UF_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
end
module M_implementation__union
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  type t_FMap_Elem_T_PtrOwn_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem_T;
    perms: t_FMap_Elem_T_PtrOwn_Node_T;
    payloads: Map.map t_Elem_T t_T;
    roots: Map.map t_Elem_T t_Elem_T }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem_T [@inline:trivial] (self: Fset.fset t_Elem_T) (e: t_Elem_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_T
  
  type t_PtrOwn_Node_T
  
  type t_Option_PtrOwn_Node_T = None | Some t_PtrOwn_Node_T
  
  function view_FMap_Elem_T_PtrOwn_Node_T (self: t_FMap_Elem_T_PtrOwn_Node_T) : Map.map t_Elem_T t_Option_PtrOwn_Node_T
  
  function get_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_Option_PtrOwn_Node_T =
    Map.get (view_FMap_Elem_T_PtrOwn_Node_T self) k
  
  meta "rewrite_def" function get_Elem_T
  
  predicate contains_Elem_T'0 [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) =
    get_Elem_T self k <> None
  
  meta "rewrite_def" predicate contains_Elem_T'0
  
  function ptr_Node_T (self: t_PtrOwn_Node_T) : Opaque.ptr
  
  predicate index_Mapping_PtrOwn_Node_T_bool [@inline:trivial] (self: Map.map t_PtrOwn_Node_T bool) (a: t_PtrOwn_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PtrOwn_Node_T_bool
  
  function such_that_PtrOwn_Node_T (p: Map.map t_PtrOwn_Node_T bool) : t_PtrOwn_Node_T
  
  axiom such_that_PtrOwn_Node_T_spec:
    forall p: Map.map t_PtrOwn_Node_T bool. (exists x: t_PtrOwn_Node_T. index_Mapping_PtrOwn_Node_T_bool p x)
      -> index_Mapping_PtrOwn_Node_T_bool p (such_that_PtrOwn_Node_T p)
  
  function unwrap_Option_PtrOwn_Node_T (self: t_Option_PtrOwn_Node_T) : t_PtrOwn_Node_T = match self with
      | Some x -> x
      | None -> such_that_PtrOwn_Node_T (fun (__0: t_PtrOwn_Node_T) -> true)
      end
  
  function lookup_Elem_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (k: t_Elem_T) : t_PtrOwn_Node_T =
    unwrap_Option_PtrOwn_Node_T (get_Elem_T self k)
  
  meta "rewrite_def" function lookup_Elem_T
  
  function index_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) (key: t_Elem_T) : t_PtrOwn_Node_T
   = lookup_Elem_T self key
  
  meta "rewrite_def" function index_FMap_Elem_T_PtrOwn_Node_T
  
  function index_Mapping_Elem_T_Elem_T [@inline:trivial] (self: Map.map t_Elem_T t_Elem_T) (a: t_Elem_T) : t_Elem_T =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_Elem_T
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem_T
  
  function val_Node_T (self: t_PtrOwn_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T_T [@inline:trivial] (self: Map.map t_Elem_T t_T) (a: t_Elem_T) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem_T. contains_Elem_T self.f0'0.domain e
      -> contains_Elem_T'0 self.f0'0.perms e
      /\ ptr_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem_T self.f0'0.domain (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
      /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots (index_Mapping_Elem_T_Elem_T self.f0'0.roots e)
        = index_Mapping_Elem_T_Elem_T self.f0'0.roots e
      /\ match val_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem_T self.f0'0.domain e2
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e <> e
        /\ index_Mapping_Elem_T_Elem_T self.f0'0.roots e = index_Mapping_Elem_T_Elem_T self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_T_Elem_T self.f0'0.roots e = e
        /\ index_Mapping_Elem_T_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem_T [@inline:trivial] (_1: t_Elem_T) = true
  
  meta "rewrite_def" predicate inv_Elem_T
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_PtrOwn_Node_T (self: t_PtrOwn_Node_T) =
    not is_null_ptr_Node_T (ptr_Node_T self)
    /\ metadata_matches_Node_T (val_Node_T self) (metadata_Node_T (ptr_Node_T self)) /\ inv_ref_Node_T (val_Node_T self)
  
  predicate inv_PtrOwn_Node_T (_1: t_PtrOwn_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_PtrOwn_Node_T [inv_PtrOwn_Node_T x]. inv_PtrOwn_Node_T x
      = invariant_PtrOwn_Node_T x
  
  predicate invariant_FMap_Elem_T_PtrOwn_Node_T [@inline:trivial] (self: t_FMap_Elem_T_PtrOwn_Node_T) =
    forall k: t_Elem_T. contains_Elem_T'0 self k
      -> inv_Elem_T k /\ inv_PtrOwn_Node_T (index_FMap_Elem_T_PtrOwn_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_T_PtrOwn_Node_T
  
  predicate inv_FMap_Elem_T_PtrOwn_Node_T (_1: t_FMap_Elem_T_PtrOwn_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_T_PtrOwn_Node_T [inv_FMap_Elem_T_PtrOwn_Node_T x]. inv_FMap_Elem_T_PtrOwn_Node_T x
      = invariant_FMap_Elem_T_PtrOwn_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_T_PtrOwn_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_UF_T
  
  predicate inv_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_UF_T
  
  predicate invariant_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_T
  
  predicate inv_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_T
  
  predicate invariant_ref_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_Ghost_ref_UF_T self.current /\ inv_Ghost_ref_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UF_T
  
  predicate inv_ref_Ghost_ref_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_ref_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UF_T
  
  predicate invariant_ref_ref_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_ref_UF_T self.current /\ inv_ref_UF_T self.final
  
  meta "rewrite_def" predicate invariant_ref_ref_UF_T
  
  predicate inv_ref_ref_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = invariant_ref_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UF_T
  
  let rec deref_mut_Ghost_ref_UF_T (self: MutBorrow.t (MutBorrow.t t_UF_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UF_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_ref_Ghost_ref_UF_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UF_T)) -> {inv_ref_ref_UF_T result}
      {result = self}
      (! return {result}) ]
  
  predicate resolve_ref_ref_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_UF_T
  
  predicate resolve_ref_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_UF_T
  
  let rec new_ref_UF_T (x: MutBorrow.t t_UF_T) (return (x'0: MutBorrow.t t_UF_T)) =
    {[@expl:new 'x' type invariant] inv_ref_UF_T x}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_Ghost_ref_UF_T result} {result = x} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem_T = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem_T) = contains_Elem_T (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem_T t_Elem_T = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem_T. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_T_Elem_T (roots_map_T self) e)
        /\ index_Mapping_Elem_T_Elem_T (roots_map_T self) e
        = index_Mapping_Elem_T_Elem_T (roots_map_T self) (index_Mapping_Elem_T_Elem_T (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem_T) : t_Elem_T = index_Mapping_Elem_T_Elem_T (roots_map_T self) e
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem_T t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UF_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  let rec find_T (uf: MutBorrow.t t_UF_T) (elem: t_Elem_T) (return (x: t_Elem_T)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:find requires] in_domain_T uf.current elem}
    any [ return (result: t_Elem_T) -> {result = root_T uf.current elem} {unchanged_T uf} (! return {result}) ]
  
  predicate domain_unchanged_T (self: MutBorrow.t t_UF_T) = domain_T self.current = domain_T self.final
  
  predicate payloads_unchanged_T (self: MutBorrow.t t_UF_T) = payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_ref_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) : t_UF_T = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UF_T
  
  let rec link_T (uf: MutBorrow.t t_UF_T) (x: t_Elem_T) (y: t_Elem_T) (return (x'0: t_Elem_T)) =
    {[@expl:link 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:link requires #0] in_domain_T uf.current x /\ in_domain_T uf.current y}
    {[@expl:link requires #1] root_T uf.current x = x /\ root_T uf.current y = y}
    any
    [ return (result: t_Elem_T) -> {domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {result = root_T uf.current x \/ result = root_T uf.current y}
      {result = root_T (fin_Ghost_ref_UF_T uf) result}
      {forall z: t_Elem_T. in_domain_T uf.current z
        -> root_T (fin_Ghost_ref_UF_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec union_T (uf: MutBorrow.t t_UF_T) (x: t_Elem_T) (y: t_Elem_T) (return (x'0: t_Elem_T)) =
    {[@expl:union 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:union requires] in_domain_T uf.current x /\ in_domain_T uf.current y}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Ghost_ref_UF_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_14 <- _ret ] -{inv_Ghost_ref_UF_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UF_T {_14} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_13 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_UF_T _13.current.current}
        MutBorrow.borrow_mut <t_UF_T> {_13.current.current}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_12 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_13 <- { _13 with current = { _13.current with current = _ret.final } } ] s1)
      | s1 = {inv_UF_T _12.current}
        MutBorrow.borrow_final <t_UF_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_11 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_12 <- { _12 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_ref_UF_T _13} s3
      | s3 = -{resolve_ref_ref_UF_T _13}- s4
      | s4 = {[@expl:type invariant] inv_ref_UF_T _12} s5
      | s5 = -{resolve_ref_UF_T _12}- s6
      | s6 = {inv_UF_T _11.current}
        MutBorrow.borrow_final <t_UF_T> {_11.current} {MutBorrow.get_id _11}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_10 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_11 <- { _11 with current = _ret.final } ] s7)
      | s7 = new_ref_UF_T {_10} (fun (_ret: MutBorrow.t t_UF_T) -> [ &_9 <- _ret ] s8)
      | s8 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_UF_T _11} s1
      | s1 = -{resolve_ref_UF_T _11}- s2
      | s2 = find_T {_9} {x} (fun (_ret: t_Elem_T) -> [ &rx <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Ghost_ref_UF_T uf}
        MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_22 <- _ret ] -{inv_Ghost_ref_UF_T _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = deref_mut_Ghost_ref_UF_T {_22} (fun (_ret: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_21 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = {inv_UF_T _21.current.current}
        MutBorrow.borrow_mut <t_UF_T> {_21.current.current}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_20 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_21 <- { _21 with current = { _21.current with current = _ret.final } } ] s1)
      | s1 = {inv_UF_T _20.current}
        MutBorrow.borrow_final <t_UF_T> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_19 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_20 <- { _20 with current = _ret.final } ] s2)
      | s2 = {[@expl:type invariant] inv_ref_ref_UF_T _21} s3
      | s3 = -{resolve_ref_ref_UF_T _21}- s4
      | s4 = {[@expl:type invariant] inv_ref_UF_T _20} s5
      | s5 = -{resolve_ref_UF_T _20}- s6
      | s6 = {inv_UF_T _19.current}
        MutBorrow.borrow_final <t_UF_T> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_UF_T) ->
            [ &_18 <- _ret ] -{inv_UF_T _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s7)
      | s7 = new_ref_UF_T {_18} (fun (_ret: MutBorrow.t t_UF_T) -> [ &_17 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_UF_T _19} s1
      | s1 = -{resolve_ref_UF_T _19}- s2
      | s2 = find_T {_17} {y} (fun (_ret: t_Elem_T) -> [ &ry <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = link_T {uf} {rx} {ry} (fun (_ret: t_Elem_T) -> [ &_0 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = return {_0} ]
    [ & _0: t_Elem_T = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & x: t_Elem_T = x
    | & y: t_Elem_T = y
    | & rx: t_Elem_T = Any.any_l ()
    | & _9: MutBorrow.t t_UF_T = Any.any_l ()
    | & _10: MutBorrow.t t_UF_T = Any.any_l ()
    | & _11: MutBorrow.t t_UF_T = Any.any_l ()
    | & _12: MutBorrow.t t_UF_T = Any.any_l ()
    | & _13: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _14: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & ry: t_Elem_T = Any.any_l ()
    | & _17: MutBorrow.t t_UF_T = Any.any_l ()
    | & _18: MutBorrow.t t_UF_T = Any.any_l ()
    | & _19: MutBorrow.t t_UF_T = Any.any_l ()
    | & _20: MutBorrow.t t_UF_T = Any.any_l ()
    | & _21: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _22: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l () ])
    [ return (result: t_Elem_T) -> {[@expl:union ensures #0] domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {[@expl:union ensures #1] result = root_T uf.current x \/ result = root_T uf.current y}
      {[@expl:union ensures #2] forall z: t_Elem_T. in_domain_T uf.current z
        -> root_T (fin_Ghost_ref_UF_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
end
module M_example
  use set.Fset
  use creusot.prelude.MutBorrow
  use creusot.int.Int32
  use map.Map
  use creusot.prelude.Any
  
  type t_UF_i32
  
  predicate invariant_UF_i32 (self: t_UF_i32)
  
  predicate inv_UF_i32 (_1: t_UF_i32)
  
  axiom inv_axiom: forall x: t_UF_i32 [inv_UF_i32 x]. inv_UF_i32 x -> invariant_UF_i32 x
  
  predicate invariant_Ghost_UF_i32 [@inline:trivial] (self: t_UF_i32) = inv_UF_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_UF_i32
  
  predicate inv_Ghost_UF_i32 [@inline:trivial] (_1: t_UF_i32) = invariant_Ghost_UF_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_UF_i32
  
  type t_Elem_i32
  
  function domain_i32 (self: t_UF_i32) : Fset.fset t_Elem_i32
  
  let rec new_i32 (return (x: t_UF_i32)) = any
    [ return (result: t_UF_i32) -> {inv_Ghost_UF_i32 result} {Fset.is_empty (domain_i32 result)} (! return {result}) ]
  
  predicate invariant_ref_Ghost_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) =
    inv_Ghost_UF_i32 self.current /\ inv_Ghost_UF_i32 self.final
  
  meta "rewrite_def" predicate invariant_ref_Ghost_UF_i32
  
  predicate inv_ref_Ghost_UF_i32 [@inline:trivial] (_1: MutBorrow.t t_UF_i32) = invariant_ref_Ghost_UF_i32 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_UF_i32
  
  predicate invariant_ref_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) =
    inv_UF_i32 self.current /\ inv_UF_i32 self.final
  
  meta "rewrite_def" predicate invariant_ref_UF_i32
  
  predicate inv_ref_UF_i32 [@inline:trivial] (_1: MutBorrow.t t_UF_i32) = invariant_ref_UF_i32 _1
  
  meta "rewrite_def" predicate inv_ref_UF_i32
  
  predicate invariant_Ghost_ref_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) = inv_ref_UF_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_i32
  
  predicate inv_Ghost_ref_UF_i32 [@inline:trivial] (_1: MutBorrow.t t_UF_i32) = invariant_Ghost_ref_UF_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_i32
  
  let rec borrow_mut_UF_i32 (self: MutBorrow.t t_UF_i32) (return (x: MutBorrow.t t_UF_i32)) =
    {[@expl:borrow_mut 'self' type invariant] inv_ref_Ghost_UF_i32 self}
    any [ return (result: MutBorrow.t t_UF_i32) -> {inv_Ghost_ref_UF_i32 result} {result = self} (! return {result}) ]
  
  predicate inv_Elem_i32 (_1: t_Elem_i32)
  
  predicate contains_Elem_i32 [@inline:trivial] (self: Fset.fset t_Elem_i32) (e: t_Elem_i32) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem_i32
  
  predicate in_domain_i32 (self: t_UF_i32) (e: t_Elem_i32) = contains_Elem_i32 (domain_i32 self) e
  
  function fin_Ghost_ref_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) : t_UF_i32 = self.final
  
  meta "rewrite_def" function fin_Ghost_ref_UF_i32
  
  function insert_Elem_i32 [@inline:trivial] (self: Fset.fset t_Elem_i32) (e: t_Elem_i32) : Fset.fset t_Elem_i32 =
    Fset.add e self
  
  meta "rewrite_def" function insert_Elem_i32
  
  function index_Mapping_Elem_i32_Elem_i32 [@inline:trivial] (self: Map.map t_Elem_i32 t_Elem_i32) (a: t_Elem_i32) : t_Elem_i32
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_i32_Elem_i32
  
  function roots_map_i32 (self: t_UF_i32) : Map.map t_Elem_i32 t_Elem_i32
  
  axiom roots_map_i32_spec: forall self: t_UF_i32. inv_UF_i32 self
      -> (forall e: t_Elem_i32. in_domain_i32 self e
        -> in_domain_i32 self (index_Mapping_Elem_i32_Elem_i32 (roots_map_i32 self) e)
        /\ index_Mapping_Elem_i32_Elem_i32 (roots_map_i32 self) e
        = index_Mapping_Elem_i32_Elem_i32 (roots_map_i32 self) (index_Mapping_Elem_i32_Elem_i32 (roots_map_i32 self) e))
  
  function payloads_map_i32 (self: t_UF_i32) : Map.map t_Elem_i32 Int32.t
  
  let rec make_i32 (uf: MutBorrow.t t_UF_i32) (payload: Int32.t) (return (x: t_Elem_i32)) =
    {[@expl:make 'uf' type invariant] inv_Ghost_ref_UF_i32 uf}
    any
    [ return (result: t_Elem_i32) -> {inv_Elem_i32 result}
      {not in_domain_i32 uf.current result}
      {domain_i32 (fin_Ghost_ref_UF_i32 uf) = insert_Elem_i32 (domain_i32 uf.current) result}
      {roots_map_i32 (fin_Ghost_ref_UF_i32 uf) = Map.set (roots_map_i32 uf.current) result result}
      {payloads_map_i32 (fin_Ghost_ref_UF_i32 uf) = Map.set (payloads_map_i32 uf.current) result payload}
      (! return {result}) ]
  
  predicate invariant_ref_Ghost_UF_i32'0 [@inline:trivial] (self: t_UF_i32) = inv_Ghost_UF_i32 self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_UF_i32'0
  
  predicate inv_ref_Ghost_UF_i32'0 [@inline:trivial] (_1: t_UF_i32) = invariant_ref_Ghost_UF_i32'0 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_UF_i32'0
  
  predicate invariant_ref_UF_i32'0 [@inline:trivial] (self: t_UF_i32) = inv_UF_i32 self
  
  meta "rewrite_def" predicate invariant_ref_UF_i32'0
  
  predicate inv_ref_UF_i32'0 [@inline:trivial] (_1: t_UF_i32) = invariant_ref_UF_i32'0 _1
  
  meta "rewrite_def" predicate inv_ref_UF_i32'0
  
  predicate invariant_Ghost_ref_UF_i32'0 [@inline:trivial] (self: t_UF_i32) = inv_ref_UF_i32'0 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_i32'0
  
  predicate inv_Ghost_ref_UF_i32'0 [@inline:trivial] (_1: t_UF_i32) = invariant_Ghost_ref_UF_i32'0 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_i32'0
  
  let rec borrow_UF_i32 (self: t_UF_i32) (return (x: t_UF_i32)) =
    {[@expl:borrow 'self' type invariant] inv_ref_Ghost_UF_i32'0 self}
    any [ return (result: t_UF_i32) -> {inv_Ghost_ref_UF_i32'0 result} {result = self} (! return {result}) ]
  
  function root_i32 (self: t_UF_i32) (e: t_Elem_i32) : t_Elem_i32 =
    index_Mapping_Elem_i32_Elem_i32 (roots_map_i32 self) e
  
  function index_Mapping_Elem_i32_i32 [@inline:trivial] (self: Map.map t_Elem_i32 Int32.t) (a: t_Elem_i32) : Int32.t =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_i32_i32
  
  function payload_i32 (self: t_UF_i32) (e: t_Elem_i32) : Int32.t = index_Mapping_Elem_i32_i32 (payloads_map_i32 self) e
  
  let rec get_i32 (uf: t_UF_i32) (elem: t_Elem_i32) (return (x: Int32.t)) =
    {[@expl:get 'uf' type invariant] inv_Ghost_ref_UF_i32'0 uf}
    {[@expl:get 'elem' type invariant] inv_Elem_i32 elem}
    {[@expl:get requires #0] in_domain_i32 uf elem}
    {[@expl:get requires #1] root_i32 uf elem = elem}
    any [ return (result: Int32.t) -> {result = payload_i32 uf elem} (! return {result}) ]
  
  predicate domain_unchanged_i32 (self: MutBorrow.t t_UF_i32) = domain_i32 self.current = domain_i32 self.final
  
  predicate payloads_unchanged_i32 (self: MutBorrow.t t_UF_i32) =
    payloads_map_i32 self.current = payloads_map_i32 self.final
  
  let rec union_i32 (uf: MutBorrow.t t_UF_i32) (x: t_Elem_i32) (y: t_Elem_i32) (return (x'0: t_Elem_i32)) =
    {[@expl:union 'uf' type invariant] inv_Ghost_ref_UF_i32 uf}
    {[@expl:union 'x' type invariant] inv_Elem_i32 x}
    {[@expl:union 'y' type invariant] inv_Elem_i32 y}
    {[@expl:union requires] in_domain_i32 uf.current x /\ in_domain_i32 uf.current y}
    any
    [ return (result: t_Elem_i32) -> {inv_Elem_i32 result}
      {domain_unchanged_i32 uf /\ payloads_unchanged_i32 uf}
      {result = root_i32 uf.current x \/ result = root_i32 uf.current y}
      {forall z: t_Elem_i32. in_domain_i32 uf.current z
        -> root_i32 (fin_Ghost_ref_UF_i32 uf) z
        = (if root_i32 uf.current z = root_i32 uf.current x \/ root_i32 uf.current z = root_i32 uf.current y then
          result
        else
          root_i32 uf.current z
        )}
      (! return {result}) ]
  
  predicate unchanged_i32 (self: MutBorrow.t t_UF_i32) =
    domain_i32 self.current = domain_i32 self.final
    /\ roots_map_i32 self.current = roots_map_i32 self.final
    /\ payloads_map_i32 self.current = payloads_map_i32 self.final
  
  let rec find_i32 (uf: MutBorrow.t t_UF_i32) (elem: t_Elem_i32) (return (x: t_Elem_i32)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_ref_UF_i32 uf}
    {[@expl:find 'elem' type invariant] inv_Elem_i32 elem}
    {[@expl:find requires] in_domain_i32 uf.current elem}
    any
    [ return (result: t_Elem_i32) -> {inv_Elem_i32 result}
      {result = root_i32 uf.current elem}
      {unchanged_i32 uf}
      (! return {result}) ]
  
  predicate resolve_UF_i32 (_1: t_UF_i32)
  
  predicate resolve_Ghost_UF_i32 [@inline:trivial] (_1: t_UF_i32) = resolve_UF_i32 _1
  
  meta "rewrite_def" predicate resolve_Ghost_UF_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new_i32 (fun (_ret: t_UF_i32) -> [ &uf <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Ghost_UF_i32 uf}
        MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_4 <- _ret ] -{inv_Ghost_UF_i32 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UF_i32 {_4} (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_3 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = make_i32 {_3} {(1: Int32.t)} (fun (_ret: t_Elem_i32) -> [ &x <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Ghost_UF_i32 uf}
        MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_7 <- _ret ] -{inv_Ghost_UF_i32 _ret.final}- [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UF_i32 {_7} (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_6 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = make_i32 {_6} {(2: Int32.t)} (fun (_ret: t_Elem_i32) -> [ &y <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {inv_Ghost_UF_i32 uf}
        MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_ret: MutBorrow.t t_UF_i32) ->
            [ &_10 <- _ret ] -{inv_Ghost_UF_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UF_i32 {_10} (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_9 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = make_i32 {_9} {(3: Int32.t)} (fun (_ret: t_Elem_i32) -> [ &z <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = borrow_UF_i32 {uf} (fun (_ret: t_UF_i32) -> [ &_15 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = get_i32 {_15} {x} (fun (_ret: Int32.t) -> [ &_14 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_12 <- _14 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0 [ s0 = borrow_UF_i32 {uf} (fun (_ret: t_UF_i32) -> [ &_23 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = get_i32 {_23} {y} (fun (_ret: Int32.t) -> [ &_22 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_20 <- _22 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_20 = false} (! bb15) | br1 -> {_20} (! bb14) ] ]
    | bb14 = s0 [ s0 = borrow_UF_i32 {uf} (fun (_ret: t_UF_i32) -> [ &_31 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = s0 [ s0 = get_i32 {_31} {z} (fun (_ret: Int32.t) -> [ &_30 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_28 <- _30 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_28 = false} (! bb19) | br1 -> {_28} (! bb18) ] ]
    | bb18 = s0
      [ s0 = {inv_Ghost_UF_i32 uf}
        MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_ret: MutBorrow.t t_UF_i32) ->
            [ &_37 <- _ret ] -{inv_Ghost_UF_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UF_i32 {_37} (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_36 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = union_i32 {_36} {x} {y} (fun (_ret: t_Elem_i32) -> [ &_35 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = s0
      [ s0 = {inv_Ghost_UF_i32 uf}
        MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_ret: MutBorrow.t t_UF_i32) ->
            [ &_42 <- _ret ] -{inv_Ghost_UF_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UF_i32 {_42} (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_41 <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = s0 [ s0 = find_i32 {_41} {x} (fun (_ret: t_Elem_i32) -> [ &xr <- _ret ] s1) | s1 = bb23 ]
    | bb23 = s0
      [ s0 = {inv_Ghost_UF_i32 uf}
        MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_ret: MutBorrow.t t_UF_i32) ->
            [ &_46 <- _ret ] -{inv_Ghost_UF_i32 _ret.final}-
            [ &uf <- _ret.final ] s1)
      | s1 = borrow_mut_UF_i32 {_46} (fun (_ret: MutBorrow.t t_UF_i32) -> [ &_45 <- _ret ] s2)
      | s2 = bb24 ]
    | bb24 = s0 [ s0 = find_i32 {_45} {y} (fun (_ret: t_Elem_i32) -> [ &yr <- _ret ] s1) | s1 = bb25 ]
    | bb25 = s0 [ s0 = borrow_UF_i32 {uf} (fun (_ret: t_UF_i32) -> [ &_52 <- _ret ] s1) | s1 = bb26 ]
    | bb26 = s0 [ s0 = get_i32 {_52} {xr} (fun (_ret: Int32.t) -> [ &_51 <- _ret ] s1) | s1 = bb27 ]
    | bb27 = s0 [ s0 = borrow_UF_i32 {uf} (fun (_ret: t_UF_i32) -> [ &_57 <- _ret ] s1) | s1 = bb28 ]
    | bb28 = s0 [ s0 = get_i32 {_57} {yr} (fun (_ret: Int32.t) -> [ &_56 <- _ret ] s1) | s1 = bb29 ]
    | bb29 = s0 [ s0 = [ &_49 <- _51 = _56 ] s1 | s1 = any [ br0 -> {_49 = false} (! bb31) | br1 -> {_49} (! bb30) ] ]
    | bb30 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UF_i32 uf} s1
      | s1 = -{resolve_Ghost_UF_i32 uf}- s2
      | s2 = borrow_UF_i32 {uf} (fun (_ret: t_UF_i32) -> [ &_65 <- _ret ] s3)
      | s3 = bb32 ]
    | bb32 = s0 [ s0 = get_i32 {_65} {z} (fun (_ret: Int32.t) -> [ &_64 <- _ret ] s1) | s1 = bb33 ]
    | bb33 = s0
      [ s0 = [ &_62 <- _64 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_62 = false} (! bb35) | br1 -> {_62} (! bb34) ] ]
    | bb34 = return {_0}
    | bb35 = {false} any
    | bb31 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UF_i32 uf} s1 | s1 = -{resolve_Ghost_UF_i32 uf}- s2 | s2 = {false} any ]
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UF_i32 uf} s1 | s1 = -{resolve_Ghost_UF_i32 uf}- s2 | s2 = {false} any ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UF_i32 uf} s1 | s1 = -{resolve_Ghost_UF_i32 uf}- s2 | s2 = {false} any ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_Ghost_UF_i32 uf} s1
      | s1 = -{resolve_Ghost_UF_i32 uf}- s2
      | s2 = {false} any ] ]
    [ & _0: () = Any.any_l ()
    | & uf: t_UF_i32 = Any.any_l ()
    | & x: t_Elem_i32 = Any.any_l ()
    | & _3: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _4: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & y: t_Elem_i32 = Any.any_l ()
    | & _6: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _7: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & z: t_Elem_i32 = Any.any_l ()
    | & _9: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _10: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _15: t_UF_i32 = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _23: t_UF_i32 = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _31: t_UF_i32 = Any.any_l ()
    | & _35: t_Elem_i32 = Any.any_l ()
    | & _36: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _37: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & xr: t_Elem_i32 = Any.any_l ()
    | & _41: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _42: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & yr: t_Elem_i32 = Any.any_l ()
    | & _45: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _46: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: Int32.t = Any.any_l ()
    | & _52: t_UF_i32 = Any.any_l ()
    | & _56: Int32.t = Any.any_l ()
    | & _57: t_UF_i32 = Any.any_l ()
    | & _62: bool = Any.any_l ()
    | & _64: Int32.t = Any.any_l ()
    | & _65: t_UF_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_implementation__impl_PartialEq_for_Elem_T__eq__refines (* <implementation::Elem<T> as std::cmp::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  
  type t_Elem_T = { f0: Opaque.ptr }
  
  function deep_model_Elem_T [@inline:trivial] (self: t_Elem_T) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Elem_T
  
  function deep_model_ref_Elem_T [@inline:trivial] (self: t_Elem_T) : UInt64.t = deep_model_Elem_T self
  
  meta "rewrite_def" function deep_model_ref_Elem_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Elem_T. forall rhs: t_Elem_T. forall result: bool. result
            = (deep_model_ref_Elem_T self_ = deep_model_ref_Elem_T rhs)
          -> result = (deep_model_ref_Elem_T self_ = deep_model_ref_Elem_T rhs)
end
