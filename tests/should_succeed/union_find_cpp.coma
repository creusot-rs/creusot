module M_implementation__impl_PartialEq_for_Elem__eq (* <implementation::Elem as std::cmp::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Elem = { f0: Opaque.ptr }
  
  let rec addr_eq_unit (p: Opaque.ptr) (q: Opaque.ptr) (return (x: bool)) = any
    [ return (result: bool) -> {result = (Ptr.addr_logic_u64 p = Ptr.addr_logic_u64 q)} (! return {result}) ]
  
  function deep_model_Elem [@inline:trivial] (self: t_Elem) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Elem
  
  function deep_model_ref_Elem [@inline:trivial] (self: t_Elem) : UInt64.t = deep_model_Elem self
  
  meta "rewrite_def" function deep_model_ref_Elem
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_Elem (self: t_Elem) (other: t_Elem) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = addr_eq_unit {self.f0} {other.f0} (fun (_x: bool) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self: t_Elem = self | & other: t_Elem = other ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model_ref_Elem self = deep_model_ref_Elem other)}
      (! return {result}) ]
end
module M_implementation__impl_Clone_for_Elem__clone (* <implementation::Elem as std::clone::Clone> *)
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  type t_Elem = { f0: Opaque.ptr }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Elem (self: t_Elem) (return (x: t_Elem)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { f0 = self.f0 } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Elem = Any.any_l () | & self: t_Elem = self ])
    [ return (result: t_Elem) -> {[@expl:clone ensures] self = result} (! return {result}) ]
end
module M_implementation__impl_UF_T__roots_map (* implementation::UF<T> *)
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  
  type t_Elem = { f0: Opaque.ptr }
  
  type t_FMap_Elem_Perm_ptr_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem;
    perms: t_FMap_Elem_Perm_ptr_Node_T;
    payloads: Map.map t_Elem t_T;
    roots: Map.map t_Elem t_Elem }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem
  
  type t_Perm_ptr_Node_T
  
  type t_Option_Perm_ptr_Node_T = None | Some t_Perm_ptr_Node_T
  
  function view_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T) : Map.map t_Elem t_Option_Perm_ptr_Node_T
  
  function get_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Option_Perm_ptr_Node_T =
    Map.get (view_FMap_Elem_Perm_ptr_Node_T self) k
  
  meta "rewrite_def" function get_Elem
  
  predicate contains_Elem'0 [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) = get_Elem self k <> None
  
  meta "rewrite_def" predicate contains_Elem'0
  
  function tied_ptr_Node_T (self: t_Perm_ptr_Node_T) : Opaque.ptr
  
  predicate index_Mapping_Perm_ptr_Node_T_bool [@inline:trivial] (self: Map.map t_Perm_ptr_Node_T bool) (a: t_Perm_ptr_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Perm_ptr_Node_T_bool
  
  function such_that_Perm_ptr_Node_T (p: Map.map t_Perm_ptr_Node_T bool) : t_Perm_ptr_Node_T
  
  axiom such_that_Perm_ptr_Node_T_spec:
    forall p: Map.map t_Perm_ptr_Node_T bool. (exists x: t_Perm_ptr_Node_T. index_Mapping_Perm_ptr_Node_T_bool p x)
      -> index_Mapping_Perm_ptr_Node_T_bool p (such_that_Perm_ptr_Node_T p)
  
  function unwrap_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) : t_Perm_ptr_Node_T = match self with
      | Some x -> x
      | None -> such_that_Perm_ptr_Node_T (fun (__0: t_Perm_ptr_Node_T) -> true)
      end
  
  function lookup_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Perm_ptr_Node_T =
    unwrap_Option_Perm_ptr_Node_T (get_Elem self k)
  
  meta "rewrite_def" function lookup_Elem
  
  function index_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) : t_Perm_ptr_Node_T
   = lookup_Elem self key
  
  meta "rewrite_def" function index_FMap_Elem_Perm_ptr_Node_T
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem
  
  function val_ptr_Node_T (self: t_Perm_ptr_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem. contains_Elem self.f0'0.domain e
      -> contains_Elem'0 self.f0'0.perms e
      /\ tied_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem self.f0'0.domain (index_Mapping_Elem_Elem self.f0'0.roots e)
      /\ index_Mapping_Elem_Elem self.f0'0.roots (index_Mapping_Elem_Elem self.f0'0.roots e)
        = index_Mapping_Elem_Elem self.f0'0.roots e
      /\ match val_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem self.f0'0.domain e2
        /\ index_Mapping_Elem_Elem self.f0'0.roots e <> e
        /\ index_Mapping_Elem_Elem self.f0'0.roots e = index_Mapping_Elem_Elem self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_Elem self.f0'0.roots e = e
        /\ index_Mapping_Elem_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem [@inline:trivial] (_1: t_Elem) = true
  
  meta "rewrite_def" predicate inv_Elem
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_Perm_ptr_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) =
    not is_null_ptr_Node_T (tied_ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_ptr_Node_T self) (metadata_Node_T (tied_ptr_Node_T self))
    /\ size_of_val_Node_T (val_ptr_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (tied_ptr_Node_T self)) + size_of_val_Node_T (val_ptr_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_ptr_Node_T self)
  
  predicate inv_Perm_ptr_Node_T (_1: t_Perm_ptr_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Perm_ptr_Node_T [inv_Perm_ptr_Node_T x]. inv_Perm_ptr_Node_T x
      = invariant_Perm_ptr_Node_T x
  
  predicate invariant_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. contains_Elem'0 self k
      -> inv_Elem k /\ inv_Perm_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_FMap_Elem_Perm_ptr_Node_T (_1: t_FMap_Elem_Perm_ptr_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_Perm_ptr_Node_T [inv_FMap_Elem_Perm_ptr_Node_T x]. inv_FMap_Elem_Perm_ptr_Node_T x
      = invariant_FMap_Elem_Perm_ptr_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_Perm_ptr_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem) = contains_Elem (domain_T self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_UF_T
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem t_Elem
  
  goal vc_roots_map_T: inv_UF_T self
    -> (let result = self.f0'0.roots in [@expl:roots_map ensures] forall e: t_Elem. in_domain_T self e
      -> in_domain_T self (index_Mapping_Elem_Elem result e)
      /\ index_Mapping_Elem_Elem result e = index_Mapping_Elem_Elem result (index_Mapping_Elem_Elem result e))
end
module M_implementation__new
  use creusot.prelude.Opaque
  use map.Map
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.int.Int64
  use map.Const
  use set.Fset
  use creusot.prelude.Any
  
  type t_FMap_Elem_Perm_ptr_Node_T
  
  type t_Elem = { f0: Opaque.ptr }
  
  type t_Perm_ptr_Node_T
  
  type t_Option_Perm_ptr_Node_T = None | Some t_Perm_ptr_Node_T
  
  function view_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T) : Map.map t_Elem t_Option_Perm_ptr_Node_T
  
  function get_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Option_Perm_ptr_Node_T =
    Map.get (view_FMap_Elem_Perm_ptr_Node_T self) k
  
  meta "rewrite_def" function get_Elem
  
  predicate contains_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) = get_Elem self k <> None
  
  meta "rewrite_def" predicate contains_Elem
  
  predicate inv_Elem [@inline:trivial] (_1: t_Elem) = true
  
  meta "rewrite_def" predicate inv_Elem
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function tied_ptr_Node_T (self: t_Perm_ptr_Node_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_Perm_ptr_Node_T)
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_T
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function val_ptr_Node_T (self: t_Perm_ptr_Node_T) : t_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'1 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) =
    not is_null_ptr_Node_T (tied_ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_ptr_Node_T self) (metadata_Node_T (tied_ptr_Node_T self))
    /\ size_of_val_Node_T (val_ptr_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (tied_ptr_Node_T self)) + size_of_val_Node_T (val_ptr_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_ptr_Node_T self)
  
  predicate inv_Perm_ptr_Node_T (_1: t_Perm_ptr_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Perm_ptr_Node_T [inv_Perm_ptr_Node_T x]. inv_Perm_ptr_Node_T x
      = invariant_Perm_ptr_Node_T x
  
  predicate index_Mapping_Perm_ptr_Node_T_bool [@inline:trivial] (self: Map.map t_Perm_ptr_Node_T bool) (a: t_Perm_ptr_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Perm_ptr_Node_T_bool
  
  function such_that_Perm_ptr_Node_T (p: Map.map t_Perm_ptr_Node_T bool) : t_Perm_ptr_Node_T
  
  axiom such_that_Perm_ptr_Node_T_spec:
    forall p: Map.map t_Perm_ptr_Node_T bool. (exists x: t_Perm_ptr_Node_T. index_Mapping_Perm_ptr_Node_T_bool p x)
      -> index_Mapping_Perm_ptr_Node_T_bool p (such_that_Perm_ptr_Node_T p)
  
  function unwrap_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) : t_Perm_ptr_Node_T = match self with
      | Some x -> x
      | None -> such_that_Perm_ptr_Node_T (fun (__0: t_Perm_ptr_Node_T) -> true)
      end
  
  function lookup_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Perm_ptr_Node_T =
    unwrap_Option_Perm_ptr_Node_T (get_Elem self k)
  
  meta "rewrite_def" function lookup_Elem
  
  function index_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) : t_Perm_ptr_Node_T
   = lookup_Elem self key
  
  meta "rewrite_def" function index_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. contains_Elem self k -> inv_Elem k /\ inv_Perm_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_FMap_Elem_Perm_ptr_Node_T (_1: t_FMap_Elem_Perm_ptr_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_Perm_ptr_Node_T [inv_FMap_Elem_Perm_ptr_Node_T x]. inv_FMap_Elem_Perm_ptr_Node_T x
      = invariant_FMap_Elem_Perm_ptr_Node_T x
  
  predicate invariant_Ghost_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_Ghost_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_Ghost_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_FMap_Elem_Perm_ptr_Node_T
  
  predicate ext_eq_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (other: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. get_Elem self k = get_Elem other k
  
  axiom ext_eq_Elem_spec:
    forall self: t_FMap_Elem_Perm_ptr_Node_T, other: t_FMap_Elem_Perm_ptr_Node_T. ext_eq_Elem self other
      = (self = other)
  
  function len_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) : int
  
  axiom len_Elem_spec: forall self: t_FMap_Elem_Perm_ptr_Node_T. len_Elem self >= 0
  
  constant empty_Elem : t_FMap_Elem_Perm_ptr_Node_T
  
  axiom empty_Elem_spec: len_Elem empty_Elem = 0
  
  axiom empty_Elem_spec'0: view_FMap_Elem_Perm_ptr_Node_T empty_Elem = Const.const (None)
  
  predicate is_empty_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) = ext_eq_Elem self empty_Elem
  
  let rec new_Elem (return (x: t_FMap_Elem_Perm_ptr_Node_T)) = any
    [ return (result: t_FMap_Elem_Perm_ptr_Node_T) -> {inv_Ghost_FMap_Elem_Perm_ptr_Node_T result}
      {is_empty_Elem result}
      (! return {result}) ]
  
  let rec into_inner_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T)
    (return (x: t_FMap_Elem_Perm_ptr_Node_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: t_FMap_Elem_Perm_ptr_Node_T) -> {inv_FMap_Elem_Perm_ptr_Node_T result}
      {result = self}
      (! return {result}) ]
  
  predicate index_Mapping_Mapping_Elem_T_bool [@inline:trivial] (self: Map.map (Map.map t_Elem t_T) bool) (a: Map.map t_Elem t_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Mapping_Elem_T_bool
  
  function such_that_Mapping_Elem_T (p: Map.map (Map.map t_Elem t_T) bool) : Map.map t_Elem t_T
  
  axiom such_that_Mapping_Elem_T_spec:
    forall p: Map.map (Map.map t_Elem t_T) bool. (exists x: Map.map t_Elem t_T. index_Mapping_Mapping_Elem_T_bool p x)
      -> index_Mapping_Mapping_Elem_T_bool p (such_that_Mapping_Elem_T p)
  
  predicate index_Mapping_Mapping_Elem_Elem_bool [@inline:trivial] (self: Map.map (Map.map t_Elem t_Elem) bool) (a: Map.map t_Elem t_Elem) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Mapping_Elem_Elem_bool
  
  function such_that_Mapping_Elem_Elem (p: Map.map (Map.map t_Elem t_Elem) bool) : Map.map t_Elem t_Elem
  
  axiom such_that_Mapping_Elem_Elem_spec:
    forall p: Map.map (Map.map t_Elem t_Elem) bool. (exists x: Map.map t_Elem t_Elem. index_Mapping_Mapping_Elem_Elem_bool p x)
      -> index_Mapping_Mapping_Elem_Elem_bool p (such_that_Mapping_Elem_Elem p)
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem;
    perms: t_FMap_Elem_Perm_ptr_Node_T;
    payloads: Map.map t_Elem t_T;
    roots: Map.map t_Elem t_Elem }
  
  type t_UF_T = { f0'1: t_UFInner_T }
  
  predicate contains_Elem'0 [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem'0
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  function index_Mapping_Elem_T [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem. contains_Elem'0 self.f0'1.domain e
      -> contains_Elem self.f0'1.perms e
      /\ tied_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'1.perms e) = e.f0
      /\ contains_Elem'0 self.f0'1.domain (index_Mapping_Elem_Elem self.f0'1.roots e)
      /\ index_Mapping_Elem_Elem self.f0'1.roots (index_Mapping_Elem_Elem self.f0'1.roots e)
        = index_Mapping_Elem_Elem self.f0'1.roots e
      /\ match val_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'1.perms e) with
        | Link e2 -> contains_Elem'0 self.f0'1.domain e2
        /\ index_Mapping_Elem_Elem self.f0'1.roots e <> e
        /\ index_Mapping_Elem_Elem self.f0'1.roots e = index_Mapping_Elem_Elem self.f0'1.roots e2
        | Root _ payload -> index_Mapping_Elem_Elem self.f0'1.roots e = e
        /\ index_Mapping_Elem_T self.f0'1.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_Perm_ptr_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'1)
  
  predicate invariant_Ghost_UF_T [@inline:trivial] (self: t_UF_T) = inv_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_UF_T
  
  predicate inv_Ghost_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_Ghost_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_UF_T
  
  let rec new_UF_T (x: t_UF_T) (return (x'0: t_UF_T)) = {[@expl:new 'x' type invariant] inv_UF_T x}
    any [ return (result: t_UF_T) -> {inv_Ghost_UF_T result} {result = x} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem = self.f0'1.domain
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_T (return (x: t_UF_T)) = (! bb0
    [ bb0 = s0
      [ s0 = new_Elem (fun (_x: t_FMap_Elem_Perm_ptr_Node_T) -> [ &_7 <- _x ] s1)
      | s1 = into_inner_FMap_Elem_Perm_ptr_Node_T {_7} (fun (_x: t_FMap_Elem_Perm_ptr_Node_T) -> [ &_6 <- _x ] s2)
      | s2 = [ &_3 <- { domain = Fset.empty: Fset.fset t_Elem;
                        perms = _6;
                        payloads = such_that_Mapping_Elem_T (fun (__0: Map.map t_Elem t_T) -> true);
                        roots = such_that_Mapping_Elem_Elem (fun (__0: Map.map t_Elem t_Elem) -> true) } ] s3
      | s3 = [ &_2 <- { f0'1 = _3 } ] s4
      | s4 = new_UF_T {_2} (fun (_x: t_UF_T) -> [ &_ret <- _x ] s5)
      | s5 = return {_ret} ] ]
    [ & _ret: t_UF_T = Any.any_l ()
    | & _2: t_UF_T = Any.any_l ()
    | & _3: t_UFInner_T = Any.any_l ()
    | & _6: t_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _7: t_FMap_Elem_Perm_ptr_Node_T = Any.any_l () ])
    [ return (result: t_UF_T) -> {[@expl:new result type invariant] inv_Ghost_UF_T result}
      {[@expl:new ensures] Fset.is_empty (domain_T result)}
      (! return {result}) ]
end
module M_implementation__make
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.MutBorrow
  use set.Fset
  use map.Map
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec new (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {result.f0 = (0: UInt64.t)} (! return {result}) ]
  
  type t_T
  
  type t_Elem = { f0'0: Opaque.ptr }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem
  
  type t_Perm_ptr_Node_T
  
  type tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T = { f0'1: Opaque.ptr; f1'1: t_Perm_ptr_Node_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function tied_ptr_Node_T (self: t_Perm_ptr_Node_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_Perm_ptr_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function val_ptr_Node_T (self: t_Perm_ptr_Node_T) : t_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) =
    not is_null_ptr_Node_T (tied_ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_ptr_Node_T self) (metadata_Node_T (tied_ptr_Node_T self))
    /\ size_of_val_Node_T (val_ptr_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (tied_ptr_Node_T self)) + size_of_val_Node_T (val_ptr_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_ptr_Node_T self)
  
  predicate inv_Perm_ptr_Node_T (_1: t_Perm_ptr_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Perm_ptr_Node_T [inv_Perm_ptr_Node_T x]. inv_Perm_ptr_Node_T x
      = invariant_Perm_ptr_Node_T x
  
  predicate invariant_Ghost_Perm_ptr_Node_T [@inline:trivial] (self: t_Perm_ptr_Node_T) = inv_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_Perm_ptr_Node_T
  
  predicate inv_Ghost_Perm_ptr_Node_T [@inline:trivial] (_1: t_Perm_ptr_Node_T) = invariant_Ghost_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_Perm_ptr_Node_T
  
  predicate inv_tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T [@inline:trivial] (_1: tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T) =
    inv_Ghost_Perm_ptr_Node_T _1.f1'1
  
  meta "rewrite_def" predicate inv_tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T
  
  let rec new_Node_T (v: t_Node_T) (return (x: tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T)) =
    {[@expl:new 'v' type invariant] inv_Node_T v}
    any
    [ return (result: tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T) -> {inv_tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T result}
      {tied_ptr_Node_T result.f1'1 = result.f0'1 /\ val_ptr_Node_T result.f1'1 = v}
      (! return {result}) ]
  
  let rec into_inner_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) (return (x: t_Perm_ptr_Node_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_Perm_ptr_Node_T self}
    any [ return (result: t_Perm_ptr_Node_T) -> {inv_Perm_ptr_Node_T result} {result = self} (! return {result}) ]
  
  type t_FMap_Elem_Perm_ptr_Node_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem;
    perms: t_FMap_Elem_Perm_ptr_Node_T;
    payloads: Map.map t_Elem t_T;
    roots: Map.map t_Elem t_Elem }
  
  type t_UF_T = { f0'2: t_UFInner_T }
  
  predicate contains_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem
  
  type t_Option_Perm_ptr_Node_T = None | Some t_Perm_ptr_Node_T
  
  function view_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T) : Map.map t_Elem t_Option_Perm_ptr_Node_T
  
  function get_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Option_Perm_ptr_Node_T =
    Map.get (view_FMap_Elem_Perm_ptr_Node_T self) k
  
  meta "rewrite_def" function get_Elem
  
  predicate contains_Elem'0 [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) = get_Elem self k <> None
  
  meta "rewrite_def" predicate contains_Elem'0
  
  predicate index_Mapping_Perm_ptr_Node_T_bool [@inline:trivial] (self: Map.map t_Perm_ptr_Node_T bool) (a: t_Perm_ptr_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Perm_ptr_Node_T_bool
  
  function such_that_Perm_ptr_Node_T (p: Map.map t_Perm_ptr_Node_T bool) : t_Perm_ptr_Node_T
  
  axiom such_that_Perm_ptr_Node_T_spec:
    forall p: Map.map t_Perm_ptr_Node_T bool. (exists x: t_Perm_ptr_Node_T. index_Mapping_Perm_ptr_Node_T_bool p x)
      -> index_Mapping_Perm_ptr_Node_T_bool p (such_that_Perm_ptr_Node_T p)
  
  function unwrap_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) : t_Perm_ptr_Node_T = match self with
      | Some x -> x
      | None -> such_that_Perm_ptr_Node_T (fun (__0: t_Perm_ptr_Node_T) -> true)
      end
  
  function lookup_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Perm_ptr_Node_T =
    unwrap_Option_Perm_ptr_Node_T (get_Elem self k)
  
  meta "rewrite_def" function lookup_Elem
  
  function index_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) : t_Perm_ptr_Node_T
   = lookup_Elem self key
  
  meta "rewrite_def" function index_FMap_Elem_Perm_ptr_Node_T
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  function index_Mapping_Elem_T [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem. contains_Elem self.f0'2.domain e
      -> contains_Elem'0 self.f0'2.perms e
      /\ tied_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'2.perms e) = e.f0'0
      /\ contains_Elem self.f0'2.domain (index_Mapping_Elem_Elem self.f0'2.roots e)
      /\ index_Mapping_Elem_Elem self.f0'2.roots (index_Mapping_Elem_Elem self.f0'2.roots e)
        = index_Mapping_Elem_Elem self.f0'2.roots e
      /\ match val_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'2.perms e) with
        | Link e2 -> contains_Elem self.f0'2.domain e2
        /\ index_Mapping_Elem_Elem self.f0'2.roots e <> e
        /\ index_Mapping_Elem_Elem self.f0'2.roots e = index_Mapping_Elem_Elem self.f0'2.roots e2
        | Root _ payload -> index_Mapping_Elem_Elem self.f0'2.roots e = e
        /\ index_Mapping_Elem_T self.f0'2.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem [@inline:trivial] (_1: t_Elem) = true
  
  meta "rewrite_def" predicate inv_Elem
  
  predicate invariant_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. contains_Elem'0 self k
      -> inv_Elem k /\ inv_Perm_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_FMap_Elem_Perm_ptr_Node_T (_1: t_FMap_Elem_Perm_ptr_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_Perm_ptr_Node_T [inv_FMap_Elem_Perm_ptr_Node_T x]. inv_FMap_Elem_Perm_ptr_Node_T x
      = invariant_FMap_Elem_Perm_ptr_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_Perm_ptr_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'2)
  
  predicate invariant_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_UF_T
  
  predicate inv_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_UF_T
  
  predicate invariant_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_refmut_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_UF_T
  
  predicate inv_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_UF_T
  
  let rec into_inner_refmut_UF_T (self: MutBorrow.t t_UF_T) (return (x: MutBorrow.t t_UF_T)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_refmut_UF_T self}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_refmut_UF_T result} {result = self} (! return {result}) ]
  
  type tup2_Perm_ptr_Node_T_refmut_UF_T = { f0'3: t_Perm_ptr_Node_T; f1'3: MutBorrow.t t_UF_T }
  
  type t_Option_ref_Perm_ptr_Node_T = None'0 | Some'0 t_Perm_ptr_Node_T
  
  predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_ref_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_ref_Perm_ptr_Node_T [@inline:trivial] (self: t_Perm_ptr_Node_T) = inv_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Perm_ptr_Node_T
  
  predicate inv_ref_Perm_ptr_Node_T [@inline:trivial] (_1: t_Perm_ptr_Node_T) = invariant_ref_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Perm_ptr_Node_T
  
  predicate inv_Option_ref_Perm_ptr_Node_T (_1: t_Option_ref_Perm_ptr_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_Perm_ptr_Node_T [inv_Option_ref_Perm_ptr_Node_T x]. inv_Option_ref_Perm_ptr_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'4 -> inv_ref_Perm_ptr_Node_T f0'4
        end
  
  function map_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) (f: Map.map t_Perm_ptr_Node_T t_Perm_ptr_Node_T) : t_Option_ref_Perm_ptr_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) (return (x: t_Option_ref_Perm_ptr_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: t_Option_ref_Perm_ptr_Node_T) -> {inv_Option_ref_Perm_ptr_Node_T result}
      {result = map_Option_Perm_ptr_Node_T (get_Elem self key) (fun (v: t_Perm_ptr_Node_T) -> v)}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_ref_Perm_ptr_Node_T) (return (f0'4: t_Perm_ptr_Node_T)) = any
    [ _k (f0'4: t_Perm_ptr_Node_T) -> {Some'0 f0'4 = _x} (! return {f0'4})
    | _chk -> (! {match _x with
        | Some'0 _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_refmut_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_Node_T) =
    inv_Perm_ptr_Node_T self.current /\ inv_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Perm_ptr_Node_T
  
  predicate inv_refmut_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_Node_T) =
    invariant_refmut_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_Perm_ptr_Node_T
  
  predicate is_disjoint_ptr_Node_T [@inline:trivial] (self: Opaque.ptr) (self_val: t_Node_T) (other: Opaque.ptr) (other_val: t_Node_T) =
    size_of_val_Node_T self_val <> 0 /\ size_of_val_Node_T other_val <> 0
    -> Ptr.addr_logic_u64 self <> Ptr.addr_logic_u64 other
  
  meta "rewrite_def" predicate is_disjoint_ptr_Node_T
  
  let rec disjoint_lemma_ptr_Node_T (self: MutBorrow.t t_Perm_ptr_Node_T) (other: t_Perm_ptr_Node_T) (return (x: ())) =
    {[@expl:disjoint_lemma 'self' type invariant] inv_refmut_Perm_ptr_Node_T self}
    {[@expl:disjoint_lemma 'other' type invariant] inv_ref_Perm_ptr_Node_T other}
    any
    [ return (result: ()) ->
    {is_disjoint_ptr_Node_T (tied_ptr_Node_T self.current) (val_ptr_Node_T self.current) (tied_ptr_Node_T other) (val_ptr_Node_T other)}
      {self.current = self.final}
      (! return {result}) ]
  
  predicate resolve_refmut_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Perm_ptr_Node_T
  
  predicate invariant_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self.current /\ inv_FMap_Elem_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_Option_Perm_ptr_Node_T (_1: t_Option_Perm_ptr_Node_T)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_Perm_ptr_Node_T [inv_Option_Perm_ptr_Node_T x]. inv_Option_Perm_ptr_Node_T x
      = match x with
        | None -> true
        | Some f0'4 -> inv_Perm_ptr_Node_T f0'4
        end
  
  function len_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) : int
  
  axiom len_Elem_spec: forall self: t_FMap_Elem_Perm_ptr_Node_T. len_Elem self >= 0
  
  function insert_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) (v: t_Perm_ptr_Node_T) : t_FMap_Elem_Perm_ptr_Node_T
  
  axiom insert_Elem_spec:
    forall self: t_FMap_Elem_Perm_ptr_Node_T, k: t_Elem, v: t_Perm_ptr_Node_T. view_FMap_Elem_Perm_ptr_Node_T (insert_Elem self k v)
      = Map.set (view_FMap_Elem_Perm_ptr_Node_T self) k (Some v)
  
  axiom insert_Elem_spec'0:
    forall self: t_FMap_Elem_Perm_ptr_Node_T, k: t_Elem, v: t_Perm_ptr_Node_T. len_Elem (insert_Elem self k v)
      = (if contains_Elem'0 self k then len_Elem self else len_Elem self + 1)
  
  let rec insert_ghost_Elem (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) (value: t_Perm_ptr_Node_T)
    (return (x: t_Option_Perm_ptr_Node_T)) =
    {[@expl:insert_ghost 'self' type invariant] inv_refmut_FMap_Elem_Perm_ptr_Node_T self}
    {[@expl:insert_ghost 'value' type invariant] inv_Perm_ptr_Node_T value}
    any
    [ return (result: t_Option_Perm_ptr_Node_T) -> {inv_Option_Perm_ptr_Node_T result}
      {self.final = insert_Elem self.current key value}
      {result = get_Elem self.current key}
      (! return {result}) ]
  
  function insert_Elem'0 [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) : Fset.fset t_Elem = Fset.add e self
  
  meta "rewrite_def" function insert_Elem'0
  
  predicate resolve_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_UF_T
  
  let rec new_unit (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem = self.f0'2.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem) = contains_Elem (domain_T self) e
  
  function fin_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) : t_UF_T = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_UF_T
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem t_Elem = self.f0'2.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_Elem (roots_map_T self) e)
        /\ index_Mapping_Elem_Elem (roots_map_T self) e
        = index_Mapping_Elem_Elem (roots_map_T self) (index_Mapping_Elem_Elem (roots_map_T self) e))
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem t_T = self.f0'2.payloads
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec make_T (uf: MutBorrow.t t_UF_T) (payload: t_T) (return (x: t_Elem)) =
    {[@expl:make 'uf' type invariant] inv_Ghost_refmut_UF_T uf}
    {[@expl:make 'payload' type invariant] inv_T payload}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &payload_snap <- payload ] s1
      | s1 = new (fun (_x: t_PeanoInt) -> [ &_19 <- _x ] s2)
      | s2 = [ &_18 <- Root _19 payload ] s3
      | s3 = new_Node_T {_18} (fun (_x: tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T) -> [ &_17 <- _x ] s4)
      | s4 = [ &ptr <- _17.f0'1 ] s5
      | s5 = [ &perm <- _17.f1'1 ] s6
      | s6 = [ &_22 <- ptr ] s7
      | s7 = [ &elt <- { f0'0 = _22 } ] s8
      | s8 = into_inner_Perm_ptr_Node_T {perm} (fun (_x: t_Perm_ptr_Node_T) -> [ &_29 <- _x ] s9)
      | s9 = into_inner_refmut_UF_T {uf} (fun (_x: MutBorrow.t t_UF_T) -> [ &_31 <- _x ] s10)
      | s10 = [ &_28 <- { f0'3 = _29; f1'3 = _31 } ] s11
      | s11 = [ &perm'0 <- _28.f0'3 ] s12
      | s12 = [ &uf'0 <- _28.f1'3 ] s13
      | s13 = [ &_37 <- elt ] s14
      | s14 = get_ghost_Elem {uf'0.current.f0'2.perms} {_37}
          (fun (_x: t_Option_ref_Perm_ptr_Node_T) -> [ &_34 <- _x ] s15)
      | s15 = any [ br0 -> {_34 = None'0} (! bb13) | br1 (x0: t_Perm_ptr_Node_T) -> {_34 = Some'0 x0} (! bb10) ] ]
    | bb10 = s0
      [ s0 = elim_Some {_34} (fun (r0: t_Perm_ptr_Node_T) -> [ &other_perm <- r0 ] s1)
      | s1 = MutBorrow.borrow_mut <t_Perm_ptr_Node_T> {perm'0}
          (fun (_bor: MutBorrow.t t_Perm_ptr_Node_T) ->
            [ &_41 <- _bor ] -{inv_Perm_ptr_Node_T _bor.final}-
            [ &perm'0 <- _bor.final ] s2) [ _ck -> (! {inv_Perm_ptr_Node_T perm'0} any) ]
      | s2 = MutBorrow.borrow_final <t_Perm_ptr_Node_T> {_41.current} {MutBorrow.get_id _41}
          (fun (_bor: MutBorrow.t t_Perm_ptr_Node_T) ->
            [ &_40 <- _bor ] -{inv_Perm_ptr_Node_T _bor.final}-
            [ &_41 <- { _41 with current = _bor.final } ] s3) [ _ck -> (! {inv_Perm_ptr_Node_T _41.current} any) ]
      | s3 = disjoint_lemma_ptr_Node_T {_40} {other_perm} (fun (_x: ()) -> [ &_33 <- _x ] s4)
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_Perm_ptr_Node_T _41} any) ]
      | s5 = -{resolve_refmut_Perm_ptr_Node_T _41}- s6
      | s6 = bb13 ]
    | bb13 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap_Elem_Perm_ptr_Node_T> {uf'0.current.f0'2.perms}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id uf'0) 1) 2}
          (fun (_bor: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) ->
            [ &_44 <- _bor ] -{inv_FMap_Elem_Perm_ptr_Node_T _bor.final}-
            [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with perms = _bor.final } } } ] s1)
        [ _ck -> (! {inv_FMap_Elem_Perm_ptr_Node_T uf'0.current.f0'2.perms} any) ]
      | s1 = insert_ghost_Elem {_44} {elt} {perm'0} (fun (_x: t_Option_Perm_ptr_Node_T) -> [ &_43 <- _x ] s2)
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_Option_Perm_ptr_Node_T _43} any) ]
      | s3 =
        [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with domain = insert_Elem'0 uf'0.current.f0'2.domain elt } } } ]
        s4
      | s4 =
        [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with payloads = Map.set uf'0.current.f0'2.payloads elt payload_snap } } } ]
        s5
      | s5 =
        [ &uf'0 <- { uf'0 with current = { f0'2 = { uf'0.current.f0'2 with roots = Map.set uf'0.current.f0'2.roots elt elt } } } ]
        s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_UF_T uf'0} any) ]
      | s7 = -{resolve_refmut_UF_T uf'0}- s8
      | s8 = new_unit {_25} (fun (_x: ()) -> [ &_24 <- _x ] s9)
      | s9 = [ &_ret <- elt ] s10
      | s10 = return {_ret} ] ]
    [ & _ret: t_Elem = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & payload: t_T = payload
    | & payload_snap: t_T = Any.any_l ()
    | & ptr: Opaque.ptr = Any.any_l ()
    | & perm: t_Perm_ptr_Node_T = Any.any_l ()
    | & _17: tup2_ptr_Node_T_Ghost_Perm_ptr_Node_T = Any.any_l ()
    | & _18: t_Node_T = Any.any_l ()
    | & _19: t_PeanoInt = Any.any_l ()
    | & elt: t_Elem = Any.any_l ()
    | & _22: Opaque.ptr = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: () = Any.any_l ()
    | & perm'0: t_Perm_ptr_Node_T = Any.any_l ()
    | & uf'0: MutBorrow.t t_UF_T = Any.any_l ()
    | & _28: tup2_Perm_ptr_Node_T_refmut_UF_T = Any.any_l ()
    | & _29: t_Perm_ptr_Node_T = Any.any_l ()
    | & _31: MutBorrow.t t_UF_T = Any.any_l ()
    | & _33: () = Any.any_l ()
    | & _34: t_Option_ref_Perm_ptr_Node_T = Any.any_l ()
    | & _37: t_Elem = Any.any_l ()
    | & other_perm: t_Perm_ptr_Node_T = Any.any_l ()
    | & _40: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _41: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _43: t_Option_Perm_ptr_Node_T = Any.any_l ()
    | & _44: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T = Any.any_l () ])
    [ return (result: t_Elem) -> {[@expl:make ensures #0] not in_domain_T uf.current result}
      {[@expl:make ensures #1] domain_T (fin_Ghost_refmut_UF_T uf) = insert_Elem'0 (domain_T uf.current) result}
      {[@expl:make ensures #2] roots_map_T (fin_Ghost_refmut_UF_T uf) = Map.set (roots_map_T uf.current) result result}
      {[@expl:make ensures #3] payloads_map_T (fin_Ghost_refmut_UF_T uf)
      = Map.set (payloads_map_T uf.current) result payload}
      (! return {result}) ]
end
module M_implementation__find
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Elem = { f0: Opaque.ptr }
  
  type t_FMap_Elem_Perm_ptr_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem;
    perms: t_FMap_Elem_Perm_ptr_Node_T;
    payloads: Map.map t_Elem t_T;
    roots: Map.map t_Elem t_Elem }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem
  
  type t_Perm_ptr_Node_T
  
  type t_Option_Perm_ptr_Node_T = None | Some t_Perm_ptr_Node_T
  
  function view_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T) : Map.map t_Elem t_Option_Perm_ptr_Node_T
  
  function get_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Option_Perm_ptr_Node_T =
    Map.get (view_FMap_Elem_Perm_ptr_Node_T self) k
  
  meta "rewrite_def" function get_Elem
  
  predicate contains_Elem'0 [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) = get_Elem self k <> None
  
  meta "rewrite_def" predicate contains_Elem'0
  
  function tied_ptr_Node_T (self: t_Perm_ptr_Node_T) : Opaque.ptr
  
  predicate index_Mapping_Perm_ptr_Node_T_bool [@inline:trivial] (self: Map.map t_Perm_ptr_Node_T bool) (a: t_Perm_ptr_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Perm_ptr_Node_T_bool
  
  function such_that_Perm_ptr_Node_T (p: Map.map t_Perm_ptr_Node_T bool) : t_Perm_ptr_Node_T
  
  axiom such_that_Perm_ptr_Node_T_spec:
    forall p: Map.map t_Perm_ptr_Node_T bool. (exists x: t_Perm_ptr_Node_T. index_Mapping_Perm_ptr_Node_T_bool p x)
      -> index_Mapping_Perm_ptr_Node_T_bool p (such_that_Perm_ptr_Node_T p)
  
  function unwrap_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) : t_Perm_ptr_Node_T = match self with
      | Some x -> x
      | None -> such_that_Perm_ptr_Node_T (fun (__0: t_Perm_ptr_Node_T) -> true)
      end
  
  function lookup_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Perm_ptr_Node_T =
    unwrap_Option_Perm_ptr_Node_T (get_Elem self k)
  
  meta "rewrite_def" function lookup_Elem
  
  function index_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) : t_Perm_ptr_Node_T
   = lookup_Elem self key
  
  meta "rewrite_def" function index_FMap_Elem_Perm_ptr_Node_T
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem
  
  function val_ptr_Node_T (self: t_Perm_ptr_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem. contains_Elem self.f0'0.domain e
      -> contains_Elem'0 self.f0'0.perms e
      /\ tied_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem self.f0'0.domain (index_Mapping_Elem_Elem self.f0'0.roots e)
      /\ index_Mapping_Elem_Elem self.f0'0.roots (index_Mapping_Elem_Elem self.f0'0.roots e)
        = index_Mapping_Elem_Elem self.f0'0.roots e
      /\ match val_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem self.f0'0.domain e2
        /\ index_Mapping_Elem_Elem self.f0'0.roots e <> e
        /\ index_Mapping_Elem_Elem self.f0'0.roots e = index_Mapping_Elem_Elem self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_Elem self.f0'0.roots e = e
        /\ index_Mapping_Elem_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem [@inline:trivial] (_1: t_Elem) = true
  
  meta "rewrite_def" predicate inv_Elem
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_Perm_ptr_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) =
    not is_null_ptr_Node_T (tied_ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_ptr_Node_T self) (metadata_Node_T (tied_ptr_Node_T self))
    /\ size_of_val_Node_T (val_ptr_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (tied_ptr_Node_T self)) + size_of_val_Node_T (val_ptr_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_ptr_Node_T self)
  
  predicate inv_Perm_ptr_Node_T (_1: t_Perm_ptr_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Perm_ptr_Node_T [inv_Perm_ptr_Node_T x]. inv_Perm_ptr_Node_T x
      = invariant_Perm_ptr_Node_T x
  
  predicate invariant_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. contains_Elem'0 self k
      -> inv_Elem k /\ inv_Perm_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_FMap_Elem_Perm_ptr_Node_T (_1: t_FMap_Elem_Perm_ptr_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_Perm_ptr_Node_T [inv_FMap_Elem_Perm_ptr_Node_T x]. inv_FMap_Elem_Perm_ptr_Node_T x
      = invariant_FMap_Elem_Perm_ptr_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_Perm_ptr_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_UF_T
  
  predicate inv_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_UF_T
  
  predicate invariant_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_refmut_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_UF_T
  
  predicate inv_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_UF_T
  
  predicate invariant_ref_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_Ghost_refmut_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_refmut_UF_T
  
  predicate inv_ref_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_refmut_UF_T
  
  predicate invariant_ref_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_refmut_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_refmut_UF_T
  
  predicate inv_ref_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_ref_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_refmut_UF_T
  
  let rec deref_Ghost_refmut_UF_T (self: MutBorrow.t t_UF_T) (return (x: MutBorrow.t t_UF_T)) =
    {[@expl:deref 'self' type invariant] inv_ref_Ghost_refmut_UF_T self}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_ref_refmut_UF_T result} {result = self} (! return {result}) ]
  
  type t_Option_ref_Perm_ptr_Node_T = None'0 | Some'0 t_Perm_ptr_Node_T
  
  predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_ref_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_ref_Perm_ptr_Node_T [@inline:trivial] (self: t_Perm_ptr_Node_T) = inv_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Perm_ptr_Node_T
  
  predicate inv_ref_Perm_ptr_Node_T [@inline:trivial] (_1: t_Perm_ptr_Node_T) = invariant_ref_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Perm_ptr_Node_T
  
  predicate inv_Option_ref_Perm_ptr_Node_T (_1: t_Option_ref_Perm_ptr_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_Perm_ptr_Node_T [inv_Option_ref_Perm_ptr_Node_T x]. inv_Option_ref_Perm_ptr_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_ref_Perm_ptr_Node_T f0'2
        end
  
  function map_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) (f: Map.map t_Perm_ptr_Node_T t_Perm_ptr_Node_T) : t_Option_ref_Perm_ptr_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) (return (x: t_Option_ref_Perm_ptr_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: t_Option_ref_Perm_ptr_Node_T) -> {inv_Option_ref_Perm_ptr_Node_T result}
      {result = map_Option_Perm_ptr_Node_T (get_Elem self key) (fun (v: t_Perm_ptr_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_Perm_ptr_Node_T (self_: t_Option_ref_Perm_ptr_Node_T) (return (x: t_Perm_ptr_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Perm_ptr_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_Perm_ptr_Node_T) -> {inv_ref_Perm_ptr_Node_T result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_Ghost_ref_Perm_ptr_Node_T [@inline:trivial] (self: t_Perm_ptr_Node_T) =
    inv_ref_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_Perm_ptr_Node_T
  
  predicate inv_Ghost_ref_Perm_ptr_Node_T [@inline:trivial] (_1: t_Perm_ptr_Node_T) =
    invariant_Ghost_ref_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_Perm_ptr_Node_T
  
  let rec new_ref_Perm_ptr_Node_T (x: t_Perm_ptr_Node_T) (return (x'0: t_Perm_ptr_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_Perm_ptr_Node_T x}
    any
    [ return (result: t_Perm_ptr_Node_T) -> {inv_Ghost_ref_Perm_ptr_Node_T result} {result = x} (! return {result}) ]
  
  let rec as_ref_Node_T (ptr: Opaque.ptr) (own: t_Perm_ptr_Node_T) (return (x: t_Node_T)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_Perm_ptr_Node_T own}
    {[@expl:as_ref requires] ptr = tied_ptr_Node_T own}
    any [ return (result: t_Node_T) -> {inv_ref_Node_T result} {result = val_ptr_Node_T own} (! return {result}) ]
  
  let rec elim_Link (_x: t_Node_T) (return (f0'2: t_Elem)) = any
    [ _k (f0'2: t_Elem) -> {Link f0'2 = _x} (! return {f0'2})
    | _chk -> (! {match _x with
        | Link _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_refmut_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_Ghost_refmut_UF_T self.current /\ inv_Ghost_refmut_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Ghost_refmut_UF_T
  
  predicate inv_refmut_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_refmut_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_Ghost_refmut_UF_T
  
  predicate invariant_refmut_refmut_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_refmut_UF_T self.current /\ inv_refmut_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_refmut_UF_T
  
  predicate inv_refmut_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_refmut_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_refmut_UF_T
  
  let rec deref_mut_Ghost_refmut_UF_T (self: MutBorrow.t (MutBorrow.t t_UF_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UF_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_refmut_Ghost_refmut_UF_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UF_T)) -> {inv_refmut_refmut_UF_T result}
      {result = self}
      (! return {result}) ]
  
  predicate resolve_refmut_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_refmut_UF_T
  
  predicate resolve_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_UF_T
  
  let rec new_refmut_UF_T (x: MutBorrow.t t_UF_T) (return (x'0: MutBorrow.t t_UF_T)) =
    {[@expl:new 'x' type invariant] inv_refmut_UF_T x}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_Ghost_refmut_UF_T result} {result = x} (! return {result}) ]
  
  predicate invariant_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_UFInner_T self.current /\ inv_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_UFInner_T
  
  predicate inv_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_refmut_UFInner_T
  
  predicate invariant_Ghost_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_refmut_UFInner_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_UFInner_T
  
  predicate inv_Ghost_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) =
    invariant_Ghost_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_UFInner_T
  
  let rec new_refmut_UFInner_T (x: MutBorrow.t t_UFInner_T) (return (x'0: MutBorrow.t t_UFInner_T)) =
    {[@expl:new 'x' type invariant] inv_refmut_UFInner_T x}
    any
    [ return (result: MutBorrow.t t_UFInner_T) -> {inv_Ghost_refmut_UFInner_T result} {result = x} (! return {result}) ]
  
  predicate invariant_refmut_Ghost_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_Ghost_refmut_UFInner_T self.current /\ inv_Ghost_refmut_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Ghost_refmut_UFInner_T
  
  predicate inv_refmut_Ghost_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_refmut_Ghost_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_refmut_Ghost_refmut_UFInner_T
  
  predicate invariant_refmut_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_refmut_UFInner_T self.current /\ inv_refmut_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_refmut_UFInner_T
  
  predicate inv_refmut_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_refmut_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_refmut_refmut_UFInner_T
  
  let rec deref_mut_Ghost_refmut_UFInner_T (self: MutBorrow.t (MutBorrow.t t_UFInner_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UFInner_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_refmut_Ghost_refmut_UFInner_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> {inv_refmut_refmut_UFInner_T result}
      {result = self}
      (! return {result}) ]
  
  type t_Option_refmut_Perm_ptr_Node_T = None'1 | Some'1 (MutBorrow.t t_Perm_ptr_Node_T)
  
  predicate invariant_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self.current /\ inv_FMap_Elem_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_refmut_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_Node_T) =
    inv_Perm_ptr_Node_T self.current /\ inv_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Perm_ptr_Node_T
  
  predicate inv_refmut_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_Node_T) =
    invariant_refmut_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_Perm_ptr_Node_T
  
  predicate inv_Option_refmut_Perm_ptr_Node_T (_1: t_Option_refmut_Perm_ptr_Node_T)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_refmut_Perm_ptr_Node_T [inv_Option_refmut_Perm_ptr_Node_T x]. inv_Option_refmut_Perm_ptr_Node_T x
      = match x with
        | None'1 -> true
        | Some'1 f0'2 -> inv_refmut_Perm_ptr_Node_T f0'2
        end
  
  function len_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) : int
  
  axiom len_Elem_spec: forall self: t_FMap_Elem_Perm_ptr_Node_T. len_Elem self >= 0
  
  let rec get_mut_ghost_Elem (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem)
    (return (x: t_Option_refmut_Perm_ptr_Node_T)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv_refmut_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: t_Option_refmut_Perm_ptr_Node_T) -> {inv_Option_refmut_Perm_ptr_Node_T result}
      {if contains_Elem'0 self.current key then
        match result with
          | None'1 -> false
          | Some'1 r -> contains_Elem'0 self.final key
          /\ index_FMap_Elem_Perm_ptr_Node_T self.current key = r.current
          /\ index_FMap_Elem_Perm_ptr_Node_T self.final key = r.final
          end
      else
        result = None'1 /\ self.current = self.final
      }
      {forall k: t_Elem. k <> key -> get_Elem self.current k = get_Elem self.final k}
      {len_Elem self.current = len_Elem self.final}
      (! return {result}) ]
  
  let rec unwrap_refmut_Perm_ptr_Node_T (self_: t_Option_refmut_Perm_ptr_Node_T)
    (return (x: MutBorrow.t t_Perm_ptr_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_refmut_Perm_ptr_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Perm_ptr_Node_T) -> {inv_refmut_Perm_ptr_Node_T result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  predicate resolve_refmut_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_refmut_UFInner_T
  
  predicate invariant_Ghost_refmut_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_Node_T) =
    inv_refmut_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_Perm_ptr_Node_T
  
  predicate inv_Ghost_refmut_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_Node_T) =
    invariant_Ghost_refmut_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_Perm_ptr_Node_T
  
  let rec new_refmut_Perm_ptr_Node_T (x: MutBorrow.t t_Perm_ptr_Node_T) (return (x'0: MutBorrow.t t_Perm_ptr_Node_T)) =
    {[@expl:new 'x' type invariant] inv_refmut_Perm_ptr_Node_T x}
    any
    [ return (result: MutBorrow.t t_Perm_ptr_Node_T) -> {inv_Ghost_refmut_Perm_ptr_Node_T result}
      {result = x}
      (! return {result}) ]
  
  predicate invariant_refmut_Node_T [@inline:trivial] (self: MutBorrow.t t_Node_T) =
    inv_Node_T self.current /\ inv_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Node_T
  
  predicate inv_refmut_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = invariant_refmut_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_Node_T
  
  function fin_Ghost_refmut_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_Node_T) : t_Perm_ptr_Node_T
   = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_Perm_ptr_Node_T
  
  let rec as_mut_Node_T (ptr: Opaque.ptr) (own: MutBorrow.t t_Perm_ptr_Node_T) (return (x: MutBorrow.t t_Node_T)) =
    {[@expl:as_mut 'own' type invariant] inv_Ghost_refmut_Perm_ptr_Node_T own}
    {[@expl:as_mut requires] ptr = tied_ptr_Node_T own.current}
    any
    [ return (result: MutBorrow.t t_Node_T) -> {inv_refmut_Node_T result}
      {result.current = val_ptr_Node_T own.current}
      {tied_ptr_Node_T (fin_Ghost_refmut_Perm_ptr_Node_T own) = tied_ptr_Node_T own.current}
      {val_ptr_Node_T (fin_Ghost_refmut_Perm_ptr_Node_T own) = result.final}
      (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Node_T (_1: t_Node_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_T [resolve_Node_T x]. resolve_Node_T x
      = match x with
        | Root x0 x1 -> resolve_T x1
        | Link x0 -> true
        end
  
  predicate resolve_refmut_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Node_T
  
  predicate resolve_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_UFInner_T
  
  predicate resolve_Ghost_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = resolve_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_refmut_UFInner_T
  
  predicate resolve_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = resolve_refmut_UF_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_refmut_UF_T
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem) = contains_Elem (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem t_Elem = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_Elem (roots_map_T self) e)
        /\ index_Mapping_Elem_Elem (roots_map_T self) e
        = index_Mapping_Elem_Elem (roots_map_T self) (index_Mapping_Elem_Elem (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem) : t_Elem = index_Mapping_Elem_Elem (roots_map_T self) e
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UF_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec find_T (uf: MutBorrow.t t_UF_T) (elem: t_Elem) (return (x: t_Elem)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_refmut_UF_T uf}
    {[@expl:find requires] in_domain_T uf.current elem}
    (! bb0
    [ bb0 = s0
      [ s0 = deref_Ghost_refmut_UF_T {uf} (fun (_x: MutBorrow.t t_UF_T) -> [ &_14 <- _x ] s1)
      | s1 = [ &_17 <- elem ] s2
      | s2 = get_ghost_Elem {_14.current.f0'0.perms} {_17} (fun (_x: t_Option_ref_Perm_ptr_Node_T) -> [ &_12 <- _x ] s3)
      | s3 = unwrap_ref_Perm_ptr_Node_T {_12} (fun (_x: t_Perm_ptr_Node_T) -> [ &__temp <- _x ] s4)
      | s4 = new_ref_Perm_ptr_Node_T {__temp} (fun (_x: t_Perm_ptr_Node_T) -> [ &perm <- _x ] s5)
      | s5 = [ &_21 <- elem.f0 ] s6
      | s6 = as_ref_Node_T {_21} {perm} (fun (_x: t_Node_T) -> [ &_20 <- _x ] s7)
      | s7 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_20 = Root x0 x1} (! bb7) | br1 (x0: t_Elem) -> {_20 = Link x0} (! bb8) ] ]
    | bb8 = s0
      [ s0 = elim_Link {_20} (fun (r0: t_Elem) -> [ &e <- r0 ] s1)
      | s1 = MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_32 <- _bor ] -{inv_Ghost_refmut_UF_T _bor.final}-
            [ &uf <- _bor.final ] s2) [ _ck -> (! {inv_Ghost_refmut_UF_T uf} any) ]
      | s2 = deref_mut_Ghost_refmut_UF_T {_32} (fun (_x: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_31 <- _x ] s3)
      | s3 = MutBorrow.borrow_mut <t_UF_T> {_31.current.current}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_30 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_31 <- { _31 with current = { _31.current with current = _bor.final } } ] s4)
        [ _ck -> (! {inv_UF_T _31.current.current} any) ]
      | s4 = MutBorrow.borrow_final <t_UF_T> {_30.current} {MutBorrow.get_id _30}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_29 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_30 <- { _30 with current = _bor.final } ] s5) [ _ck -> (! {inv_UF_T _30.current} any) ]
      | s5 = s6 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _31} any) ]
      | s6 = -{resolve_refmut_refmut_UF_T _31}- s7
      | s7 = s8 [ _ck -> (! {[@expl:type invariant] inv_refmut_UF_T _30} any) ]
      | s8 = -{resolve_refmut_UF_T _30}- s9
      | s9 = MutBorrow.borrow_final <t_UF_T> {_29.current} {MutBorrow.get_id _29}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_28 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_29 <- { _29 with current = _bor.final } ] s10) [ _ck -> (! {inv_UF_T _29.current} any) ]
      | s10 = new_refmut_UF_T {_28} (fun (_x: MutBorrow.t t_UF_T) -> [ &_27 <- _x ] s11)
      | s11 = s12 [ _ck -> (! {[@expl:type invariant] inv_refmut_UF_T _29} any) ]
      | s12 = -{resolve_refmut_UF_T _29}- s13
      | s13 = find_T {_27} {e} (fun (_x: t_Elem) -> [ &root <- _x ] s14)
      | s14 = MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_36 <- _bor ] -{inv_Ghost_refmut_UF_T _bor.final}-
            [ &uf <- _bor.final ] s15) [ _ck -> (! {inv_Ghost_refmut_UF_T uf} any) ]
      | s15 = deref_mut_Ghost_refmut_UF_T {_36} (fun (_x: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_35 <- _x ] s16)
      | s16 = MutBorrow.borrow_mut <t_UFInner_T> {_35.current.current.f0'0}
          (fun (_bor: MutBorrow.t t_UFInner_T) ->
            [ &__temp'0 <- _bor ] -{inv_UFInner_T _bor.final}-
            [ &_35 <- { _35 with current = { _35.current with current = { f0'0 = _bor.final } } } ] s17)
        [ _ck -> (! {inv_UFInner_T _35.current.current.f0'0} any) ]
      | s17 = new_refmut_UFInner_T {__temp'0} (fun (_x: MutBorrow.t t_UFInner_T) -> [ &uf'0 <- _x ] s18)
      | s18 = MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_43 <- _bor ] -{inv_Ghost_refmut_UFInner_T _bor.final}-
            [ &uf'0 <- _bor.final ] s19) [ _ck -> (! {inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s19 = deref_mut_Ghost_refmut_UFInner_T {_43}
          (fun (_x: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_42 <- _x ] s20)
      | s20 = [ &_45 <- elem ] s21
      | s21 = MutBorrow.borrow_mut <t_FMap_Elem_Perm_ptr_Node_T> {_42.current.current.perms}
          (fun (_bor: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) ->
            [ &_41 <- _bor ] -{inv_FMap_Elem_Perm_ptr_Node_T _bor.final}-
            [ &_42 <- { _42 with current = { _42.current with current = { _42.current.current with perms = _bor.final } } } ]
            s22) [ _ck -> (! {inv_FMap_Elem_Perm_ptr_Node_T _42.current.current.perms} any) ]
      | s22 = get_mut_ghost_Elem {_41} {_45} (fun (_x: t_Option_refmut_Perm_ptr_Node_T) -> [ &_40 <- _x ] s23)
      | s23 = unwrap_refmut_Perm_ptr_Node_T {_40} (fun (_x: MutBorrow.t t_Perm_ptr_Node_T) -> [ &__temp'1 <- _x ] s24)
      | s24 = s25 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UFInner_T _42} any) ]
      | s25 = -{resolve_refmut_refmut_UFInner_T _42}- s26
      | s26 = new_refmut_Perm_ptr_Node_T {__temp'1} (fun (_x: MutBorrow.t t_Perm_ptr_Node_T) -> [ &mut_perm <- _x ] s27)
      | s27 = [ &_49 <- Link root ] s28
      | s28 = [ &_52 <- elem.f0 ] s29
      | s29 = as_mut_Node_T {_52} {mut_perm} (fun (_x: MutBorrow.t t_Node_T) -> [ &_51 <- _x ] s30)
      | s30 = s31 [ _ck -> (! {[@expl:type invariant] inv_Node_T _51.current} any) ]
      | s31 = -{resolve_Node_T _51.current}- s32
      | s32 = [ &_51 <- { _51 with current = _49 } ] s33
      | s33 = s34 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T _51} any) ]
      | s34 = -{resolve_refmut_Node_T _51}- s35
      | s35 = s36 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s36 = -{resolve_Ghost_refmut_UFInner_T uf'0}- s37
      | s37 = s38 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _35} any) ]
      | s38 = -{resolve_refmut_refmut_UF_T _35}- s39
      | s39 = s40 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UF_T uf} any) ]
      | s40 = -{resolve_Ghost_refmut_UF_T uf}- s41
      | s41 = [ &_ret <- root ] s42
      | s42 = return {_ret} ]
    | bb7 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UF_T uf} any) ]
      | s1 = -{resolve_Ghost_refmut_UF_T uf}- s2
      | s2 = [ &_ret <- elem ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Elem = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & elem: t_Elem = elem
    | & __temp: t_Perm_ptr_Node_T = Any.any_l ()
    | & _12: t_Option_ref_Perm_ptr_Node_T = Any.any_l ()
    | & _14: MutBorrow.t t_UF_T = Any.any_l ()
    | & _17: t_Elem = Any.any_l ()
    | & perm: t_Perm_ptr_Node_T = Any.any_l ()
    | & _20: t_Node_T = Any.any_l ()
    | & _21: Opaque.ptr = Any.any_l ()
    | & e: t_Elem = Any.any_l ()
    | & root: t_Elem = Any.any_l ()
    | & _27: MutBorrow.t t_UF_T = Any.any_l ()
    | & _28: MutBorrow.t t_UF_T = Any.any_l ()
    | & _29: MutBorrow.t t_UF_T = Any.any_l ()
    | & _30: MutBorrow.t t_UF_T = Any.any_l ()
    | & _31: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _32: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & __temp'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _35: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _36: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & __temp'1: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _40: t_Option_refmut_Perm_ptr_Node_T = Any.any_l ()
    | & _41: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _42: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _43: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _45: t_Elem = Any.any_l ()
    | & mut_perm: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _49: t_Node_T = Any.any_l ()
    | & _51: MutBorrow.t t_Node_T = Any.any_l ()
    | & _52: Opaque.ptr = Any.any_l () ])
    [ return (result: t_Elem) -> {[@expl:find ensures #0] result = root_T uf.current elem}
      {[@expl:find ensures #1] unchanged_T uf}
      (! return {result}) ]
end
module M_implementation__get
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Elem = { f0: Opaque.ptr }
  
  type t_FMap_Elem_Perm_ptr_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem;
    perms: t_FMap_Elem_Perm_ptr_Node_T;
    payloads: Map.map t_Elem t_T;
    roots: Map.map t_Elem t_Elem }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem
  
  type t_Perm_ptr_Node_T
  
  type t_Option_Perm_ptr_Node_T = None | Some t_Perm_ptr_Node_T
  
  function view_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T) : Map.map t_Elem t_Option_Perm_ptr_Node_T
  
  function get_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Option_Perm_ptr_Node_T =
    Map.get (view_FMap_Elem_Perm_ptr_Node_T self) k
  
  meta "rewrite_def" function get_Elem
  
  predicate contains_Elem'0 [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) = get_Elem self k <> None
  
  meta "rewrite_def" predicate contains_Elem'0
  
  function tied_ptr_Node_T (self: t_Perm_ptr_Node_T) : Opaque.ptr
  
  predicate index_Mapping_Perm_ptr_Node_T_bool [@inline:trivial] (self: Map.map t_Perm_ptr_Node_T bool) (a: t_Perm_ptr_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Perm_ptr_Node_T_bool
  
  function such_that_Perm_ptr_Node_T (p: Map.map t_Perm_ptr_Node_T bool) : t_Perm_ptr_Node_T
  
  axiom such_that_Perm_ptr_Node_T_spec:
    forall p: Map.map t_Perm_ptr_Node_T bool. (exists x: t_Perm_ptr_Node_T. index_Mapping_Perm_ptr_Node_T_bool p x)
      -> index_Mapping_Perm_ptr_Node_T_bool p (such_that_Perm_ptr_Node_T p)
  
  function unwrap_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) : t_Perm_ptr_Node_T = match self with
      | Some x -> x
      | None -> such_that_Perm_ptr_Node_T (fun (__0: t_Perm_ptr_Node_T) -> true)
      end
  
  function lookup_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Perm_ptr_Node_T =
    unwrap_Option_Perm_ptr_Node_T (get_Elem self k)
  
  meta "rewrite_def" function lookup_Elem
  
  function index_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) : t_Perm_ptr_Node_T
   = lookup_Elem self key
  
  meta "rewrite_def" function index_FMap_Elem_Perm_ptr_Node_T
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem
  
  function val_ptr_Node_T (self: t_Perm_ptr_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem. contains_Elem self.f0'0.domain e
      -> contains_Elem'0 self.f0'0.perms e
      /\ tied_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem self.f0'0.domain (index_Mapping_Elem_Elem self.f0'0.roots e)
      /\ index_Mapping_Elem_Elem self.f0'0.roots (index_Mapping_Elem_Elem self.f0'0.roots e)
        = index_Mapping_Elem_Elem self.f0'0.roots e
      /\ match val_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem self.f0'0.domain e2
        /\ index_Mapping_Elem_Elem self.f0'0.roots e <> e
        /\ index_Mapping_Elem_Elem self.f0'0.roots e = index_Mapping_Elem_Elem self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_Elem self.f0'0.roots e = e
        /\ index_Mapping_Elem_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem [@inline:trivial] (_1: t_Elem) = true
  
  meta "rewrite_def" predicate inv_Elem
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_Perm_ptr_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) =
    not is_null_ptr_Node_T (tied_ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_ptr_Node_T self) (metadata_Node_T (tied_ptr_Node_T self))
    /\ size_of_val_Node_T (val_ptr_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (tied_ptr_Node_T self)) + size_of_val_Node_T (val_ptr_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_ptr_Node_T self)
  
  predicate inv_Perm_ptr_Node_T (_1: t_Perm_ptr_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Perm_ptr_Node_T [inv_Perm_ptr_Node_T x]. inv_Perm_ptr_Node_T x
      = invariant_Perm_ptr_Node_T x
  
  predicate invariant_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. contains_Elem'0 self k
      -> inv_Elem k /\ inv_Perm_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_FMap_Elem_Perm_ptr_Node_T (_1: t_FMap_Elem_Perm_ptr_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_Perm_ptr_Node_T [inv_FMap_Elem_Perm_ptr_Node_T x]. inv_FMap_Elem_Perm_ptr_Node_T x
      = invariant_FMap_Elem_Perm_ptr_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_Perm_ptr_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_UF_T
  
  predicate inv_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_UF_T
  
  predicate invariant_Ghost_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_T
  
  predicate inv_Ghost_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_T
  
  predicate invariant_ref_Ghost_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_Ghost_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_UF_T
  
  predicate inv_ref_Ghost_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_ref_Ghost_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_UF_T
  
  predicate invariant_ref_ref_UF_T [@inline:trivial] (self: t_UF_T) = inv_ref_UF_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_UF_T
  
  predicate inv_ref_ref_UF_T [@inline:trivial] (_1: t_UF_T) = invariant_ref_ref_UF_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_UF_T
  
  let rec deref_Ghost_ref_UF_T (self: t_UF_T) (return (x: t_UF_T)) =
    {[@expl:deref 'self' type invariant] inv_ref_Ghost_ref_UF_T self}
    any [ return (result: t_UF_T) -> {inv_ref_ref_UF_T result} {result = self} (! return {result}) ]
  
  type t_Option_ref_Perm_ptr_Node_T = None'0 | Some'0 t_Perm_ptr_Node_T
  
  predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_ref_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_ref_Perm_ptr_Node_T [@inline:trivial] (self: t_Perm_ptr_Node_T) = inv_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Perm_ptr_Node_T
  
  predicate inv_ref_Perm_ptr_Node_T [@inline:trivial] (_1: t_Perm_ptr_Node_T) = invariant_ref_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Perm_ptr_Node_T
  
  predicate inv_Option_ref_Perm_ptr_Node_T (_1: t_Option_ref_Perm_ptr_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_Perm_ptr_Node_T [inv_Option_ref_Perm_ptr_Node_T x]. inv_Option_ref_Perm_ptr_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_ref_Perm_ptr_Node_T f0'2
        end
  
  function map_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) (f: Map.map t_Perm_ptr_Node_T t_Perm_ptr_Node_T) : t_Option_ref_Perm_ptr_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) (return (x: t_Option_ref_Perm_ptr_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: t_Option_ref_Perm_ptr_Node_T) -> {inv_Option_ref_Perm_ptr_Node_T result}
      {result = map_Option_Perm_ptr_Node_T (get_Elem self key) (fun (v: t_Perm_ptr_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_Perm_ptr_Node_T (self_: t_Option_ref_Perm_ptr_Node_T) (return (x: t_Perm_ptr_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Perm_ptr_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_Perm_ptr_Node_T) -> {inv_ref_Perm_ptr_Node_T result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_Ghost_ref_Perm_ptr_Node_T [@inline:trivial] (self: t_Perm_ptr_Node_T) =
    inv_ref_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_Perm_ptr_Node_T
  
  predicate inv_Ghost_ref_Perm_ptr_Node_T [@inline:trivial] (_1: t_Perm_ptr_Node_T) =
    invariant_Ghost_ref_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_Perm_ptr_Node_T
  
  let rec new_ref_Perm_ptr_Node_T (x: t_Perm_ptr_Node_T) (return (x'0: t_Perm_ptr_Node_T)) =
    {[@expl:new 'x' type invariant] inv_ref_Perm_ptr_Node_T x}
    any
    [ return (result: t_Perm_ptr_Node_T) -> {inv_Ghost_ref_Perm_ptr_Node_T result} {result = x} (! return {result}) ]
  
  let rec as_ref_Node_T (ptr: Opaque.ptr) (own: t_Perm_ptr_Node_T) (return (x: t_Node_T)) =
    {[@expl:as_ref 'own' type invariant] inv_Ghost_ref_Perm_ptr_Node_T own}
    {[@expl:as_ref requires] ptr = tied_ptr_Node_T own}
    any [ return (result: t_Node_T) -> {inv_ref_Node_T result} {result = val_ptr_Node_T own} (! return {result}) ]
  
  let rec elim_Root (_x: t_Node_T) (return (rank: t_PeanoInt) (payload: t_T)) = any
    [ _k (rank: t_PeanoInt) (payload: t_T) -> {Root rank payload = _x} (! return {rank} {payload})
    | _chk -> (! {match _x with
        | Root _ _ -> true
        | _ -> false
        end}
      any) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem) = contains_Elem (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem t_Elem = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_Elem (roots_map_T self) e)
        /\ index_Mapping_Elem_Elem (roots_map_T self) e
        = index_Mapping_Elem_Elem (roots_map_T self) (index_Mapping_Elem_Elem (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem) : t_Elem = index_Mapping_Elem_Elem (roots_map_T self) e
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem t_T = self.f0'0.payloads
  
  function payload_T (self: t_UF_T) (e: t_Elem) : t_T = index_Mapping_Elem_T (payloads_map_T self) e
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_T (uf: t_UF_T) (elem: t_Elem) (return (x: t_T)) = {[@expl:get 'uf' type invariant] inv_Ghost_ref_UF_T uf}
    {[@expl:get requires #0] in_domain_T uf elem}
    {[@expl:get requires #1] root_T uf elem = elem}
    (! bb0
    [ bb0 = s0
      [ s0 = deref_Ghost_ref_UF_T {uf} (fun (_x: t_UF_T) -> [ &_16 <- _x ] s1)
      | s1 = [ &_19 <- elem ] s2
      | s2 = get_ghost_Elem {_16.f0'0.perms} {_19} (fun (_x: t_Option_ref_Perm_ptr_Node_T) -> [ &_14 <- _x ] s3)
      | s3 = unwrap_ref_Perm_ptr_Node_T {_14} (fun (_x: t_Perm_ptr_Node_T) -> [ &_13 <- _x ] s4)
      | s4 = new_ref_Perm_ptr_Node_T {_13} (fun (_x: t_Perm_ptr_Node_T) -> [ &perm <- _x ] s5)
      | s5 = [ &_21 <- elem.f0 ] s6
      | s6 = as_ref_Node_T {_21} {perm} (fun (_x: t_Node_T) -> [ &_20 <- _x ] s7)
      | s7 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {_20 = Root x0 x1} (! bb8) | br1 (x0: t_Elem) -> {_20 = Link x0} (! bb6) ] ]
    | bb6 = {false} any
    | bb8 = s0
      [ s0 = elim_Root {_20} (fun (rrank: t_PeanoInt) (rpayload: t_T) -> [ &payload <- rpayload ] s1)
      | s1 = [ &_ret <- payload ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l ()
    | & uf: t_UF_T = uf
    | & elem: t_Elem = elem
    | & perm: t_Perm_ptr_Node_T = Any.any_l ()
    | & _13: t_Perm_ptr_Node_T = Any.any_l ()
    | & _14: t_Option_ref_Perm_ptr_Node_T = Any.any_l ()
    | & _16: t_UF_T = Any.any_l ()
    | & _19: t_Elem = Any.any_l ()
    | & _20: t_Node_T = Any.any_l ()
    | & _21: Opaque.ptr = Any.any_l ()
    | & payload: t_T = Any.any_l () ])
    [ return (result: t_T) -> {[@expl:get result type invariant] inv_ref_T result}
      {[@expl:get ensures] result = payload_T uf elem}
      (! return {result}) ]
end
module M_implementation__link
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Elem = { f0: Opaque.ptr }
  
  type t_FMap_Elem_Perm_ptr_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem;
    perms: t_FMap_Elem_Perm_ptr_Node_T;
    payloads: Map.map t_Elem t_T;
    roots: Map.map t_Elem t_Elem }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem
  
  type t_Perm_ptr_Node_T
  
  type t_Option_Perm_ptr_Node_T = None | Some t_Perm_ptr_Node_T
  
  function view_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T) : Map.map t_Elem t_Option_Perm_ptr_Node_T
  
  function get_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Option_Perm_ptr_Node_T =
    Map.get (view_FMap_Elem_Perm_ptr_Node_T self) k
  
  meta "rewrite_def" function get_Elem
  
  predicate contains_Elem'0 [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) = get_Elem self k <> None
  
  meta "rewrite_def" predicate contains_Elem'0
  
  function tied_ptr_Node_T (self: t_Perm_ptr_Node_T) : Opaque.ptr
  
  predicate index_Mapping_Perm_ptr_Node_T_bool [@inline:trivial] (self: Map.map t_Perm_ptr_Node_T bool) (a: t_Perm_ptr_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Perm_ptr_Node_T_bool
  
  function such_that_Perm_ptr_Node_T (p: Map.map t_Perm_ptr_Node_T bool) : t_Perm_ptr_Node_T
  
  axiom such_that_Perm_ptr_Node_T_spec:
    forall p: Map.map t_Perm_ptr_Node_T bool. (exists x: t_Perm_ptr_Node_T. index_Mapping_Perm_ptr_Node_T_bool p x)
      -> index_Mapping_Perm_ptr_Node_T_bool p (such_that_Perm_ptr_Node_T p)
  
  function unwrap_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) : t_Perm_ptr_Node_T = match self with
      | Some x -> x
      | None -> such_that_Perm_ptr_Node_T (fun (__0: t_Perm_ptr_Node_T) -> true)
      end
  
  function lookup_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Perm_ptr_Node_T =
    unwrap_Option_Perm_ptr_Node_T (get_Elem self k)
  
  meta "rewrite_def" function lookup_Elem
  
  function index_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) : t_Perm_ptr_Node_T
   = lookup_Elem self key
  
  meta "rewrite_def" function index_FMap_Elem_Perm_ptr_Node_T
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem
  
  function val_ptr_Node_T (self: t_Perm_ptr_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem. contains_Elem self.f0'0.domain e
      -> contains_Elem'0 self.f0'0.perms e
      /\ tied_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem self.f0'0.domain (index_Mapping_Elem_Elem self.f0'0.roots e)
      /\ index_Mapping_Elem_Elem self.f0'0.roots (index_Mapping_Elem_Elem self.f0'0.roots e)
        = index_Mapping_Elem_Elem self.f0'0.roots e
      /\ match val_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem self.f0'0.domain e2
        /\ index_Mapping_Elem_Elem self.f0'0.roots e <> e
        /\ index_Mapping_Elem_Elem self.f0'0.roots e = index_Mapping_Elem_Elem self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_Elem self.f0'0.roots e = e
        /\ index_Mapping_Elem_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem [@inline:trivial] (_1: t_Elem) = true
  
  meta "rewrite_def" predicate inv_Elem
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_Perm_ptr_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) =
    not is_null_ptr_Node_T (tied_ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_ptr_Node_T self) (metadata_Node_T (tied_ptr_Node_T self))
    /\ size_of_val_Node_T (val_ptr_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (tied_ptr_Node_T self)) + size_of_val_Node_T (val_ptr_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_ptr_Node_T self)
  
  predicate inv_Perm_ptr_Node_T (_1: t_Perm_ptr_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Perm_ptr_Node_T [inv_Perm_ptr_Node_T x]. inv_Perm_ptr_Node_T x
      = invariant_Perm_ptr_Node_T x
  
  predicate invariant_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. contains_Elem'0 self k
      -> inv_Elem k /\ inv_Perm_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_FMap_Elem_Perm_ptr_Node_T (_1: t_FMap_Elem_Perm_ptr_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_Perm_ptr_Node_T [inv_FMap_Elem_Perm_ptr_Node_T x]. inv_FMap_Elem_Perm_ptr_Node_T x
      = invariant_FMap_Elem_Perm_ptr_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_Perm_ptr_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_UF_T
  
  predicate inv_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_UF_T
  
  predicate invariant_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_refmut_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_UF_T
  
  predicate inv_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_UF_T
  
  predicate invariant_refmut_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_Ghost_refmut_UF_T self.current /\ inv_Ghost_refmut_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Ghost_refmut_UF_T
  
  predicate inv_refmut_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_refmut_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_Ghost_refmut_UF_T
  
  predicate invariant_refmut_refmut_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_refmut_UF_T self.current /\ inv_refmut_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_refmut_UF_T
  
  predicate inv_refmut_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_refmut_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_refmut_UF_T
  
  let rec deref_mut_Ghost_refmut_UF_T (self: MutBorrow.t (MutBorrow.t t_UF_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UF_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_refmut_Ghost_refmut_UF_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UF_T)) -> {inv_refmut_refmut_UF_T result}
      {result = self}
      (! return {result}) ]
  
  predicate invariant_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_UFInner_T self.current /\ inv_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_UFInner_T
  
  predicate inv_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = invariant_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_refmut_UFInner_T
  
  predicate invariant_Ghost_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t t_UFInner_T) =
    inv_refmut_UFInner_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_UFInner_T
  
  predicate inv_Ghost_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) =
    invariant_Ghost_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_UFInner_T
  
  let rec new_refmut_UFInner_T (x: MutBorrow.t t_UFInner_T) (return (x'0: MutBorrow.t t_UFInner_T)) =
    {[@expl:new 'x' type invariant] inv_refmut_UFInner_T x}
    any
    [ return (result: MutBorrow.t t_UFInner_T) -> {inv_Ghost_refmut_UFInner_T result} {result = x} (! return {result}) ]
  
  function deep_model_Elem [@inline:trivial] (self: t_Elem) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Elem
  
  function deep_model_ref_Elem [@inline:trivial] (self: t_Elem) : UInt64.t = deep_model_Elem self
  
  meta "rewrite_def" function deep_model_ref_Elem
  
  let rec eq_Elem (self: t_Elem) (other: t_Elem) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Elem self = deep_model_ref_Elem other)} (! return {result}) ]
  
  let rec into_ghost_bool (self: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self} (! return {result}) ]
  
  let rec into_inner_bool (self: bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = self} (! return {result}) ]
  
  predicate invariant_refmut_Ghost_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_Ghost_refmut_UFInner_T self.current /\ inv_Ghost_refmut_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Ghost_refmut_UFInner_T
  
  predicate inv_refmut_Ghost_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_refmut_Ghost_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_refmut_Ghost_refmut_UFInner_T
  
  predicate invariant_refmut_refmut_UFInner_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    inv_refmut_UFInner_T self.current /\ inv_refmut_UFInner_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_refmut_UFInner_T
  
  predicate inv_refmut_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    invariant_refmut_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate inv_refmut_refmut_UFInner_T
  
  let rec deref_mut_Ghost_refmut_UFInner_T (self: MutBorrow.t (MutBorrow.t t_UFInner_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UFInner_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_refmut_Ghost_refmut_UFInner_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> {inv_refmut_refmut_UFInner_T result}
      {result = self}
      (! return {result}) ]
  
  type tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T = {
    f0'2: MutBorrow.t t_Perm_ptr_Node_T;
    f1'2: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T }
  
  predicate invariant_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self.current /\ inv_FMap_Elem_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_refmut_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_Node_T) =
    inv_Perm_ptr_Node_T self.current /\ inv_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Perm_ptr_Node_T
  
  predicate inv_refmut_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_Node_T) =
    invariant_refmut_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_Perm_ptr_Node_T
  
  predicate inv_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) =
    inv_refmut_Perm_ptr_Node_T _1.f0'2 /\ inv_refmut_FMap_Elem_Perm_ptr_Node_T _1.f1'2
  
  meta "rewrite_def" predicate inv_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T
  
  function len_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) : int
  
  axiom len_Elem_spec: forall self: t_FMap_Elem_Perm_ptr_Node_T. len_Elem self >= 0
  
  function remove_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_FMap_Elem_Perm_ptr_Node_T
  
  axiom remove_Elem_spec:
    forall self: t_FMap_Elem_Perm_ptr_Node_T, k: t_Elem. view_FMap_Elem_Perm_ptr_Node_T (remove_Elem self k)
      = Map.set (view_FMap_Elem_Perm_ptr_Node_T self) k (None)
  
  axiom remove_Elem_spec'0: forall self: t_FMap_Elem_Perm_ptr_Node_T, k: t_Elem. len_Elem (remove_Elem self k)
      = (if contains_Elem'0 self k then len_Elem self - 1 else len_Elem self)
  
  function insert_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) (v: t_Perm_ptr_Node_T) : t_FMap_Elem_Perm_ptr_Node_T
  
  axiom insert_Elem_spec:
    forall self: t_FMap_Elem_Perm_ptr_Node_T, k: t_Elem, v: t_Perm_ptr_Node_T. view_FMap_Elem_Perm_ptr_Node_T (insert_Elem self k v)
      = Map.set (view_FMap_Elem_Perm_ptr_Node_T self) k (Some v)
  
  axiom insert_Elem_spec'0:
    forall self: t_FMap_Elem_Perm_ptr_Node_T, k: t_Elem, v: t_Perm_ptr_Node_T. len_Elem (insert_Elem self k v)
      = (if contains_Elem'0 self k then len_Elem self else len_Elem self + 1)
  
  let rec split_mut_ghost_Elem (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem)
    (return (x: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T)) =
    {[@expl:split_mut_ghost 'self' type invariant] inv_refmut_FMap_Elem_Perm_ptr_Node_T self}
    {[@expl:split_mut_ghost requires] contains_Elem'0 self.current key}
    any
    [ return (result: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) ->
    {inv_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T result}
      {result.f1'2.current = remove_Elem self.current key}
      {index_FMap_Elem_Perm_ptr_Node_T self.current key = result.f0'2.current
      /\ self.final = insert_Elem result.f1'2.final key result.f0'2.final}
      (! return {result}) ]
  
  predicate resolve_refmut_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UFInner_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_refmut_UFInner_T
  
  predicate resolve_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_FMap_Elem_Perm_ptr_Node_T
  
  type t_Option_ref_Perm_ptr_Node_T = None'0 | Some'0 t_Perm_ptr_Node_T
  
  predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    inv_FMap_Elem_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_ref_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_ref_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_ref_Perm_ptr_Node_T [@inline:trivial] (self: t_Perm_ptr_Node_T) = inv_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Perm_ptr_Node_T
  
  predicate inv_ref_Perm_ptr_Node_T [@inline:trivial] (_1: t_Perm_ptr_Node_T) = invariant_ref_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Perm_ptr_Node_T
  
  predicate inv_Option_ref_Perm_ptr_Node_T (_1: t_Option_ref_Perm_ptr_Node_T)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_Option_ref_Perm_ptr_Node_T [inv_Option_ref_Perm_ptr_Node_T x]. inv_Option_ref_Perm_ptr_Node_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'3 -> inv_ref_Perm_ptr_Node_T f0'3
        end
  
  function map_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) (f: Map.map t_Perm_ptr_Node_T t_Perm_ptr_Node_T) : t_Option_ref_Perm_ptr_Node_T
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  let rec get_ghost_Elem (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) (return (x: t_Option_ref_Perm_ptr_Node_T)) =
    {[@expl:get_ghost 'self' type invariant] inv_ref_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: t_Option_ref_Perm_ptr_Node_T) -> {inv_Option_ref_Perm_ptr_Node_T result}
      {result = map_Option_Perm_ptr_Node_T (get_Elem self key) (fun (v: t_Perm_ptr_Node_T) -> v)}
      (! return {result}) ]
  
  let rec unwrap_ref_Perm_ptr_Node_T (self_: t_Option_ref_Perm_ptr_Node_T) (return (x: t_Perm_ptr_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Perm_ptr_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_Perm_ptr_Node_T) -> {inv_ref_Perm_ptr_Node_T result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate is_disjoint_ptr_Node_T [@inline:trivial] (self: Opaque.ptr) (self_val: t_Node_T) (other: Opaque.ptr) (other_val: t_Node_T) =
    size_of_val_Node_T self_val <> 0 /\ size_of_val_Node_T other_val <> 0
    -> Ptr.addr_logic_u64 self <> Ptr.addr_logic_u64 other
  
  meta "rewrite_def" predicate is_disjoint_ptr_Node_T
  
  let rec disjoint_lemma_ptr_Node_T (self: MutBorrow.t t_Perm_ptr_Node_T) (other: t_Perm_ptr_Node_T) (return (x: ())) =
    {[@expl:disjoint_lemma 'self' type invariant] inv_refmut_Perm_ptr_Node_T self}
    {[@expl:disjoint_lemma 'other' type invariant] inv_ref_Perm_ptr_Node_T other}
    any
    [ return (result: ()) ->
    {is_disjoint_ptr_Node_T (tied_ptr_Node_T self.current) (val_ptr_Node_T self.current) (tied_ptr_Node_T other) (val_ptr_Node_T other)}
      {self.current = self.final}
      (! return {result}) ]
  
  predicate resolve_refmut_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Perm_ptr_Node_T
  
  predicate resolve_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_UFInner_T
  
  predicate resolve_Ghost_refmut_UFInner_T [@inline:trivial] (_1: MutBorrow.t t_UFInner_T) = resolve_refmut_UFInner_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_refmut_UFInner_T
  
  predicate resolve_refmut_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_refmut_UF_T
  
  predicate resolve_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_UF_T
  
  predicate resolve_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = resolve_refmut_UF_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_refmut_UF_T
  
  let rec new_unit (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  predicate invariant_Ghost_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) =
    inv_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_Ghost_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) =
    invariant_Ghost_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T
  
  let rec new_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T
    (x: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T)
    (return (x'0: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T)) =
    {[@expl:new 'x' type invariant] inv_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T x}
    any
    [ return (result: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) ->
    {inv_Ghost_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T result}
      {result = x}
      (! return {result}) ]
  
  type tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T = {
    f0'3: MutBorrow.t t_Perm_ptr_Node_T;
    f1'3: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T }
  
  predicate invariant_Ghost_refmut_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_Node_T) =
    inv_refmut_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_Perm_ptr_Node_T
  
  predicate inv_Ghost_refmut_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_Node_T) =
    invariant_Ghost_refmut_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_Perm_ptr_Node_T
  
  predicate invariant_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    inv_refmut_FMap_Elem_Perm_ptr_Node_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    invariant_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T) =
    inv_Ghost_refmut_Perm_ptr_Node_T _1.f0'3 /\ inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T _1.f1'3
  
  meta "rewrite_def" predicate inv_tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T
  
  let rec split_refmut_Perm_ptr_Node_T (self: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T)
    (return (x: tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T)) =
    {[@expl:split 'self' type invariant] inv_Ghost_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T) ->
    {inv_tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T result}
      {self.f0'2 = result.f0'3}
      {self.f1'2 = result.f1'3}
      (! return {result}) ]
  
  predicate invariant_refmut_Node_T [@inline:trivial] (self: MutBorrow.t t_Node_T) =
    inv_Node_T self.current /\ inv_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Node_T
  
  predicate inv_refmut_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = invariant_refmut_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_Node_T
  
  function fin_Ghost_refmut_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_Node_T) : t_Perm_ptr_Node_T
   = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_Perm_ptr_Node_T
  
  let rec as_mut_Node_T (ptr: Opaque.ptr) (own: MutBorrow.t t_Perm_ptr_Node_T) (return (x: MutBorrow.t t_Node_T)) =
    {[@expl:as_mut 'own' type invariant] inv_Ghost_refmut_Perm_ptr_Node_T own}
    {[@expl:as_mut requires] ptr = tied_ptr_Node_T own.current}
    any
    [ return (result: MutBorrow.t t_Node_T) -> {inv_refmut_Node_T result}
      {result.current = val_ptr_Node_T own.current}
      {tied_ptr_Node_T (fin_Ghost_refmut_Perm_ptr_Node_T own) = tied_ptr_Node_T own.current}
      {val_ptr_Node_T (fin_Ghost_refmut_Perm_ptr_Node_T own) = result.final}
      (! return {result}) ]
  
  predicate resolve_refmut_Node_T [@inline:trivial] (_1: MutBorrow.t t_Node_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Node_T
  
  predicate invariant_refmut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) =
    inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T self.current /\ inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_refmut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) =
    invariant_refmut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate invariant_refmut_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) =
    inv_refmut_FMap_Elem_Perm_ptr_Node_T self.current /\ inv_refmut_FMap_Elem_Perm_ptr_Node_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_refmut_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) =
    invariant_refmut_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate inv_refmut_refmut_FMap_Elem_Perm_ptr_Node_T
  
  let rec deref_mut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T (self: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T))
    (return (x: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_refmut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) ->
    {inv_refmut_refmut_FMap_Elem_Perm_ptr_Node_T result}
      {result = self}
      (! return {result}) ]
  
  type t_Option_refmut_Perm_ptr_Node_T = None'1 | Some'1 (MutBorrow.t t_Perm_ptr_Node_T)
  
  predicate inv_Option_refmut_Perm_ptr_Node_T (_1: t_Option_refmut_Perm_ptr_Node_T)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_Option_refmut_Perm_ptr_Node_T [inv_Option_refmut_Perm_ptr_Node_T x]. inv_Option_refmut_Perm_ptr_Node_T x
      = match x with
        | None'1 -> true
        | Some'1 f0'4 -> inv_refmut_Perm_ptr_Node_T f0'4
        end
  
  let rec get_mut_ghost_Elem (self: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem)
    (return (x: t_Option_refmut_Perm_ptr_Node_T)) =
    {[@expl:get_mut_ghost 'self' type invariant] inv_refmut_FMap_Elem_Perm_ptr_Node_T self}
    any
    [ return (result: t_Option_refmut_Perm_ptr_Node_T) -> {inv_Option_refmut_Perm_ptr_Node_T result}
      {if contains_Elem'0 self.current key then
        match result with
          | None'1 -> false
          | Some'1 r -> contains_Elem'0 self.final key
          /\ index_FMap_Elem_Perm_ptr_Node_T self.current key = r.current
          /\ index_FMap_Elem_Perm_ptr_Node_T self.final key = r.final
          end
      else
        result = None'1 /\ self.current = self.final
      }
      {forall k: t_Elem. k <> key -> get_Elem self.current k = get_Elem self.final k}
      {len_Elem self.current = len_Elem self.final}
      (! return {result}) ]
  
  let rec unwrap_refmut_Perm_ptr_Node_T (self_: t_Option_refmut_Perm_ptr_Node_T)
    (return (x: MutBorrow.t t_Perm_ptr_Node_T)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_refmut_Perm_ptr_Node_T self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Perm_ptr_Node_T) -> {inv_refmut_Perm_ptr_Node_T result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  predicate resolve_refmut_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_refmut_FMap_Elem_Perm_ptr_Node_T
  
  let rec new_refmut_Perm_ptr_Node_T (x: MutBorrow.t t_Perm_ptr_Node_T) (return (x'0: MutBorrow.t t_Perm_ptr_Node_T)) =
    {[@expl:new 'x' type invariant] inv_refmut_Perm_ptr_Node_T x}
    any
    [ return (result: MutBorrow.t t_Perm_ptr_Node_T) -> {inv_Ghost_refmut_Perm_ptr_Node_T result}
      {result = x}
      (! return {result}) ]
  
  let rec elim_Root (_x: t_Node_T) (return (rank: t_PeanoInt) (payload: t_T)) = any
    [ _k (rank: t_PeanoInt) (payload: t_T) -> {Root rank payload = _x} (! return {rank} {payload})
    | _chk -> (! {match _x with
        | Root _ _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate resolve_refmut_PeanoInt [@inline:trivial] (_1: MutBorrow.t t_PeanoInt) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_PeanoInt
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'1
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_refmut_PeanoInt [@inline:trivial] (self: MutBorrow.t t_PeanoInt) : UInt64.t =
    deep_model_PeanoInt self.current
  
  meta "rewrite_def" function deep_model_refmut_PeanoInt
  
  function deep_model_ref_refmut_PeanoInt [@inline:trivial] (self: MutBorrow.t t_PeanoInt) : UInt64.t =
    deep_model_refmut_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_refmut_PeanoInt
  
  let rec lt_refmut_PeanoInt (self_: MutBorrow.t t_PeanoInt) (other: MutBorrow.t t_PeanoInt) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = UInt64.lt (deep_model_ref_refmut_PeanoInt self_) (deep_model_ref_refmut_PeanoInt other)}
      (! return {result}) ]
  
  predicate resolve_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (_1: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) =
    resolve_refmut_FMap_Elem_Perm_ptr_Node_T _1
  
  meta "rewrite_def" predicate resolve_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Node_T (_1: t_Node_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_T [resolve_Node_T x]. resolve_Node_T x
      = match x with
        | Root x0 x1 -> resolve_T x1
        | Link x0 -> true
        end
  
  let rec eq_refmut_PeanoInt (self_: MutBorrow.t t_PeanoInt) (rhs: MutBorrow.t t_PeanoInt) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_refmut_PeanoInt self_ = deep_model_ref_refmut_PeanoInt rhs)}
      (! return {result}) ]
  
  let rec incr (self: t_PeanoInt) (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {UInt64.t'int result.f0'1 = UInt64.t'int self.f0'1 + 1} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem) = contains_Elem (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem t_Elem = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_Elem (roots_map_T self) e)
        /\ index_Mapping_Elem_Elem (roots_map_T self) e
        = index_Mapping_Elem_Elem (roots_map_T self) (index_Mapping_Elem_Elem (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem) : t_Elem = index_Mapping_Elem_Elem (roots_map_T self) e
  
  predicate domain_unchanged_T (self: MutBorrow.t t_UF_T) = domain_T self.current = domain_T self.final
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem t_T = self.f0'0.payloads
  
  predicate payloads_unchanged_T (self: MutBorrow.t t_UF_T) = payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) : t_UF_T = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_UF_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec link_T (uf: MutBorrow.t t_UF_T) (x: t_Elem) (y: t_Elem) (return (x'0: t_Elem)) =
    {[@expl:link 'uf' type invariant] inv_Ghost_refmut_UF_T uf}
    {[@expl:link requires #0] in_domain_T uf.current x /\ in_domain_T uf.current y}
    {[@expl:link requires #1] root_T uf.current x = x /\ root_T uf.current y = y}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_26 <- _bor ] -{inv_Ghost_refmut_UF_T _bor.final}-
            [ &uf <- _bor.final ] s1) [ _ck -> (! {inv_Ghost_refmut_UF_T uf} any) ]
      | s1 = deref_mut_Ghost_refmut_UF_T {_26} (fun (_x: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_25 <- _x ] s2)
      | s2 = MutBorrow.borrow_mut <t_UFInner_T> {_25.current.current.f0'0}
          (fun (_bor: MutBorrow.t t_UFInner_T) ->
            [ &__temp <- _bor ] -{inv_UFInner_T _bor.final}-
            [ &_25 <- { _25 with current = { _25.current with current = { f0'0 = _bor.final } } } ] s3)
        [ _ck -> (! {inv_UFInner_T _25.current.current.f0'0} any) ]
      | s3 = new_refmut_UFInner_T {__temp} (fun (_x: MutBorrow.t t_UFInner_T) -> [ &uf'0 <- _x ] s4)
      | s4 = eq_Elem {x} {y} (fun (_x: bool) -> [ &_30 <- _x ] s5)
      | s5 = any [ br0 -> {_30 = false} (! bb16) | br1 -> {_30} (! bb5) ] ]
    | bb5 = s0
      [ s0 = into_ghost_bool {x <> y} (fun (_x: bool) -> [ &_37 <- _x ] s1)
      | s1 = into_inner_bool {_37} (fun (_x: bool) -> [ &_36 <- _x ] s2)
      | s2 = any [ br0 -> {_36 = false} (! bb14) | br1 -> {_36} (! bb8) ] ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_47 <- _bor ] -{inv_Ghost_refmut_UFInner_T _bor.final}-
            [ &uf'0 <- _bor.final ] s1) [ _ck -> (! {inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s1 = deref_mut_Ghost_refmut_UFInner_T {_47}
          (fun (_x: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_46 <- _x ] s2)
      | s2 = [ &_49 <- x ] s3
      | s3 = MutBorrow.borrow_mut <t_FMap_Elem_Perm_ptr_Node_T> {_46.current.current.perms}
          (fun (_bor: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) ->
            [ &_45 <- _bor ] -{inv_FMap_Elem_Perm_ptr_Node_T _bor.final}-
            [ &_46 <- { _46 with current = { _46.current with current = { _46.current.current with perms = _bor.final } } } ]
            s4) [ _ck -> (! {inv_FMap_Elem_Perm_ptr_Node_T _46.current.current.perms} any) ]
      | s4 = split_mut_ghost_Elem {_45} {_49}
          (fun (_x: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) -> [ &_44 <- _x ] s5)
      | s5 = [ &perm_x <- _44.f0'2 ] s6
      | s6 = [ &m <- _44.f1'2 ] s7
      | s7 = s8 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UFInner_T _46} any) ]
      | s8 = -{resolve_refmut_refmut_UFInner_T _46}- s9
      | s9 = s10 [ _ck -> (! {[@expl:type invariant] inv_refmut_FMap_Elem_Perm_ptr_Node_T m} any) ]
      | s10 = -{resolve_refmut_FMap_Elem_Perm_ptr_Node_T m}- s11
      | s11 = [ &_57 <- y ] s12
      | s12 = get_ghost_Elem {m.current} {_57} (fun (_x: t_Option_ref_Perm_ptr_Node_T) -> [ &_54 <- _x ] s13)
      | s13 = unwrap_ref_Perm_ptr_Node_T {_54} (fun (_x: t_Perm_ptr_Node_T) -> [ &_53 <- _x ] s14)
      | s14 = MutBorrow.borrow_final <t_Perm_ptr_Node_T> {perm_x.current} {MutBorrow.get_id perm_x}
          (fun (_bor: MutBorrow.t t_Perm_ptr_Node_T) ->
            [ &_51 <- _bor ] -{inv_Perm_ptr_Node_T _bor.final}-
            [ &perm_x <- { perm_x with current = _bor.final } ] s15)
        [ _ck -> (! {inv_Perm_ptr_Node_T perm_x.current} any) ]
      | s15 = disjoint_lemma_ptr_Node_T {_51} {_53} (fun (_x: ()) -> [ &_50 <- _x ] s16)
      | s16 = s17 [ _ck -> (! {[@expl:type invariant] inv_refmut_Perm_ptr_Node_T perm_x} any) ]
      | s17 = -{resolve_refmut_Perm_ptr_Node_T perm_x}- s18
      | s18 = s19 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s19 = -{resolve_Ghost_refmut_UFInner_T uf'0}- s20
      | s20 = s21 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _25} any) ]
      | s21 = -{resolve_refmut_refmut_UF_T _25}- s22
      | s22 = s23 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UF_T uf} any) ]
      | s23 = -{resolve_Ghost_refmut_UF_T uf}- s24
      | s24 = {false} any ]
    | bb14 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s1 = -{resolve_Ghost_refmut_UFInner_T uf'0}- s2
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _25} any) ]
      | s3 = -{resolve_refmut_refmut_UF_T _25}- s4
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UF_T uf} any) ]
      | s5 = -{resolve_Ghost_refmut_UF_T uf}- s6
      | s6 = new_unit {_35} (fun (_x: ()) -> [ &_34 <- _x ] s7)
      | s7 = [ &_ret <- x ] s8
      | s8 = return {_ret} ]
    | bb16 = s0
      [ s0 = MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_66 <- _bor ] -{inv_Ghost_refmut_UFInner_T _bor.final}-
            [ &uf'0 <- _bor.final ] s1) [ _ck -> (! {inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s1 = deref_mut_Ghost_refmut_UFInner_T {_66}
          (fun (_x: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_65 <- _x ] s2)
      | s2 = [ &_68 <- x ] s3
      | s3 = MutBorrow.borrow_mut <t_FMap_Elem_Perm_ptr_Node_T> {_65.current.current.perms}
          (fun (_bor: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) ->
            [ &_64 <- _bor ] -{inv_FMap_Elem_Perm_ptr_Node_T _bor.final}-
            [ &_65 <- { _65 with current = { _65.current with current = { _65.current.current with perms = _bor.final } } } ]
            s4) [ _ck -> (! {inv_FMap_Elem_Perm_ptr_Node_T _65.current.current.perms} any) ]
      | s4 = split_mut_ghost_Elem {_64} {_68}
          (fun (_x: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) -> [ &_63 <- _x ] s5)
      | s5 = s6 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UFInner_T _65} any) ]
      | s6 = -{resolve_refmut_refmut_UFInner_T _65}- s7
      | s7 = new_tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T {_63}
          (fun (_x: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T) -> [ &_62 <- _x ] s8)
      | s8 = split_refmut_Perm_ptr_Node_T {_62}
          (fun (_x: tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T) -> [ &_61 <- _x ] s9)
      | s9 = [ &perm_x'0 <- _61.f0'3 ] s10
      | s10 = [ &m'0 <- _61.f1'3 ] s11
      | s11 = [ &_71 <- x.f0 ] s12
      | s12 = as_mut_Node_T {_71} {perm_x'0} (fun (_x: MutBorrow.t t_Node_T) -> [ &_70 <- _x ] s13)
      | s13 = MutBorrow.borrow_final <t_Node_T> {_70.current} {MutBorrow.get_id _70}
          (fun (_bor: MutBorrow.t t_Node_T) ->
            [ &bx <- _bor ] -{inv_Node_T _bor.final}-
            [ &_70 <- { _70 with current = _bor.final } ] s14) [ _ck -> (! {inv_Node_T _70.current} any) ]
      | s14 = s15 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T _70} any) ]
      | s15 = -{resolve_refmut_Node_T _70}- s16
      | s16 = [ &_76 <- y.f0 ] s17
      | s17 = MutBorrow.borrow_mut <MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T> {m'0}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) ->
            [ &_85 <- _bor ] -{inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T _bor.final}-
            [ &m'0 <- _bor.final ] s18) [ _ck -> (! {inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T m'0} any) ]
      | s18 = deref_mut_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T {_85}
          (fun (_x: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T)) -> [ &_84 <- _x ] s19)
      | s19 = [ &_87 <- y ] s20
      | s20 = MutBorrow.borrow_mut <t_FMap_Elem_Perm_ptr_Node_T> {_84.current.current}
          (fun (_bor: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) ->
            [ &_83 <- _bor ] -{inv_FMap_Elem_Perm_ptr_Node_T _bor.final}-
            [ &_84 <- { _84 with current = { _84.current with current = _bor.final } } ] s21)
        [ _ck -> (! {inv_FMap_Elem_Perm_ptr_Node_T _84.current.current} any) ]
      | s21 = get_mut_ghost_Elem {_83} {_87} (fun (_x: t_Option_refmut_Perm_ptr_Node_T) -> [ &_82 <- _x ] s22)
      | s22 = unwrap_refmut_Perm_ptr_Node_T {_82} (fun (_x: MutBorrow.t t_Perm_ptr_Node_T) -> [ &_81 <- _x ] s23)
      | s23 = MutBorrow.borrow_final <t_Perm_ptr_Node_T> {_81.current} {MutBorrow.get_id _81}
          (fun (_bor: MutBorrow.t t_Perm_ptr_Node_T) ->
            [ &_80 <- _bor ] -{inv_Perm_ptr_Node_T _bor.final}-
            [ &_81 <- { _81 with current = _bor.final } ] s24) [ _ck -> (! {inv_Perm_ptr_Node_T _81.current} any) ]
      | s24 = s25 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_FMap_Elem_Perm_ptr_Node_T _84} any) ]
      | s25 = -{resolve_refmut_refmut_FMap_Elem_Perm_ptr_Node_T _84}- s26
      | s26 = s27 [ _ck -> (! {[@expl:type invariant] inv_refmut_Perm_ptr_Node_T _81} any) ]
      | s27 = -{resolve_refmut_Perm_ptr_Node_T _81}- s28
      | s28 = MutBorrow.borrow_final <t_Perm_ptr_Node_T> {_80.current} {MutBorrow.get_id _80}
          (fun (_bor: MutBorrow.t t_Perm_ptr_Node_T) ->
            [ &_79 <- _bor ] -{inv_Perm_ptr_Node_T _bor.final}-
            [ &_80 <- { _80 with current = _bor.final } ] s29) [ _ck -> (! {inv_Perm_ptr_Node_T _80.current} any) ]
      | s29 = new_refmut_Perm_ptr_Node_T {_79} (fun (_x: MutBorrow.t t_Perm_ptr_Node_T) -> [ &_78 <- _x ] s30)
      | s30 = s31 [ _ck -> (! {[@expl:type invariant] inv_refmut_Perm_ptr_Node_T _80} any) ]
      | s31 = -{resolve_refmut_Perm_ptr_Node_T _80}- s32
      | s32 = as_mut_Node_T {_76} {_78} (fun (_x: MutBorrow.t t_Node_T) -> [ &_75 <- _x ] s33)
      | s33 = MutBorrow.borrow_final <t_Node_T> {_75.current} {MutBorrow.get_id _75}
          (fun (_bor: MutBorrow.t t_Node_T) ->
            [ &by' <- _bor ] -{inv_Node_T _bor.final}-
            [ &_75 <- { _75 with current = _bor.final } ] s34) [ _ck -> (! {inv_Node_T _75.current} any) ]
      | s34 = s35 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T _75} any) ]
      | s35 = -{resolve_refmut_Node_T _75}- s36
      | s36 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {bx.current = Root x0 x1} (! bb29)
        | br1 (x0: t_Elem) -> {bx.current = Link x0} (! bb27) ] ]
    | bb27 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T by'} any) ]
      | s1 = -{resolve_refmut_Node_T by'}- s2
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T bx} any) ]
      | s3 = -{resolve_refmut_Node_T bx}- s4
      | s4 = {false} any ]
    | bb29 = s0
      [ s0 = elim_Root {bx.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_bor: MutBorrow.t t_PeanoInt) ->
                [ &rx <- _bor ] [ &bx <- { bx with current = Root _bor.final rpayload } ] s1))
      | s1 = any
        [ br0 (x0: t_PeanoInt) (x1: t_T) -> {by'.current = Root x0 x1} (! bb32)
        | br1 (x0: t_Elem) -> {by'.current = Link x0} (! bb30) ] ]
    | bb30 = s0
      [ s0 = -{resolve_refmut_PeanoInt rx}- s1
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T by'} any) ]
      | s2 = -{resolve_refmut_Node_T by'}- s3
      | s3 = {false} any ]
    | bb32 = s0
      [ s0 = elim_Root {by'.current}
          (fun (rrank: t_PeanoInt) (rpayload: t_T) ->
            MutBorrow.borrow_mut <t_PeanoInt> {rrank}
              (fun (_bor: MutBorrow.t t_PeanoInt) ->
                [ &ry <- _bor ] [ &by' <- { by' with current = Root _bor.final rpayload } ] s1))
      | s1 = MutBorrow.borrow_final <t_PeanoInt> {ry.current} {MutBorrow.get_id ry}
          (fun (_bor: MutBorrow.t t_PeanoInt) -> [ &_97 <- _bor ] [ &ry <- { ry with current = _bor.final } ] s2)
      | s2 = -{resolve_refmut_PeanoInt _97}- s3
      | s3 = lt_refmut_PeanoInt {rx} {_97} (fun (_x: bool) -> [ &_94 <- _x ] s4)
      | s4 = any [ br0 -> {_94 = false} (! bb41) | br1 -> {_94} (! bb34) ] ]
    | bb34 = s0
      [ s0 = -{resolve_refmut_PeanoInt ry}- s1
      | s1 = -{resolve_refmut_PeanoInt rx}- s2
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T by'} any) ]
      | s3 = -{resolve_refmut_Node_T by'}- s4
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T m'0} any) ]
      | s5 = -{resolve_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T m'0}- s6
      | s6 = [ &_98 <- Link y ] s7
      | s7 = s8 [ _ck -> (! {[@expl:type invariant] inv_Node_T bx.current} any) ]
      | s8 = -{resolve_Node_T bx.current}- s9
      | s9 = [ &bx <- { bx with current = _98 } ] s10
      | s10 = s11 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T bx} any) ]
      | s11 = -{resolve_refmut_Node_T bx}- s12
      | s12 = [ &_102 <- fun (z: t_Elem) -> if index_Mapping_Elem_Elem uf'0.current.roots z = x then
          y
        else
          index_Mapping_Elem_Elem uf'0.current.roots z
         ] s13
      | s13 = MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_108 <- _bor ] -{inv_Ghost_refmut_UFInner_T _bor.final}-
            [ &uf'0 <- _bor.final ] s14) [ _ck -> (! {inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s14 = deref_mut_Ghost_refmut_UFInner_T {_108}
          (fun (_x: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_107 <- _x ] s15)
      | s15 =
        [ &_107 <- { _107 with current = { _107.current with current = { _107.current.current with roots = _102 } } } ]
        s16
      | s16 = s17 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UFInner_T _107} any) ]
      | s17 = -{resolve_refmut_refmut_UFInner_T _107}- s18
      | s18 = s19 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s19 = -{resolve_Ghost_refmut_UFInner_T uf'0}- s20
      | s20 = s21 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _25} any) ]
      | s21 = -{resolve_refmut_refmut_UF_T _25}- s22
      | s22 = s23 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UF_T uf} any) ]
      | s23 = -{resolve_Ghost_refmut_UF_T uf}- s24
      | s24 = new_unit {_101} (fun (_x: ()) -> [ &_100 <- _x ] s25)
      | s25 = [ &_ret <- y ] s26
      | s26 = return {_ret} ]
    | bb41 = s0
      [ s0 = -{resolve_refmut_PeanoInt ry}- s1
      | s1 = eq_refmut_PeanoInt {rx} {ry} (fun (_x: bool) -> [ &_110 <- _x ] s2)
      | s2 = any [ br0 -> {_110 = false} (! bb45) | br1 -> {_110} (! bb43) ] ]
    | bb43 = s0
      [ s0 = -{resolve_refmut_PeanoInt rx}- s1
      | s1 = incr {rx.current} (fun (_x: t_PeanoInt) -> [ &_113 <- _x ] s2)
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T bx} any) ]
      | s3 = -{resolve_refmut_Node_T bx}- s4
      | s4 = bb46 ]
    | bb45 = s0
      [ s0 = -{resolve_refmut_PeanoInt rx}- s1
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T bx} any) ]
      | s2 = -{resolve_refmut_Node_T bx}- s3
      | s3 = bb46 ]
    | bb46 = s0
      [ s0 = [ &_115 <- Link x ] s1
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_Node_T by'.current} any) ]
      | s2 = -{resolve_Node_T by'.current}- s3
      | s3 = [ &by' <- { by' with current = _115 } ] s4
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_Node_T by'} any) ]
      | s5 = -{resolve_refmut_Node_T by'}- s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T m'0} any) ]
      | s7 = -{resolve_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T m'0}- s8
      | s8 = [ &_119 <- fun (z: t_Elem) -> if index_Mapping_Elem_Elem uf'0.current.roots z = y then
          x
        else
          index_Mapping_Elem_Elem uf'0.current.roots z
         ] s9
      | s9 = MutBorrow.borrow_mut <MutBorrow.t t_UFInner_T> {uf'0}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UFInner_T)) ->
            [ &_125 <- _bor ] -{inv_Ghost_refmut_UFInner_T _bor.final}-
            [ &uf'0 <- _bor.final ] s10) [ _ck -> (! {inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s10 = deref_mut_Ghost_refmut_UFInner_T {_125}
          (fun (_x: MutBorrow.t (MutBorrow.t t_UFInner_T)) -> [ &_124 <- _x ] s11)
      | s11 =
        [ &_124 <- { _124 with current = { _124.current with current = { _124.current.current with roots = _119 } } } ]
        s12
      | s12 = s13 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UFInner_T _124} any) ]
      | s13 = -{resolve_refmut_refmut_UFInner_T _124}- s14
      | s14 = s15 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UFInner_T uf'0} any) ]
      | s15 = -{resolve_Ghost_refmut_UFInner_T uf'0}- s16
      | s16 = s17 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _25} any) ]
      | s17 = -{resolve_refmut_refmut_UF_T _25}- s18
      | s18 = s19 [ _ck -> (! {[@expl:type invariant] inv_Ghost_refmut_UF_T uf} any) ]
      | s19 = -{resolve_Ghost_refmut_UF_T uf}- s20
      | s20 = new_unit {_118} (fun (_x: ()) -> [ &_117 <- _x ] s21)
      | s21 = [ &_ret <- x ] s22
      | s22 = return {_ret} ] ]
    [ & _ret: t_Elem = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & x: t_Elem = x
    | & y: t_Elem = y
    | & __temp: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _25: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _26: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & uf'0: MutBorrow.t t_UFInner_T = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _34: () = Any.any_l ()
    | & _35: () = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & perm_x: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & m: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _44: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _45: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _46: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _47: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _49: t_Elem = Any.any_l ()
    | & _50: () = Any.any_l ()
    | & _51: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _53: t_Perm_ptr_Node_T = Any.any_l ()
    | & _54: t_Option_ref_Perm_ptr_Node_T = Any.any_l ()
    | & _57: t_Elem = Any.any_l ()
    | & perm_x'0: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & m'0: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _61: tup2_Ghost_refmut_Perm_ptr_Node_T_Ghost_refmut_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _62: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _63: tup2_refmut_Perm_ptr_Node_T_refmut_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _64: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _65: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _66: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _68: t_Elem = Any.any_l ()
    | & bx: MutBorrow.t t_Node_T = Any.any_l ()
    | & _70: MutBorrow.t t_Node_T = Any.any_l ()
    | & _71: Opaque.ptr = Any.any_l ()
    | & by': MutBorrow.t t_Node_T = Any.any_l ()
    | & _75: MutBorrow.t t_Node_T = Any.any_l ()
    | & _76: Opaque.ptr = Any.any_l ()
    | & _78: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _79: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _80: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _81: MutBorrow.t t_Perm_ptr_Node_T = Any.any_l ()
    | & _82: t_Option_refmut_Perm_ptr_Node_T = Any.any_l ()
    | & _83: MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T = Any.any_l ()
    | & _84: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) = Any.any_l ()
    | & _85: MutBorrow.t (MutBorrow.t t_FMap_Elem_Perm_ptr_Node_T) = Any.any_l ()
    | & _87: t_Elem = Any.any_l ()
    | & rx: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & ry: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _94: bool = Any.any_l ()
    | & _97: MutBorrow.t t_PeanoInt = Any.any_l ()
    | & _98: t_Node_T = Any.any_l ()
    | & _100: () = Any.any_l ()
    | & _101: () = Any.any_l ()
    | & _102: Map.map t_Elem t_Elem = Any.any_l ()
    | & _107: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _108: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _110: bool = Any.any_l ()
    | & _113: t_PeanoInt = Any.any_l ()
    | & _115: t_Node_T = Any.any_l ()
    | & _117: () = Any.any_l ()
    | & _118: () = Any.any_l ()
    | & _119: Map.map t_Elem t_Elem = Any.any_l ()
    | & _124: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l ()
    | & _125: MutBorrow.t (MutBorrow.t t_UFInner_T) = Any.any_l () ])
    [ return (result: t_Elem) -> {[@expl:link ensures #0] domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {[@expl:link ensures #1] result = root_T uf.current x \/ result = root_T uf.current y}
      {[@expl:link ensures #2] result = root_T (fin_Ghost_refmut_UF_T uf) result}
      {[@expl:link ensures #3] forall z: t_Elem. in_domain_T uf.current z
        -> root_T (fin_Ghost_refmut_UF_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
end
module M_implementation__union
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use set.Fset
  use map.Map
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use mach.int.Int
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Elem = { f0: Opaque.ptr }
  
  type t_FMap_Elem_Perm_ptr_Node_T
  
  type t_T
  
  type t_UFInner_T = {
    domain: Fset.fset t_Elem;
    perms: t_FMap_Elem_Perm_ptr_Node_T;
    payloads: Map.map t_Elem t_T;
    roots: Map.map t_Elem t_Elem }
  
  type t_UF_T = { f0'0: t_UFInner_T }
  
  predicate contains_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem
  
  type t_Perm_ptr_Node_T
  
  type t_Option_Perm_ptr_Node_T = None | Some t_Perm_ptr_Node_T
  
  function view_FMap_Elem_Perm_ptr_Node_T (self: t_FMap_Elem_Perm_ptr_Node_T) : Map.map t_Elem t_Option_Perm_ptr_Node_T
  
  function get_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Option_Perm_ptr_Node_T =
    Map.get (view_FMap_Elem_Perm_ptr_Node_T self) k
  
  meta "rewrite_def" function get_Elem
  
  predicate contains_Elem'0 [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) = get_Elem self k <> None
  
  meta "rewrite_def" predicate contains_Elem'0
  
  function tied_ptr_Node_T (self: t_Perm_ptr_Node_T) : Opaque.ptr
  
  predicate index_Mapping_Perm_ptr_Node_T_bool [@inline:trivial] (self: Map.map t_Perm_ptr_Node_T bool) (a: t_Perm_ptr_Node_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Perm_ptr_Node_T_bool
  
  function such_that_Perm_ptr_Node_T (p: Map.map t_Perm_ptr_Node_T bool) : t_Perm_ptr_Node_T
  
  axiom such_that_Perm_ptr_Node_T_spec:
    forall p: Map.map t_Perm_ptr_Node_T bool. (exists x: t_Perm_ptr_Node_T. index_Mapping_Perm_ptr_Node_T_bool p x)
      -> index_Mapping_Perm_ptr_Node_T_bool p (such_that_Perm_ptr_Node_T p)
  
  function unwrap_Option_Perm_ptr_Node_T (self: t_Option_Perm_ptr_Node_T) : t_Perm_ptr_Node_T = match self with
      | Some x -> x
      | None -> such_that_Perm_ptr_Node_T (fun (__0: t_Perm_ptr_Node_T) -> true)
      end
  
  function lookup_Elem [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (k: t_Elem) : t_Perm_ptr_Node_T =
    unwrap_Option_Perm_ptr_Node_T (get_Elem self k)
  
  meta "rewrite_def" function lookup_Elem
  
  function index_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) (key: t_Elem) : t_Perm_ptr_Node_T
   = lookup_Elem self key
  
  meta "rewrite_def" function index_FMap_Elem_Perm_ptr_Node_T
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Node_T = Root t_PeanoInt t_T | Link t_Elem
  
  function val_ptr_Node_T (self: t_Perm_ptr_Node_T) : t_Node_T
  
  function index_Mapping_Elem_T [@inline:trivial] (self: Map.map t_Elem t_T) (a: t_Elem) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_T
  
  predicate invariant_UF_T [@inline:trivial] (self: t_UF_T) =
    forall e: t_Elem. contains_Elem self.f0'0.domain e
      -> contains_Elem'0 self.f0'0.perms e
      /\ tied_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) = e.f0
      /\ contains_Elem self.f0'0.domain (index_Mapping_Elem_Elem self.f0'0.roots e)
      /\ index_Mapping_Elem_Elem self.f0'0.roots (index_Mapping_Elem_Elem self.f0'0.roots e)
        = index_Mapping_Elem_Elem self.f0'0.roots e
      /\ match val_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self.f0'0.perms e) with
        | Link e2 -> contains_Elem self.f0'0.domain e2
        /\ index_Mapping_Elem_Elem self.f0'0.roots e <> e
        /\ index_Mapping_Elem_Elem self.f0'0.roots e = index_Mapping_Elem_Elem self.f0'0.roots e2
        | Root _ payload -> index_Mapping_Elem_Elem self.f0'0.roots e = e
        /\ index_Mapping_Elem_T self.f0'0.payloads e = payload
        end
  
  meta "rewrite_def" predicate invariant_UF_T
  
  predicate inv_Elem [@inline:trivial] (_1: t_Elem) = true
  
  meta "rewrite_def" predicate inv_Elem
  
  predicate is_null_ptr_Node_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  predicate ptr_is_aligned_opaque_Node_T (self: t_Perm_ptr_Node_T)
  
  predicate metadata_matches_Node_T [@inline:trivial] (_value: t_Node_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_Node_T
  
  function metadata_Node_T (_1: Opaque.ptr) : ()
  
  constant size_of_Node_T : int
  
  axiom size_of_Node_T_spec: 0 <= size_of_Node_T
  
  axiom nonzero_size_of_Node_T: size_of_Node_T > 0
  
  function size_of_val_Node_T [@inline:trivial] (val': t_Node_T) : int = size_of_Node_T
  
  meta "rewrite_def" function size_of_val_Node_T
  
  axiom size_of_val_Node_T_spec: forall val': t_Node_T. 0 <= size_of_val_Node_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Node_T (_1: t_Node_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_T [inv_Node_T x]. inv_Node_T x
      = match x with
        | Root rank payload -> inv_T payload
        | Link f0'2 -> true
        end
  
  predicate invariant_ref_Node_T [@inline:trivial] (self: t_Node_T) = inv_Node_T self
  
  meta "rewrite_def" predicate invariant_ref_Node_T
  
  predicate inv_ref_Node_T [@inline:trivial] (_1: t_Node_T) = invariant_ref_Node_T _1
  
  meta "rewrite_def" predicate inv_ref_Node_T
  
  predicate invariant_Perm_ptr_Node_T (self: t_Perm_ptr_Node_T) =
    not is_null_ptr_Node_T (tied_ptr_Node_T self)
    /\ ptr_is_aligned_opaque_Node_T self
    /\ metadata_matches_Node_T (val_ptr_Node_T self) (metadata_Node_T (tied_ptr_Node_T self))
    /\ size_of_val_Node_T (val_ptr_Node_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (tied_ptr_Node_T self)) + size_of_val_Node_T (val_ptr_Node_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_Node_T (val_ptr_Node_T self)
  
  predicate inv_Perm_ptr_Node_T (_1: t_Perm_ptr_Node_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Perm_ptr_Node_T [inv_Perm_ptr_Node_T x]. inv_Perm_ptr_Node_T x
      = invariant_Perm_ptr_Node_T x
  
  predicate invariant_FMap_Elem_Perm_ptr_Node_T [@inline:trivial] (self: t_FMap_Elem_Perm_ptr_Node_T) =
    forall k: t_Elem. contains_Elem'0 self k
      -> inv_Elem k /\ inv_Perm_ptr_Node_T (index_FMap_Elem_Perm_ptr_Node_T self k)
  
  meta "rewrite_def" predicate invariant_FMap_Elem_Perm_ptr_Node_T
  
  predicate inv_FMap_Elem_Perm_ptr_Node_T (_1: t_FMap_Elem_Perm_ptr_Node_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_FMap_Elem_Perm_ptr_Node_T [inv_FMap_Elem_Perm_ptr_Node_T x]. inv_FMap_Elem_Perm_ptr_Node_T x
      = invariant_FMap_Elem_Perm_ptr_Node_T x
  
  predicate inv_UFInner_T (_1: t_UFInner_T)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_UFInner_T [inv_UFInner_T x]. inv_UFInner_T x
      = inv_FMap_Elem_Perm_ptr_Node_T x.perms
  
  predicate inv_UF_T (_1: t_UF_T)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_UF_T [inv_UF_T x]. inv_UF_T x = (invariant_UF_T x /\ inv_UFInner_T x.f0'0)
  
  predicate invariant_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) =
    inv_UF_T self.current /\ inv_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_UF_T
  
  predicate inv_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_UF_T
  
  predicate invariant_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) = inv_refmut_UF_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_UF_T
  
  predicate inv_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = invariant_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_UF_T
  
  predicate invariant_refmut_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_Ghost_refmut_UF_T self.current /\ inv_Ghost_refmut_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Ghost_refmut_UF_T
  
  predicate inv_refmut_Ghost_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_refmut_Ghost_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_Ghost_refmut_UF_T
  
  predicate invariant_refmut_refmut_UF_T [@inline:trivial] (self: MutBorrow.t (MutBorrow.t t_UF_T)) =
    inv_refmut_UF_T self.current /\ inv_refmut_UF_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_refmut_UF_T
  
  predicate inv_refmut_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) =
    invariant_refmut_refmut_UF_T _1
  
  meta "rewrite_def" predicate inv_refmut_refmut_UF_T
  
  let rec deref_mut_Ghost_refmut_UF_T (self: MutBorrow.t (MutBorrow.t t_UF_T))
    (return (x: MutBorrow.t (MutBorrow.t t_UF_T))) =
    {[@expl:deref_mut 'self' type invariant] inv_refmut_Ghost_refmut_UF_T self}
    any
    [ return (result: MutBorrow.t (MutBorrow.t t_UF_T)) -> {inv_refmut_refmut_UF_T result}
      {result = self}
      (! return {result}) ]
  
  predicate resolve_refmut_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t t_UF_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_refmut_UF_T
  
  predicate resolve_refmut_UF_T [@inline:trivial] (_1: MutBorrow.t t_UF_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_UF_T
  
  let rec new_refmut_UF_T (x: MutBorrow.t t_UF_T) (return (x'0: MutBorrow.t t_UF_T)) =
    {[@expl:new 'x' type invariant] inv_refmut_UF_T x}
    any [ return (result: MutBorrow.t t_UF_T) -> {inv_Ghost_refmut_UF_T result} {result = x} (! return {result}) ]
  
  function domain_T (self: t_UF_T) : Fset.fset t_Elem = self.f0'0.domain
  
  predicate in_domain_T (self: t_UF_T) (e: t_Elem) = contains_Elem (domain_T self) e
  
  function roots_map_T (self: t_UF_T) : Map.map t_Elem t_Elem = self.f0'0.roots
  
  axiom roots_map_T_spec: forall self: t_UF_T. inv_UF_T self
      -> (forall e: t_Elem. in_domain_T self e
        -> in_domain_T self (index_Mapping_Elem_Elem (roots_map_T self) e)
        /\ index_Mapping_Elem_Elem (roots_map_T self) e
        = index_Mapping_Elem_Elem (roots_map_T self) (index_Mapping_Elem_Elem (roots_map_T self) e))
  
  function root_T (self: t_UF_T) (e: t_Elem) : t_Elem = index_Mapping_Elem_Elem (roots_map_T self) e
  
  function payloads_map_T (self: t_UF_T) : Map.map t_Elem t_T = self.f0'0.payloads
  
  predicate unchanged_T (self: MutBorrow.t t_UF_T) =
    domain_T self.current = domain_T self.final
    /\ roots_map_T self.current = roots_map_T self.final /\ payloads_map_T self.current = payloads_map_T self.final
  
  let rec find_T (uf: MutBorrow.t t_UF_T) (elem: t_Elem) (return (x: t_Elem)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_refmut_UF_T uf}
    {[@expl:find requires] in_domain_T uf.current elem}
    any [ return (result: t_Elem) -> {result = root_T uf.current elem} {unchanged_T uf} (! return {result}) ]
  
  predicate domain_unchanged_T (self: MutBorrow.t t_UF_T) = domain_T self.current = domain_T self.final
  
  predicate payloads_unchanged_T (self: MutBorrow.t t_UF_T) = payloads_map_T self.current = payloads_map_T self.final
  
  function fin_Ghost_refmut_UF_T [@inline:trivial] (self: MutBorrow.t t_UF_T) : t_UF_T = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_UF_T
  
  let rec link_T (uf: MutBorrow.t t_UF_T) (x: t_Elem) (y: t_Elem) (return (x'0: t_Elem)) =
    {[@expl:link 'uf' type invariant] inv_Ghost_refmut_UF_T uf}
    {[@expl:link requires #0] in_domain_T uf.current x /\ in_domain_T uf.current y}
    {[@expl:link requires #1] root_T uf.current x = x /\ root_T uf.current y = y}
    any
    [ return (result: t_Elem) -> {domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {result = root_T uf.current x \/ result = root_T uf.current y}
      {result = root_T (fin_Ghost_refmut_UF_T uf) result}
      {forall z: t_Elem. in_domain_T uf.current z
        -> root_T (fin_Ghost_refmut_UF_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec union_T (uf: MutBorrow.t t_UF_T) (x: t_Elem) (y: t_Elem) (return (x'0: t_Elem)) =
    {[@expl:union 'uf' type invariant] inv_Ghost_refmut_UF_T uf}
    {[@expl:union requires] in_domain_T uf.current x /\ in_domain_T uf.current y}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_24 <- _bor ] -{inv_Ghost_refmut_UF_T _bor.final}-
            [ &uf <- _bor.final ] s1) [ _ck -> (! {inv_Ghost_refmut_UF_T uf} any) ]
      | s1 = deref_mut_Ghost_refmut_UF_T {_24} (fun (_x: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_23 <- _x ] s2)
      | s2 = MutBorrow.borrow_mut <t_UF_T> {_23.current.current}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_22 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_23 <- { _23 with current = { _23.current with current = _bor.final } } ] s3)
        [ _ck -> (! {inv_UF_T _23.current.current} any) ]
      | s3 = MutBorrow.borrow_final <t_UF_T> {_22.current} {MutBorrow.get_id _22}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_21 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_22 <- { _22 with current = _bor.final } ] s4) [ _ck -> (! {inv_UF_T _22.current} any) ]
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _23} any) ]
      | s5 = -{resolve_refmut_refmut_UF_T _23}- s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_UF_T _22} any) ]
      | s7 = -{resolve_refmut_UF_T _22}- s8
      | s8 = MutBorrow.borrow_final <t_UF_T> {_21.current} {MutBorrow.get_id _21}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_20 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_21 <- { _21 with current = _bor.final } ] s9) [ _ck -> (! {inv_UF_T _21.current} any) ]
      | s9 = new_refmut_UF_T {_20} (fun (_x: MutBorrow.t t_UF_T) -> [ &_19 <- _x ] s10)
      | s10 = s11 [ _ck -> (! {[@expl:type invariant] inv_refmut_UF_T _21} any) ]
      | s11 = -{resolve_refmut_UF_T _21}- s12
      | s12 = find_T {_19} {x} (fun (_x: t_Elem) -> [ &rx <- _x ] s13)
      | s13 = MutBorrow.borrow_mut <MutBorrow.t t_UF_T> {uf}
          (fun (_bor: MutBorrow.t (MutBorrow.t t_UF_T)) ->
            [ &_32 <- _bor ] -{inv_Ghost_refmut_UF_T _bor.final}-
            [ &uf <- _bor.final ] s14) [ _ck -> (! {inv_Ghost_refmut_UF_T uf} any) ]
      | s14 = deref_mut_Ghost_refmut_UF_T {_32} (fun (_x: MutBorrow.t (MutBorrow.t t_UF_T)) -> [ &_31 <- _x ] s15)
      | s15 = MutBorrow.borrow_mut <t_UF_T> {_31.current.current}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_30 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_31 <- { _31 with current = { _31.current with current = _bor.final } } ] s16)
        [ _ck -> (! {inv_UF_T _31.current.current} any) ]
      | s16 = MutBorrow.borrow_final <t_UF_T> {_30.current} {MutBorrow.get_id _30}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_29 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_30 <- { _30 with current = _bor.final } ] s17) [ _ck -> (! {inv_UF_T _30.current} any) ]
      | s17 = s18 [ _ck -> (! {[@expl:type invariant] inv_refmut_refmut_UF_T _31} any) ]
      | s18 = -{resolve_refmut_refmut_UF_T _31}- s19
      | s19 = s20 [ _ck -> (! {[@expl:type invariant] inv_refmut_UF_T _30} any) ]
      | s20 = -{resolve_refmut_UF_T _30}- s21
      | s21 = MutBorrow.borrow_final <t_UF_T> {_29.current} {MutBorrow.get_id _29}
          (fun (_bor: MutBorrow.t t_UF_T) ->
            [ &_28 <- _bor ] -{inv_UF_T _bor.final}-
            [ &_29 <- { _29 with current = _bor.final } ] s22) [ _ck -> (! {inv_UF_T _29.current} any) ]
      | s22 = new_refmut_UF_T {_28} (fun (_x: MutBorrow.t t_UF_T) -> [ &_27 <- _x ] s23)
      | s23 = s24 [ _ck -> (! {[@expl:type invariant] inv_refmut_UF_T _29} any) ]
      | s24 = -{resolve_refmut_UF_T _29}- s25
      | s25 = find_T {_27} {y} (fun (_x: t_Elem) -> [ &ry <- _x ] s26)
      | s26 = link_T {uf} {rx} {ry} (fun (_x: t_Elem) -> [ &_ret <- _x ] s27)
      | s27 = return {_ret} ] ]
    [ & _ret: t_Elem = Any.any_l ()
    | & uf: MutBorrow.t t_UF_T = uf
    | & x: t_Elem = x
    | & y: t_Elem = y
    | & rx: t_Elem = Any.any_l ()
    | & _19: MutBorrow.t t_UF_T = Any.any_l ()
    | & _20: MutBorrow.t t_UF_T = Any.any_l ()
    | & _21: MutBorrow.t t_UF_T = Any.any_l ()
    | & _22: MutBorrow.t t_UF_T = Any.any_l ()
    | & _23: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _24: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & ry: t_Elem = Any.any_l ()
    | & _27: MutBorrow.t t_UF_T = Any.any_l ()
    | & _28: MutBorrow.t t_UF_T = Any.any_l ()
    | & _29: MutBorrow.t t_UF_T = Any.any_l ()
    | & _30: MutBorrow.t t_UF_T = Any.any_l ()
    | & _31: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l ()
    | & _32: MutBorrow.t (MutBorrow.t t_UF_T) = Any.any_l () ])
    [ return (result: t_Elem) -> {[@expl:union ensures #0] domain_unchanged_T uf /\ payloads_unchanged_T uf}
      {[@expl:union ensures #1] result = root_T uf.current x \/ result = root_T uf.current y}
      {[@expl:union ensures #2] forall z: t_Elem. in_domain_T uf.current z
        -> root_T (fin_Ghost_refmut_UF_T uf) z
        = (if root_T uf.current z = root_T uf.current x \/ root_T uf.current z = root_T uf.current y then
          result
        else
          root_T uf.current z
        )}
      (! return {result}) ]
end
module M_example
  use set.Fset
  use creusot.prelude.MutBorrow
  use creusot.int.Int32
  use map.Map
  use creusot.prelude.Any
  
  type t_UF_i32
  
  predicate invariant_UF_i32 (self: t_UF_i32)
  
  predicate inv_UF_i32 (_1: t_UF_i32)
  
  axiom inv_axiom: forall x: t_UF_i32 [inv_UF_i32 x]. inv_UF_i32 x -> invariant_UF_i32 x
  
  predicate invariant_Ghost_UF_i32 [@inline:trivial] (self: t_UF_i32) = inv_UF_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_UF_i32
  
  predicate inv_Ghost_UF_i32 [@inline:trivial] (_1: t_UF_i32) = invariant_Ghost_UF_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_UF_i32
  
  type t_Elem
  
  function domain_i32 (self: t_UF_i32) : Fset.fset t_Elem
  
  let rec new_i32 (return (x: t_UF_i32)) = any
    [ return (result: t_UF_i32) -> {inv_Ghost_UF_i32 result} {Fset.is_empty (domain_i32 result)} (! return {result}) ]
  
  predicate invariant_refmut_Ghost_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) =
    inv_Ghost_UF_i32 self.current /\ inv_Ghost_UF_i32 self.final
  
  meta "rewrite_def" predicate invariant_refmut_Ghost_UF_i32
  
  predicate inv_refmut_Ghost_UF_i32 [@inline:trivial] (_1: MutBorrow.t t_UF_i32) = invariant_refmut_Ghost_UF_i32 _1
  
  meta "rewrite_def" predicate inv_refmut_Ghost_UF_i32
  
  predicate invariant_refmut_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) =
    inv_UF_i32 self.current /\ inv_UF_i32 self.final
  
  meta "rewrite_def" predicate invariant_refmut_UF_i32
  
  predicate inv_refmut_UF_i32 [@inline:trivial] (_1: MutBorrow.t t_UF_i32) = invariant_refmut_UF_i32 _1
  
  meta "rewrite_def" predicate inv_refmut_UF_i32
  
  predicate invariant_Ghost_refmut_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) = inv_refmut_UF_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_UF_i32
  
  predicate inv_Ghost_refmut_UF_i32 [@inline:trivial] (_1: MutBorrow.t t_UF_i32) = invariant_Ghost_refmut_UF_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_UF_i32
  
  let rec borrow_mut_UF_i32 (self: MutBorrow.t t_UF_i32) (return (x: MutBorrow.t t_UF_i32)) =
    {[@expl:borrow_mut 'self' type invariant] inv_refmut_Ghost_UF_i32 self}
    any
    [ return (result: MutBorrow.t t_UF_i32) -> {inv_Ghost_refmut_UF_i32 result} {result = self} (! return {result}) ]
  
  predicate inv_Elem (_1: t_Elem)
  
  predicate contains_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Elem
  
  predicate in_domain_i32 (self: t_UF_i32) (e: t_Elem) = contains_Elem (domain_i32 self) e
  
  function fin_Ghost_refmut_UF_i32 [@inline:trivial] (self: MutBorrow.t t_UF_i32) : t_UF_i32 = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_UF_i32
  
  function insert_Elem [@inline:trivial] (self: Fset.fset t_Elem) (e: t_Elem) : Fset.fset t_Elem = Fset.add e self
  
  meta "rewrite_def" function insert_Elem
  
  function index_Mapping_Elem_Elem [@inline:trivial] (self: Map.map t_Elem t_Elem) (a: t_Elem) : t_Elem = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_Elem
  
  function roots_map_i32 (self: t_UF_i32) : Map.map t_Elem t_Elem
  
  axiom roots_map_i32_spec: forall self: t_UF_i32. inv_UF_i32 self
      -> (forall e: t_Elem. in_domain_i32 self e
        -> in_domain_i32 self (index_Mapping_Elem_Elem (roots_map_i32 self) e)
        /\ index_Mapping_Elem_Elem (roots_map_i32 self) e
        = index_Mapping_Elem_Elem (roots_map_i32 self) (index_Mapping_Elem_Elem (roots_map_i32 self) e))
  
  function payloads_map_i32 (self: t_UF_i32) : Map.map t_Elem Int32.t
  
  let rec make_i32 (uf: MutBorrow.t t_UF_i32) (payload: Int32.t) (return (x: t_Elem)) =
    {[@expl:make 'uf' type invariant] inv_Ghost_refmut_UF_i32 uf}
    any
    [ return (result: t_Elem) -> {inv_Elem result}
      {not in_domain_i32 uf.current result}
      {domain_i32 (fin_Ghost_refmut_UF_i32 uf) = insert_Elem (domain_i32 uf.current) result}
      {roots_map_i32 (fin_Ghost_refmut_UF_i32 uf) = Map.set (roots_map_i32 uf.current) result result}
      {payloads_map_i32 (fin_Ghost_refmut_UF_i32 uf) = Map.set (payloads_map_i32 uf.current) result payload}
      (! return {result}) ]
  
  predicate invariant_ref_Ghost_UF_i32 [@inline:trivial] (self: t_UF_i32) = inv_Ghost_UF_i32 self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_UF_i32
  
  predicate inv_ref_Ghost_UF_i32 [@inline:trivial] (_1: t_UF_i32) = invariant_ref_Ghost_UF_i32 _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_UF_i32
  
  predicate invariant_ref_UF_i32 [@inline:trivial] (self: t_UF_i32) = inv_UF_i32 self
  
  meta "rewrite_def" predicate invariant_ref_UF_i32
  
  predicate inv_ref_UF_i32 [@inline:trivial] (_1: t_UF_i32) = invariant_ref_UF_i32 _1
  
  meta "rewrite_def" predicate inv_ref_UF_i32
  
  predicate invariant_Ghost_ref_UF_i32 [@inline:trivial] (self: t_UF_i32) = inv_ref_UF_i32 self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_UF_i32
  
  predicate inv_Ghost_ref_UF_i32 [@inline:trivial] (_1: t_UF_i32) = invariant_Ghost_ref_UF_i32 _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_UF_i32
  
  let rec borrow_UF_i32 (self: t_UF_i32) (return (x: t_UF_i32)) =
    {[@expl:borrow 'self' type invariant] inv_ref_Ghost_UF_i32 self}
    any [ return (result: t_UF_i32) -> {inv_Ghost_ref_UF_i32 result} {result = self} (! return {result}) ]
  
  function root_i32 (self: t_UF_i32) (e: t_Elem) : t_Elem = index_Mapping_Elem_Elem (roots_map_i32 self) e
  
  function index_Mapping_Elem_i32 [@inline:trivial] (self: Map.map t_Elem Int32.t) (a: t_Elem) : Int32.t =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Elem_i32
  
  function payload_i32 (self: t_UF_i32) (e: t_Elem) : Int32.t = index_Mapping_Elem_i32 (payloads_map_i32 self) e
  
  let rec get_i32 (uf: t_UF_i32) (elem: t_Elem) (return (x: Int32.t)) =
    {[@expl:get 'uf' type invariant] inv_Ghost_ref_UF_i32 uf}
    {[@expl:get 'elem' type invariant] inv_Elem elem}
    {[@expl:get requires #0] in_domain_i32 uf elem}
    {[@expl:get requires #1] root_i32 uf elem = elem}
    any [ return (result: Int32.t) -> {result = payload_i32 uf elem} (! return {result}) ]
  
  predicate domain_unchanged_i32 (self: MutBorrow.t t_UF_i32) = domain_i32 self.current = domain_i32 self.final
  
  predicate payloads_unchanged_i32 (self: MutBorrow.t t_UF_i32) =
    payloads_map_i32 self.current = payloads_map_i32 self.final
  
  let rec union_i32 (uf: MutBorrow.t t_UF_i32) (x: t_Elem) (y: t_Elem) (return (x'0: t_Elem)) =
    {[@expl:union 'uf' type invariant] inv_Ghost_refmut_UF_i32 uf}
    {[@expl:union 'x' type invariant] inv_Elem x}
    {[@expl:union 'y' type invariant] inv_Elem y}
    {[@expl:union requires] in_domain_i32 uf.current x /\ in_domain_i32 uf.current y}
    any
    [ return (result: t_Elem) -> {inv_Elem result}
      {domain_unchanged_i32 uf /\ payloads_unchanged_i32 uf}
      {result = root_i32 uf.current x \/ result = root_i32 uf.current y}
      {forall z: t_Elem. in_domain_i32 uf.current z
        -> root_i32 (fin_Ghost_refmut_UF_i32 uf) z
        = (if root_i32 uf.current z = root_i32 uf.current x \/ root_i32 uf.current z = root_i32 uf.current y then
          result
        else
          root_i32 uf.current z
        )}
      (! return {result}) ]
  
  predicate unchanged_i32 (self: MutBorrow.t t_UF_i32) =
    domain_i32 self.current = domain_i32 self.final
    /\ roots_map_i32 self.current = roots_map_i32 self.final
    /\ payloads_map_i32 self.current = payloads_map_i32 self.final
  
  let rec find_i32 (uf: MutBorrow.t t_UF_i32) (elem: t_Elem) (return (x: t_Elem)) =
    {[@expl:find 'uf' type invariant] inv_Ghost_refmut_UF_i32 uf}
    {[@expl:find 'elem' type invariant] inv_Elem elem}
    {[@expl:find requires] in_domain_i32 uf.current elem}
    any
    [ return (result: t_Elem) -> {inv_Elem result}
      {result = root_i32 uf.current elem}
      {unchanged_i32 uf}
      (! return {result}) ]
  
  predicate resolve_UF_i32 (_1: t_UF_i32)
  
  predicate resolve_Ghost_UF_i32 [@inline:trivial] (_1: t_UF_i32) = resolve_UF_i32 _1
  
  meta "rewrite_def" predicate resolve_Ghost_UF_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = new_i32 (fun (_x: t_UF_i32) -> [ &uf <- _x ] s1)
      | s1 = MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_bor: MutBorrow.t t_UF_i32) -> [ &_4 <- _bor ] -{inv_Ghost_UF_i32 _bor.final}- [ &uf <- _bor.final ] s2)
        [ _ck -> (! {inv_Ghost_UF_i32 uf} any) ]
      | s2 = borrow_mut_UF_i32 {_4} (fun (_x: MutBorrow.t t_UF_i32) -> [ &_3 <- _x ] s3)
      | s3 = make_i32 {_3} {(1: Int32.t)} (fun (_x: t_Elem) -> [ &x <- _x ] s4)
      | s4 = MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_bor: MutBorrow.t t_UF_i32) -> [ &_7 <- _bor ] -{inv_Ghost_UF_i32 _bor.final}- [ &uf <- _bor.final ] s5)
        [ _ck -> (! {inv_Ghost_UF_i32 uf} any) ]
      | s5 = borrow_mut_UF_i32 {_7} (fun (_x: MutBorrow.t t_UF_i32) -> [ &_6 <- _x ] s6)
      | s6 = make_i32 {_6} {(2: Int32.t)} (fun (_x: t_Elem) -> [ &y <- _x ] s7)
      | s7 = MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_bor: MutBorrow.t t_UF_i32) ->
            [ &_10 <- _bor ] -{inv_Ghost_UF_i32 _bor.final}-
            [ &uf <- _bor.final ] s8) [ _ck -> (! {inv_Ghost_UF_i32 uf} any) ]
      | s8 = borrow_mut_UF_i32 {_10} (fun (_x: MutBorrow.t t_UF_i32) -> [ &_9 <- _x ] s9)
      | s9 = make_i32 {_9} {(3: Int32.t)} (fun (_x: t_Elem) -> [ &z <- _x ] s10)
      | s10 = borrow_UF_i32 {uf} (fun (_x: t_UF_i32) -> [ &_15 <- _x ] s11)
      | s11 = get_i32 {_15} {x} (fun (_x: Int32.t) -> [ &_14 <- _x ] s12)
      | s12 = [ &_12 <- _14 = (1: Int32.t) ] s13
      | s13 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0
      [ s0 = borrow_UF_i32 {uf} (fun (_x: t_UF_i32) -> [ &_23 <- _x ] s1)
      | s1 = get_i32 {_23} {y} (fun (_x: Int32.t) -> [ &_22 <- _x ] s2)
      | s2 = [ &_20 <- _22 = (2: Int32.t) ] s3
      | s3 = any [ br0 -> {_20 = false} (! bb15) | br1 -> {_20} (! bb14) ] ]
    | bb14 = s0
      [ s0 = borrow_UF_i32 {uf} (fun (_x: t_UF_i32) -> [ &_31 <- _x ] s1)
      | s1 = get_i32 {_31} {z} (fun (_x: Int32.t) -> [ &_30 <- _x ] s2)
      | s2 = [ &_28 <- _30 = (3: Int32.t) ] s3
      | s3 = any [ br0 -> {_28 = false} (! bb19) | br1 -> {_28} (! bb18) ] ]
    | bb18 = s0
      [ s0 = MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_bor: MutBorrow.t t_UF_i32) ->
            [ &_37 <- _bor ] -{inv_Ghost_UF_i32 _bor.final}-
            [ &uf <- _bor.final ] s1) [ _ck -> (! {inv_Ghost_UF_i32 uf} any) ]
      | s1 = borrow_mut_UF_i32 {_37} (fun (_x: MutBorrow.t t_UF_i32) -> [ &_36 <- _x ] s2)
      | s2 = union_i32 {_36} {x} {y} (fun (_x: t_Elem) -> [ &_35 <- _x ] s3)
      | s3 = MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_bor: MutBorrow.t t_UF_i32) ->
            [ &_42 <- _bor ] -{inv_Ghost_UF_i32 _bor.final}-
            [ &uf <- _bor.final ] s4) [ _ck -> (! {inv_Ghost_UF_i32 uf} any) ]
      | s4 = borrow_mut_UF_i32 {_42} (fun (_x: MutBorrow.t t_UF_i32) -> [ &_41 <- _x ] s5)
      | s5 = find_i32 {_41} {x} (fun (_x: t_Elem) -> [ &xr <- _x ] s6)
      | s6 = MutBorrow.borrow_mut <t_UF_i32> {uf}
          (fun (_bor: MutBorrow.t t_UF_i32) ->
            [ &_46 <- _bor ] -{inv_Ghost_UF_i32 _bor.final}-
            [ &uf <- _bor.final ] s7) [ _ck -> (! {inv_Ghost_UF_i32 uf} any) ]
      | s7 = borrow_mut_UF_i32 {_46} (fun (_x: MutBorrow.t t_UF_i32) -> [ &_45 <- _x ] s8)
      | s8 = find_i32 {_45} {y} (fun (_x: t_Elem) -> [ &yr <- _x ] s9)
      | s9 = borrow_UF_i32 {uf} (fun (_x: t_UF_i32) -> [ &_52 <- _x ] s10)
      | s10 = get_i32 {_52} {xr} (fun (_x: Int32.t) -> [ &_51 <- _x ] s11)
      | s11 = borrow_UF_i32 {uf} (fun (_x: t_UF_i32) -> [ &_57 <- _x ] s12)
      | s12 = get_i32 {_57} {yr} (fun (_x: Int32.t) -> [ &_56 <- _x ] s13)
      | s13 = [ &_49 <- _51 = _56 ] s14
      | s14 = any [ br0 -> {_49 = false} (! bb31) | br1 -> {_49} (! bb30) ] ]
    | bb30 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Ghost_UF_i32 uf} any) ]
      | s1 = -{resolve_Ghost_UF_i32 uf}- s2
      | s2 = borrow_UF_i32 {uf} (fun (_x: t_UF_i32) -> [ &_65 <- _x ] s3)
      | s3 = get_i32 {_65} {z} (fun (_x: Int32.t) -> [ &_64 <- _x ] s4)
      | s4 = [ &_62 <- _64 = (3: Int32.t) ] s5
      | s5 = any [ br0 -> {_62 = false} (! bb35) | br1 -> {_62} (! bb34) ] ]
    | bb34 = return {_ret}
    | bb35 = {false} any
    | bb31 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Ghost_UF_i32 uf} any) ]
      | s1 = -{resolve_Ghost_UF_i32 uf}- s2
      | s2 = {false} any ]
    | bb19 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Ghost_UF_i32 uf} any) ]
      | s1 = -{resolve_Ghost_UF_i32 uf}- s2
      | s2 = {false} any ]
    | bb15 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Ghost_UF_i32 uf} any) ]
      | s1 = -{resolve_Ghost_UF_i32 uf}- s2
      | s2 = {false} any ]
    | bb11 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Ghost_UF_i32 uf} any) ]
      | s1 = -{resolve_Ghost_UF_i32 uf}- s2
      | s2 = {false} any ] ]
    [ & _ret: () = Any.any_l ()
    | & uf: t_UF_i32 = Any.any_l ()
    | & x: t_Elem = Any.any_l ()
    | & _3: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _4: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & y: t_Elem = Any.any_l ()
    | & _6: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _7: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & z: t_Elem = Any.any_l ()
    | & _9: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _10: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _15: t_UF_i32 = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _23: t_UF_i32 = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _31: t_UF_i32 = Any.any_l ()
    | & _35: t_Elem = Any.any_l ()
    | & _36: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _37: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & xr: t_Elem = Any.any_l ()
    | & _41: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _42: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & yr: t_Elem = Any.any_l ()
    | & _45: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _46: MutBorrow.t t_UF_i32 = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: Int32.t = Any.any_l ()
    | & _52: t_UF_i32 = Any.any_l ()
    | & _56: Int32.t = Any.any_l ()
    | & _57: t_UF_i32 = Any.any_l ()
    | & _62: bool = Any.any_l ()
    | & _64: Int32.t = Any.any_l ()
    | & _65: t_UF_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_implementation__impl_PartialEq_for_Elem__eq__refines (* <implementation::Elem as std::cmp::PartialEq> *)
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  
  type t_Elem = { f0: Opaque.ptr }
  
  function deep_model_Elem [@inline:trivial] (self: t_Elem) : UInt64.t = Ptr.addr_logic_u64 self.f0
  
  meta "rewrite_def" function deep_model_Elem
  
  function deep_model_ref_Elem [@inline:trivial] (self: t_Elem) : UInt64.t = deep_model_Elem self
  
  meta "rewrite_def" function deep_model_ref_Elem
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Elem. forall rhs: t_Elem. forall result: bool. result
            = (deep_model_ref_Elem self_ = deep_model_ref_Elem rhs)
          -> result = (deep_model_ref_Elem self_ = deep_model_ref_Elem rhs)
end
