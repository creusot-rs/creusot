module M_agree__agreement [#"agree.rs" 6 0 6 62]
  let%span sagree = "agree.rs" 4 11 4 27
  let%span sagree'0 = "agree.rs" 5 10 5 18
  let%span sagree'1 = "../../../creusot-contracts/src/logic/ra/agree.rs" 47 14 50 5
  let%span sagree'2 = "../../../creusot-contracts/src/logic/ra/agree.rs" 52 8 62 9
  let%span sagree'3 = "../../../creusot-contracts/src/logic/ra/agree.rs" 67 14 67 32
  let%span sagree'4 = "../../../creusot-contracts/src/logic/ra/agree.rs" 72 14 72 44
  let%span sagree'5 = "../../../creusot-contracts/src/logic/ra/agree.rs" 17 8 26 9
  let%span sagree'6 = "../../../creusot-contracts/src/logic/ra/agree.rs" 32 8 35 9
  let%span sresource = "../../../creusot-contracts/src/resource.rs" 190 15 190 38
  let%span sresource'0 = "../../../creusot-contracts/src/resource.rs" 191 14 191 38
  let%span sresource'1 = "../../../creusot-contracts/src/resource.rs" 192 14 192 81
  let%span sresource'2 = "../../../creusot-contracts/src/resource.rs" 47 8 47 18
  let%span sresource'3 = "../../../creusot-contracts/src/resource.rs" 75 14 75 28
  let%span smodel = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sra = "../../../creusot-contracts/src/logic/ra.rs" 150 4 150 61
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Resource  =
    { t_Resource__0: () }
  
  type t_Id
  
  function id (self: t_Resource) : t_Id
  
  type t_Ag  =
    | C_Ag Int32.t
    | C_Bot
  
  type t_Option  =
    | C_None
    | C_Some t_Ag
  
  type tuple  =
    { _p0: t_Ag; _p1: t_Ag }
  
  function op (self: t_Ag) (other: t_Ag) : t_Ag =
    [%#sagree'5] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Ag x else C_Bot
      | _ -> C_Bot
      end
  
  function associative (a: t_Ag) (b: t_Ag) (c: t_Ag) : ()
  
  axiom associative_spec: forall a: t_Ag, b: t_Ag, c: t_Ag. [%#sagree'4] op (op a b) c = op a (op b c)
  
  function commutative (a: t_Ag) (b: t_Ag) : ()
  
  axiom commutative_spec: forall a: t_Ag, b: t_Ag. [%#sagree'3] op a b = op b a
  
  function incl (self: t_Ag) (other: t_Ag) : t_Option =
    [%#sagree'2] match { _p0 = self; _p1 = other } with
      | {_p0 = C_Ag x ; _p1 = C_Ag y} -> if x = y then C_Some (C_Ag x) else C_None
      | {_p1 = C_Bot} -> C_Some (C_Bot)
      | {_p1 = C_Ag _} -> C_None
      end
  
  axiom incl_spec: forall self: t_Ag, other: t_Ag. [%#sagree'1] match incl self other with
    | C_Some c -> op self c = other
    | C_None -> forall c: t_Ag. op self c <> other
    end
  
  function incl_eq (this: t_Ag) (other: t_Ag) : t_Option =
    [%#sra] if this = other then C_Some this else incl this other
  
  function valid (self: t_Ag) : bool =
    [%#sagree'6] match self with
      | C_Ag _ -> true
      | C_Bot -> false
      end
  
  function val' (self: t_Resource) : t_Ag
  
  axiom val_spec: forall self: t_Resource. [%#sresource'3] valid (val' self)
  
  function view (self: t_Resource) : t_Ag =
    [%#sresource'2] val' self
  
  function view'0 (self: t_Resource) : t_Ag =
    [%#smodel] view self
  
  let rec join_shared (self:t_Resource) (other:t_Resource) (return'  (x:t_Resource))= {[@expl:join_shared requires] [%#sresource] id self
    = id other}
    any
    [ return''0 (result:t_Resource)-> {[%#sresource'0] id result = id self}
      {[%#sresource'1] incl_eq (view'0 self) (view'0 result) <> C_None
      /\ incl_eq (view'0 other) (view'0 result) <> C_None}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec agreement[#"agree.rs" 6 0 6 62] (x:t_Resource) (y:t_Resource) (return'  (x'0:()))= {[@expl:agreement requires] [%#sagree] id x
    = id y}
    (! bb0
    [ bb0 = s0 [ s0 = join_shared {x'0} {y'0} (fun (_ret:t_Resource) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: () = Any.any_l () | & x'0: t_Resource = x | & y'0: t_Resource = y | & _5: t_Resource = Any.any_l () ] 
    [ return''0 (result:())-> {[@expl:agreement ensures] [%#sagree'0] view'0 x = view'0 y} (! return' {result}) ]

end
