module M_agreement
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Resource_Ag_i32
  
  type t_Id
  
  function id_Ag_i32 (self: t_Resource_Ag_i32) : t_Id
  
  type t_Ag_i32 = { f0: Int32.t }
  
  type t_Option_Ag_i32 = None | Some t_Ag_i32
  
  function op_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) : t_Option_Ag_i32 = if self.f0 = other.f0 then
      Some self
    else
      None
  
  
  function commutative_Ag_i32 (a: t_Ag_i32) (b: t_Ag_i32) : ()
  
  axiom commutative_Ag_i32_spec: forall a: t_Ag_i32, b: t_Ag_i32. op_Ag_i32 a b = op_Ag_i32 b a
  
  function factor_Ag_i32 (self: t_Ag_i32) (factor: t_Ag_i32) : t_Option_Ag_i32 = op_Ag_i32 self factor
  
  axiom factor_Ag_i32_spec: forall self: t_Ag_i32, factor: t_Ag_i32. match factor_Ag_i32 self factor with
        | Some c -> op_Ag_i32 factor c = Some self
        | None -> forall c: t_Ag_i32. op_Ag_i32 factor c <> Some self
        end
  
  predicate incl_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) = factor_Ag_i32 other self <> None
  
  function incl_transitive_Ag_i32 (a: t_Ag_i32) (b: t_Ag_i32) (c: t_Ag_i32) : ()
  
  axiom incl_transitive_Ag_i32_spec: forall a: t_Ag_i32, b: t_Ag_i32, c: t_Ag_i32. incl_Ag_i32 a b
      -> incl_Ag_i32 b c -> incl_Ag_i32 a c
  
  function associative_some_Ag_i32 (a: t_Ag_i32) (b: t_Ag_i32) (c: t_Ag_i32) (ab: t_Ag_i32) (bc: t_Ag_i32) : ()
  
  axiom associative_some_Ag_i32_spec:
    forall a: t_Ag_i32, b: t_Ag_i32, c: t_Ag_i32, ab: t_Ag_i32, bc: t_Ag_i32. op_Ag_i32 a b = Some ab
      -> op_Ag_i32 b c = Some bc -> op_Ag_i32 a bc = op_Ag_i32 ab c
  
  function associative_none_Ag_i32 (a: t_Ag_i32) (b: t_Ag_i32) (c: t_Ag_i32) (bc: t_Ag_i32) : ()
  
  axiom associative_none_Ag_i32_spec: forall a: t_Ag_i32, b: t_Ag_i32, c: t_Ag_i32, bc: t_Ag_i32. op_Ag_i32 a b = None
      -> op_Ag_i32 b c = Some bc -> op_Ag_i32 a bc = None
  
  function incl_op_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) (comb: t_Ag_i32) : ()
  
  axiom incl_op_Ag_i32_spec: forall self: t_Ag_i32, other: t_Ag_i32, comb: t_Ag_i32. op_Ag_i32 self other = Some comb
      -> incl_Ag_i32 self comb
  
  predicate eq_Ag_i32 [@inline:trivial] (self: t_Ag_i32) (other: t_Ag_i32) = self = other
  
  meta "rewrite_def" predicate eq_Ag_i32
  
  axiom eq_Ag_i32_spec: forall self: t_Ag_i32, other: t_Ag_i32. eq_Ag_i32 self other = (self = other)
  
  predicate incl_eq_Ag_i32 (self: t_Ag_i32) (other: t_Ag_i32) = eq_Ag_i32 self other \/ incl_Ag_i32 self other
  
  function val_Ag_i32 (self: t_Resource_Ag_i32) : t_Ag_i32
  
  function view_Resource_Ag_i32 [@inline:trivial] (self: t_Resource_Ag_i32) : t_Ag_i32 = val_Ag_i32 self
  
  meta "rewrite_def" function view_Resource_Ag_i32
  
  let rec join_shared_Ag_i32 (self: t_Resource_Ag_i32) (other: t_Resource_Ag_i32) (return (x: t_Resource_Ag_i32)) =
    {[@stop_split] [@expl:join_shared requires] id_Ag_i32 self = id_Ag_i32 other}
    any
    [ return (result: t_Resource_Ag_i32) ->
    {[@stop_split] [@expl:join_shared_Ag_i32 ensures] ([@stop_split] [@expl:join_shared ensures #0] id_Ag_i32 result
        = id_Ag_i32 self)
      /\ ([@stop_split] [@expl:join_shared ensures #1] incl_eq_Ag_i32 (view_Resource_Ag_i32 self) (view_Resource_Ag_i32 result)
      /\ incl_eq_Ag_i32 (view_Resource_Ag_i32 other) (view_Resource_Ag_i32 result))}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec agreement (x: t_Resource_Ag_i32) (y: t_Resource_Ag_i32) (return (x'0: ())) =
    {[@stop_split] [@expl:agreement requires] id_Ag_i32 x = id_Ag_i32 y}
    (! bb0
    [ bb0 = s0
      [ s0 = join_shared_Ag_i32 {x} {y} (fun (_x: t_Resource_Ag_i32) -> [ &_9 <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & x: t_Resource_Ag_i32 = x
    | & y: t_Resource_Ag_i32 = y
    | & _9: t_Resource_Ag_i32 = Any.any_l () ])
    [ return (result: ()) -> {[@stop_split] [@expl:agreement ensures] view_Resource_Ag_i32 x = view_Resource_Ag_i32 y}
      (! return {result}) ]
end
