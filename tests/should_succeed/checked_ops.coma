module M_test_u8_add_example
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ + UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec unwrap_u8 (self_: t_Option_u8) (return (x: UInt8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: UInt8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.add self_ rhs} (! return {result}) ]
  
  let rec saturating_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result = UInt8.t'int self_ + UInt8.t'int rhs}
      {UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX -> UInt8.t'int result = UInt8.t'int const_MAX}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ + UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ + UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_add_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_add {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_4 <- _x ] s1)
      | s1 = unwrap_u8 {_4} (fun (_x: UInt8.t) -> [ &_3 <- _x ] s2)
      | s2 = [ &_2 <- _3 = (15: UInt8.t) ] s3
      | s3 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_add {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_9 <- _x ] s1)
      | s1 = is_none_u8 {_9} (fun (_x: bool) -> [ &_7 <- _x ] s2)
      | s2 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = wrapping_add {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_13 <- _x ] s1)
      | s1 = [ &_12 <- _13 = (15: UInt8.t) ] s2
      | s2 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0
      [ s0 = wrapping_add {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_17 <- _x ] s1)
      | s1 = [ &_16 <- _17 = (4: UInt8.t) ] s2
      | s2 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ] ]
    | bb13 = s0
      [ s0 = saturating_add {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_21 <- _x ] s1)
      | s1 = [ &_20 <- _21 = (15: UInt8.t) ] s2
      | s2 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ] ]
    | bb16 = s0
      [ s0 = saturating_add {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_25 <- _x ] s1)
      | s1 = [ &_24 <- _25 = (255: UInt8.t) ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ] ]
    | bb19 = s0
      [ s0 = overflowing_add {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_29 <- res.f0 = (15: UInt8.t) ] s2
      | s2 = any [ br0 -> {_29 = false} (! bb26) | br1 -> {_29} (! bb22) ] ]
    | bb22 = s0
      [ s0 = [ &_31 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_31 = false} (! bb26) | br1 -> {_31} (! bb23) ] ]
    | bb23 = s0
      [ s0 = overflowing_add {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: tup2_u8_bool) -> [ &res'0 <- _x ] s1)
      | s1 = [ &_36 <- res'0.f0 = (4: UInt8.t) ] s2
      | s2 = any [ br0 -> {_36 = false} (! bb32) | br1 -> {_36} (! bb28) ] ]
    | bb28 = s0 [ s0 = [ &_38 <- res'0.f1 ] s1 | s1 = any [ br0 -> {_38 = false} (! bb32) | br1 -> {_38} (! bb29) ] ]
    | bb29 = return {_ret}
    | bb32 = {false} any
    | bb26 = {false} any
    | bb20 = {false} any
    | bb17 = {false} any
    | bb14 = {false} any
    | bb11 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: UInt8.t = Any.any_l ()
    | & _4: t_Option_u8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option_u8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _25: UInt8.t = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & res'0: tup2_u8_bool = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _38: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_add_overflow
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ + UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.add self_ rhs} (! return {result}) ]
  
  let rec saturating_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result = UInt8.t'int self_ + UInt8.t'int rhs}
      {UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX -> UInt8.t'int result = UInt8.t'int const_MAX}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ + UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ + UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_add_overflow (a: UInt8.t) (return (x: ())) = {[@expl:test_u8_add_overflow requires] UInt8.t'int a
    <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add {(255: UInt8.t)} {a} (fun (_x: t_Option_u8) -> [ &_7 <- _x ] s1)
      | s1 = is_none_u8 {_7} (fun (_x: bool) -> [ &_5 <- _x ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_add {(255: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_12 <- _x ] s1)
      | s1 = UInt8.sub {a} {(1: UInt8.t)} (fun (_x: UInt8.t) -> [ &_14 <- _x ] s2)
      | s2 = [ &_11 <- _12 = _14 ] s3
      | s3 = any [ br0 -> {_11 = false} (! bb7) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_add {(255: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_19 <- _x ] s1)
      | s1 = [ &_18 <- _19 = (255: UInt8.t) ] s2
      | s2 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_add {(255: UInt8.t)} {a} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = UInt8.sub {a} {(1: UInt8.t)} (fun (_x: UInt8.t) -> [ &_27 <- _x ] s2)
      | s2 = [ &_25 <- res.f0 = _27 ] s3
      | s3 = any [ br0 -> {_25 = false} (! bb16) | br1 -> {_25} (! bb12) ] ]
    | bb12 = s0 [ s0 = [ &_29 <- res.f1 ] s1 | s1 = any [ br0 -> {_29 = false} (! bb16) | br1 -> {_29} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: UInt8.t = a
    | & _5: bool = Any.any_l ()
    | & _7: t_Option_u8 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: UInt8.t = Any.any_l ()
    | & _14: UInt8.t = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _19: UInt8.t = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _27: UInt8.t = Any.any_l ()
    | & _29: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_wrapping_add
  use creusot.int.UInt8
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.add self_ rhs} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_wrapping_add (a: UInt8.t) (b: UInt8.t) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_add {a} {b} (fun (_x: UInt8.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: UInt8.t = Any.any_l () | & a: UInt8.t = a | & b: UInt8.t = b ])
    [ return (result: UInt8.t) -> {[@expl:test_u8_wrapping_add ensures] UInt8.t'int result
        = UInt8.t'int a + UInt8.t'int b
      \/ UInt8.t'int result = UInt8.t'int a + UInt8.t'int b - 256}
      (! return {result}) ]
end
module M_test_u8_overflowing_add
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec overflowing_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ + UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ + UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  let rec wrapping_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.add self_ rhs} (! return {result}) ]
  
  type t_Option_u8 = None | Some UInt8.t
  
  let rec checked_add (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ + UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_overflowing_add (a: UInt8.t) (b: UInt8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = overflowing_add {a} {b} (fun (_x: tup2_u8_bool) -> [ &_6 <- _x ] s1)
      | s1 = wrapping_add {a} {b} (fun (_x: UInt8.t) -> [ &_9 <- _x ] s2)
      | s2 = [ &_4 <- _6.f0 = _9 ] s3
      | s3 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] ]
    | bb3 = s0
      [ s0 = overflowing_add {a} {b} (fun (_x: tup2_u8_bool) -> [ &_16 <- _x ] s1)
      | s1 = checked_add {a} {b} (fun (_x: t_Option_u8) -> [ &_21 <- _x ] s2)
      | s2 = is_none_u8 {_21} (fun (_x: bool) -> [ &_19 <- _x ] s3)
      | s3 = [ &_14 <- _16.f1 = _19 ] s4
      | s4 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ] ]
    | bb8 = return {_ret}
    | bb9 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: UInt8.t = a
    | & b: UInt8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tup2_u8_bool = Any.any_l ()
    | & _9: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tup2_u8_bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option_u8 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_sub_example
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ - UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec unwrap_u8 (self_: t_Option_u8) (return (x: UInt8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: UInt8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec wrapping_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.sub self_ rhs} (! return {result}) ]
  
  let rec saturating_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result = UInt8.t'int self_ - UInt8.t'int rhs}
      {UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX -> UInt8.t'int result = UInt8.t'int const_MAX}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ - UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ - UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_sub_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_4 <- _x ] s1)
      | s1 = is_none_u8 {_4} (fun (_x: bool) -> [ &_2 <- _x ] s2)
      | s2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_sub {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_9 <- _x ] s1)
      | s1 = unwrap_u8 {_9} (fun (_x: UInt8.t) -> [ &_8 <- _x ] s2)
      | s2 = [ &_7 <- _8 = (240: UInt8.t) ] s3
      | s3 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = wrapping_sub {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_13 <- _x ] s1)
      | s1 = [ &_12 <- _13 = (251: UInt8.t) ] s2
      | s2 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0
      [ s0 = wrapping_sub {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_17 <- _x ] s1)
      | s1 = [ &_16 <- _17 = (240: UInt8.t) ] s2
      | s2 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ] ]
    | bb13 = s0
      [ s0 = saturating_sub {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_21 <- _x ] s1)
      | s1 = [ &_20 <- _21 = (0: UInt8.t) ] s2
      | s2 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ] ]
    | bb16 = s0
      [ s0 = saturating_sub {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_25 <- _x ] s1)
      | s1 = [ &_24 <- _25 = (240: UInt8.t) ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ] ]
    | bb19 = s0
      [ s0 = overflowing_sub {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_29 <- res.f0 = (251: UInt8.t) ] s2
      | s2 = any [ br0 -> {_29 = false} (! bb26) | br1 -> {_29} (! bb22) ] ]
    | bb22 = s0 [ s0 = [ &_31 <- res.f1 ] s1 | s1 = any [ br0 -> {_31 = false} (! bb26) | br1 -> {_31} (! bb23) ] ]
    | bb23 = s0
      [ s0 = overflowing_sub {(250: UInt8.t)} {(10: UInt8.t)} (fun (_x: tup2_u8_bool) -> [ &res'0 <- _x ] s1)
      | s1 = [ &_36 <- res'0.f0 = (240: UInt8.t) ] s2
      | s2 = any [ br0 -> {_36 = false} (! bb32) | br1 -> {_36} (! bb28) ] ]
    | bb28 = s0
      [ s0 = [ &_38 <- res'0.f1 = false ] s1 | s1 = any [ br0 -> {_38 = false} (! bb32) | br1 -> {_38} (! bb29) ] ]
    | bb29 = return {_ret}
    | bb32 = {false} any
    | bb26 = {false} any
    | bb20 = {false} any
    | bb17 = {false} any
    | bb14 = {false} any
    | bb11 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _4: t_Option_u8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: UInt8.t = Any.any_l ()
    | & _9: t_Option_u8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _25: UInt8.t = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & res'0: tup2_u8_bool = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _38: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_sub_overflow
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ - UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.sub self_ rhs} (! return {result}) ]
  
  let rec saturating_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result = UInt8.t'int self_ - UInt8.t'int rhs}
      {UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX -> UInt8.t'int result = UInt8.t'int const_MAX}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ - UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ - UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_sub_overflow (a: UInt8.t) (return (x: ())) = {[@expl:test_u8_sub_overflow requires] UInt8.t'int a
    <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {(0: UInt8.t)} {a} (fun (_x: t_Option_u8) -> [ &_7 <- _x ] s1)
      | s1 = is_none_u8 {_7} (fun (_x: bool) -> [ &_5 <- _x ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_sub {(0: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_12 <- _x ] s1)
      | s1 = UInt8.sub {(255: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_15 <- _x ] s2)
      | s2 = UInt8.add {_15} {(1: UInt8.t)} (fun (_x: UInt8.t) -> [ &_14 <- _x ] s3)
      | s3 = [ &_11 <- _12 = _14 ] s4
      | s4 = any [ br0 -> {_11 = false} (! bb7) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_sub {(0: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_20 <- _x ] s1)
      | s1 = [ &_19 <- _20 = (0: UInt8.t) ] s2
      | s2 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_sub {(0: UInt8.t)} {a} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = UInt8.sub {(255: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_29 <- _x ] s2)
      | s2 = UInt8.add {_29} {(1: UInt8.t)} (fun (_x: UInt8.t) -> [ &_28 <- _x ] s3)
      | s3 = [ &_26 <- res.f0 = _28 ] s4
      | s4 = any [ br0 -> {_26 = false} (! bb16) | br1 -> {_26} (! bb12) ] ]
    | bb12 = s0 [ s0 = [ &_31 <- res.f1 ] s1 | s1 = any [ br0 -> {_31 = false} (! bb16) | br1 -> {_31} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: UInt8.t = a
    | & _5: bool = Any.any_l ()
    | & _7: t_Option_u8 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: UInt8.t = Any.any_l ()
    | & _14: UInt8.t = Any.any_l ()
    | & _15: UInt8.t = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: UInt8.t = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: UInt8.t = Any.any_l ()
    | & _29: UInt8.t = Any.any_l ()
    | & _31: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_wrapping_sub
  use creusot.int.UInt8
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.sub self_ rhs} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_wrapping_sub (a: UInt8.t) (b: UInt8.t) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub {a} {b} (fun (_x: UInt8.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: UInt8.t = Any.any_l () | & a: UInt8.t = a | & b: UInt8.t = b ])
    [ return (result: UInt8.t) -> {[@expl:test_u8_wrapping_sub ensures] UInt8.t'int result
        = UInt8.t'int a - UInt8.t'int b
      \/ UInt8.t'int result = UInt8.t'int a - UInt8.t'int b + 256}
      (! return {result}) ]
end
module M_test_u8_overflowing_sub
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec overflowing_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ - UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ - UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  let rec wrapping_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.sub self_ rhs} (! return {result}) ]
  
  type t_Option_u8 = None | Some UInt8.t
  
  let rec checked_sub (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ - UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_overflowing_sub (a: UInt8.t) (b: UInt8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = overflowing_sub {a} {b} (fun (_x: tup2_u8_bool) -> [ &_6 <- _x ] s1)
      | s1 = wrapping_sub {a} {b} (fun (_x: UInt8.t) -> [ &_9 <- _x ] s2)
      | s2 = [ &_4 <- _6.f0 = _9 ] s3
      | s3 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] ]
    | bb3 = s0
      [ s0 = overflowing_sub {a} {b} (fun (_x: tup2_u8_bool) -> [ &_16 <- _x ] s1)
      | s1 = checked_sub {a} {b} (fun (_x: t_Option_u8) -> [ &_21 <- _x ] s2)
      | s2 = is_none_u8 {_21} (fun (_x: bool) -> [ &_19 <- _x ] s3)
      | s3 = [ &_14 <- _16.f1 = _19 ] s4
      | s4 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ] ]
    | bb8 = return {_ret}
    | bb9 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: UInt8.t = a
    | & b: UInt8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tup2_u8_bool = Any.any_l ()
    | & _9: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tup2_u8_bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option_u8 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_mul_example
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ * UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec unwrap_u8 (self_: t_Option_u8) (return (x: UInt8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: UInt8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.mul self_ rhs} (! return {result}) ]
  
  let rec saturating_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result = UInt8.t'int self_ * UInt8.t'int rhs}
      {UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX -> UInt8.t'int result = UInt8.t'int const_MAX}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ * UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ * UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_mul_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_4 <- _x ] s1)
      | s1 = unwrap_u8 {_4} (fun (_x: UInt8.t) -> [ &_3 <- _x ] s2)
      | s2 = [ &_2 <- _3 = (50: UInt8.t) ] s3
      | s3 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_mul {(50: UInt8.t)} {(10: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_9 <- _x ] s1)
      | s1 = is_none_u8 {_9} (fun (_x: bool) -> [ &_7 <- _x ] s2)
      | s2 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = wrapping_mul {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_13 <- _x ] s1)
      | s1 = [ &_12 <- _13 = (50: UInt8.t) ] s2
      | s2 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0
      [ s0 = wrapping_mul {(50: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_17 <- _x ] s1)
      | s1 = [ &_16 <- _17 = (244: UInt8.t) ] s2
      | s2 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ] ]
    | bb13 = s0
      [ s0 = saturating_mul {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_21 <- _x ] s1)
      | s1 = [ &_20 <- _21 = (50: UInt8.t) ] s2
      | s2 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ] ]
    | bb16 = s0
      [ s0 = saturating_mul {(50: UInt8.t)} {(10: UInt8.t)} (fun (_x: UInt8.t) -> [ &_25 <- _x ] s1)
      | s1 = [ &_24 <- _25 = (255: UInt8.t) ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ] ]
    | bb19 = s0
      [ s0 = overflowing_mul {(5: UInt8.t)} {(10: UInt8.t)} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_29 <- res.f0 = (50: UInt8.t) ] s2
      | s2 = any [ br0 -> {_29 = false} (! bb26) | br1 -> {_29} (! bb22) ] ]
    | bb22 = s0
      [ s0 = [ &_31 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_31 = false} (! bb26) | br1 -> {_31} (! bb23) ] ]
    | bb23 = s0
      [ s0 = overflowing_mul {(50: UInt8.t)} {(10: UInt8.t)} (fun (_x: tup2_u8_bool) -> [ &res'0 <- _x ] s1)
      | s1 = [ &_36 <- res'0.f0 = (244: UInt8.t) ] s2
      | s2 = any [ br0 -> {_36 = false} (! bb32) | br1 -> {_36} (! bb28) ] ]
    | bb28 = s0 [ s0 = [ &_38 <- res'0.f1 ] s1 | s1 = any [ br0 -> {_38 = false} (! bb32) | br1 -> {_38} (! bb29) ] ]
    | bb29 = return {_ret}
    | bb32 = {false} any
    | bb26 = {false} any
    | bb20 = {false} any
    | bb17 = {false} any
    | bb14 = {false} any
    | bb11 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: UInt8.t = Any.any_l ()
    | & _4: t_Option_u8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option_u8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _25: UInt8.t = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & res'0: tup2_u8_bool = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _38: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_mul_zero
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ * UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec unwrap_u8 (self_: t_Option_u8) (return (x: UInt8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: UInt8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec wrapping_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.mul self_ rhs} (! return {result}) ]
  
  let rec saturating_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result = UInt8.t'int self_ * UInt8.t'int rhs}
      {UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX -> UInt8.t'int result = UInt8.t'int const_MAX}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ * UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ * UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_mul_zero (a: UInt8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {(0: UInt8.t)} {a} (fun (_x: t_Option_u8) -> [ &_5 <- _x ] s1)
      | s1 = unwrap_u8 {_5} (fun (_x: UInt8.t) -> [ &_4 <- _x ] s2)
      | s2 = [ &_3 <- _4 = (0: UInt8.t) ] s3
      | s3 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_mul {(0: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_10 <- _x ] s1)
      | s1 = [ &_9 <- _10 = (0: UInt8.t) ] s2
      | s2 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_mul {(0: UInt8.t)} {a} (fun (_x: UInt8.t) -> [ &_15 <- _x ] s1)
      | s1 = [ &_14 <- _15 = (0: UInt8.t) ] s2
      | s2 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_mul {(0: UInt8.t)} {a} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_21 <- res.f0 = (0: UInt8.t) ] s2
      | s2 = any [ br0 -> {_21 = false} (! bb16) | br1 -> {_21} (! bb12) ] ]
    | bb12 = s0
      [ s0 = [ &_23 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_23 = false} (! bb16) | br1 -> {_23} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: UInt8.t = a
    | & _3: bool = Any.any_l ()
    | & _4: UInt8.t = Any.any_l ()
    | & _5: t_Option_u8 = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: UInt8.t = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_overflowing_mul
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  constant const_MAX: UInt8.t = (255: UInt8.t)
  
  let rec overflowing_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) = any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int const_MIN
        /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int const_MAX
      -> UInt8.t'int result.f0 = UInt8.t'int self_ * UInt8.t'int rhs}
      {exists k: int. UInt8.t'int result.f0
        = UInt8.t'int self_ * UInt8.t'int rhs + k * (UInt8.t'int const_MAX - UInt8.t'int const_MIN + 1)}
      {result.f1
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX)}
      (! return {result}) ]
  
  let rec wrapping_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) = any
    [ return (result: UInt8.t) -> {result = UInt8.mul self_ rhs} (! return {result}) ]
  
  type t_Option_u8 = None | Some UInt8.t
  
  let rec checked_mul (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int const_MIN
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int const_MAX)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = UInt8.t'int self_ * UInt8.t'int rhs}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_overflowing_mul (a: UInt8.t) (b: UInt8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = overflowing_mul {a} {b} (fun (_x: tup2_u8_bool) -> [ &_6 <- _x ] s1)
      | s1 = wrapping_mul {a} {b} (fun (_x: UInt8.t) -> [ &_9 <- _x ] s2)
      | s2 = [ &_4 <- _6.f0 = _9 ] s3
      | s3 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] ]
    | bb3 = s0
      [ s0 = overflowing_mul {a} {b} (fun (_x: tup2_u8_bool) -> [ &_16 <- _x ] s1)
      | s1 = checked_mul {a} {b} (fun (_x: t_Option_u8) -> [ &_21 <- _x ] s2)
      | s2 = is_none_u8 {_21} (fun (_x: bool) -> [ &_19 <- _x ] s3)
      | s3 = [ &_14 <- _16.f1 = _19 ] s4
      | s4 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ] ]
    | bb8 = return {_ret}
    | bb9 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: UInt8.t = a
    | & b: UInt8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tup2_u8_bool = Any.any_l ()
    | & _9: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tup2_u8_bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option_u8 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_div_example
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  let rec checked_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec unwrap_u8 (self_: t_Option_u8) (return (x: UInt8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: UInt8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec wrapping_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) =
    {[@expl:wrapping_div requires] UInt8.t'int rhs <> 0}
    any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      -> UInt8.t'int result = UInt8.t'int self_}
      {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return {result}) ]
  
  let rec saturating_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) =
    {[@expl:saturating_div requires] UInt8.t'int rhs <> 0}
    any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) =
    {[@expl:overflowing_div requires] UInt8.t'int rhs <> 0}
    any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      -> UInt8.t'int result.f0 = UInt8.t'int self_}
      {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result.f0 = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      {result.f1 = (UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_div_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_div {(5: UInt8.t)} {(0: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_4 <- _x ] s1)
      | s1 = is_none_u8 {_4} (fun (_x: bool) -> [ &_2 <- _x ] s2)
      | s2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_div {(5: UInt8.t)} {(2: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_9 <- _x ] s1)
      | s1 = unwrap_u8 {_9} (fun (_x: UInt8.t) -> [ &_8 <- _x ] s2)
      | s2 = [ &_7 <- _8 = (2: UInt8.t) ] s3
      | s3 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = wrapping_div {(5: UInt8.t)} {(2: UInt8.t)} (fun (_x: UInt8.t) -> [ &_13 <- _x ] s1)
      | s1 = [ &_12 <- _13 = (2: UInt8.t) ] s2
      | s2 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ] ]
    | bb10 = s0
      [ s0 = saturating_div {(5: UInt8.t)} {(2: UInt8.t)} (fun (_x: UInt8.t) -> [ &_17 <- _x ] s1)
      | s1 = [ &_16 <- _17 = (2: UInt8.t) ] s2
      | s2 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ] ]
    | bb13 = s0
      [ s0 = overflowing_div {(5: UInt8.t)} {(2: UInt8.t)} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_21 <- res.f0 = (2: UInt8.t) ] s2
      | s2 = any [ br0 -> {_21 = false} (! bb20) | br1 -> {_21} (! bb16) ] ]
    | bb16 = s0
      [ s0 = [ &_23 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_23 = false} (! bb20) | br1 -> {_23} (! bb17) ] ]
    | bb17 = return {_ret}
    | bb20 = {false} any
    | bb14 = {false} any
    | bb11 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _4: t_Option_u8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: UInt8.t = Any.any_l ()
    | & _9: t_Option_u8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_div_no_overflow
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  let rec checked_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return {result}) ]
  
  let rec unwrap_u8 (self_: t_Option_u8) (return (x: UInt8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: UInt8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec wrapping_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) =
    {[@expl:wrapping_div requires] UInt8.t'int rhs <> 0}
    any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      -> UInt8.t'int result = UInt8.t'int self_}
      {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return {result}) ]
  
  let rec saturating_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: UInt8.t)) =
    {[@expl:saturating_div requires] UInt8.t'int rhs <> 0}
    any
    [ return (result: UInt8.t) -> {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      -> UInt8.t'int result = UInt8.t'int const_MIN}
      {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return {result}) ]
  
  type tup2_u8_bool = { f0: UInt8.t; f1: bool }
  
  let rec overflowing_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: tup2_u8_bool)) =
    {[@expl:overflowing_div requires] UInt8.t'int rhs <> 0}
    any
    [ return (result: tup2_u8_bool) -> {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      -> UInt8.t'int result.f0 = UInt8.t'int self_}
      {UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result.f0 = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      {result.f1 = (UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_div_no_overflow (a: UInt8.t) (b: UInt8.t) (return (x: ())) =
    {[@expl:test_u8_div_no_overflow requires] UInt8.t'int b <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_div {a} {b} (fun (_x: t_Option_u8) -> [ &_8 <- _x ] s1)
      | s1 = unwrap_u8 {_8} (fun (_x: UInt8.t) -> [ &_7 <- _x ] s2)
      | s2 = [ &_13 <- b ] s3
      | s3 = [ &_14 <- _13 = (0: UInt8.t) ] s4
      | s4 = {[@expl:division by zero] not _14} s5
      | s5 = UInt8.div {a} {_13} (fun (_x: UInt8.t) -> [ &_11 <- _x ] s6)
      | s6 = [ &_6 <- _7 = _11 ] s7
      | s7 = any [ br0 -> {_6 = false} (! bb5) | br1 -> {_6} (! bb4) ] ]
    | bb4 = s0
      [ s0 = wrapping_div {a} {b} (fun (_x: UInt8.t) -> [ &_18 <- _x ] s1)
      | s1 = [ &_23 <- b ] s2
      | s2 = [ &_24 <- _23 = (0: UInt8.t) ] s3
      | s3 = {[@expl:division by zero] not _24} s4
      | s4 = UInt8.div {a} {_23} (fun (_x: UInt8.t) -> [ &_21 <- _x ] s5)
      | s5 = [ &_17 <- _18 = _21 ] s6
      | s6 = any [ br0 -> {_17 = false} (! bb9) | br1 -> {_17} (! bb8) ] ]
    | bb8 = s0
      [ s0 = saturating_div {a} {b} (fun (_x: UInt8.t) -> [ &_28 <- _x ] s1)
      | s1 = [ &_33 <- b ] s2
      | s2 = [ &_34 <- _33 = (0: UInt8.t) ] s3
      | s3 = {[@expl:division by zero] not _34} s4
      | s4 = UInt8.div {a} {_33} (fun (_x: UInt8.t) -> [ &_31 <- _x ] s5)
      | s5 = [ &_27 <- _28 = _31 ] s6
      | s6 = any [ br0 -> {_27 = false} (! bb13) | br1 -> {_27} (! bb12) ] ]
    | bb12 = s0
      [ s0 = overflowing_div {a} {b} (fun (_x: tup2_u8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_44 <- b ] s2
      | s2 = [ &_45 <- _44 = (0: UInt8.t) ] s3
      | s3 = {[@expl:division by zero] not _45} s4
      | s4 = UInt8.div {a} {_44} (fun (_x: UInt8.t) -> [ &_42 <- _x ] s5)
      | s5 = [ &_40 <- res.f0 = _42 ] s6
      | s6 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb16) ] ]
    | bb16 = s0
      [ s0 = [ &_46 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_46 = false} (! bb20) | br1 -> {_46} (! bb17) ] ]
    | bb17 = return {_ret}
    | bb20 = {false} any
    | bb13 = {false} any
    | bb9 = {false} any
    | bb5 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: UInt8.t = a
    | & b: UInt8.t = b
    | & _6: bool = Any.any_l ()
    | & _7: UInt8.t = Any.any_l ()
    | & _8: t_Option_u8 = Any.any_l ()
    | & _11: UInt8.t = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: UInt8.t = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _23: UInt8.t = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _27: bool = Any.any_l ()
    | & _28: UInt8.t = Any.any_l ()
    | & _31: UInt8.t = Any.any_l ()
    | & _33: UInt8.t = Any.any_l ()
    | & _34: bool = Any.any_l ()
    | & res: tup2_u8_bool = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & _42: UInt8.t = Any.any_l ()
    | & _44: UInt8.t = Any.any_l ()
    | & _45: bool = Any.any_l ()
    | & _46: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_u8_div_zero
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_u8 = None | Some UInt8.t
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  let rec checked_div (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_u8)) = any
    [ return (result: t_Option_u8) -> {(result = None)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self_ = UInt8.t'int const_MIN /\ UInt8.t'int rhs = - 1)}
      {forall r: UInt8.t. result = Some r -> UInt8.t'int r = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return {result}) ]
  
  let rec is_none_u8 (self_: t_Option_u8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_u8_div_zero (a: UInt8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_div {a} {(0: UInt8.t)} (fun (_x: t_Option_u8) -> [ &_5 <- _x ] s1)
      | s1 = is_none_u8 {_5} (fun (_x: bool) -> [ &_3 <- _x ] s2)
      | s2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] ]
    | bb3 = return {_ret}
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l () | & a: UInt8.t = a | & _3: bool = Any.any_l () | & _5: t_Option_u8 = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_add_example
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_add (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return {result}) ]
  
  let rec unwrap_i8 (self_: t_Option_i8) (return (x: Int8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.add self_ rhs} (! return {result}) ]
  
  let rec saturating_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ + Int8.to_int rhs}
      {Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_add (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ + Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_add_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_add {(5: Int8.t)} {(10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_4 <- _x ] s1)
      | s1 = unwrap_i8 {_4} (fun (_x: Int8.t) -> [ &_3 <- _x ] s2)
      | s2 = [ &_2 <- _3 = (15: Int8.t) ] s3
      | s3 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_add {(120: Int8.t)} {(10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_9 <- _x ] s1)
      | s1 = is_none_i8 {_9} (fun (_x: bool) -> [ &_7 <- _x ] s2)
      | s2 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = checked_add {(-120: Int8.t)} {(-10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_14 <- _x ] s1)
      | s1 = is_none_i8 {_14} (fun (_x: bool) -> [ &_12 <- _x ] s2)
      | s2 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] ]
    | bb11 = s0
      [ s0 = wrapping_add {(5: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_18 <- _x ] s1)
      | s1 = [ &_17 <- _18 = (15: Int8.t) ] s2
      | s2 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ] ]
    | bb14 = s0
      [ s0 = wrapping_add {(120: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_22 <- _x ] s1)
      | s1 = [ &_21 <- _22 = (-126: Int8.t) ] s2
      | s2 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ] ]
    | bb17 = s0
      [ s0 = wrapping_add {(-120: Int8.t)} {(-10: Int8.t)} (fun (_x: Int8.t) -> [ &_26 <- _x ] s1)
      | s1 = [ &_25 <- _26 = (126: Int8.t) ] s2
      | s2 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ] ]
    | bb20 = s0
      [ s0 = saturating_add {(5: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_30 <- _x ] s1)
      | s1 = [ &_29 <- _30 = (15: Int8.t) ] s2
      | s2 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ] ]
    | bb23 = s0
      [ s0 = saturating_add {(120: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_34 <- _x ] s1)
      | s1 = [ &_33 <- _34 = (127: Int8.t) ] s2
      | s2 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ] ]
    | bb26 = s0
      [ s0 = saturating_add {(-120: Int8.t)} {(-10: Int8.t)} (fun (_x: Int8.t) -> [ &_38 <- _x ] s1)
      | s1 = [ &_37 <- _38 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ] ]
    | bb29 = s0
      [ s0 = overflowing_add {(5: Int8.t)} {(10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_42 <- res.f0 = (15: Int8.t) ] s2
      | s2 = any [ br0 -> {_42 = false} (! bb36) | br1 -> {_42} (! bb32) ] ]
    | bb32 = s0
      [ s0 = [ &_44 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_44 = false} (! bb36) | br1 -> {_44} (! bb33) ] ]
    | bb33 = s0
      [ s0 = overflowing_add {(120: Int8.t)} {(10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'0 <- _x ] s1)
      | s1 = [ &_49 <- res'0.f0 = (-126: Int8.t) ] s2
      | s2 = any [ br0 -> {_49 = false} (! bb42) | br1 -> {_49} (! bb38) ] ]
    | bb38 = s0 [ s0 = [ &_51 <- res'0.f1 ] s1 | s1 = any [ br0 -> {_51 = false} (! bb42) | br1 -> {_51} (! bb39) ] ]
    | bb39 = s0
      [ s0 = overflowing_add {(-120: Int8.t)} {(-10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'1 <- _x ] s1)
      | s1 = [ &_56 <- res'1.f0 = (126: Int8.t) ] s2
      | s2 = any [ br0 -> {_56 = false} (! bb48) | br1 -> {_56} (! bb44) ] ]
    | bb44 = s0 [ s0 = [ &_58 <- res'1.f1 ] s1 | s1 = any [ br0 -> {_58 = false} (! bb48) | br1 -> {_58} (! bb45) ] ]
    | bb45 = return {_ret}
    | bb48 = {false} any
    | bb42 = {false} any
    | bb36 = {false} any
    | bb30 = {false} any
    | bb27 = {false} any
    | bb24 = {false} any
    | bb21 = {false} any
    | bb18 = {false} any
    | bb15 = {false} any
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: Int8.t = Any.any_l ()
    | & _4: t_Option_i8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option_i8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: t_Option_i8 = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: Int8.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int8.t = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int8.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _34: Int8.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & res'0: tup2_i8_bool = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & res'1: tup2_i8_bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_add_overflow_pos
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_add (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.add self_ rhs} (! return {result}) ]
  
  let rec saturating_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ + Int8.to_int rhs}
      {Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_add (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ + Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_add_overflow_pos (a: Int8.t) (return (x: ())) =
    {[@expl:test_i8_add_overflow_pos requires] Int8.to_int a > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add {(127: Int8.t)} {a} (fun (_x: t_Option_i8) -> [ &_7 <- _x ] s1)
      | s1 = is_none_i8 {_7} (fun (_x: bool) -> [ &_5 <- _x ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_add {(127: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_12 <- _x ] s1)
      | s1 = Int8.sub {a} {(127: Int8.t)} (fun (_x: Int8.t) -> [ &_15 <- _x ] s2)
      | s2 = Int8.sub {_15} {(2: Int8.t)} (fun (_x: Int8.t) -> [ &_14 <- _x ] s3)
      | s3 = [ &_11 <- _12 = _14 ] s4
      | s4 = any [ br0 -> {_11 = false} (! bb7) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_add {(127: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_20 <- _x ] s1)
      | s1 = [ &_19 <- _20 = (127: Int8.t) ] s2
      | s2 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_add {(127: Int8.t)} {a} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = Int8.sub {a} {(127: Int8.t)} (fun (_x: Int8.t) -> [ &_29 <- _x ] s2)
      | s2 = Int8.sub {_29} {(2: Int8.t)} (fun (_x: Int8.t) -> [ &_28 <- _x ] s3)
      | s3 = [ &_26 <- res.f0 = _28 ] s4
      | s4 = any [ br0 -> {_26 = false} (! bb16) | br1 -> {_26} (! bb12) ] ]
    | bb12 = s0 [ s0 = [ &_31 <- res.f1 ] s1 | s1 = any [ br0 -> {_31 = false} (! bb16) | br1 -> {_31} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & _5: bool = Any.any_l ()
    | & _7: t_Option_i8 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _15: Int8.t = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: Int8.t = Any.any_l ()
    | & _29: Int8.t = Any.any_l ()
    | & _31: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_add_overflow_neg
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_add (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.add self_ rhs} (! return {result}) ]
  
  let rec saturating_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ + Int8.to_int rhs}
      {Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_add (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ + Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_add_overflow_neg (a: Int8.t) (return (x: ())) =
    {[@expl:test_i8_add_overflow_neg requires] Int8.to_int a < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add {(-128: Int8.t)} {a} (fun (_x: t_Option_i8) -> [ &_7 <- _x ] s1)
      | s1 = is_none_i8 {_7} (fun (_x: bool) -> [ &_5 <- _x ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_add {(-128: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_12 <- _x ] s1)
      | s1 = Int8.add {a} {(127: Int8.t)} (fun (_x: Int8.t) -> [ &_15 <- _x ] s2)
      | s2 = Int8.add {_15} {(1: Int8.t)} (fun (_x: Int8.t) -> [ &_14 <- _x ] s3)
      | s3 = [ &_11 <- _12 = _14 ] s4
      | s4 = any [ br0 -> {_11 = false} (! bb7) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_add {(-128: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_20 <- _x ] s1)
      | s1 = [ &_19 <- _20 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_add {(-128: Int8.t)} {a} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = Int8.add {a} {(127: Int8.t)} (fun (_x: Int8.t) -> [ &_29 <- _x ] s2)
      | s2 = Int8.add {_29} {(1: Int8.t)} (fun (_x: Int8.t) -> [ &_28 <- _x ] s3)
      | s3 = [ &_26 <- res.f0 = _28 ] s4
      | s4 = any [ br0 -> {_26 = false} (! bb16) | br1 -> {_26} (! bb12) ] ]
    | bb12 = s0 [ s0 = [ &_31 <- res.f1 ] s1 | s1 = any [ br0 -> {_31 = false} (! bb16) | br1 -> {_31} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & _5: bool = Any.any_l ()
    | & _7: t_Option_i8 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _15: Int8.t = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: Int8.t = Any.any_l ()
    | & _29: Int8.t = Any.any_l ()
    | & _31: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_wrapping_add
  use creusot.int.Int8
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.add self_ rhs} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_wrapping_add (a: Int8.t) (b: Int8.t) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_add {a} {b} (fun (_x: Int8.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int8.t = Any.any_l () | & a: Int8.t = a | & b: Int8.t = b ])
    [ return (result: Int8.t) -> {[@expl:test_i8_wrapping_add ensures] Int8.to_int result
        = Int8.to_int a + Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256}
      (! return {result}) ]
end
module M_test_i8_overflowing_add
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec overflowing_add (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ + Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  let rec wrapping_add (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.add self_ rhs} (! return {result}) ]
  
  type t_Option_i8 = None | Some Int8.t
  
  let rec checked_add (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_overflowing_add (a: Int8.t) (b: Int8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = overflowing_add {a} {b} (fun (_x: tup2_i8_bool) -> [ &_6 <- _x ] s1)
      | s1 = wrapping_add {a} {b} (fun (_x: Int8.t) -> [ &_9 <- _x ] s2)
      | s2 = [ &_4 <- _6.f0 = _9 ] s3
      | s3 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] ]
    | bb3 = s0
      [ s0 = overflowing_add {a} {b} (fun (_x: tup2_i8_bool) -> [ &_16 <- _x ] s1)
      | s1 = checked_add {a} {b} (fun (_x: t_Option_i8) -> [ &_21 <- _x ] s2)
      | s2 = is_none_i8 {_21} (fun (_x: bool) -> [ &_19 <- _x ] s3)
      | s3 = [ &_14 <- _16.f1 = _19 ] s4
      | s4 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ] ]
    | bb8 = return {_ret}
    | bb9 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & b: Int8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tup2_i8_bool = Any.any_l ()
    | & _9: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tup2_i8_bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option_i8 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_sub_example
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_sub (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return {result}) ]
  
  let rec unwrap_i8 (self_: t_Option_i8) (return (x: Int8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.sub self_ rhs} (! return {result}) ]
  
  let rec saturating_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ - Int8.to_int rhs}
      {Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_sub (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ - Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_sub_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {(5: Int8.t)} {(10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_4 <- _x ] s1)
      | s1 = unwrap_i8 {_4} (fun (_x: Int8.t) -> [ &_3 <- _x ] s2)
      | s2 = [ &_2 <- _3 = (-5: Int8.t) ] s3
      | s3 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_sub {(120: Int8.t)} {(10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_9 <- _x ] s1)
      | s1 = unwrap_i8 {_9} (fun (_x: Int8.t) -> [ &_8 <- _x ] s2)
      | s2 = [ &_7 <- _8 = (110: Int8.t) ] s3
      | s3 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = checked_sub {(-120: Int8.t)} {(10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_14 <- _x ] s1)
      | s1 = is_none_i8 {_14} (fun (_x: bool) -> [ &_12 <- _x ] s2)
      | s2 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] ]
    | bb11 = s0
      [ s0 = wrapping_sub {(5: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_18 <- _x ] s1)
      | s1 = [ &_17 <- _18 = (-5: Int8.t) ] s2
      | s2 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ] ]
    | bb14 = s0
      [ s0 = wrapping_sub {(120: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_22 <- _x ] s1)
      | s1 = [ &_21 <- _22 = (110: Int8.t) ] s2
      | s2 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ] ]
    | bb17 = s0
      [ s0 = wrapping_sub {(-120: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_26 <- _x ] s1)
      | s1 = [ &_25 <- _26 = (126: Int8.t) ] s2
      | s2 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ] ]
    | bb20 = s0
      [ s0 = saturating_sub {(5: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_30 <- _x ] s1)
      | s1 = [ &_29 <- _30 = (-5: Int8.t) ] s2
      | s2 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ] ]
    | bb23 = s0
      [ s0 = saturating_sub {(120: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_34 <- _x ] s1)
      | s1 = [ &_33 <- _34 = (110: Int8.t) ] s2
      | s2 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ] ]
    | bb26 = s0
      [ s0 = saturating_sub {(-120: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_38 <- _x ] s1)
      | s1 = [ &_37 <- _38 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ] ]
    | bb29 = s0
      [ s0 = overflowing_sub {(5: Int8.t)} {(10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_42 <- res.f0 = (-5: Int8.t) ] s2
      | s2 = any [ br0 -> {_42 = false} (! bb36) | br1 -> {_42} (! bb32) ] ]
    | bb32 = s0
      [ s0 = [ &_44 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_44 = false} (! bb36) | br1 -> {_44} (! bb33) ] ]
    | bb33 = s0
      [ s0 = overflowing_sub {(120: Int8.t)} {(10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'0 <- _x ] s1)
      | s1 = [ &_49 <- res'0.f0 = (110: Int8.t) ] s2
      | s2 = any [ br0 -> {_49 = false} (! bb42) | br1 -> {_49} (! bb38) ] ]
    | bb38 = s0
      [ s0 = [ &_51 <- res'0.f1 = false ] s1 | s1 = any [ br0 -> {_51 = false} (! bb42) | br1 -> {_51} (! bb39) ] ]
    | bb39 = s0
      [ s0 = overflowing_sub {(-120: Int8.t)} {(10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'1 <- _x ] s1)
      | s1 = [ &_56 <- res'1.f0 = (126: Int8.t) ] s2
      | s2 = any [ br0 -> {_56 = false} (! bb48) | br1 -> {_56} (! bb44) ] ]
    | bb44 = s0 [ s0 = [ &_58 <- res'1.f1 ] s1 | s1 = any [ br0 -> {_58 = false} (! bb48) | br1 -> {_58} (! bb45) ] ]
    | bb45 = return {_ret}
    | bb48 = {false} any
    | bb42 = {false} any
    | bb36 = {false} any
    | bb30 = {false} any
    | bb27 = {false} any
    | bb24 = {false} any
    | bb21 = {false} any
    | bb18 = {false} any
    | bb15 = {false} any
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: Int8.t = Any.any_l ()
    | & _4: t_Option_i8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: Int8.t = Any.any_l ()
    | & _9: t_Option_i8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: t_Option_i8 = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: Int8.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int8.t = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int8.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _34: Int8.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & res'0: tup2_i8_bool = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & res'1: tup2_i8_bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_sub_overflow_pos
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_sub (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.sub self_ rhs} (! return {result}) ]
  
  let rec saturating_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ - Int8.to_int rhs}
      {Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_sub (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ - Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_sub_overflow_pos (a: Int8.t) (return (x: ())) =
    {[@expl:test_i8_sub_overflow_pos requires] Int8.to_int a > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {(-128: Int8.t)} {a} (fun (_x: t_Option_i8) -> [ &_7 <- _x ] s1)
      | s1 = is_none_i8 {_7} (fun (_x: bool) -> [ &_5 <- _x ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_sub {(-128: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_12 <- _x ] s1)
      | s1 = Int8.sub {(127: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_15 <- _x ] s2)
      | s2 = Int8.add {_15} {(1: Int8.t)} (fun (_x: Int8.t) -> [ &_14 <- _x ] s3)
      | s3 = [ &_11 <- _12 = _14 ] s4
      | s4 = any [ br0 -> {_11 = false} (! bb7) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_sub {(-128: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_20 <- _x ] s1)
      | s1 = [ &_19 <- _20 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_sub {(-128: Int8.t)} {a} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = Int8.sub {(127: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_29 <- _x ] s2)
      | s2 = Int8.add {_29} {(1: Int8.t)} (fun (_x: Int8.t) -> [ &_28 <- _x ] s3)
      | s3 = [ &_26 <- res.f0 = _28 ] s4
      | s4 = any [ br0 -> {_26 = false} (! bb16) | br1 -> {_26} (! bb12) ] ]
    | bb12 = s0 [ s0 = [ &_31 <- res.f1 ] s1 | s1 = any [ br0 -> {_31 = false} (! bb16) | br1 -> {_31} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & _5: bool = Any.any_l ()
    | & _7: t_Option_i8 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _15: Int8.t = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: Int8.t = Any.any_l ()
    | & _29: Int8.t = Any.any_l ()
    | & _31: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_sub_overflow_neg
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_sub (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.sub self_ rhs} (! return {result}) ]
  
  let rec saturating_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ - Int8.to_int rhs}
      {Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_sub (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ - Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_sub_overflow_neg (a: Int8.t) (return (x: ())) =
    {[@expl:test_i8_sub_overflow_neg requires] Int8.to_int a < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {(127: Int8.t)} {a} (fun (_x: t_Option_i8) -> [ &_7 <- _x ] s1)
      | s1 = is_none_i8 {_7} (fun (_x: bool) -> [ &_5 <- _x ] s2)
      | s2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_sub {(127: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_12 <- _x ] s1)
      | s1 = Int8.add {(2: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_16 <- _x ] s2)
      | s2 = Int8.neg {_16} (fun (_x: Int8.t) -> [ &_15 <- _x ] s3)
      | s3 = Int8.sub {_15} {(127: Int8.t)} (fun (_x: Int8.t) -> [ &_14 <- _x ] s4)
      | s4 = [ &_11 <- _12 = _14 ] s5
      | s5 = any [ br0 -> {_11 = false} (! bb7) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_sub {(127: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_21 <- _x ] s1)
      | s1 = [ &_20 <- _21 = (127: Int8.t) ] s2
      | s2 = any [ br0 -> {_20 = false} (! bb10) | br1 -> {_20} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_sub {(127: Int8.t)} {a} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = Int8.add {(2: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_31 <- _x ] s2)
      | s2 = Int8.neg {_31} (fun (_x: Int8.t) -> [ &_30 <- _x ] s3)
      | s3 = Int8.sub {_30} {(127: Int8.t)} (fun (_x: Int8.t) -> [ &_29 <- _x ] s4)
      | s4 = [ &_27 <- res.f0 = _29 ] s5
      | s5 = any [ br0 -> {_27 = false} (! bb16) | br1 -> {_27} (! bb12) ] ]
    | bb12 = s0 [ s0 = [ &_33 <- res.f1 ] s1 | s1 = any [ br0 -> {_33 = false} (! bb16) | br1 -> {_33} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & _5: bool = Any.any_l ()
    | & _7: t_Option_i8 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _15: Int8.t = Any.any_l ()
    | & _16: Int8.t = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _21: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _27: bool = Any.any_l ()
    | & _29: Int8.t = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _31: Int8.t = Any.any_l ()
    | & _33: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_wrapping_sub
  use creusot.int.Int8
  use creusot.prelude.Any
  use mach.int.Int
  
  let rec wrapping_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.sub self_ rhs} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_wrapping_sub (a: Int8.t) (b: Int8.t) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub {a} {b} (fun (_x: Int8.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int8.t = Any.any_l () | & a: Int8.t = a | & b: Int8.t = b ])
    [ return (result: Int8.t) -> {[@expl:test_i8_wrapping_sub ensures] Int8.to_int result
        = Int8.to_int a - Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256}
      (! return {result}) ]
end
module M_test_i8_overflowing_sub
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec overflowing_sub (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ - Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  let rec wrapping_sub (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.sub self_ rhs} (! return {result}) ]
  
  type t_Option_i8 = None | Some Int8.t
  
  let rec checked_sub (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_overflowing_sub (a: Int8.t) (b: Int8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = overflowing_sub {a} {b} (fun (_x: tup2_i8_bool) -> [ &_6 <- _x ] s1)
      | s1 = wrapping_sub {a} {b} (fun (_x: Int8.t) -> [ &_9 <- _x ] s2)
      | s2 = [ &_4 <- _6.f0 = _9 ] s3
      | s3 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] ]
    | bb3 = s0
      [ s0 = overflowing_sub {a} {b} (fun (_x: tup2_i8_bool) -> [ &_16 <- _x ] s1)
      | s1 = checked_sub {a} {b} (fun (_x: t_Option_i8) -> [ &_21 <- _x ] s2)
      | s2 = is_none_i8 {_21} (fun (_x: bool) -> [ &_19 <- _x ] s3)
      | s3 = [ &_14 <- _16.f1 = _19 ] s4
      | s4 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ] ]
    | bb8 = return {_ret}
    | bb9 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & b: Int8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tup2_i8_bool = Any.any_l ()
    | & _9: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tup2_i8_bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option_i8 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_mul_example
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_mul (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ * Int8.to_int rhs}
      (! return {result}) ]
  
  let rec unwrap_i8 (self_: t_Option_i8) (return (x: Int8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec wrapping_mul (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.mul self_ rhs} (! return {result}) ]
  
  let rec saturating_mul (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ * Int8.to_int rhs}
      {Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_mul (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ * Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ * Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_mul_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {(5: Int8.t)} {(10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_4 <- _x ] s1)
      | s1 = unwrap_i8 {_4} (fun (_x: Int8.t) -> [ &_3 <- _x ] s2)
      | s2 = [ &_2 <- _3 = (50: Int8.t) ] s3
      | s3 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_mul {(50: Int8.t)} {(10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_9 <- _x ] s1)
      | s1 = is_none_i8 {_9} (fun (_x: bool) -> [ &_7 <- _x ] s2)
      | s2 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = checked_mul {(50: Int8.t)} {(-10: Int8.t)} (fun (_x: t_Option_i8) -> [ &_14 <- _x ] s1)
      | s1 = is_none_i8 {_14} (fun (_x: bool) -> [ &_12 <- _x ] s2)
      | s2 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] ]
    | bb11 = s0
      [ s0 = wrapping_mul {(5: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_18 <- _x ] s1)
      | s1 = [ &_17 <- _18 = (50: Int8.t) ] s2
      | s2 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ] ]
    | bb14 = s0
      [ s0 = wrapping_mul {(50: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_22 <- _x ] s1)
      | s1 = [ &_21 <- _22 = (-12: Int8.t) ] s2
      | s2 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ] ]
    | bb17 = s0
      [ s0 = wrapping_mul {(50: Int8.t)} {(-10: Int8.t)} (fun (_x: Int8.t) -> [ &_26 <- _x ] s1)
      | s1 = [ &_25 <- _26 = (12: Int8.t) ] s2
      | s2 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ] ]
    | bb20 = s0
      [ s0 = saturating_mul {(5: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_30 <- _x ] s1)
      | s1 = [ &_29 <- _30 = (50: Int8.t) ] s2
      | s2 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ] ]
    | bb23 = s0
      [ s0 = saturating_mul {(50: Int8.t)} {(10: Int8.t)} (fun (_x: Int8.t) -> [ &_34 <- _x ] s1)
      | s1 = [ &_33 <- _34 = (127: Int8.t) ] s2
      | s2 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ] ]
    | bb26 = s0
      [ s0 = saturating_mul {(50: Int8.t)} {(-10: Int8.t)} (fun (_x: Int8.t) -> [ &_38 <- _x ] s1)
      | s1 = [ &_37 <- _38 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ] ]
    | bb29 = s0
      [ s0 = overflowing_mul {(5: Int8.t)} {(10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_42 <- res.f0 = (50: Int8.t) ] s2
      | s2 = any [ br0 -> {_42 = false} (! bb36) | br1 -> {_42} (! bb32) ] ]
    | bb32 = s0
      [ s0 = [ &_44 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_44 = false} (! bb36) | br1 -> {_44} (! bb33) ] ]
    | bb33 = s0
      [ s0 = overflowing_mul {(50: Int8.t)} {(10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'0 <- _x ] s1)
      | s1 = [ &_49 <- res'0.f0 = (-12: Int8.t) ] s2
      | s2 = any [ br0 -> {_49 = false} (! bb42) | br1 -> {_49} (! bb38) ] ]
    | bb38 = s0 [ s0 = [ &_51 <- res'0.f1 ] s1 | s1 = any [ br0 -> {_51 = false} (! bb42) | br1 -> {_51} (! bb39) ] ]
    | bb39 = s0
      [ s0 = overflowing_mul {(50: Int8.t)} {(-10: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'1 <- _x ] s1)
      | s1 = [ &_56 <- res'1.f0 = (12: Int8.t) ] s2
      | s2 = any [ br0 -> {_56 = false} (! bb48) | br1 -> {_56} (! bb44) ] ]
    | bb44 = s0 [ s0 = [ &_58 <- res'1.f1 ] s1 | s1 = any [ br0 -> {_58 = false} (! bb48) | br1 -> {_58} (! bb45) ] ]
    | bb45 = return {_ret}
    | bb48 = {false} any
    | bb42 = {false} any
    | bb36 = {false} any
    | bb30 = {false} any
    | bb27 = {false} any
    | bb24 = {false} any
    | bb21 = {false} any
    | bb18 = {false} any
    | bb15 = {false} any
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: Int8.t = Any.any_l ()
    | & _4: t_Option_i8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option_i8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: t_Option_i8 = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: Int8.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int8.t = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int8.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _34: Int8.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & res'0: tup2_i8_bool = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & res'1: tup2_i8_bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_mul_zero
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_mul (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ * Int8.to_int rhs}
      (! return {result}) ]
  
  let rec unwrap_i8 (self_: t_Option_i8) (return (x: Int8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec wrapping_mul (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.mul self_ rhs} (! return {result}) ]
  
  let rec saturating_mul (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result = Int8.to_int self_ * Int8.to_int rhs}
      {Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX -> Int8.to_int result = Int8.to_int const_MAX}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_mul (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ * Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ * Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_mul_zero (a: Int8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {(0: Int8.t)} {a} (fun (_x: t_Option_i8) -> [ &_5 <- _x ] s1)
      | s1 = unwrap_i8 {_5} (fun (_x: Int8.t) -> [ &_4 <- _x ] s2)
      | s2 = [ &_3 <- _4 = (0: Int8.t) ] s3
      | s3 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] ]
    | bb3 = s0
      [ s0 = wrapping_mul {(0: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_10 <- _x ] s1)
      | s1 = [ &_9 <- _10 = (0: Int8.t) ] s2
      | s2 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ] ]
    | bb6 = s0
      [ s0 = saturating_mul {(0: Int8.t)} {a} (fun (_x: Int8.t) -> [ &_15 <- _x ] s1)
      | s1 = [ &_14 <- _15 = (0: Int8.t) ] s2
      | s2 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ] ]
    | bb9 = s0
      [ s0 = overflowing_mul {(0: Int8.t)} {a} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_21 <- res.f0 = (0: Int8.t) ] s2
      | s2 = any [ br0 -> {_21 = false} (! bb16) | br1 -> {_21} (! bb12) ] ]
    | bb12 = s0
      [ s0 = [ &_23 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_23 = false} (! bb16) | br1 -> {_23} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb16 = {false} any
    | bb10 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & _3: bool = Any.any_l ()
    | & _4: Int8.t = Any.any_l ()
    | & _5: t_Option_i8 = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_overflowing_mul
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  constant const_MAX: Int8.t = (127: Int8.t)
  
  let rec overflowing_mul (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) = any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int const_MIN
        /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int const_MAX
      -> Int8.to_int result.f0 = Int8.to_int self_ * Int8.to_int rhs}
      {exists k: int. Int8.to_int result.f0
        = Int8.to_int self_ * Int8.to_int rhs + k * (Int8.to_int const_MAX - Int8.to_int const_MIN + 1)}
      {result.f1
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX)}
      (! return {result}) ]
  
  let rec wrapping_mul (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) = any
    [ return (result: Int8.t) -> {result = Int8.mul self_ rhs} (! return {result}) ]
  
  type t_Option_i8 = None | Some Int8.t
  
  let rec checked_mul (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int const_MIN
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int const_MAX)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int8.to_int self_ * Int8.to_int rhs}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_overflowing_mul (a: Int8.t) (b: Int8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = overflowing_mul {a} {b} (fun (_x: tup2_i8_bool) -> [ &_6 <- _x ] s1)
      | s1 = wrapping_mul {a} {b} (fun (_x: Int8.t) -> [ &_9 <- _x ] s2)
      | s2 = [ &_4 <- _6.f0 = _9 ] s3
      | s3 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] ]
    | bb3 = s0
      [ s0 = overflowing_mul {a} {b} (fun (_x: tup2_i8_bool) -> [ &_16 <- _x ] s1)
      | s1 = checked_mul {a} {b} (fun (_x: t_Option_i8) -> [ &_21 <- _x ] s2)
      | s2 = is_none_i8 {_21} (fun (_x: bool) -> [ &_19 <- _x ] s3)
      | s3 = [ &_14 <- _16.f1 = _19 ] s4
      | s4 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ] ]
    | bb8 = return {_ret}
    | bb9 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & b: Int8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tup2_i8_bool = Any.any_l ()
    | & _9: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tup2_i8_bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option_i8 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_div_example
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  let rec checked_div (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec unwrap_i8 (self_: t_Option_i8) (return (x: Int8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec wrapping_div (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) =
    {[@expl:wrapping_div requires] Int8.to_int rhs <> 0}
    any
    [ return (result: Int8.t) -> {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      -> Int8.to_int result = Int8.to_int self_}
      {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return {result}) ]
  
  let rec saturating_div (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) =
    {[@expl:saturating_div requires] Int8.to_int rhs <> 0}
    any
    [ return (result: Int8.t) -> {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_div (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) =
    {[@expl:overflowing_div requires] Int8.to_int rhs <> 0}
    any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      -> Int8.to_int result.f0 = Int8.to_int self_}
      {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result.f0 = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      {result.f1 = (Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_div_example (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_div {(5: Int8.t)} {(0: Int8.t)} (fun (_x: t_Option_i8) -> [ &_4 <- _x ] s1)
      | s1 = is_none_i8 {_4} (fun (_x: bool) -> [ &_2 <- _x ] s2)
      | s2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] ]
    | bb3 = s0
      [ s0 = checked_div {(5: Int8.t)} {(2: Int8.t)} (fun (_x: t_Option_i8) -> [ &_9 <- _x ] s1)
      | s1 = unwrap_i8 {_9} (fun (_x: Int8.t) -> [ &_8 <- _x ] s2)
      | s2 = [ &_7 <- _8 = (2: Int8.t) ] s3
      | s3 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] ]
    | bb7 = s0
      [ s0 = checked_div {(5: Int8.t)} {(-2: Int8.t)} (fun (_x: t_Option_i8) -> [ &_14 <- _x ] s1)
      | s1 = unwrap_i8 {_14} (fun (_x: Int8.t) -> [ &_13 <- _x ] s2)
      | s2 = [ &_12 <- _13 = (-2: Int8.t) ] s3
      | s3 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] ]
    | bb11 = s0
      [ s0 = checked_div {(-128: Int8.t)} {(-1: Int8.t)} (fun (_x: t_Option_i8) -> [ &_19 <- _x ] s1)
      | s1 = is_none_i8 {_19} (fun (_x: bool) -> [ &_17 <- _x ] s2)
      | s2 = any [ br0 -> {_17 = false} (! bb16) | br1 -> {_17} (! bb15) ] ]
    | bb15 = s0
      [ s0 = wrapping_div {(5: Int8.t)} {(2: Int8.t)} (fun (_x: Int8.t) -> [ &_23 <- _x ] s1)
      | s1 = [ &_22 <- _23 = (2: Int8.t) ] s2
      | s2 = any [ br0 -> {_22 = false} (! bb19) | br1 -> {_22} (! bb18) ] ]
    | bb18 = s0
      [ s0 = wrapping_div {(5: Int8.t)} {(-2: Int8.t)} (fun (_x: Int8.t) -> [ &_27 <- _x ] s1)
      | s1 = [ &_26 <- _27 = (-2: Int8.t) ] s2
      | s2 = any [ br0 -> {_26 = false} (! bb22) | br1 -> {_26} (! bb21) ] ]
    | bb21 = s0
      [ s0 = wrapping_div {(-128: Int8.t)} {(-1: Int8.t)} (fun (_x: Int8.t) -> [ &_31 <- _x ] s1)
      | s1 = [ &_30 <- _31 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_30 = false} (! bb25) | br1 -> {_30} (! bb24) ] ]
    | bb24 = s0
      [ s0 = saturating_div {(5: Int8.t)} {(2: Int8.t)} (fun (_x: Int8.t) -> [ &_35 <- _x ] s1)
      | s1 = [ &_34 <- _35 = (2: Int8.t) ] s2
      | s2 = any [ br0 -> {_34 = false} (! bb28) | br1 -> {_34} (! bb27) ] ]
    | bb27 = s0
      [ s0 = saturating_div {(5: Int8.t)} {(-2: Int8.t)} (fun (_x: Int8.t) -> [ &_39 <- _x ] s1)
      | s1 = [ &_38 <- _39 = (-2: Int8.t) ] s2
      | s2 = any [ br0 -> {_38 = false} (! bb31) | br1 -> {_38} (! bb30) ] ]
    | bb30 = s0
      [ s0 = saturating_div {(-128: Int8.t)} {(-1: Int8.t)} (fun (_x: Int8.t) -> [ &_43 <- _x ] s1)
      | s1 = [ &_42 <- _43 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_42 = false} (! bb34) | br1 -> {_42} (! bb33) ] ]
    | bb33 = s0
      [ s0 = overflowing_div {(5: Int8.t)} {(2: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_47 <- res.f0 = (2: Int8.t) ] s2
      | s2 = any [ br0 -> {_47 = false} (! bb40) | br1 -> {_47} (! bb36) ] ]
    | bb36 = s0
      [ s0 = [ &_49 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_49 = false} (! bb40) | br1 -> {_49} (! bb37) ] ]
    | bb37 = s0
      [ s0 = overflowing_div {(5: Int8.t)} {(-2: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'0 <- _x ] s1)
      | s1 = [ &_54 <- res'0.f0 = (-2: Int8.t) ] s2
      | s2 = any [ br0 -> {_54 = false} (! bb46) | br1 -> {_54} (! bb42) ] ]
    | bb42 = s0
      [ s0 = [ &_56 <- res'0.f1 = false ] s1 | s1 = any [ br0 -> {_56 = false} (! bb46) | br1 -> {_56} (! bb43) ] ]
    | bb43 = s0
      [ s0 = overflowing_div {(-128: Int8.t)} {(-1: Int8.t)} (fun (_x: tup2_i8_bool) -> [ &res'1 <- _x ] s1)
      | s1 = [ &_61 <- res'1.f0 = (-128: Int8.t) ] s2
      | s2 = any [ br0 -> {_61 = false} (! bb52) | br1 -> {_61} (! bb48) ] ]
    | bb48 = s0 [ s0 = [ &_63 <- res'1.f1 ] s1 | s1 = any [ br0 -> {_63 = false} (! bb52) | br1 -> {_63} (! bb49) ] ]
    | bb49 = return {_ret}
    | bb52 = {false} any
    | bb46 = {false} any
    | bb40 = {false} any
    | bb34 = {false} any
    | bb31 = {false} any
    | bb28 = {false} any
    | bb25 = {false} any
    | bb22 = {false} any
    | bb19 = {false} any
    | bb16 = {false} any
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _4: t_Option_i8 = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: Int8.t = Any.any_l ()
    | & _9: t_Option_i8 = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: Int8.t = Any.any_l ()
    | & _14: t_Option_i8 = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: t_Option_i8 = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _23: Int8.t = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: Int8.t = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _31: Int8.t = Any.any_l ()
    | & _34: bool = Any.any_l ()
    | & _35: Int8.t = Any.any_l ()
    | & _38: bool = Any.any_l ()
    | & _39: Int8.t = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _43: Int8.t = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _47: bool = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & res'0: tup2_i8_bool = Any.any_l ()
    | & _54: bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & res'1: tup2_i8_bool = Any.any_l ()
    | & _61: bool = Any.any_l ()
    | & _63: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_div_no_overflow
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  let rec checked_div (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return {result}) ]
  
  let rec unwrap_i8 (self_: t_Option_i8) (return (x: Int8.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int8.t) -> {Some result = self_} (! return {result}) ]
  
  let rec wrapping_div (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) =
    {[@expl:wrapping_div requires] Int8.to_int rhs <> 0}
    any
    [ return (result: Int8.t) -> {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      -> Int8.to_int result = Int8.to_int self_}
      {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return {result}) ]
  
  let rec saturating_div (self_: Int8.t) (rhs: Int8.t) (return (x: Int8.t)) =
    {[@expl:saturating_div requires] Int8.to_int rhs <> 0}
    any
    [ return (result: Int8.t) -> {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      -> Int8.to_int result = Int8.to_int const_MIN}
      {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return {result}) ]
  
  type tup2_i8_bool = { f0: Int8.t; f1: bool }
  
  let rec overflowing_div (self_: Int8.t) (rhs: Int8.t) (return (x: tup2_i8_bool)) =
    {[@expl:overflowing_div requires] Int8.to_int rhs <> 0}
    any
    [ return (result: tup2_i8_bool) -> {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      -> Int8.to_int result.f0 = Int8.to_int self_}
      {Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result.f0 = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      {result.f1 = (Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_div_no_overflow (a: Int8.t) (b: Int8.t) (return (x: ())) =
    {[@expl:test_i8_div_no_overflow requires] Int8.to_int b <> 0 /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_div {a} {b} (fun (_x: t_Option_i8) -> [ &_9 <- _x ] s1)
      | s1 = unwrap_i8 {_9} (fun (_x: Int8.t) -> [ &_8 <- _x ] s2)
      | s2 = [ &_13 <- a ] s3
      | s3 = [ &_14 <- b ] s4
      | s4 = [ &_15 <- _14 = (0: Int8.t) ] s5
      | s5 = {[@expl:division by zero] not _15} s6
      | s6 = [ &_16 <- _14 = (-1: Int8.t) ] s7
      | s7 = [ &_17 <- _13 = (-128: Int8.t) ] s8
      | s8 = [ &_18 <- Bool.bw_and _16 _17 ] s9
      | s9 = {[@expl:Div overflow] not _18} s10
      | s10 = Int8.div {_13} {_14} (fun (_x: Int8.t) -> [ &_12 <- _x ] s11)
      | s11 = [ &_7 <- _8 = _12 ] s12
      | s12 = any [ br0 -> {_7 = false} (! bb6) | br1 -> {_7} (! bb5) ] ]
    | bb5 = s0
      [ s0 = wrapping_div {a} {b} (fun (_x: Int8.t) -> [ &_22 <- _x ] s1)
      | s1 = [ &_26 <- a ] s2
      | s2 = [ &_27 <- b ] s3
      | s3 = [ &_28 <- _27 = (0: Int8.t) ] s4
      | s4 = {[@expl:division by zero] not _28} s5
      | s5 = [ &_29 <- _27 = (-1: Int8.t) ] s6
      | s6 = [ &_30 <- _26 = (-128: Int8.t) ] s7
      | s7 = [ &_31 <- Bool.bw_and _29 _30 ] s8
      | s8 = {[@expl:Div overflow] not _31} s9
      | s9 = Int8.div {_26} {_27} (fun (_x: Int8.t) -> [ &_25 <- _x ] s10)
      | s10 = [ &_21 <- _22 = _25 ] s11
      | s11 = any [ br0 -> {_21 = false} (! bb11) | br1 -> {_21} (! bb10) ] ]
    | bb10 = s0
      [ s0 = saturating_div {a} {b} (fun (_x: Int8.t) -> [ &_35 <- _x ] s1)
      | s1 = [ &_39 <- a ] s2
      | s2 = [ &_40 <- b ] s3
      | s3 = [ &_41 <- _40 = (0: Int8.t) ] s4
      | s4 = {[@expl:division by zero] not _41} s5
      | s5 = [ &_42 <- _40 = (-1: Int8.t) ] s6
      | s6 = [ &_43 <- _39 = (-128: Int8.t) ] s7
      | s7 = [ &_44 <- Bool.bw_and _42 _43 ] s8
      | s8 = {[@expl:Div overflow] not _44} s9
      | s9 = Int8.div {_39} {_40} (fun (_x: Int8.t) -> [ &_38 <- _x ] s10)
      | s10 = [ &_34 <- _35 = _38 ] s11
      | s11 = any [ br0 -> {_34 = false} (! bb16) | br1 -> {_34} (! bb15) ] ]
    | bb15 = s0
      [ s0 = overflowing_div {a} {b} (fun (_x: tup2_i8_bool) -> [ &res <- _x ] s1)
      | s1 = [ &_53 <- a ] s2
      | s2 = [ &_54 <- b ] s3
      | s3 = [ &_55 <- _54 = (0: Int8.t) ] s4
      | s4 = {[@expl:division by zero] not _55} s5
      | s5 = [ &_56 <- _54 = (-1: Int8.t) ] s6
      | s6 = [ &_57 <- _53 = (-128: Int8.t) ] s7
      | s7 = [ &_58 <- Bool.bw_and _56 _57 ] s8
      | s8 = {[@expl:Div overflow] not _58} s9
      | s9 = Int8.div {_53} {_54} (fun (_x: Int8.t) -> [ &_52 <- _x ] s10)
      | s10 = [ &_50 <- res.f0 = _52 ] s11
      | s11 = any [ br0 -> {_50 = false} (! bb24) | br1 -> {_50} (! bb20) ] ]
    | bb20 = s0
      [ s0 = [ &_59 <- res.f1 = false ] s1 | s1 = any [ br0 -> {_59 = false} (! bb24) | br1 -> {_59} (! bb21) ] ]
    | bb21 = return {_ret}
    | bb24 = {false} any
    | bb16 = {false} any
    | bb11 = {false} any
    | bb6 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & a: Int8.t = a
    | & b: Int8.t = b
    | & _7: bool = Any.any_l ()
    | & _8: Int8.t = Any.any_l ()
    | & _9: t_Option_i8 = Any.any_l ()
    | & _12: Int8.t = Any.any_l ()
    | & _13: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int8.t = Any.any_l ()
    | & _25: Int8.t = Any.any_l ()
    | & _26: Int8.t = Any.any_l ()
    | & _27: Int8.t = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _34: bool = Any.any_l ()
    | & _35: Int8.t = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & _39: Int8.t = Any.any_l ()
    | & _40: Int8.t = Any.any_l ()
    | & _41: bool = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _43: bool = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & res: tup2_i8_bool = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & _52: Int8.t = Any.any_l ()
    | & _53: Int8.t = Any.any_l ()
    | & _54: Int8.t = Any.any_l ()
    | & _55: bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _57: bool = Any.any_l ()
    | & _58: bool = Any.any_l ()
    | & _59: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_test_i8_div_zero
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_i8 = None | Some Int8.t
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  let rec checked_div (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_i8)) = any
    [ return (result: t_Option_i8) -> {(result = None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self_ = Int8.to_int const_MIN /\ Int8.to_int rhs = - 1)}
      {forall r: Int8.t. result = Some r -> Int8.to_int r = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return {result}) ]
  
  let rec is_none_i8 (self_: t_Option_i8) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec test_i8_div_zero (a: Int8.t) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = checked_div {a} {(0: Int8.t)} (fun (_x: t_Option_i8) -> [ &_5 <- _x ] s1)
      | s1 = is_none_i8 {_5} (fun (_x: bool) -> [ &_3 <- _x ] s2)
      | s2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] ]
    | bb3 = return {_ret}
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l () | & a: Int8.t = a | & _3: bool = Any.any_l () | & _5: t_Option_i8 = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
