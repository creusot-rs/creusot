module M_checked_ops__test_u8_add_example [#"checked_ops.rs" 5 0 5 28]
  let%span schecked_ops = "checked_ops.rs" 6 12 6 15
  let%span schecked_ops'0 = "checked_ops.rs" 6 28 6 30
  let%span schecked_ops'1 = "checked_ops.rs" 6 44 6 46
  let%span schecked_ops'2 = "checked_ops.rs" 7 12 7 17
  let%span schecked_ops'3 = "checked_ops.rs" 7 30 7 32
  let%span schecked_ops'4 = "checked_ops.rs" 9 12 9 15
  let%span schecked_ops'5 = "checked_ops.rs" 9 29 9 31
  let%span schecked_ops'6 = "checked_ops.rs" 9 36 9 38
  let%span schecked_ops'7 = "checked_ops.rs" 10 12 10 17
  let%span schecked_ops'8 = "checked_ops.rs" 10 31 10 33
  let%span schecked_ops'9 = "checked_ops.rs" 10 38 10 39
  let%span schecked_ops'10 = "checked_ops.rs" 12 12 12 15
  let%span schecked_ops'11 = "checked_ops.rs" 12 31 12 33
  let%span schecked_ops'12 = "checked_ops.rs" 12 38 12 40
  let%span schecked_ops'13 = "checked_ops.rs" 13 12 13 17
  let%span schecked_ops'14 = "checked_ops.rs" 13 33 13 35
  let%span schecked_ops'15 = "checked_ops.rs" 13 40 13 43
  let%span schecked_ops'16 = "checked_ops.rs" 15 14 15 17
  let%span schecked_ops'17 = "checked_ops.rs" 15 34 15 36
  let%span schecked_ops'18 = "checked_ops.rs" 16 21 16 23
  let%span schecked_ops'19 = "checked_ops.rs" 16 36 16 41
  let%span schecked_ops'20 = "checked_ops.rs" 17 14 17 19
  let%span schecked_ops'21 = "checked_ops.rs" 17 36 17 38
  let%span schecked_ops'22 = "checked_ops.rs" 18 21 18 22
  let%span schecked_ops'23 = "checked_ops.rs" 18 35 18 39
  let%span schecked_ops'24 = "checked_ops.rs" 18 4 18 40
  let%span schecked_ops'25 = "checked_ops.rs" 16 4 16 42
  let%span schecked_ops'26 = "checked_ops.rs" 13 4 13 44
  let%span schecked_ops'27 = "checked_ops.rs" 12 4 12 41
  let%span schecked_ops'28 = "checked_ops.rs" 10 4 10 40
  let%span schecked_ops'29 = "checked_ops.rs" 9 4 9 39
  let%span schecked_ops'30 = "checked_ops.rs" 7 4 7 44
  let%span schecked_ops'31 = "checked_ops.rs" 6 4 6 47
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ + UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:UInt8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:UInt8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption'1] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'1] result = UInt8.add self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self_ + UInt8.t'int rhs}
      {[%#snum'3] UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'4] UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX: UInt8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ + UInt8.t'int rhs}
      {[%#snum'6] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ + UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'7] result._p1
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_add_example[#"checked_ops.rs" 5 0 5 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add {[%#schecked_ops] (5: UInt8.t)} {[%#schecked_ops'0] (10: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_4} (fun (_ret:UInt8.t) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_2 <- _3 = ([%#schecked_ops'1] (15: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = checked_add {[%#schecked_ops'2] (250: UInt8.t)} {[%#schecked_ops'3] (10: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = is_none {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = wrapping_add {[%#schecked_ops'4] (5: UInt8.t)} {[%#schecked_ops'5] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_13 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &_12 <- _13 = ([%#schecked_ops'6] (15: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
    
    | bb10 = s0
      [ s0 = wrapping_add {[%#schecked_ops'7] (250: UInt8.t)} {[%#schecked_ops'8] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_17 <- _ret ] s1)
      | s1 = bb12 ]
    
    | bb12 = s0
      [ s0 =  [ &_16 <- _17 = ([%#schecked_ops'9] (4: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = saturating_add {[%#schecked_ops'10] (5: UInt8.t)} {[%#schecked_ops'11] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_21 <- _ret ] s1)
      | s1 = bb15 ]
    
    | bb15 = s0
      [ s0 =  [ &_20 <- _21 = ([%#schecked_ops'12] (15: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
    
    | bb16 = s0
      [ s0 = saturating_add {[%#schecked_ops'13] (250: UInt8.t)} {[%#schecked_ops'14] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_25 <- _ret ] s1)
      | s1 = bb18 ]
    
    | bb18 = s0
      [ s0 =  [ &_24 <- _25 = ([%#schecked_ops'15] (255: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 = overflowing_add {[%#schecked_ops'16] (5: UInt8.t)} {[%#schecked_ops'17] (10: UInt8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb21 ]
    
    | bb21 = s0
      [ s0 =  [ &_29 <- res._p0 = ([%#schecked_ops'18] (15: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
    
    | bb22 = s0
      [ s0 =  [ &_31 <- res._p1 = ([%#schecked_ops'19] false) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = overflowing_add {[%#schecked_ops'20] (250: UInt8.t)} {[%#schecked_ops'21] (10: UInt8.t)}
          (fun (_ret:tuple) ->  [ &res'0 <- _ret ] s1)
      | s1 = bb27 ]
    
    | bb27 = s0
      [ s0 =  [ &_36 <- res'0._p0 = ([%#schecked_ops'22] (4: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
    
    | bb28 = s0
      [ s0 =  [ &_38 <- res'0._p1 ] s1 | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
    
    | bb29 = return''0 {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops'24] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops'25] false} any
    | bb20 = {[%#schecked_ops'26] false} any
    | bb17 = {[%#schecked_ops'27] false} any
    | bb14 = {[%#schecked_ops'28] false} any
    | bb11 = {[%#schecked_ops'29] false} any
    | bb8 = {[%#schecked_ops'30] false} any
    | bb4 = {[%#schecked_ops'31] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: UInt8.t = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _25: UInt8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & res'0: tuple = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _38: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_add_overflow [#"checked_ops.rs" 23 0 23 34]
  let%span schecked_ops = "checked_ops.rs" 24 12 24 17
  let%span schecked_ops'0 = "checked_ops.rs" 25 12 25 17
  let%span schecked_ops'1 = "checked_ops.rs" 25 41 25 42
  let%span schecked_ops'2 = "checked_ops.rs" 26 12 26 17
  let%span schecked_ops'3 = "checked_ops.rs" 26 39 26 42
  let%span schecked_ops'4 = "checked_ops.rs" 27 14 27 19
  let%span schecked_ops'5 = "checked_ops.rs" 28 25 28 26
  let%span schecked_ops'6 = "checked_ops.rs" 28 39 28 43
  let%span schecked_ops'7 = "checked_ops.rs" 28 4 28 44
  let%span schecked_ops'8 = "checked_ops.rs" 26 4 26 43
  let%span schecked_ops'9 = "checked_ops.rs" 25 4 25 43
  let%span schecked_ops'10 = "checked_ops.rs" 24 4 24 43
  let%span schecked_ops'11 = "checked_ops.rs" 22 11 22 18
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ + UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'1] result = UInt8.add self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self_ + UInt8.t'int rhs}
      {[%#snum'3] UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'4] UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX: UInt8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ + UInt8.t'int rhs}
      {[%#snum'6] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ + UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'7] result._p1
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_add_overflow[#"checked_ops.rs" 23 0 23 34] (a:UInt8.t) (return'  (x:()))= {[@expl:test_u8_add_overflow requires] [%#schecked_ops'11] UInt8.t'int a
    <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add {[%#schecked_ops] (255: UInt8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_6 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add {[%#schecked_ops'0] (255: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 = UInt8.sub {a'0} {[%#schecked_ops'1] (1: UInt8.t)} (fun (_ret:UInt8.t) ->  [ &_13 <- _ret ] s1)
      | s1 =  [ &_10 <- _11 = _13 ] s2
      | s2 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_add {[%#schecked_ops'2] (255: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_18 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_17 <- _18 = ([%#schecked_ops'3] (255: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_17 = false} (! bb10) | br1 -> {_17} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_add {[%#schecked_ops'4] (255: UInt8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 = UInt8.sub {a'0} {[%#schecked_ops'5] (1: UInt8.t)} (fun (_ret:UInt8.t) ->  [ &_26 <- _ret ] s1)
      | s1 =  [ &_24 <- res._p0 = _26 ] s2
      | s2 = any [ br0 -> {_24 = false} (! bb15) | br1 -> {_24} (! bb12) ]  ]
    
    | bb12 = s0 [ s0 =  [ &_28 <- res._p1 ] s1 | s1 = any [ br0 -> {_28 = false} (! bb14) | br1 -> {_28} (! bb13) ]  ] 
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'7] false} any
    | bb10 = {[%#schecked_ops'8] false} any
    | bb7 = {[%#schecked_ops'9] false} any
    | bb4 = {[%#schecked_ops'10] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: UInt8.t = a
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: UInt8.t = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: UInt8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: UInt8.t = Any.any_l ()
    | & _28: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_wrapping_add [#"checked_ops.rs" 34 0 34 47]
  let%span schecked_ops = "checked_ops.rs" 33 10 33 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec wrapping_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum] result = UInt8.add self_ rhs} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_wrapping_add[#"checked_ops.rs" 34 0 34 47] (a:UInt8.t) (b:UInt8.t) (return'  (x:UInt8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add {a'0} {b'0} (fun (_ret:UInt8.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: UInt8.t = Any.any_l () | & a'0: UInt8.t = a | & b'0: UInt8.t = b ] 
    [ return''0 (result:UInt8.t)-> {[@expl:test_u8_wrapping_add ensures] [%#schecked_ops] UInt8.t'int result
      = UInt8.t'int a + UInt8.t'int b
      \/ UInt8.t'int result = UInt8.t'int a + UInt8.t'int b - 256}
      (! return' {result}) ]

end
module M_checked_ops__test_u8_overflowing_add [#"checked_ops.rs" 39 0 39 44]
  let%span schecked_ops = "checked_ops.rs" 41 4 41 65
  let%span schecked_ops'0 = "checked_ops.rs" 40 4 40 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec overflowing_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum] UInt8.t'int self_ + UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ + UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ + UInt8.t'int rhs}
      {[%#snum'0] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ + UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'1] result._p1
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  let rec wrapping_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] result = UInt8.add self_ rhs} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  let rec checked_add (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum'3] (result = C_None)
      = (UInt8.t'int self_ + UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ + UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'4] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ + UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_add[#"checked_ops.rs" 39 0 39 44] (a:UInt8.t) (b:UInt8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add {a'0} {b'0} (fun (_ret:tuple) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_add {a'0} {b'0} (fun (_ret:UInt8.t) ->  [ &_9 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_4 <- _6._p0 = _9 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0 [ s0 = overflowing_add {a'0} {b'0} (fun (_ret:tuple) ->  [ &_16 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_add {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_21 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none {_21} (fun (_ret:bool) ->  [ &_19 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- _16._p1 = _19 ] s1 | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
    
    | bb8 = return''0 {_0}
    | bb9 = {[%#schecked_ops] false} any
    | bb4 = {[%#schecked_ops'0] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: UInt8.t = a
    | & b'0: UInt8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _9: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_sub_example [#"checked_ops.rs" 45 0 45 28]
  let%span schecked_ops = "checked_ops.rs" 46 12 46 15
  let%span schecked_ops'0 = "checked_ops.rs" 46 28 46 30
  let%span schecked_ops'1 = "checked_ops.rs" 47 12 47 17
  let%span schecked_ops'2 = "checked_ops.rs" 47 30 47 32
  let%span schecked_ops'3 = "checked_ops.rs" 47 46 47 49
  let%span schecked_ops'4 = "checked_ops.rs" 49 12 49 15
  let%span schecked_ops'5 = "checked_ops.rs" 49 29 49 31
  let%span schecked_ops'6 = "checked_ops.rs" 49 36 49 39
  let%span schecked_ops'7 = "checked_ops.rs" 50 12 50 17
  let%span schecked_ops'8 = "checked_ops.rs" 50 31 50 33
  let%span schecked_ops'9 = "checked_ops.rs" 50 38 50 41
  let%span schecked_ops'10 = "checked_ops.rs" 52 12 52 15
  let%span schecked_ops'11 = "checked_ops.rs" 52 31 52 33
  let%span schecked_ops'12 = "checked_ops.rs" 52 38 52 39
  let%span schecked_ops'13 = "checked_ops.rs" 53 12 53 17
  let%span schecked_ops'14 = "checked_ops.rs" 53 33 53 35
  let%span schecked_ops'15 = "checked_ops.rs" 53 40 53 43
  let%span schecked_ops'16 = "checked_ops.rs" 55 14 55 17
  let%span schecked_ops'17 = "checked_ops.rs" 55 34 55 36
  let%span schecked_ops'18 = "checked_ops.rs" 56 21 56 24
  let%span schecked_ops'19 = "checked_ops.rs" 56 37 56 41
  let%span schecked_ops'20 = "checked_ops.rs" 57 14 57 19
  let%span schecked_ops'21 = "checked_ops.rs" 57 36 57 38
  let%span schecked_ops'22 = "checked_ops.rs" 58 21 58 24
  let%span schecked_ops'23 = "checked_ops.rs" 58 37 58 42
  let%span schecked_ops'24 = "checked_ops.rs" 58 4 58 43
  let%span schecked_ops'25 = "checked_ops.rs" 56 4 56 42
  let%span schecked_ops'26 = "checked_ops.rs" 53 4 53 44
  let%span schecked_ops'27 = "checked_ops.rs" 52 4 52 40
  let%span schecked_ops'28 = "checked_ops.rs" 50 4 50 42
  let%span schecked_ops'29 = "checked_ops.rs" 49 4 49 40
  let%span schecked_ops'30 = "checked_ops.rs" 47 4 47 50
  let%span schecked_ops'31 = "checked_ops.rs" 46 4 46 42
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ - UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:UInt8.t))= {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any [ return''0 (result:UInt8.t)-> {[%#soption'1] C_Some result = self_} (! return' {result}) ] 
  
  let rec wrapping_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'1] result = UInt8.sub self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self_ - UInt8.t'int rhs}
      {[%#snum'3] UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'4] UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX: UInt8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ - UInt8.t'int rhs}
      {[%#snum'6] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ - UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'7] result._p1
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_sub_example[#"checked_ops.rs" 45 0 45 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {[%#schecked_ops] (5: UInt8.t)} {[%#schecked_ops'0] (10: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_4} (fun (_ret:bool) ->  [ &_2 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_sub {[%#schecked_ops'1] (250: UInt8.t)} {[%#schecked_ops'2] (10: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = unwrap {_9} (fun (_ret:UInt8.t) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_7 <- _8 = ([%#schecked_ops'3] (240: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'4] (5: UInt8.t)} {[%#schecked_ops'5] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_13 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &_12 <- _13 = ([%#schecked_ops'6] (251: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
    
    | bb10 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'7] (250: UInt8.t)} {[%#schecked_ops'8] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_17 <- _ret ] s1)
      | s1 = bb12 ]
    
    | bb12 = s0
      [ s0 =  [ &_16 <- _17 = ([%#schecked_ops'9] (240: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = saturating_sub {[%#schecked_ops'10] (5: UInt8.t)} {[%#schecked_ops'11] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_21 <- _ret ] s1)
      | s1 = bb15 ]
    
    | bb15 = s0
      [ s0 =  [ &_20 <- _21 = ([%#schecked_ops'12] (0: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
    
    | bb16 = s0
      [ s0 = saturating_sub {[%#schecked_ops'13] (250: UInt8.t)} {[%#schecked_ops'14] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_25 <- _ret ] s1)
      | s1 = bb18 ]
    
    | bb18 = s0
      [ s0 =  [ &_24 <- _25 = ([%#schecked_ops'15] (240: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'16] (5: UInt8.t)} {[%#schecked_ops'17] (10: UInt8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb21 ]
    
    | bb21 = s0
      [ s0 =  [ &_29 <- res._p0 = ([%#schecked_ops'18] (251: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
    
    | bb22 = s0 [ s0 =  [ &_31 <- res._p1 ] s1 | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ] 
    | bb23 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'20] (250: UInt8.t)} {[%#schecked_ops'21] (10: UInt8.t)}
          (fun (_ret:tuple) ->  [ &res'0 <- _ret ] s1)
      | s1 = bb27 ]
    
    | bb27 = s0
      [ s0 =  [ &_36 <- res'0._p0 = ([%#schecked_ops'22] (240: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
    
    | bb28 = s0
      [ s0 =  [ &_38 <- res'0._p1 = ([%#schecked_ops'23] false) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
    
    | bb29 = return''0 {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops'24] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops'25] false} any
    | bb20 = {[%#schecked_ops'26] false} any
    | bb17 = {[%#schecked_ops'27] false} any
    | bb14 = {[%#schecked_ops'28] false} any
    | bb11 = {[%#schecked_ops'29] false} any
    | bb8 = {[%#schecked_ops'30] false} any
    | bb4 = {[%#schecked_ops'31] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: UInt8.t = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _25: UInt8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & res'0: tuple = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _38: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_sub_overflow [#"checked_ops.rs" 63 0 63 34]
  let%span schecked_ops = "checked_ops.rs" 64 12 64 15
  let%span schecked_ops'0 = "checked_ops.rs" 65 12 65 15
  let%span schecked_ops'1 = "checked_ops.rs" 65 35 65 38
  let%span schecked_ops'2 = "checked_ops.rs" 65 45 65 46
  let%span schecked_ops'3 = "checked_ops.rs" 66 12 66 15
  let%span schecked_ops'4 = "checked_ops.rs" 66 37 66 38
  let%span schecked_ops'5 = "checked_ops.rs" 67 14 67 17
  let%span schecked_ops'6 = "checked_ops.rs" 68 21 68 24
  let%span schecked_ops'7 = "checked_ops.rs" 68 31 68 32
  let%span schecked_ops'8 = "checked_ops.rs" 68 45 68 49
  let%span schecked_ops'9 = "checked_ops.rs" 68 4 68 50
  let%span schecked_ops'10 = "checked_ops.rs" 66 4 66 39
  let%span schecked_ops'11 = "checked_ops.rs" 65 4 65 47
  let%span schecked_ops'12 = "checked_ops.rs" 64 4 64 41
  let%span schecked_ops'13 = "checked_ops.rs" 62 11 62 18
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ - UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'1] result = UInt8.sub self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self_ - UInt8.t'int rhs}
      {[%#snum'3] UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'4] UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX: UInt8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ - UInt8.t'int rhs}
      {[%#snum'6] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ - UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'7] result._p1
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_sub_overflow[#"checked_ops.rs" 63 0 63 34] (a:UInt8.t) (return'  (x:()))= {[@expl:test_u8_sub_overflow requires] [%#schecked_ops'13] UInt8.t'int a
    <> 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {[%#schecked_ops] (0: UInt8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'0] (0: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 = UInt8.sub {[%#schecked_ops'1] (255: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_14 <- _ret ] s1)
      | s1 = UInt8.add {_14} {[%#schecked_ops'2] (1: UInt8.t)} (fun (_ret:UInt8.t) ->  [ &_13 <- _ret ] s2)
      | s2 =  [ &_10 <- _11 = _13 ] s3
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_sub {[%#schecked_ops'3] (0: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_19 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_18 <- _19 = ([%#schecked_ops'4] (0: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'5] (0: UInt8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 = UInt8.sub {[%#schecked_ops'6] (255: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_28 <- _ret ] s1)
      | s1 = UInt8.add {_28} {[%#schecked_ops'7] (1: UInt8.t)} (fun (_ret:UInt8.t) ->  [ &_27 <- _ret ] s2)
      | s2 =  [ &_25 <- res._p0 = _27 ] s3
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
    
    | bb12 = s0 [ s0 =  [ &_30 <- res._p1 ] s1 | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ] 
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'9] false} any
    | bb10 = {[%#schecked_ops'10] false} any
    | bb7 = {[%#schecked_ops'11] false} any
    | bb4 = {[%#schecked_ops'12] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: UInt8.t = a
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: UInt8.t = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _14: UInt8.t = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _19: UInt8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _27: UInt8.t = Any.any_l ()
    | & _28: UInt8.t = Any.any_l ()
    | & _30: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_wrapping_sub [#"checked_ops.rs" 74 0 74 47]
  let%span schecked_ops = "checked_ops.rs" 73 10 73 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec wrapping_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum] result = UInt8.sub self_ rhs} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_wrapping_sub[#"checked_ops.rs" 74 0 74 47] (a:UInt8.t) (b:UInt8.t) (return'  (x:UInt8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub {a'0} {b'0} (fun (_ret:UInt8.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: UInt8.t = Any.any_l () | & a'0: UInt8.t = a | & b'0: UInt8.t = b ] 
    [ return''0 (result:UInt8.t)-> {[@expl:test_u8_wrapping_sub ensures] [%#schecked_ops] UInt8.t'int result
      = UInt8.t'int a - UInt8.t'int b
      \/ UInt8.t'int result = UInt8.t'int a - UInt8.t'int b + 256}
      (! return' {result}) ]

end
module M_checked_ops__test_u8_overflowing_sub [#"checked_ops.rs" 79 0 79 44]
  let%span schecked_ops = "checked_ops.rs" 81 4 81 65
  let%span schecked_ops'0 = "checked_ops.rs" 80 4 80 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec overflowing_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum] UInt8.t'int self_ - UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ - UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ - UInt8.t'int rhs}
      {[%#snum'0] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ - UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'1] result._p1
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  let rec wrapping_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] result = UInt8.sub self_ rhs} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  let rec checked_sub (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum'3] (result = C_None)
      = (UInt8.t'int self_ - UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ - UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'4] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ - UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_sub[#"checked_ops.rs" 79 0 79 44] (a:UInt8.t) (b:UInt8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub {a'0} {b'0} (fun (_ret:tuple) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_sub {a'0} {b'0} (fun (_ret:UInt8.t) ->  [ &_9 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_4 <- _6._p0 = _9 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0 [ s0 = overflowing_sub {a'0} {b'0} (fun (_ret:tuple) ->  [ &_16 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_sub {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_21 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none {_21} (fun (_ret:bool) ->  [ &_19 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- _16._p1 = _19 ] s1 | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
    
    | bb8 = return''0 {_0}
    | bb9 = {[%#schecked_ops] false} any
    | bb4 = {[%#schecked_ops'0] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: UInt8.t = a
    | & b'0: UInt8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _9: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_mul_example [#"checked_ops.rs" 85 0 85 28]
  let%span schecked_ops = "checked_ops.rs" 86 12 86 15
  let%span schecked_ops'0 = "checked_ops.rs" 86 28 86 30
  let%span schecked_ops'1 = "checked_ops.rs" 86 44 86 46
  let%span schecked_ops'2 = "checked_ops.rs" 87 12 87 16
  let%span schecked_ops'3 = "checked_ops.rs" 87 29 87 31
  let%span schecked_ops'4 = "checked_ops.rs" 89 12 89 15
  let%span schecked_ops'5 = "checked_ops.rs" 89 29 89 31
  let%span schecked_ops'6 = "checked_ops.rs" 89 36 89 38
  let%span schecked_ops'7 = "checked_ops.rs" 90 12 90 16
  let%span schecked_ops'8 = "checked_ops.rs" 90 30 90 32
  let%span schecked_ops'9 = "checked_ops.rs" 90 37 90 40
  let%span schecked_ops'10 = "checked_ops.rs" 92 12 92 15
  let%span schecked_ops'11 = "checked_ops.rs" 92 31 92 33
  let%span schecked_ops'12 = "checked_ops.rs" 92 38 92 40
  let%span schecked_ops'13 = "checked_ops.rs" 93 12 93 16
  let%span schecked_ops'14 = "checked_ops.rs" 93 32 93 34
  let%span schecked_ops'15 = "checked_ops.rs" 93 39 93 42
  let%span schecked_ops'16 = "checked_ops.rs" 95 14 95 17
  let%span schecked_ops'17 = "checked_ops.rs" 95 34 95 36
  let%span schecked_ops'18 = "checked_ops.rs" 96 21 96 23
  let%span schecked_ops'19 = "checked_ops.rs" 96 36 96 41
  let%span schecked_ops'20 = "checked_ops.rs" 97 14 97 18
  let%span schecked_ops'21 = "checked_ops.rs" 97 35 97 37
  let%span schecked_ops'22 = "checked_ops.rs" 98 21 98 24
  let%span schecked_ops'23 = "checked_ops.rs" 98 37 98 41
  let%span schecked_ops'24 = "checked_ops.rs" 98 4 98 42
  let%span schecked_ops'25 = "checked_ops.rs" 96 4 96 42
  let%span schecked_ops'26 = "checked_ops.rs" 93 4 93 43
  let%span schecked_ops'27 = "checked_ops.rs" 92 4 92 41
  let%span schecked_ops'28 = "checked_ops.rs" 90 4 90 41
  let%span schecked_ops'29 = "checked_ops.rs" 89 4 89 39
  let%span schecked_ops'30 = "checked_ops.rs" 87 4 87 43
  let%span schecked_ops'31 = "checked_ops.rs" 86 4 86 47
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ * UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:UInt8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:UInt8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption'1] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'1] result = UInt8.mul self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self_ * UInt8.t'int rhs}
      {[%#snum'3] UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'4] UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX: UInt8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ * UInt8.t'int rhs}
      {[%#snum'6] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ * UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'7] result._p1
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_mul_example[#"checked_ops.rs" 85 0 85 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {[%#schecked_ops] (5: UInt8.t)} {[%#schecked_ops'0] (10: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_4} (fun (_ret:UInt8.t) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_2 <- _3 = ([%#schecked_ops'1] (50: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = checked_mul {[%#schecked_ops'2] (50: UInt8.t)} {[%#schecked_ops'3] (10: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = is_none {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = wrapping_mul {[%#schecked_ops'4] (5: UInt8.t)} {[%#schecked_ops'5] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_13 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &_12 <- _13 = ([%#schecked_ops'6] (50: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
    
    | bb10 = s0
      [ s0 = wrapping_mul {[%#schecked_ops'7] (50: UInt8.t)} {[%#schecked_ops'8] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_17 <- _ret ] s1)
      | s1 = bb12 ]
    
    | bb12 = s0
      [ s0 =  [ &_16 <- _17 = ([%#schecked_ops'9] (244: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = saturating_mul {[%#schecked_ops'10] (5: UInt8.t)} {[%#schecked_ops'11] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_21 <- _ret ] s1)
      | s1 = bb15 ]
    
    | bb15 = s0
      [ s0 =  [ &_20 <- _21 = ([%#schecked_ops'12] (50: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb16) ]  ]
    
    | bb16 = s0
      [ s0 = saturating_mul {[%#schecked_ops'13] (50: UInt8.t)} {[%#schecked_ops'14] (10: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_25 <- _ret ] s1)
      | s1 = bb18 ]
    
    | bb18 = s0
      [ s0 =  [ &_24 <- _25 = ([%#schecked_ops'15] (255: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb19) ]  ]
    
    | bb19 = s0
      [ s0 = overflowing_mul {[%#schecked_ops'16] (5: UInt8.t)} {[%#schecked_ops'17] (10: UInt8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb21 ]
    
    | bb21 = s0
      [ s0 =  [ &_29 <- res._p0 = ([%#schecked_ops'18] (50: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb25) | br1 -> {_29} (! bb22) ]  ]
    
    | bb22 = s0
      [ s0 =  [ &_31 <- res._p1 = ([%#schecked_ops'19] false) ] s1
      | s1 = any [ br0 -> {_31 = false} (! bb24) | br1 -> {_31} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = overflowing_mul {[%#schecked_ops'20] (50: UInt8.t)} {[%#schecked_ops'21] (10: UInt8.t)}
          (fun (_ret:tuple) ->  [ &res'0 <- _ret ] s1)
      | s1 = bb27 ]
    
    | bb27 = s0
      [ s0 =  [ &_36 <- res'0._p0 = ([%#schecked_ops'22] (244: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_36 = false} (! bb31) | br1 -> {_36} (! bb28) ]  ]
    
    | bb28 = s0
      [ s0 =  [ &_38 <- res'0._p1 ] s1 | s1 = any [ br0 -> {_38 = false} (! bb30) | br1 -> {_38} (! bb29) ]  ]
    
    | bb29 = return''0 {_0}
    | bb30 = bb32
    | bb31 = bb32
    | bb32 = {[%#schecked_ops'24] false} any
    | bb24 = bb26
    | bb25 = bb26
    | bb26 = {[%#schecked_ops'25] false} any
    | bb20 = {[%#schecked_ops'26] false} any
    | bb17 = {[%#schecked_ops'27] false} any
    | bb14 = {[%#schecked_ops'28] false} any
    | bb11 = {[%#schecked_ops'29] false} any
    | bb8 = {[%#schecked_ops'30] false} any
    | bb4 = {[%#schecked_ops'31] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: UInt8.t = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _21: UInt8.t = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _25: UInt8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & res'0: tuple = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _38: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_mul_zero [#"checked_ops.rs" 102 0 102 30]
  let%span schecked_ops = "checked_ops.rs" 103 12 103 15
  let%span schecked_ops'0 = "checked_ops.rs" 103 43 103 44
  let%span schecked_ops'1 = "checked_ops.rs" 104 12 104 15
  let%span schecked_ops'2 = "checked_ops.rs" 104 35 104 36
  let%span schecked_ops'3 = "checked_ops.rs" 105 12 105 15
  let%span schecked_ops'4 = "checked_ops.rs" 105 37 105 38
  let%span schecked_ops'5 = "checked_ops.rs" 106 14 106 17
  let%span schecked_ops'6 = "checked_ops.rs" 107 21 107 22
  let%span schecked_ops'7 = "checked_ops.rs" 107 35 107 40
  let%span schecked_ops'8 = "checked_ops.rs" 107 4 107 41
  let%span schecked_ops'9 = "checked_ops.rs" 105 4 105 39
  let%span schecked_ops'10 = "checked_ops.rs" 104 4 104 37
  let%span schecked_ops'11 = "checked_ops.rs" 103 4 103 45
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec checked_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ * UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:UInt8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:UInt8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec wrapping_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'1] result = UInt8.mul self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int self_ * UInt8.t'int rhs}
      {[%#snum'3] UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'4] UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result = UInt8.t'int (v_MAX: UInt8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ * UInt8.t'int rhs}
      {[%#snum'6] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ * UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'7] result._p1
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_mul_zero[#"checked_ops.rs" 102 0 102 30] (a:UInt8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {[%#schecked_ops] (0: UInt8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_5} (fun (_ret:UInt8.t) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_3 <- _4 = ([%#schecked_ops'0] (0: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = wrapping_mul {[%#schecked_ops'1] (0: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_10 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 =  [ &_9 <- _10 = ([%#schecked_ops'2] (0: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_mul {[%#schecked_ops'3] (0: UInt8.t)} {a'0} (fun (_ret:UInt8.t) ->  [ &_15 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_14 <- _15 = ([%#schecked_ops'4] (0: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_mul {[%#schecked_ops'5] (0: UInt8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 =  [ &_21 <- res._p0 = ([%#schecked_ops'6] (0: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
    
    | bb12 = s0
      [ s0 =  [ &_23 <- res._p1 = ([%#schecked_ops'7] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
    
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'8] false} any
    | bb10 = {[%#schecked_ops'9] false} any
    | bb7 = {[%#schecked_ops'10] false} any
    | bb4 = {[%#schecked_ops'11] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: UInt8.t = a
    | & _3: bool = Any.any_l ()
    | & _4: UInt8.t = Any.any_l ()
    | & _5: t_Option = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: UInt8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_overflowing_mul [#"checked_ops.rs" 111 0 111 44]
  let%span schecked_ops = "checked_ops.rs" 113 4 113 65
  let%span schecked_ops'0 = "checked_ops.rs" 112 4 112 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  constant v_MAX: UInt8.t = (255: UInt8.t)
  
  let rec overflowing_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum] UInt8.t'int self_ * UInt8.t'int rhs >= UInt8.t'int (v_MIN: UInt8.t)
      /\ UInt8.t'int self_ * UInt8.t'int rhs <= UInt8.t'int (v_MAX: UInt8.t)
       -> UInt8.t'int result._p0 = UInt8.t'int self_ * UInt8.t'int rhs}
      {[%#snum'0] exists k: int. UInt8.t'int result._p0
      = UInt8.t'int self_ * UInt8.t'int rhs + k * (UInt8.t'int (v_MAX: UInt8.t) - UInt8.t'int (v_MIN: UInt8.t) + 1)}
      {[%#snum'1] result._p1
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      (! return' {result}) ]
  
  
  let rec wrapping_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] result = UInt8.mul self_ rhs} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  let rec checked_mul (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum'3] (result = C_None)
      = (UInt8.t'int self_ * UInt8.t'int rhs < UInt8.t'int (v_MIN: UInt8.t)
      \/ UInt8.t'int self_ * UInt8.t'int rhs > UInt8.t'int (v_MAX: UInt8.t))}
      {[%#snum'4] forall r: UInt8.t. result = C_Some r  -> UInt8.t'int r = UInt8.t'int self_ * UInt8.t'int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_overflowing_mul[#"checked_ops.rs" 111 0 111 44] (a:UInt8.t) (b:UInt8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul {a'0} {b'0} (fun (_ret:tuple) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_mul {a'0} {b'0} (fun (_ret:UInt8.t) ->  [ &_9 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_4 <- _6._p0 = _9 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0 [ s0 = overflowing_mul {a'0} {b'0} (fun (_ret:tuple) ->  [ &_16 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_mul {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_21 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none {_21} (fun (_ret:bool) ->  [ &_19 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- _16._p1 = _19 ] s1 | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
    
    | bb8 = return''0 {_0}
    | bb9 = {[%#schecked_ops] false} any
    | bb4 = {[%#schecked_ops'0] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: UInt8.t = a
    | & b'0: UInt8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _9: UInt8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_example [#"checked_ops.rs" 117 0 117 28]
  let%span schecked_ops = "checked_ops.rs" 118 12 118 15
  let%span schecked_ops'0 = "checked_ops.rs" 118 28 118 29
  let%span schecked_ops'1 = "checked_ops.rs" 119 12 119 15
  let%span schecked_ops'2 = "checked_ops.rs" 119 28 119 29
  let%span schecked_ops'3 = "checked_ops.rs" 119 43 119 44
  let%span schecked_ops'4 = "checked_ops.rs" 120 12 120 15
  let%span schecked_ops'5 = "checked_ops.rs" 120 29 120 30
  let%span schecked_ops'6 = "checked_ops.rs" 120 35 120 36
  let%span schecked_ops'7 = "checked_ops.rs" 121 12 121 15
  let%span schecked_ops'8 = "checked_ops.rs" 121 31 121 32
  let%span schecked_ops'9 = "checked_ops.rs" 121 37 121 38
  let%span schecked_ops'10 = "checked_ops.rs" 122 14 122 17
  let%span schecked_ops'11 = "checked_ops.rs" 122 34 122 35
  let%span schecked_ops'12 = "checked_ops.rs" 123 21 123 22
  let%span schecked_ops'13 = "checked_ops.rs" 123 35 123 40
  let%span schecked_ops'14 = "checked_ops.rs" 123 4 123 41
  let%span schecked_ops'15 = "checked_ops.rs" 121 4 121 39
  let%span schecked_ops'16 = "checked_ops.rs" 120 4 120 37
  let%span schecked_ops'17 = "checked_ops.rs" 119 4 119 45
  let%span schecked_ops'18 = "checked_ops.rs" 118 4 118 41
  let%span snum = "../../creusot-contracts/src/std/num.rs" 141 26 141 97
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 143 26 143 83
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 149 27 149 36
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 151 26 151 83
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 153 26 153 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 159 27 159 36
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 161 26 161 89
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 163 26 163 89
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 169 27 169 36
  let%span snum'8 = "../../creusot-contracts/src/std/num.rs" 171 26 171 85
  let%span snum'9 = "../../creusot-contracts/src/std/num.rs" 173 26 173 91
  let%span snum'10 = "../../creusot-contracts/src/std/num.rs" 175 26 175 74
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  let rec checked_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1)}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r
       -> UInt8.t'int r = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:UInt8.t))= {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any [ return''0 (result:UInt8.t)-> {[%#soption'1] C_Some result = self_} (! return' {result}) ] 
  
  let rec wrapping_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= {[@expl:wrapping_div requires] [%#snum'1] UInt8.t'int rhs
    <> 0}
    any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int self_}
      {[%#snum'3] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return' {result}) ]
  
  
  let rec saturating_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= {[@expl:saturating_div requires] [%#snum'4] UInt8.t'int rhs
    <> 0}
    any
    [ return''0 (result:UInt8.t)-> {[%#snum'5] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'6] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= {[@expl:overflowing_div requires] [%#snum'7] UInt8.t'int rhs
    <> 0}
    any
    [ return''0 (result:tuple)-> {[%#snum'8] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result._p0 = UInt8.t'int self_}
      {[%#snum'9] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result._p0 = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      {[%#snum'10] result._p1 = (UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1)}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_example[#"checked_ops.rs" 117 0 117 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div {[%#schecked_ops] (5: UInt8.t)} {[%#schecked_ops'0] (0: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_4} (fun (_ret:bool) ->  [ &_2 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_div {[%#schecked_ops'1] (5: UInt8.t)} {[%#schecked_ops'2] (2: UInt8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = unwrap {_9} (fun (_ret:UInt8.t) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_7 <- _8 = ([%#schecked_ops'3] (2: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = wrapping_div {[%#schecked_ops'4] (5: UInt8.t)} {[%#schecked_ops'5] (2: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_13 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0
      [ s0 =  [ &_12 <- _13 = ([%#schecked_ops'6] (2: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_12 = false} (! bb11) | br1 -> {_12} (! bb10) ]  ]
    
    | bb10 = s0
      [ s0 = saturating_div {[%#schecked_ops'7] (5: UInt8.t)} {[%#schecked_ops'8] (2: UInt8.t)}
          (fun (_ret:UInt8.t) ->  [ &_17 <- _ret ] s1)
      | s1 = bb12 ]
    
    | bb12 = s0
      [ s0 =  [ &_16 <- _17 = ([%#schecked_ops'9] (2: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb13) ]  ]
    
    | bb13 = s0
      [ s0 = overflowing_div {[%#schecked_ops'10] (5: UInt8.t)} {[%#schecked_ops'11] (2: UInt8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb15 ]
    
    | bb15 = s0
      [ s0 =  [ &_21 <- res._p0 = ([%#schecked_ops'12] (2: UInt8.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb19) | br1 -> {_21} (! bb16) ]  ]
    
    | bb16 = s0
      [ s0 =  [ &_23 <- res._p1 = ([%#schecked_ops'13] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb18) | br1 -> {_23} (! bb17) ]  ]
    
    | bb17 = return''0 {_0}
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = {[%#schecked_ops'14] false} any
    | bb14 = {[%#schecked_ops'15] false} any
    | bb11 = {[%#schecked_ops'16] false} any
    | bb8 = {[%#schecked_ops'17] false} any
    | bb4 = {[%#schecked_ops'18] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: UInt8.t = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: UInt8.t = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_no_overflow [#"checked_ops.rs" 128 0 128 44]
  let%span schecked_ops = "checked_ops.rs" 129 41 129 46
  let%span schecked_ops'0 = "checked_ops.rs" 130 33 130 38
  let%span schecked_ops'1 = "checked_ops.rs" 131 35 131 40
  let%span schecked_ops'2 = "checked_ops.rs" 133 21 133 26
  let%span schecked_ops'3 = "checked_ops.rs" 133 39 133 44
  let%span schecked_ops'4 = "checked_ops.rs" 133 4 133 45
  let%span schecked_ops'5 = "checked_ops.rs" 131 4 131 41
  let%span schecked_ops'6 = "checked_ops.rs" 130 4 130 39
  let%span schecked_ops'7 = "checked_ops.rs" 129 4 129 47
  let%span schecked_ops'8 = "checked_ops.rs" 127 11 127 18
  let%span snum = "../../creusot-contracts/src/std/num.rs" 141 26 141 97
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 143 26 143 83
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 149 27 149 36
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 151 26 151 83
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 153 26 153 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 159 27 159 36
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 161 26 161 89
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 163 26 163 89
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 169 27 169 36
  let%span snum'8 = "../../creusot-contracts/src/std/num.rs" 171 26 171 85
  let%span snum'9 = "../../creusot-contracts/src/std/num.rs" 173 26 173 91
  let%span snum'10 = "../../creusot-contracts/src/std/num.rs" 175 26 175 74
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  let rec checked_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1)}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r
       -> UInt8.t'int r = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:UInt8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:UInt8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec wrapping_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= {[@expl:wrapping_div requires] [%#snum'1] UInt8.t'int rhs
    <> 0}
    any
    [ return''0 (result:UInt8.t)-> {[%#snum'2] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int self_}
      {[%#snum'3] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return' {result}) ]
  
  
  let rec saturating_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:UInt8.t))= {[@expl:saturating_div requires] [%#snum'4] UInt8.t'int rhs
    <> 0}
    any
    [ return''0 (result:UInt8.t)-> {[%#snum'5] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result = UInt8.t'int (v_MIN: UInt8.t)}
      {[%#snum'6] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: UInt8.t; _p1: bool }
  
  let rec overflowing_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:tuple))= {[@expl:overflowing_div requires] [%#snum'7] UInt8.t'int rhs
    <> 0}
    any
    [ return''0 (result:tuple)-> {[%#snum'8] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
       -> UInt8.t'int result._p0 = UInt8.t'int self_}
      {[%#snum'9] UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1
      \/ UInt8.t'int result._p0 = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      {[%#snum'10] result._p1 = (UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1)}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_no_overflow[#"checked_ops.rs" 128 0 128 44] (a:UInt8.t) (b:UInt8.t) (return'  (x:()))= {[@expl:test_u8_div_no_overflow requires] [%#schecked_ops'8] UInt8.t'int b
    <> 0}
    (! bb0
    [ bb0 = s0 [ s0 = checked_div {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_7 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = unwrap {_7} (fun (_ret:UInt8.t) ->  [ &_6 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_12 <- b'0 ] s1
      | s1 =  [ &_13 <- _12 = ([%#schecked_ops] (0: UInt8.t)) ] s2
      | s2 = {[@expl:division by zero] [%#schecked_ops] not _13} s3
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = UInt8.div {a'0} {_12} (fun (_ret:UInt8.t) ->  [ &_10 <- _ret ] s1)
      | s1 =  [ &_5 <- _6 = _10 ] s2
      | s2 = any [ br0 -> {_5 = false} (! bb5) | br1 -> {_5} (! bb4) ]  ]
    
    | bb4 = s0 [ s0 = wrapping_div {a'0} {b'0} (fun (_ret:UInt8.t) ->  [ &_17 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_22 <- b'0 ] s1
      | s1 =  [ &_23 <- _22 = ([%#schecked_ops'0] (0: UInt8.t)) ] s2
      | s2 = {[@expl:division by zero] [%#schecked_ops'0] not _23} s3
      | s3 = bb7 ]
    
    | bb7 = s0
      [ s0 = UInt8.div {a'0} {_22} (fun (_ret:UInt8.t) ->  [ &_20 <- _ret ] s1)
      | s1 =  [ &_16 <- _17 = _20 ] s2
      | s2 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ]  ]
    
    | bb8 = s0 [ s0 = saturating_div {a'0} {b'0} (fun (_ret:UInt8.t) ->  [ &_27 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_32 <- b'0 ] s1
      | s1 =  [ &_33 <- _32 = ([%#schecked_ops'1] (0: UInt8.t)) ] s2
      | s2 = {[@expl:division by zero] [%#schecked_ops'1] not _33} s3
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = UInt8.div {a'0} {_32} (fun (_ret:UInt8.t) ->  [ &_30 <- _ret ] s1)
      | s1 =  [ &_26 <- _27 = _30 ] s2
      | s2 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ]  ]
    
    | bb12 = s0 [ s0 = overflowing_div {a'0} {b'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1) | s1 = bb14 ] 
    | bb14 = s0
      [ s0 =  [ &_43 <- b'0 ] s1
      | s1 =  [ &_44 <- _43 = ([%#schecked_ops'2] (0: UInt8.t)) ] s2
      | s2 = {[@expl:division by zero] [%#schecked_ops'2] not _44} s3
      | s3 = bb15 ]
    
    | bb15 = s0
      [ s0 = UInt8.div {a'0} {_43} (fun (_ret:UInt8.t) ->  [ &_41 <- _ret ] s1)
      | s1 =  [ &_39 <- res._p0 = _41 ] s2
      | s2 = any [ br0 -> {_39 = false} (! bb19) | br1 -> {_39} (! bb16) ]  ]
    
    | bb16 = s0
      [ s0 =  [ &_45 <- res._p1 = ([%#schecked_ops'3] false) ] s1
      | s1 = any [ br0 -> {_45 = false} (! bb18) | br1 -> {_45} (! bb17) ]  ]
    
    | bb17 = return''0 {_0}
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = {[%#schecked_ops'4] false} any
    | bb13 = {[%#schecked_ops'5] false} any
    | bb9 = {[%#schecked_ops'6] false} any
    | bb5 = {[%#schecked_ops'7] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: UInt8.t = a
    | & b'0: UInt8.t = b
    | & _5: bool = Any.any_l ()
    | & _6: UInt8.t = Any.any_l ()
    | & _7: t_Option = Any.any_l ()
    | & _10: UInt8.t = Any.any_l ()
    | & _12: UInt8.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: UInt8.t = Any.any_l ()
    | & _20: UInt8.t = Any.any_l ()
    | & _22: UInt8.t = Any.any_l ()
    | & _23: bool = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: UInt8.t = Any.any_l ()
    | & _30: UInt8.t = Any.any_l ()
    | & _32: UInt8.t = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & _41: UInt8.t = Any.any_l ()
    | & _43: UInt8.t = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & _45: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_u8_div_zero [#"checked_ops.rs" 137 0 137 30]
  let%span schecked_ops = "checked_ops.rs" 138 26 138 27
  let%span schecked_ops'0 = "checked_ops.rs" 138 4 138 39
  let%span snum = "../../creusot-contracts/src/std/num.rs" 141 26 141 97
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 143 26 143 83
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.UInt8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some UInt8.t
  
  constant v_MIN: UInt8.t = (0: UInt8.t)
  
  let rec checked_div (self_:UInt8.t) (rhs:UInt8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (UInt8.t'int rhs = 0 \/ UInt8.t'int self_ = UInt8.t'int (v_MIN: UInt8.t) /\ UInt8.t'int rhs = - 1)}
      {[%#snum'0] forall r: UInt8.t. result = C_Some r
       -> UInt8.t'int r = Int.div (UInt8.t'int self_) (UInt8.t'int rhs)}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_u8_div_zero[#"checked_ops.rs" 137 0 137 30] (a:UInt8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div {a'0} {[%#schecked_ops] (0: UInt8.t)} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_5} (fun (_ret:bool) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = return''0 {_0}
    | bb4 = {[%#schecked_ops'0] false} any ]
    ) [ & _0: () = Any.any_l () | & a'0: UInt8.t = a | & _3: bool = Any.any_l () | & _5: t_Option = Any.any_l () ] 
    [ return''0 (result:())-> (! return' {result}) ]

end
module M_checked_ops__test_i8_add_example [#"checked_ops.rs" 142 0 142 28]
  let%span schecked_ops = "checked_ops.rs" 143 12 143 15
  let%span schecked_ops'0 = "checked_ops.rs" 143 28 143 30
  let%span schecked_ops'1 = "checked_ops.rs" 143 44 143 46
  let%span schecked_ops'2 = "checked_ops.rs" 144 12 144 17
  let%span schecked_ops'3 = "checked_ops.rs" 144 30 144 32
  let%span schecked_ops'4 = "checked_ops.rs" 145 12 145 20
  let%span schecked_ops'5 = "checked_ops.rs" 145 33 145 36
  let%span schecked_ops'6 = "checked_ops.rs" 147 12 147 15
  let%span schecked_ops'7 = "checked_ops.rs" 147 29 147 31
  let%span schecked_ops'8 = "checked_ops.rs" 147 36 147 38
  let%span schecked_ops'9 = "checked_ops.rs" 148 12 148 17
  let%span schecked_ops'10 = "checked_ops.rs" 148 31 148 33
  let%span schecked_ops'11 = "checked_ops.rs" 148 38 148 42
  let%span schecked_ops'12 = "checked_ops.rs" 149 12 149 20
  let%span schecked_ops'13 = "checked_ops.rs" 149 34 149 37
  let%span schecked_ops'14 = "checked_ops.rs" 149 42 149 45
  let%span schecked_ops'15 = "checked_ops.rs" 151 12 151 15
  let%span schecked_ops'16 = "checked_ops.rs" 151 31 151 33
  let%span schecked_ops'17 = "checked_ops.rs" 151 38 151 40
  let%span schecked_ops'18 = "checked_ops.rs" 152 12 152 17
  let%span schecked_ops'19 = "checked_ops.rs" 152 33 152 35
  let%span schecked_ops'20 = "checked_ops.rs" 152 40 152 43
  let%span schecked_ops'21 = "checked_ops.rs" 153 12 153 20
  let%span schecked_ops'22 = "checked_ops.rs" 153 36 153 39
  let%span schecked_ops'23 = "checked_ops.rs" 153 44 153 48
  let%span schecked_ops'24 = "checked_ops.rs" 155 14 155 17
  let%span schecked_ops'25 = "checked_ops.rs" 155 34 155 36
  let%span schecked_ops'26 = "checked_ops.rs" 156 21 156 23
  let%span schecked_ops'27 = "checked_ops.rs" 156 36 156 41
  let%span schecked_ops'28 = "checked_ops.rs" 157 14 157 19
  let%span schecked_ops'29 = "checked_ops.rs" 157 36 157 38
  let%span schecked_ops'30 = "checked_ops.rs" 158 21 158 25
  let%span schecked_ops'31 = "checked_ops.rs" 158 38 158 42
  let%span schecked_ops'32 = "checked_ops.rs" 159 14 159 22
  let%span schecked_ops'33 = "checked_ops.rs" 159 39 159 42
  let%span schecked_ops'34 = "checked_ops.rs" 160 21 160 24
  let%span schecked_ops'35 = "checked_ops.rs" 160 37 160 41
  let%span schecked_ops'36 = "checked_ops.rs" 160 4 160 42
  let%span schecked_ops'37 = "checked_ops.rs" 158 4 158 43
  let%span schecked_ops'38 = "checked_ops.rs" 156 4 156 42
  let%span schecked_ops'39 = "checked_ops.rs" 153 4 153 49
  let%span schecked_ops'40 = "checked_ops.rs" 152 4 152 44
  let%span schecked_ops'41 = "checked_ops.rs" 151 4 151 41
  let%span schecked_ops'42 = "checked_ops.rs" 149 4 149 46
  let%span schecked_ops'43 = "checked_ops.rs" 148 4 148 43
  let%span schecked_ops'44 = "checked_ops.rs" 147 4 147 39
  let%span schecked_ops'45 = "checked_ops.rs" 145 4 145 48
  let%span schecked_ops'46 = "checked_ops.rs" 144 4 144 44
  let%span schecked_ops'47 = "checked_ops.rs" 143 4 143 47
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:Int8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:Int8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption'1] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.add self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ + Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ + Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_example[#"checked_ops.rs" 142 0 142 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_add {[%#schecked_ops] (5: Int8.t)} {[%#schecked_ops'0] (10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_4} (fun (_ret:Int8.t) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_2 <- _3 = ([%#schecked_ops'1] (15: Int8.t)) ] s1
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = checked_add {[%#schecked_ops'2] (120: Int8.t)} {[%#schecked_ops'3] (10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = is_none {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = checked_add {[%#schecked_ops'4] (-120: Int8.t)} {[%#schecked_ops'5] (-10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_14 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = is_none {_14} (fun (_ret:bool) ->  [ &_12 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_add {[%#schecked_ops'6] (5: Int8.t)} {[%#schecked_ops'7] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_18 <- _ret ] s1)
      | s1 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_17 <- _18 = ([%#schecked_ops'8] (15: Int8.t)) ] s1
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
    
    | bb14 = s0
      [ s0 = wrapping_add {[%#schecked_ops'9] (120: Int8.t)} {[%#schecked_ops'10] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_22 <- _ret ] s1)
      | s1 = bb16 ]
    
    | bb16 = s0
      [ s0 =  [ &_21 <- _22 = ([%#schecked_ops'11] (-126: Int8.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 = wrapping_add {[%#schecked_ops'12] (-120: Int8.t)} {[%#schecked_ops'13] (-10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_26 <- _ret ] s1)
      | s1 = bb19 ]
    
    | bb19 = s0
      [ s0 =  [ &_25 <- _26 = ([%#schecked_ops'14] (126: Int8.t)) ] s1
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
    
    | bb20 = s0
      [ s0 = saturating_add {[%#schecked_ops'15] (5: Int8.t)} {[%#schecked_ops'16] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_30 <- _ret ] s1)
      | s1 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &_29 <- _30 = ([%#schecked_ops'17] (15: Int8.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = saturating_add {[%#schecked_ops'18] (120: Int8.t)} {[%#schecked_ops'19] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_34 <- _ret ] s1)
      | s1 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &_33 <- _34 = ([%#schecked_ops'20] (127: Int8.t)) ] s1
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
    
    | bb26 = s0
      [ s0 = saturating_add {[%#schecked_ops'21] (-120: Int8.t)} {[%#schecked_ops'22] (-10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_38 <- _ret ] s1)
      | s1 = bb28 ]
    
    | bb28 = s0
      [ s0 =  [ &_37 <- _38 = ([%#schecked_ops'23] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
    
    | bb29 = s0
      [ s0 = overflowing_add {[%#schecked_ops'24] (5: Int8.t)} {[%#schecked_ops'25] (10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb31 ]
    
    | bb31 = s0
      [ s0 =  [ &_42 <- res._p0 = ([%#schecked_ops'26] (15: Int8.t)) ] s1
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
    
    | bb32 = s0
      [ s0 =  [ &_44 <- res._p1 = ([%#schecked_ops'27] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
    
    | bb33 = s0
      [ s0 = overflowing_add {[%#schecked_ops'28] (120: Int8.t)} {[%#schecked_ops'29] (10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'0 <- _ret ] s1)
      | s1 = bb37 ]
    
    | bb37 = s0
      [ s0 =  [ &_49 <- res'0._p0 = ([%#schecked_ops'30] (-126: Int8.t)) ] s1
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
    
    | bb38 = s0
      [ s0 =  [ &_51 <- res'0._p1 ] s1 | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
    
    | bb39 = s0
      [ s0 = overflowing_add {[%#schecked_ops'32] (-120: Int8.t)} {[%#schecked_ops'33] (-10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'1 <- _ret ] s1)
      | s1 = bb43 ]
    
    | bb43 = s0
      [ s0 =  [ &_56 <- res'1._p0 = ([%#schecked_ops'34] (126: Int8.t)) ] s1
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
    
    | bb44 = s0
      [ s0 =  [ &_58 <- res'1._p1 ] s1 | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
    
    | bb45 = return''0 {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops'36] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops'37] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops'38] false} any
    | bb30 = {[%#schecked_ops'39] false} any
    | bb27 = {[%#schecked_ops'40] false} any
    | bb24 = {[%#schecked_ops'41] false} any
    | bb21 = {[%#schecked_ops'42] false} any
    | bb18 = {[%#schecked_ops'43] false} any
    | bb15 = {[%#schecked_ops'44] false} any
    | bb12 = {[%#schecked_ops'45] false} any
    | bb8 = {[%#schecked_ops'46] false} any
    | bb4 = {[%#schecked_ops'47] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: Int8.t = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: Int8.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int8.t = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int8.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _34: Int8.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & res'0: tuple = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & res'1: tuple = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_add_overflow_pos [#"checked_ops.rs" 165 0 165 38]
  let%span schecked_ops = "checked_ops.rs" 166 12 166 17
  let%span schecked_ops'0 = "checked_ops.rs" 167 12 167 17
  let%span schecked_ops'1 = "checked_ops.rs" 167 41 167 44
  let%span schecked_ops'2 = "checked_ops.rs" 167 47 167 48
  let%span schecked_ops'3 = "checked_ops.rs" 168 12 168 17
  let%span schecked_ops'4 = "checked_ops.rs" 168 39 168 42
  let%span schecked_ops'5 = "checked_ops.rs" 169 14 169 19
  let%span schecked_ops'6 = "checked_ops.rs" 170 25 170 28
  let%span schecked_ops'7 = "checked_ops.rs" 170 31 170 32
  let%span schecked_ops'8 = "checked_ops.rs" 170 45 170 49
  let%span schecked_ops'9 = "checked_ops.rs" 170 4 170 50
  let%span schecked_ops'10 = "checked_ops.rs" 168 4 168 43
  let%span schecked_ops'11 = "checked_ops.rs" 167 4 167 49
  let%span schecked_ops'12 = "checked_ops.rs" 166 4 166 43
  let%span schecked_ops'13 = "checked_ops.rs" 164 11 164 17
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.add self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ + Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ + Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_overflow_pos[#"checked_ops.rs" 165 0 165 38] (a:Int8.t) (return'  (x:()))= {[@expl:test_i8_add_overflow_pos requires] [%#schecked_ops'13] Int8.to_int a
    > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add {[%#schecked_ops] (127: Int8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_6 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add {[%#schecked_ops'0] (127: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 = Int8.sub {a'0} {[%#schecked_ops'1] (127: Int8.t)} (fun (_ret:Int8.t) ->  [ &_14 <- _ret ] s1)
      | s1 = Int8.sub {_14} {[%#schecked_ops'2] (2: Int8.t)} (fun (_ret:Int8.t) ->  [ &_13 <- _ret ] s2)
      | s2 =  [ &_10 <- _11 = _13 ] s3
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_add {[%#schecked_ops'3] (127: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_19 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_18 <- _19 = ([%#schecked_ops'4] (127: Int8.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_add {[%#schecked_ops'5] (127: Int8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 = Int8.sub {a'0} {[%#schecked_ops'6] (127: Int8.t)} (fun (_ret:Int8.t) ->  [ &_28 <- _ret ] s1)
      | s1 = Int8.sub {_28} {[%#schecked_ops'7] (2: Int8.t)} (fun (_ret:Int8.t) ->  [ &_27 <- _ret ] s2)
      | s2 =  [ &_25 <- res._p0 = _27 ] s3
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
    
    | bb12 = s0 [ s0 =  [ &_30 <- res._p1 ] s1 | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ] 
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'9] false} any
    | bb10 = {[%#schecked_ops'10] false} any
    | bb7 = {[%#schecked_ops'11] false} any
    | bb4 = {[%#schecked_ops'12] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int8.t = Any.any_l ()
    | & _13: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _19: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _27: Int8.t = Any.any_l ()
    | & _28: Int8.t = Any.any_l ()
    | & _30: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_add_overflow_neg [#"checked_ops.rs" 175 0 175 38]
  let%span schecked_ops = "checked_ops.rs" 176 12 176 20
  let%span schecked_ops'0 = "checked_ops.rs" 177 12 177 20
  let%span schecked_ops'1 = "checked_ops.rs" 177 44 177 47
  let%span schecked_ops'2 = "checked_ops.rs" 177 50 177 51
  let%span schecked_ops'3 = "checked_ops.rs" 178 12 178 20
  let%span schecked_ops'4 = "checked_ops.rs" 178 42 178 46
  let%span schecked_ops'5 = "checked_ops.rs" 179 14 179 22
  let%span schecked_ops'6 = "checked_ops.rs" 180 25 180 28
  let%span schecked_ops'7 = "checked_ops.rs" 180 31 180 32
  let%span schecked_ops'8 = "checked_ops.rs" 180 45 180 49
  let%span schecked_ops'9 = "checked_ops.rs" 180 4 180 50
  let%span schecked_ops'10 = "checked_ops.rs" 178 4 178 47
  let%span schecked_ops'11 = "checked_ops.rs" 177 4 177 52
  let%span schecked_ops'12 = "checked_ops.rs" 176 4 176 46
  let%span schecked_ops'13 = "checked_ops.rs" 174 11 174 17
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.add self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ + Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ + Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_add_overflow_neg[#"checked_ops.rs" 175 0 175 38] (a:Int8.t) (return'  (x:()))= {[@expl:test_i8_add_overflow_neg requires] [%#schecked_ops'13] Int8.to_int a
    < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_add {[%#schecked_ops] (-128: Int8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_6 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_add {[%#schecked_ops'0] (-128: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 = Int8.add {a'0} {[%#schecked_ops'1] (127: Int8.t)} (fun (_ret:Int8.t) ->  [ &_14 <- _ret ] s1)
      | s1 = Int8.add {_14} {[%#schecked_ops'2] (1: Int8.t)} (fun (_ret:Int8.t) ->  [ &_13 <- _ret ] s2)
      | s2 =  [ &_10 <- _11 = _13 ] s3
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_add {[%#schecked_ops'3] (-128: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_19 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_18 <- _19 = ([%#schecked_ops'4] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_add {[%#schecked_ops'5] (-128: Int8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 = Int8.add {a'0} {[%#schecked_ops'6] (127: Int8.t)} (fun (_ret:Int8.t) ->  [ &_28 <- _ret ] s1)
      | s1 = Int8.add {_28} {[%#schecked_ops'7] (1: Int8.t)} (fun (_ret:Int8.t) ->  [ &_27 <- _ret ] s2)
      | s2 =  [ &_25 <- res._p0 = _27 ] s3
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
    
    | bb12 = s0 [ s0 =  [ &_30 <- res._p1 ] s1 | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ] 
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'9] false} any
    | bb10 = {[%#schecked_ops'10] false} any
    | bb7 = {[%#schecked_ops'11] false} any
    | bb4 = {[%#schecked_ops'12] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int8.t = Any.any_l ()
    | & _13: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _19: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _27: Int8.t = Any.any_l ()
    | & _28: Int8.t = Any.any_l ()
    | & _30: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_wrapping_add [#"checked_ops.rs" 186 0 186 47]
  let%span schecked_ops = "checked_ops.rs" 185 10 185 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec wrapping_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum] result = Int8.add self_ rhs} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_wrapping_add[#"checked_ops.rs" 186 0 186 47] (a:Int8.t) (b:Int8.t) (return'  (x:Int8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_add {a'0} {b'0} (fun (_ret:Int8.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: Int8.t = Any.any_l () | & a'0: Int8.t = a | & b'0: Int8.t = b ] 
    [ return''0 (result:Int8.t)-> {[@expl:test_i8_wrapping_add ensures] [%#schecked_ops] Int8.to_int result
      = Int8.to_int a + Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b - 256
      \/ Int8.to_int result = Int8.to_int a + Int8.to_int b + 256}
      (! return' {result}) ]

end
module M_checked_ops__test_i8_overflowing_add [#"checked_ops.rs" 191 0 191 44]
  let%span schecked_ops = "checked_ops.rs" 193 4 193 65
  let%span schecked_ops'0 = "checked_ops.rs" 192 4 192 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec overflowing_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum] Int8.to_int self_ + Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ + Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ + Int8.to_int rhs}
      {[%#snum'0] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ + Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'1] result._p1
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  let rec wrapping_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] result = Int8.add self_ rhs} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  let rec checked_add (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum'3] (result = C_None)
      = (Int8.to_int self_ + Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ + Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'4] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ + Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_add[#"checked_ops.rs" 191 0 191 44] (a:Int8.t) (b:Int8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_add {a'0} {b'0} (fun (_ret:tuple) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_add {a'0} {b'0} (fun (_ret:Int8.t) ->  [ &_9 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_4 <- _6._p0 = _9 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0 [ s0 = overflowing_add {a'0} {b'0} (fun (_ret:tuple) ->  [ &_16 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_add {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_21 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none {_21} (fun (_ret:bool) ->  [ &_19 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- _16._p1 = _19 ] s1 | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
    
    | bb8 = return''0 {_0}
    | bb9 = {[%#schecked_ops] false} any
    | bb4 = {[%#schecked_ops'0] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & b'0: Int8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _9: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_example [#"checked_ops.rs" 197 0 197 28]
  let%span schecked_ops = "checked_ops.rs" 198 12 198 15
  let%span schecked_ops'0 = "checked_ops.rs" 198 28 198 30
  let%span schecked_ops'1 = "checked_ops.rs" 198 44 198 46
  let%span schecked_ops'2 = "checked_ops.rs" 199 12 199 17
  let%span schecked_ops'3 = "checked_ops.rs" 199 30 199 32
  let%span schecked_ops'4 = "checked_ops.rs" 199 46 199 49
  let%span schecked_ops'5 = "checked_ops.rs" 200 12 200 20
  let%span schecked_ops'6 = "checked_ops.rs" 200 33 200 35
  let%span schecked_ops'7 = "checked_ops.rs" 202 12 202 15
  let%span schecked_ops'8 = "checked_ops.rs" 202 29 202 31
  let%span schecked_ops'9 = "checked_ops.rs" 202 36 202 38
  let%span schecked_ops'10 = "checked_ops.rs" 203 12 203 17
  let%span schecked_ops'11 = "checked_ops.rs" 203 31 203 33
  let%span schecked_ops'12 = "checked_ops.rs" 203 38 203 41
  let%span schecked_ops'13 = "checked_ops.rs" 204 12 204 20
  let%span schecked_ops'14 = "checked_ops.rs" 204 34 204 36
  let%span schecked_ops'15 = "checked_ops.rs" 204 41 204 44
  let%span schecked_ops'16 = "checked_ops.rs" 206 12 206 15
  let%span schecked_ops'17 = "checked_ops.rs" 206 31 206 33
  let%span schecked_ops'18 = "checked_ops.rs" 206 38 206 40
  let%span schecked_ops'19 = "checked_ops.rs" 207 12 207 17
  let%span schecked_ops'20 = "checked_ops.rs" 207 33 207 35
  let%span schecked_ops'21 = "checked_ops.rs" 207 40 207 43
  let%span schecked_ops'22 = "checked_ops.rs" 208 12 208 20
  let%span schecked_ops'23 = "checked_ops.rs" 208 36 208 38
  let%span schecked_ops'24 = "checked_ops.rs" 208 43 208 47
  let%span schecked_ops'25 = "checked_ops.rs" 210 14 210 17
  let%span schecked_ops'26 = "checked_ops.rs" 210 34 210 36
  let%span schecked_ops'27 = "checked_ops.rs" 211 21 211 23
  let%span schecked_ops'28 = "checked_ops.rs" 211 36 211 41
  let%span schecked_ops'29 = "checked_ops.rs" 212 14 212 19
  let%span schecked_ops'30 = "checked_ops.rs" 212 36 212 38
  let%span schecked_ops'31 = "checked_ops.rs" 213 21 213 24
  let%span schecked_ops'32 = "checked_ops.rs" 213 37 213 42
  let%span schecked_ops'33 = "checked_ops.rs" 214 14 214 22
  let%span schecked_ops'34 = "checked_ops.rs" 214 39 214 41
  let%span schecked_ops'35 = "checked_ops.rs" 215 21 215 24
  let%span schecked_ops'36 = "checked_ops.rs" 215 37 215 41
  let%span schecked_ops'37 = "checked_ops.rs" 215 4 215 42
  let%span schecked_ops'38 = "checked_ops.rs" 213 4 213 43
  let%span schecked_ops'39 = "checked_ops.rs" 211 4 211 42
  let%span schecked_ops'40 = "checked_ops.rs" 208 4 208 48
  let%span schecked_ops'41 = "checked_ops.rs" 207 4 207 44
  let%span schecked_ops'42 = "checked_ops.rs" 206 4 206 41
  let%span schecked_ops'43 = "checked_ops.rs" 204 4 204 45
  let%span schecked_ops'44 = "checked_ops.rs" 203 4 203 42
  let%span schecked_ops'45 = "checked_ops.rs" 202 4 202 39
  let%span schecked_ops'46 = "checked_ops.rs" 200 4 200 47
  let%span schecked_ops'47 = "checked_ops.rs" 199 4 199 50
  let%span schecked_ops'48 = "checked_ops.rs" 198 4 198 47
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:Int8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:Int8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption'1] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.sub self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ - Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ - Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_example[#"checked_ops.rs" 197 0 197 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {[%#schecked_ops] (5: Int8.t)} {[%#schecked_ops'0] (10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_4} (fun (_ret:Int8.t) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_2 <- _3 = ([%#schecked_ops'1] (-5: Int8.t)) ] s1
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = checked_sub {[%#schecked_ops'2] (120: Int8.t)} {[%#schecked_ops'3] (10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = unwrap {_9} (fun (_ret:Int8.t) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_7 <- _8 = ([%#schecked_ops'4] (110: Int8.t)) ] s1
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = checked_sub {[%#schecked_ops'5] (-120: Int8.t)} {[%#schecked_ops'6] (10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_14 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = is_none {_14} (fun (_ret:bool) ->  [ &_12 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'7] (5: Int8.t)} {[%#schecked_ops'8] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_18 <- _ret ] s1)
      | s1 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_17 <- _18 = ([%#schecked_ops'9] (-5: Int8.t)) ] s1
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
    
    | bb14 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'10] (120: Int8.t)} {[%#schecked_ops'11] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_22 <- _ret ] s1)
      | s1 = bb16 ]
    
    | bb16 = s0
      [ s0 =  [ &_21 <- _22 = ([%#schecked_ops'12] (110: Int8.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'13] (-120: Int8.t)} {[%#schecked_ops'14] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_26 <- _ret ] s1)
      | s1 = bb19 ]
    
    | bb19 = s0
      [ s0 =  [ &_25 <- _26 = ([%#schecked_ops'15] (126: Int8.t)) ] s1
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
    
    | bb20 = s0
      [ s0 = saturating_sub {[%#schecked_ops'16] (5: Int8.t)} {[%#schecked_ops'17] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_30 <- _ret ] s1)
      | s1 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &_29 <- _30 = ([%#schecked_ops'18] (-5: Int8.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = saturating_sub {[%#schecked_ops'19] (120: Int8.t)} {[%#schecked_ops'20] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_34 <- _ret ] s1)
      | s1 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &_33 <- _34 = ([%#schecked_ops'21] (110: Int8.t)) ] s1
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
    
    | bb26 = s0
      [ s0 = saturating_sub {[%#schecked_ops'22] (-120: Int8.t)} {[%#schecked_ops'23] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_38 <- _ret ] s1)
      | s1 = bb28 ]
    
    | bb28 = s0
      [ s0 =  [ &_37 <- _38 = ([%#schecked_ops'24] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
    
    | bb29 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'25] (5: Int8.t)} {[%#schecked_ops'26] (10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb31 ]
    
    | bb31 = s0
      [ s0 =  [ &_42 <- res._p0 = ([%#schecked_ops'27] (-5: Int8.t)) ] s1
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
    
    | bb32 = s0
      [ s0 =  [ &_44 <- res._p1 = ([%#schecked_ops'28] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
    
    | bb33 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'29] (120: Int8.t)} {[%#schecked_ops'30] (10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'0 <- _ret ] s1)
      | s1 = bb37 ]
    
    | bb37 = s0
      [ s0 =  [ &_49 <- res'0._p0 = ([%#schecked_ops'31] (110: Int8.t)) ] s1
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
    
    | bb38 = s0
      [ s0 =  [ &_51 <- res'0._p1 = ([%#schecked_ops'32] false) ] s1
      | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
    
    | bb39 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'33] (-120: Int8.t)} {[%#schecked_ops'34] (10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'1 <- _ret ] s1)
      | s1 = bb43 ]
    
    | bb43 = s0
      [ s0 =  [ &_56 <- res'1._p0 = ([%#schecked_ops'35] (126: Int8.t)) ] s1
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
    
    | bb44 = s0
      [ s0 =  [ &_58 <- res'1._p1 ] s1 | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
    
    | bb45 = return''0 {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops'37] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops'38] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops'39] false} any
    | bb30 = {[%#schecked_ops'40] false} any
    | bb27 = {[%#schecked_ops'41] false} any
    | bb24 = {[%#schecked_ops'42] false} any
    | bb21 = {[%#schecked_ops'43] false} any
    | bb18 = {[%#schecked_ops'44] false} any
    | bb15 = {[%#schecked_ops'45] false} any
    | bb12 = {[%#schecked_ops'46] false} any
    | bb8 = {[%#schecked_ops'47] false} any
    | bb4 = {[%#schecked_ops'48] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: Int8.t = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: Int8.t = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: Int8.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int8.t = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int8.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _34: Int8.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & res'0: tuple = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & res'1: tuple = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_overflow_pos [#"checked_ops.rs" 220 0 220 38]
  let%span schecked_ops = "checked_ops.rs" 221 12 221 20
  let%span schecked_ops'0 = "checked_ops.rs" 222 12 222 20
  let%span schecked_ops'1 = "checked_ops.rs" 222 40 222 43
  let%span schecked_ops'2 = "checked_ops.rs" 222 50 222 51
  let%span schecked_ops'3 = "checked_ops.rs" 223 12 223 20
  let%span schecked_ops'4 = "checked_ops.rs" 223 42 223 46
  let%span schecked_ops'5 = "checked_ops.rs" 224 14 224 22
  let%span schecked_ops'6 = "checked_ops.rs" 225 21 225 24
  let%span schecked_ops'7 = "checked_ops.rs" 225 31 225 32
  let%span schecked_ops'8 = "checked_ops.rs" 225 45 225 49
  let%span schecked_ops'9 = "checked_ops.rs" 225 4 225 50
  let%span schecked_ops'10 = "checked_ops.rs" 223 4 223 47
  let%span schecked_ops'11 = "checked_ops.rs" 222 4 222 52
  let%span schecked_ops'12 = "checked_ops.rs" 221 4 221 46
  let%span schecked_ops'13 = "checked_ops.rs" 219 11 219 17
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.sub self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ - Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ - Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_overflow_pos[#"checked_ops.rs" 220 0 220 38] (a:Int8.t) (return'  (x:()))= {[@expl:test_i8_sub_overflow_pos requires] [%#schecked_ops'13] Int8.to_int a
    > 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {[%#schecked_ops] (-128: Int8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_6 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'0] (-128: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 = Int8.sub {[%#schecked_ops'1] (127: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_14 <- _ret ] s1)
      | s1 = Int8.add {_14} {[%#schecked_ops'2] (1: Int8.t)} (fun (_ret:Int8.t) ->  [ &_13 <- _ret ] s2)
      | s2 =  [ &_10 <- _11 = _13 ] s3
      | s3 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_sub {[%#schecked_ops'3] (-128: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_19 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_18 <- _19 = ([%#schecked_ops'4] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'5] (-128: Int8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 = Int8.sub {[%#schecked_ops'6] (127: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_28 <- _ret ] s1)
      | s1 = Int8.add {_28} {[%#schecked_ops'7] (1: Int8.t)} (fun (_ret:Int8.t) ->  [ &_27 <- _ret ] s2)
      | s2 =  [ &_25 <- res._p0 = _27 ] s3
      | s3 = any [ br0 -> {_25 = false} (! bb15) | br1 -> {_25} (! bb12) ]  ]
    
    | bb12 = s0 [ s0 =  [ &_30 <- res._p1 ] s1 | s1 = any [ br0 -> {_30 = false} (! bb14) | br1 -> {_30} (! bb13) ]  ] 
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'9] false} any
    | bb10 = {[%#schecked_ops'10] false} any
    | bb7 = {[%#schecked_ops'11] false} any
    | bb4 = {[%#schecked_ops'12] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int8.t = Any.any_l ()
    | & _13: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _19: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _27: Int8.t = Any.any_l ()
    | & _28: Int8.t = Any.any_l ()
    | & _30: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_sub_overflow_neg [#"checked_ops.rs" 230 0 230 38]
  let%span schecked_ops = "checked_ops.rs" 231 12 231 17
  let%span schecked_ops'0 = "checked_ops.rs" 232 12 232 17
  let%span schecked_ops'1 = "checked_ops.rs" 232 39 232 40
  let%span schecked_ops'2 = "checked_ops.rs" 232 48 232 51
  let%span schecked_ops'3 = "checked_ops.rs" 233 12 233 17
  let%span schecked_ops'4 = "checked_ops.rs" 233 39 233 42
  let%span schecked_ops'5 = "checked_ops.rs" 234 14 234 19
  let%span schecked_ops'6 = "checked_ops.rs" 235 23 235 24
  let%span schecked_ops'7 = "checked_ops.rs" 235 32 235 35
  let%span schecked_ops'8 = "checked_ops.rs" 235 48 235 52
  let%span schecked_ops'9 = "checked_ops.rs" 235 4 235 53
  let%span schecked_ops'10 = "checked_ops.rs" 233 4 233 43
  let%span schecked_ops'11 = "checked_ops.rs" 232 4 232 52
  let%span schecked_ops'12 = "checked_ops.rs" 231 4 231 43
  let%span schecked_ops'13 = "checked_ops.rs" 229 11 229 17
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.sub self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ - Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ - Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_sub_overflow_neg[#"checked_ops.rs" 230 0 230 38] (a:Int8.t) (return'  (x:()))= {[@expl:test_i8_sub_overflow_neg requires] [%#schecked_ops'13] Int8.to_int a
    < 0}
    (! bb0
    [ bb0 = s0
      [ s0 = checked_sub {[%#schecked_ops] (127: Int8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_6 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_6} (fun (_ret:bool) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ] 
    | bb3 = s0
      [ s0 = wrapping_sub {[%#schecked_ops'0] (127: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 = Int8.add {[%#schecked_ops'1] (2: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_15 <- _ret ] s1)
      | s1 = Int8.neg {_15} (fun (_ret:Int8.t) ->  [ &_14 <- _ret ] s2)
      | s2 = Int8.sub {_14} {[%#schecked_ops'2] (127: Int8.t)} (fun (_ret:Int8.t) ->  [ &_13 <- _ret ] s3)
      | s3 =  [ &_10 <- _11 = _13 ] s4
      | s4 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_sub {[%#schecked_ops'3] (127: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_20 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_19 <- _20 = ([%#schecked_ops'4] (127: Int8.t)) ] s1
      | s1 = any [ br0 -> {_19 = false} (! bb10) | br1 -> {_19} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_sub {[%#schecked_ops'5] (127: Int8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 = Int8.add {[%#schecked_ops'6] (2: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_30 <- _ret ] s1)
      | s1 = Int8.neg {_30} (fun (_ret:Int8.t) ->  [ &_29 <- _ret ] s2)
      | s2 = Int8.sub {_29} {[%#schecked_ops'7] (127: Int8.t)} (fun (_ret:Int8.t) ->  [ &_28 <- _ret ] s3)
      | s3 =  [ &_26 <- res._p0 = _28 ] s4
      | s4 = any [ br0 -> {_26 = false} (! bb15) | br1 -> {_26} (! bb12) ]  ]
    
    | bb12 = s0 [ s0 =  [ &_32 <- res._p1 ] s1 | s1 = any [ br0 -> {_32 = false} (! bb14) | br1 -> {_32} (! bb13) ]  ] 
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'9] false} any
    | bb10 = {[%#schecked_ops'10] false} any
    | bb7 = {[%#schecked_ops'11] false} any
    | bb4 = {[%#schecked_ops'12] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & _4: bool = Any.any_l ()
    | & _6: t_Option = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int8.t = Any.any_l ()
    | & _13: Int8.t = Any.any_l ()
    | & _14: Int8.t = Any.any_l ()
    | & _15: Int8.t = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: Int8.t = Any.any_l ()
    | & _29: Int8.t = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _32: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_wrapping_sub [#"checked_ops.rs" 241 0 241 47]
  let%span schecked_ops = "checked_ops.rs" 240 10 240 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  let rec wrapping_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum] result = Int8.sub self_ rhs} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_wrapping_sub[#"checked_ops.rs" 241 0 241 47] (a:Int8.t) (b:Int8.t) (return'  (x:Int8.t))= (! bb0
    [ bb0 = s0 [ s0 = wrapping_sub {a'0} {b'0} (fun (_ret:Int8.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = return''0 {_0} ]
    ) [ & _0: Int8.t = Any.any_l () | & a'0: Int8.t = a | & b'0: Int8.t = b ] 
    [ return''0 (result:Int8.t)-> {[@expl:test_i8_wrapping_sub ensures] [%#schecked_ops] Int8.to_int result
      = Int8.to_int a - Int8.to_int b
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b + 256
      \/ Int8.to_int result = Int8.to_int a - Int8.to_int b - 256}
      (! return' {result}) ]

end
module M_checked_ops__test_i8_overflowing_sub [#"checked_ops.rs" 246 0 246 44]
  let%span schecked_ops = "checked_ops.rs" 248 4 248 65
  let%span schecked_ops'0 = "checked_ops.rs" 247 4 247 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec overflowing_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum] Int8.to_int self_ - Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ - Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ - Int8.to_int rhs}
      {[%#snum'0] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ - Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'1] result._p1
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  let rec wrapping_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] result = Int8.sub self_ rhs} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  let rec checked_sub (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum'3] (result = C_None)
      = (Int8.to_int self_ - Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ - Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'4] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ - Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_sub[#"checked_ops.rs" 246 0 246 44] (a:Int8.t) (b:Int8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_sub {a'0} {b'0} (fun (_ret:tuple) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_sub {a'0} {b'0} (fun (_ret:Int8.t) ->  [ &_9 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_4 <- _6._p0 = _9 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0 [ s0 = overflowing_sub {a'0} {b'0} (fun (_ret:tuple) ->  [ &_16 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_sub {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_21 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none {_21} (fun (_ret:bool) ->  [ &_19 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- _16._p1 = _19 ] s1 | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
    
    | bb8 = return''0 {_0}
    | bb9 = {[%#schecked_ops] false} any
    | bb4 = {[%#schecked_ops'0] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & b'0: Int8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _9: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_mul_example [#"checked_ops.rs" 252 0 252 28]
  let%span schecked_ops = "checked_ops.rs" 253 12 253 15
  let%span schecked_ops'0 = "checked_ops.rs" 253 28 253 30
  let%span schecked_ops'1 = "checked_ops.rs" 253 44 253 46
  let%span schecked_ops'2 = "checked_ops.rs" 254 12 254 16
  let%span schecked_ops'3 = "checked_ops.rs" 254 29 254 31
  let%span schecked_ops'4 = "checked_ops.rs" 255 12 255 16
  let%span schecked_ops'5 = "checked_ops.rs" 255 29 255 32
  let%span schecked_ops'6 = "checked_ops.rs" 257 12 257 15
  let%span schecked_ops'7 = "checked_ops.rs" 257 29 257 31
  let%span schecked_ops'8 = "checked_ops.rs" 257 36 257 38
  let%span schecked_ops'9 = "checked_ops.rs" 258 12 258 16
  let%span schecked_ops'10 = "checked_ops.rs" 258 30 258 32
  let%span schecked_ops'11 = "checked_ops.rs" 258 37 258 40
  let%span schecked_ops'12 = "checked_ops.rs" 259 12 259 16
  let%span schecked_ops'13 = "checked_ops.rs" 259 30 259 33
  let%span schecked_ops'14 = "checked_ops.rs" 259 38 259 40
  let%span schecked_ops'15 = "checked_ops.rs" 261 12 261 15
  let%span schecked_ops'16 = "checked_ops.rs" 261 31 261 33
  let%span schecked_ops'17 = "checked_ops.rs" 261 38 261 40
  let%span schecked_ops'18 = "checked_ops.rs" 262 12 262 16
  let%span schecked_ops'19 = "checked_ops.rs" 262 32 262 34
  let%span schecked_ops'20 = "checked_ops.rs" 262 39 262 42
  let%span schecked_ops'21 = "checked_ops.rs" 263 12 263 16
  let%span schecked_ops'22 = "checked_ops.rs" 263 32 263 35
  let%span schecked_ops'23 = "checked_ops.rs" 263 40 263 44
  let%span schecked_ops'24 = "checked_ops.rs" 265 14 265 17
  let%span schecked_ops'25 = "checked_ops.rs" 265 34 265 36
  let%span schecked_ops'26 = "checked_ops.rs" 266 21 266 23
  let%span schecked_ops'27 = "checked_ops.rs" 266 36 266 41
  let%span schecked_ops'28 = "checked_ops.rs" 267 14 267 18
  let%span schecked_ops'29 = "checked_ops.rs" 267 35 267 37
  let%span schecked_ops'30 = "checked_ops.rs" 268 21 268 24
  let%span schecked_ops'31 = "checked_ops.rs" 268 37 268 41
  let%span schecked_ops'32 = "checked_ops.rs" 269 14 269 18
  let%span schecked_ops'33 = "checked_ops.rs" 269 35 269 38
  let%span schecked_ops'34 = "checked_ops.rs" 270 21 270 23
  let%span schecked_ops'35 = "checked_ops.rs" 270 36 270 40
  let%span schecked_ops'36 = "checked_ops.rs" 270 4 270 41
  let%span schecked_ops'37 = "checked_ops.rs" 268 4 268 42
  let%span schecked_ops'38 = "checked_ops.rs" 266 4 266 42
  let%span schecked_ops'39 = "checked_ops.rs" 263 4 263 45
  let%span schecked_ops'40 = "checked_ops.rs" 262 4 262 43
  let%span schecked_ops'41 = "checked_ops.rs" 261 4 261 41
  let%span schecked_ops'42 = "checked_ops.rs" 259 4 259 41
  let%span schecked_ops'43 = "checked_ops.rs" 258 4 258 41
  let%span schecked_ops'44 = "checked_ops.rs" 257 4 257 39
  let%span schecked_ops'45 = "checked_ops.rs" 255 4 255 44
  let%span schecked_ops'46 = "checked_ops.rs" 254 4 254 43
  let%span schecked_ops'47 = "checked_ops.rs" 253 4 253 47
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ * Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:Int8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:Int8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption'1] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec wrapping_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.mul self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ * Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ * Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ * Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_mul_example[#"checked_ops.rs" 252 0 252 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {[%#schecked_ops] (5: Int8.t)} {[%#schecked_ops'0] (10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_4} (fun (_ret:Int8.t) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_2 <- _3 = ([%#schecked_ops'1] (50: Int8.t)) ] s1
      | s1 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = checked_mul {[%#schecked_ops'2] (50: Int8.t)} {[%#schecked_ops'3] (10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = is_none {_9} (fun (_ret:bool) ->  [ &_7 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ] 
    | bb7 = s0
      [ s0 = checked_mul {[%#schecked_ops'4] (50: Int8.t)} {[%#schecked_ops'5] (-10: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_14 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = is_none {_14} (fun (_ret:bool) ->  [ &_12 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ] 
    | bb11 = s0
      [ s0 = wrapping_mul {[%#schecked_ops'6] (5: Int8.t)} {[%#schecked_ops'7] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_18 <- _ret ] s1)
      | s1 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_17 <- _18 = ([%#schecked_ops'8] (50: Int8.t)) ] s1
      | s1 = any [ br0 -> {_17 = false} (! bb15) | br1 -> {_17} (! bb14) ]  ]
    
    | bb14 = s0
      [ s0 = wrapping_mul {[%#schecked_ops'9] (50: Int8.t)} {[%#schecked_ops'10] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_22 <- _ret ] s1)
      | s1 = bb16 ]
    
    | bb16 = s0
      [ s0 =  [ &_21 <- _22 = ([%#schecked_ops'11] (-12: Int8.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb17) ]  ]
    
    | bb17 = s0
      [ s0 = wrapping_mul {[%#schecked_ops'12] (50: Int8.t)} {[%#schecked_ops'13] (-10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_26 <- _ret ] s1)
      | s1 = bb19 ]
    
    | bb19 = s0
      [ s0 =  [ &_25 <- _26 = ([%#schecked_ops'14] (12: Int8.t)) ] s1
      | s1 = any [ br0 -> {_25 = false} (! bb21) | br1 -> {_25} (! bb20) ]  ]
    
    | bb20 = s0
      [ s0 = saturating_mul {[%#schecked_ops'15] (5: Int8.t)} {[%#schecked_ops'16] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_30 <- _ret ] s1)
      | s1 = bb22 ]
    
    | bb22 = s0
      [ s0 =  [ &_29 <- _30 = ([%#schecked_ops'17] (50: Int8.t)) ] s1
      | s1 = any [ br0 -> {_29 = false} (! bb24) | br1 -> {_29} (! bb23) ]  ]
    
    | bb23 = s0
      [ s0 = saturating_mul {[%#schecked_ops'18] (50: Int8.t)} {[%#schecked_ops'19] (10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_34 <- _ret ] s1)
      | s1 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &_33 <- _34 = ([%#schecked_ops'20] (127: Int8.t)) ] s1
      | s1 = any [ br0 -> {_33 = false} (! bb27) | br1 -> {_33} (! bb26) ]  ]
    
    | bb26 = s0
      [ s0 = saturating_mul {[%#schecked_ops'21] (50: Int8.t)} {[%#schecked_ops'22] (-10: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_38 <- _ret ] s1)
      | s1 = bb28 ]
    
    | bb28 = s0
      [ s0 =  [ &_37 <- _38 = ([%#schecked_ops'23] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_37 = false} (! bb30) | br1 -> {_37} (! bb29) ]  ]
    
    | bb29 = s0
      [ s0 = overflowing_mul {[%#schecked_ops'24] (5: Int8.t)} {[%#schecked_ops'25] (10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb31 ]
    
    | bb31 = s0
      [ s0 =  [ &_42 <- res._p0 = ([%#schecked_ops'26] (50: Int8.t)) ] s1
      | s1 = any [ br0 -> {_42 = false} (! bb35) | br1 -> {_42} (! bb32) ]  ]
    
    | bb32 = s0
      [ s0 =  [ &_44 <- res._p1 = ([%#schecked_ops'27] false) ] s1
      | s1 = any [ br0 -> {_44 = false} (! bb34) | br1 -> {_44} (! bb33) ]  ]
    
    | bb33 = s0
      [ s0 = overflowing_mul {[%#schecked_ops'28] (50: Int8.t)} {[%#schecked_ops'29] (10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'0 <- _ret ] s1)
      | s1 = bb37 ]
    
    | bb37 = s0
      [ s0 =  [ &_49 <- res'0._p0 = ([%#schecked_ops'30] (-12: Int8.t)) ] s1
      | s1 = any [ br0 -> {_49 = false} (! bb41) | br1 -> {_49} (! bb38) ]  ]
    
    | bb38 = s0
      [ s0 =  [ &_51 <- res'0._p1 ] s1 | s1 = any [ br0 -> {_51 = false} (! bb40) | br1 -> {_51} (! bb39) ]  ]
    
    | bb39 = s0
      [ s0 = overflowing_mul {[%#schecked_ops'32] (50: Int8.t)} {[%#schecked_ops'33] (-10: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'1 <- _ret ] s1)
      | s1 = bb43 ]
    
    | bb43 = s0
      [ s0 =  [ &_56 <- res'1._p0 = ([%#schecked_ops'34] (12: Int8.t)) ] s1
      | s1 = any [ br0 -> {_56 = false} (! bb47) | br1 -> {_56} (! bb44) ]  ]
    
    | bb44 = s0
      [ s0 =  [ &_58 <- res'1._p1 ] s1 | s1 = any [ br0 -> {_58 = false} (! bb46) | br1 -> {_58} (! bb45) ]  ]
    
    | bb45 = return''0 {_0}
    | bb46 = bb48
    | bb47 = bb48
    | bb48 = {[%#schecked_ops'36] false} any
    | bb40 = bb42
    | bb41 = bb42
    | bb42 = {[%#schecked_ops'37] false} any
    | bb34 = bb36
    | bb35 = bb36
    | bb36 = {[%#schecked_ops'38] false} any
    | bb30 = {[%#schecked_ops'39] false} any
    | bb27 = {[%#schecked_ops'40] false} any
    | bb24 = {[%#schecked_ops'41] false} any
    | bb21 = {[%#schecked_ops'42] false} any
    | bb18 = {[%#schecked_ops'43] false} any
    | bb15 = {[%#schecked_ops'44] false} any
    | bb12 = {[%#schecked_ops'45] false} any
    | bb8 = {[%#schecked_ops'46] false} any
    | bb4 = {[%#schecked_ops'47] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _3: Int8.t = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _18: Int8.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int8.t = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int8.t = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int8.t = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _34: Int8.t = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & res'0: tuple = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: bool = Any.any_l ()
    | & res'1: tuple = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _58: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_mul_zero [#"checked_ops.rs" 274 0 274 30]
  let%span schecked_ops = "checked_ops.rs" 275 12 275 15
  let%span schecked_ops'0 = "checked_ops.rs" 275 43 275 44
  let%span schecked_ops'1 = "checked_ops.rs" 276 12 276 15
  let%span schecked_ops'2 = "checked_ops.rs" 276 35 276 36
  let%span schecked_ops'3 = "checked_ops.rs" 277 12 277 15
  let%span schecked_ops'4 = "checked_ops.rs" 277 37 277 38
  let%span schecked_ops'5 = "checked_ops.rs" 278 14 278 17
  let%span schecked_ops'6 = "checked_ops.rs" 279 21 279 22
  let%span schecked_ops'7 = "checked_ops.rs" 279 35 279 40
  let%span schecked_ops'8 = "checked_ops.rs" 279 4 279 41
  let%span schecked_ops'9 = "checked_ops.rs" 277 4 277 39
  let%span schecked_ops'10 = "checked_ops.rs" 276 4 276 37
  let%span schecked_ops'11 = "checked_ops.rs" 275 4 275 45
  let%span snum = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 223 20 224 51
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 227 26 227 83
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 228 26 228 83
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec checked_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ * Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:Int8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:Int8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec wrapping_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'1] result = Int8.mul self_ rhs} (! return' {result}) ]
  
  
  let rec saturating_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int self_ * Int8.to_int rhs}
      {[%#snum'3] Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'4] Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result = Int8.to_int (v_MAX: Int8.t)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum'5] Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ * Int8.to_int rhs}
      {[%#snum'6] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ * Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'7] result._p1
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_mul_zero[#"checked_ops.rs" 274 0 274 30] (a:Int8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_mul {[%#schecked_ops] (0: Int8.t)} {a'0} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_5} (fun (_ret:Int8.t) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_3 <- _4 = ([%#schecked_ops'0] (0: Int8.t)) ] s1
      | s1 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]  ]
    
    | bb3 = s0
      [ s0 = wrapping_mul {[%#schecked_ops'1] (0: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_10 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 =  [ &_9 <- _10 = ([%#schecked_ops'2] (0: Int8.t)) ] s1
      | s1 = any [ br0 -> {_9 = false} (! bb7) | br1 -> {_9} (! bb6) ]  ]
    
    | bb6 = s0
      [ s0 = saturating_mul {[%#schecked_ops'3] (0: Int8.t)} {a'0} (fun (_ret:Int8.t) ->  [ &_15 <- _ret ] s1)
      | s1 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_14 <- _15 = ([%#schecked_ops'4] (0: Int8.t)) ] s1
      | s1 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]  ]
    
    | bb9 = s0
      [ s0 = overflowing_mul {[%#schecked_ops'5] (0: Int8.t)} {a'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb11 ]
    
    | bb11 = s0
      [ s0 =  [ &_21 <- res._p0 = ([%#schecked_ops'6] (0: Int8.t)) ] s1
      | s1 = any [ br0 -> {_21 = false} (! bb15) | br1 -> {_21} (! bb12) ]  ]
    
    | bb12 = s0
      [ s0 =  [ &_23 <- res._p1 = ([%#schecked_ops'7] false) ] s1
      | s1 = any [ br0 -> {_23 = false} (! bb14) | br1 -> {_23} (! bb13) ]  ]
    
    | bb13 = return''0 {_0}
    | bb14 = bb16
    | bb15 = bb16
    | bb16 = {[%#schecked_ops'8] false} any
    | bb10 = {[%#schecked_ops'9] false} any
    | bb7 = {[%#schecked_ops'10] false} any
    | bb4 = {[%#schecked_ops'11] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & _3: bool = Any.any_l ()
    | & _4: Int8.t = Any.any_l ()
    | & _5: t_Option = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_overflowing_mul [#"checked_ops.rs" 283 0 283 44]
  let%span schecked_ops = "checked_ops.rs" 285 4 285 65
  let%span schecked_ops'0 = "checked_ops.rs" 284 4 284 56
  let%span snum = "../../creusot-contracts/src/std/num.rs" 237 20 238 53
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 244 20 244 102
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 248 20 248 98
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 214 26 214 48
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 204 20 205 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 208 26 208 87
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  constant v_MAX: Int8.t = (127: Int8.t)
  
  let rec overflowing_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#snum] Int8.to_int self_ * Int8.to_int rhs >= Int8.to_int (v_MIN: Int8.t)
      /\ Int8.to_int self_ * Int8.to_int rhs <= Int8.to_int (v_MAX: Int8.t)
       -> Int8.to_int result._p0 = Int8.to_int self_ * Int8.to_int rhs}
      {[%#snum'0] exists k: int. Int8.to_int result._p0
      = Int8.to_int self_ * Int8.to_int rhs + k * (Int8.to_int (v_MAX: Int8.t) - Int8.to_int (v_MIN: Int8.t) + 1)}
      {[%#snum'1] result._p1
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      (! return' {result}) ]
  
  
  let rec wrapping_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= any
    [ return''0 (result:Int8.t)-> {[%#snum'2] result = Int8.mul self_ rhs} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  let rec checked_mul (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum'3] (result = C_None)
      = (Int8.to_int self_ * Int8.to_int rhs < Int8.to_int (v_MIN: Int8.t)
      \/ Int8.to_int self_ * Int8.to_int rhs > Int8.to_int (v_MAX: Int8.t))}
      {[%#snum'4] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int8.to_int self_ * Int8.to_int rhs}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_overflowing_mul[#"checked_ops.rs" 283 0 283 44] (a:Int8.t) (b:Int8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = overflowing_mul {a'0} {b'0} (fun (_ret:tuple) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = wrapping_mul {a'0} {b'0} (fun (_ret:Int8.t) ->  [ &_9 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 =  [ &_4 <- _6._p0 = _9 ] s1 | s1 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]  ] 
    | bb3 = s0 [ s0 = overflowing_mul {a'0} {b'0} (fun (_ret:tuple) ->  [ &_16 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0 [ s0 = checked_mul {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_21 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0 [ s0 = is_none {_21} (fun (_ret:bool) ->  [ &_19 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_14 <- _16._p1 = _19 ] s1 | s1 = any [ br0 -> {_14 = false} (! bb9) | br1 -> {_14} (! bb8) ]  ]
    
    | bb8 = return''0 {_0}
    | bb9 = {[%#schecked_ops] false} any
    | bb4 = {[%#schecked_ops'0] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & b'0: Int8.t = b
    | & _4: bool = Any.any_l ()
    | & _6: tuple = Any.any_l ()
    | & _9: Int8.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Option = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_example [#"checked_ops.rs" 289 0 289 28]
  let%span schecked_ops = "checked_ops.rs" 290 12 290 15
  let%span schecked_ops'0 = "checked_ops.rs" 290 28 290 29
  let%span schecked_ops'1 = "checked_ops.rs" 291 12 291 15
  let%span schecked_ops'2 = "checked_ops.rs" 291 28 291 29
  let%span schecked_ops'3 = "checked_ops.rs" 291 43 291 44
  let%span schecked_ops'4 = "checked_ops.rs" 292 12 292 15
  let%span schecked_ops'5 = "checked_ops.rs" 292 28 292 30
  let%span schecked_ops'6 = "checked_ops.rs" 292 44 292 46
  let%span schecked_ops'7 = "checked_ops.rs" 293 12 293 20
  let%span schecked_ops'8 = "checked_ops.rs" 293 33 293 35
  let%span schecked_ops'9 = "checked_ops.rs" 295 12 295 15
  let%span schecked_ops'10 = "checked_ops.rs" 295 29 295 30
  let%span schecked_ops'11 = "checked_ops.rs" 295 35 295 36
  let%span schecked_ops'12 = "checked_ops.rs" 296 12 296 15
  let%span schecked_ops'13 = "checked_ops.rs" 296 29 296 31
  let%span schecked_ops'14 = "checked_ops.rs" 296 36 296 38
  let%span schecked_ops'15 = "checked_ops.rs" 297 12 297 20
  let%span schecked_ops'16 = "checked_ops.rs" 297 34 297 36
  let%span schecked_ops'17 = "checked_ops.rs" 297 41 297 45
  let%span schecked_ops'18 = "checked_ops.rs" 299 12 299 15
  let%span schecked_ops'19 = "checked_ops.rs" 299 31 299 32
  let%span schecked_ops'20 = "checked_ops.rs" 299 37 299 38
  let%span schecked_ops'21 = "checked_ops.rs" 300 12 300 15
  let%span schecked_ops'22 = "checked_ops.rs" 300 31 300 33
  let%span schecked_ops'23 = "checked_ops.rs" 300 38 300 40
  let%span schecked_ops'24 = "checked_ops.rs" 301 12 301 20
  let%span schecked_ops'25 = "checked_ops.rs" 301 36 301 38
  let%span schecked_ops'26 = "checked_ops.rs" 301 43 301 47
  let%span schecked_ops'27 = "checked_ops.rs" 303 14 303 17
  let%span schecked_ops'28 = "checked_ops.rs" 303 34 303 35
  let%span schecked_ops'29 = "checked_ops.rs" 304 21 304 22
  let%span schecked_ops'30 = "checked_ops.rs" 304 35 304 40
  let%span schecked_ops'31 = "checked_ops.rs" 305 14 305 17
  let%span schecked_ops'32 = "checked_ops.rs" 305 34 305 36
  let%span schecked_ops'33 = "checked_ops.rs" 306 21 306 23
  let%span schecked_ops'34 = "checked_ops.rs" 306 36 306 41
  let%span schecked_ops'35 = "checked_ops.rs" 307 14 307 22
  let%span schecked_ops'36 = "checked_ops.rs" 307 39 307 41
  let%span schecked_ops'37 = "checked_ops.rs" 308 21 308 25
  let%span schecked_ops'38 = "checked_ops.rs" 308 38 308 42
  let%span schecked_ops'39 = "checked_ops.rs" 308 4 308 43
  let%span schecked_ops'40 = "checked_ops.rs" 306 4 306 42
  let%span schecked_ops'41 = "checked_ops.rs" 304 4 304 41
  let%span schecked_ops'42 = "checked_ops.rs" 301 4 301 48
  let%span schecked_ops'43 = "checked_ops.rs" 300 4 300 41
  let%span schecked_ops'44 = "checked_ops.rs" 299 4 299 39
  let%span schecked_ops'45 = "checked_ops.rs" 297 4 297 46
  let%span schecked_ops'46 = "checked_ops.rs" 296 4 296 39
  let%span schecked_ops'47 = "checked_ops.rs" 295 4 295 37
  let%span schecked_ops'48 = "checked_ops.rs" 293 4 293 47
  let%span schecked_ops'49 = "checked_ops.rs" 292 4 292 47
  let%span schecked_ops'50 = "checked_ops.rs" 291 4 291 45
  let%span schecked_ops'51 = "checked_ops.rs" 290 4 290 41
  let%span snum = "../../creusot-contracts/src/std/num.rs" 141 26 141 97
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 143 26 143 83
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 149 27 149 36
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 151 26 151 83
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 153 26 153 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 159 27 159 36
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 161 26 161 89
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 163 26 163 89
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 169 27 169 36
  let%span snum'8 = "../../creusot-contracts/src/std/num.rs" 171 26 171 85
  let%span snum'9 = "../../creusot-contracts/src/std/num.rs" 173 26 173 91
  let%span snum'10 = "../../creusot-contracts/src/std/num.rs" 175 26 175 74
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  let rec checked_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1)}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:Int8.t))= {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any [ return''0 (result:Int8.t)-> {[%#soption'1] C_Some result = self_} (! return' {result}) ] 
  
  let rec wrapping_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= {[@expl:wrapping_div requires] [%#snum'1] Int8.to_int rhs
    <> 0}
    any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int self_}
      {[%#snum'3] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return' {result}) ]
  
  
  let rec saturating_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= {[@expl:saturating_div requires] [%#snum'4] Int8.to_int rhs
    <> 0}
    any
    [ return''0 (result:Int8.t)-> {[%#snum'5] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'6] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= {[@expl:overflowing_div requires] [%#snum'7] Int8.to_int rhs
    <> 0}
    any
    [ return''0 (result:tuple)-> {[%#snum'8] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result._p0 = Int8.to_int self_}
      {[%#snum'9] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result._p0 = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      {[%#snum'10] result._p1 = (Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_example[#"checked_ops.rs" 289 0 289 28] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div {[%#schecked_ops] (5: Int8.t)} {[%#schecked_ops'0] (0: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_4 <- _ret ] s1)
      | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_4} (fun (_ret:bool) ->  [ &_2 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_2 = false} (! bb4) | br1 -> {_2} (! bb3) ] 
    | bb3 = s0
      [ s0 = checked_div {[%#schecked_ops'1] (5: Int8.t)} {[%#schecked_ops'2] (2: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_9 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0 [ s0 = unwrap {_9} (fun (_ret:Int8.t) ->  [ &_8 <- _ret ] s1) | s1 = bb6 ] 
    | bb6 = s0
      [ s0 =  [ &_7 <- _8 = ([%#schecked_ops'3] (2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_7 = false} (! bb8) | br1 -> {_7} (! bb7) ]  ]
    
    | bb7 = s0
      [ s0 = checked_div {[%#schecked_ops'4] (5: Int8.t)} {[%#schecked_ops'5] (-2: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_14 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = unwrap {_14} (fun (_ret:Int8.t) ->  [ &_13 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = s0
      [ s0 =  [ &_12 <- _13 = ([%#schecked_ops'6] (-2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_12 = false} (! bb12) | br1 -> {_12} (! bb11) ]  ]
    
    | bb11 = s0
      [ s0 = checked_div {[%#schecked_ops'7] (-128: Int8.t)} {[%#schecked_ops'8] (-1: Int8.t)}
          (fun (_ret:t_Option) ->  [ &_19 <- _ret ] s1)
      | s1 = bb13 ]
    
    | bb13 = s0 [ s0 = is_none {_19} (fun (_ret:bool) ->  [ &_17 <- _ret ] s1) | s1 = bb14 ] 
    | bb14 = any [ br0 -> {_17 = false} (! bb16) | br1 -> {_17} (! bb15) ] 
    | bb15 = s0
      [ s0 = wrapping_div {[%#schecked_ops'9] (5: Int8.t)} {[%#schecked_ops'10] (2: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_23 <- _ret ] s1)
      | s1 = bb17 ]
    
    | bb17 = s0
      [ s0 =  [ &_22 <- _23 = ([%#schecked_ops'11] (2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_22 = false} (! bb19) | br1 -> {_22} (! bb18) ]  ]
    
    | bb18 = s0
      [ s0 = wrapping_div {[%#schecked_ops'12] (5: Int8.t)} {[%#schecked_ops'13] (-2: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_27 <- _ret ] s1)
      | s1 = bb20 ]
    
    | bb20 = s0
      [ s0 =  [ &_26 <- _27 = ([%#schecked_ops'14] (-2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_26 = false} (! bb22) | br1 -> {_26} (! bb21) ]  ]
    
    | bb21 = s0
      [ s0 = wrapping_div {[%#schecked_ops'15] (-128: Int8.t)} {[%#schecked_ops'16] (-1: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_31 <- _ret ] s1)
      | s1 = bb23 ]
    
    | bb23 = s0
      [ s0 =  [ &_30 <- _31 = ([%#schecked_ops'17] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_30 = false} (! bb25) | br1 -> {_30} (! bb24) ]  ]
    
    | bb24 = s0
      [ s0 = saturating_div {[%#schecked_ops'18] (5: Int8.t)} {[%#schecked_ops'19] (2: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_35 <- _ret ] s1)
      | s1 = bb26 ]
    
    | bb26 = s0
      [ s0 =  [ &_34 <- _35 = ([%#schecked_ops'20] (2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_34 = false} (! bb28) | br1 -> {_34} (! bb27) ]  ]
    
    | bb27 = s0
      [ s0 = saturating_div {[%#schecked_ops'21] (5: Int8.t)} {[%#schecked_ops'22] (-2: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_39 <- _ret ] s1)
      | s1 = bb29 ]
    
    | bb29 = s0
      [ s0 =  [ &_38 <- _39 = ([%#schecked_ops'23] (-2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_38 = false} (! bb31) | br1 -> {_38} (! bb30) ]  ]
    
    | bb30 = s0
      [ s0 = saturating_div {[%#schecked_ops'24] (-128: Int8.t)} {[%#schecked_ops'25] (-1: Int8.t)}
          (fun (_ret:Int8.t) ->  [ &_43 <- _ret ] s1)
      | s1 = bb32 ]
    
    | bb32 = s0
      [ s0 =  [ &_42 <- _43 = ([%#schecked_ops'26] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_42 = false} (! bb34) | br1 -> {_42} (! bb33) ]  ]
    
    | bb33 = s0
      [ s0 = overflowing_div {[%#schecked_ops'27] (5: Int8.t)} {[%#schecked_ops'28] (2: Int8.t)}
          (fun (_ret:tuple) ->  [ &res <- _ret ] s1)
      | s1 = bb35 ]
    
    | bb35 = s0
      [ s0 =  [ &_47 <- res._p0 = ([%#schecked_ops'29] (2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_47 = false} (! bb39) | br1 -> {_47} (! bb36) ]  ]
    
    | bb36 = s0
      [ s0 =  [ &_49 <- res._p1 = ([%#schecked_ops'30] false) ] s1
      | s1 = any [ br0 -> {_49 = false} (! bb38) | br1 -> {_49} (! bb37) ]  ]
    
    | bb37 = s0
      [ s0 = overflowing_div {[%#schecked_ops'31] (5: Int8.t)} {[%#schecked_ops'32] (-2: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'0 <- _ret ] s1)
      | s1 = bb41 ]
    
    | bb41 = s0
      [ s0 =  [ &_54 <- res'0._p0 = ([%#schecked_ops'33] (-2: Int8.t)) ] s1
      | s1 = any [ br0 -> {_54 = false} (! bb45) | br1 -> {_54} (! bb42) ]  ]
    
    | bb42 = s0
      [ s0 =  [ &_56 <- res'0._p1 = ([%#schecked_ops'34] false) ] s1
      | s1 = any [ br0 -> {_56 = false} (! bb44) | br1 -> {_56} (! bb43) ]  ]
    
    | bb43 = s0
      [ s0 = overflowing_div {[%#schecked_ops'35] (-128: Int8.t)} {[%#schecked_ops'36] (-1: Int8.t)}
          (fun (_ret:tuple) ->  [ &res'1 <- _ret ] s1)
      | s1 = bb47 ]
    
    | bb47 = s0
      [ s0 =  [ &_61 <- res'1._p0 = ([%#schecked_ops'37] (-128: Int8.t)) ] s1
      | s1 = any [ br0 -> {_61 = false} (! bb51) | br1 -> {_61} (! bb48) ]  ]
    
    | bb48 = s0
      [ s0 =  [ &_63 <- res'1._p1 ] s1 | s1 = any [ br0 -> {_63 = false} (! bb50) | br1 -> {_63} (! bb49) ]  ]
    
    | bb49 = return''0 {_0}
    | bb50 = bb52
    | bb51 = bb52
    | bb52 = {[%#schecked_ops'39] false} any
    | bb44 = bb46
    | bb45 = bb46
    | bb46 = {[%#schecked_ops'40] false} any
    | bb38 = bb40
    | bb39 = bb40
    | bb40 = {[%#schecked_ops'41] false} any
    | bb34 = {[%#schecked_ops'42] false} any
    | bb31 = {[%#schecked_ops'43] false} any
    | bb28 = {[%#schecked_ops'44] false} any
    | bb25 = {[%#schecked_ops'45] false} any
    | bb22 = {[%#schecked_ops'46] false} any
    | bb19 = {[%#schecked_ops'47] false} any
    | bb16 = {[%#schecked_ops'48] false} any
    | bb12 = {[%#schecked_ops'49] false} any
    | bb8 = {[%#schecked_ops'50] false} any
    | bb4 = {[%#schecked_ops'51] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & _2: bool = Any.any_l ()
    | & _4: t_Option = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _8: Int8.t = Any.any_l ()
    | & _9: t_Option = Any.any_l ()
    | & _12: bool = Any.any_l ()
    | & _13: Int8.t = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: t_Option = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _23: Int8.t = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: Int8.t = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _31: Int8.t = Any.any_l ()
    | & _34: bool = Any.any_l ()
    | & _35: Int8.t = Any.any_l ()
    | & _38: bool = Any.any_l ()
    | & _39: Int8.t = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _43: Int8.t = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _47: bool = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & res'0: tuple = Any.any_l ()
    | & _54: bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & res'1: tuple = Any.any_l ()
    | & _61: bool = Any.any_l ()
    | & _63: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_no_overflow [#"checked_ops.rs" 313 0 313 44]
  let%span schecked_ops = "checked_ops.rs" 314 41 314 46
  let%span schecked_ops'0 = "checked_ops.rs" 315 33 315 38
  let%span schecked_ops'1 = "checked_ops.rs" 316 35 316 40
  let%span schecked_ops'2 = "checked_ops.rs" 318 21 318 26
  let%span schecked_ops'3 = "checked_ops.rs" 318 39 318 44
  let%span schecked_ops'4 = "checked_ops.rs" 318 4 318 45
  let%span schecked_ops'5 = "checked_ops.rs" 316 4 316 41
  let%span schecked_ops'6 = "checked_ops.rs" 315 4 315 39
  let%span schecked_ops'7 = "checked_ops.rs" 314 4 314 47
  let%span schecked_ops'8 = "checked_ops.rs" 312 11 312 46
  let%span snum = "../../creusot-contracts/src/std/num.rs" 141 26 141 97
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 143 26 143 83
  let%span snum'1 = "../../creusot-contracts/src/std/num.rs" 149 27 149 36
  let%span snum'2 = "../../creusot-contracts/src/std/num.rs" 151 26 151 83
  let%span snum'3 = "../../creusot-contracts/src/std/num.rs" 153 26 153 89
  let%span snum'4 = "../../creusot-contracts/src/std/num.rs" 159 27 159 36
  let%span snum'5 = "../../creusot-contracts/src/std/num.rs" 161 26 161 89
  let%span snum'6 = "../../creusot-contracts/src/std/num.rs" 163 26 163 89
  let%span snum'7 = "../../creusot-contracts/src/std/num.rs" 169 27 169 36
  let%span snum'8 = "../../creusot-contracts/src/std/num.rs" 171 26 171 85
  let%span snum'9 = "../../creusot-contracts/src/std/num.rs" 173 26 173 91
  let%span snum'10 = "../../creusot-contracts/src/std/num.rs" 175 26 175 74
  let%span soption = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Bool
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  let rec checked_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1)}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option) (return'  (x:Int8.t))= {[@expl:unwrap requires] [%#soption] self_ <> C_None}
    any [ return''0 (result:Int8.t)-> {[%#soption'0] C_Some result = self_} (! return' {result}) ] 
  
  let rec wrapping_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= {[@expl:wrapping_div requires] [%#snum'1] Int8.to_int rhs
    <> 0}
    any
    [ return''0 (result:Int8.t)-> {[%#snum'2] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int self_}
      {[%#snum'3] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return' {result}) ]
  
  
  let rec saturating_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:Int8.t))= {[@expl:saturating_div requires] [%#snum'4] Int8.to_int rhs
    <> 0}
    any
    [ return''0 (result:Int8.t)-> {[%#snum'5] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result = Int8.to_int (v_MIN: Int8.t)}
      {[%#snum'6] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return' {result}) ]
  
  
  type tuple  =
    { _p0: Int8.t; _p1: bool }
  
  let rec overflowing_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:tuple))= {[@expl:overflowing_div requires] [%#snum'7] Int8.to_int rhs
    <> 0}
    any
    [ return''0 (result:tuple)-> {[%#snum'8] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
       -> Int8.to_int result._p0 = Int8.to_int self_}
      {[%#snum'9] Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1
      \/ Int8.to_int result._p0 = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      {[%#snum'10] result._p1 = (Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1)}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_no_overflow[#"checked_ops.rs" 313 0 313 44] (a:Int8.t) (b:Int8.t) (return'  (x:()))= {[@expl:test_i8_div_no_overflow requires] [%#schecked_ops'8] Int8.to_int b
    <> 0
    /\ (Int8.to_int a <> - 128 \/ Int8.to_int b <> - 1)}
    (! bb0
    [ bb0 = s0 [ s0 = checked_div {a'0} {b'0} (fun (_ret:t_Option) ->  [ &_7 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = unwrap {_7} (fun (_ret:Int8.t) ->  [ &_6 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_11 <- a'0 ] s1
      | s1 =  [ &_12 <- b'0 ] s2
      | s2 =  [ &_13 <- _12 = ([%#schecked_ops] (0: Int8.t)) ] s3
      | s3 = {[@expl:division by zero] [%#schecked_ops] not _13} s4
      | s4 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &_14 <- _12 = ([%#schecked_ops] (-1: Int8.t)) ] s1
      | s1 =  [ &_15 <- _11 = ([%#schecked_ops] (-128: Int8.t)) ] s2
      | s2 =  [ &_16 <- Bool.bw_and _14 _15 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops] not _16} s4
      | s4 = bb4 ]
    
    | bb4 = s0
      [ s0 = Int8.div {_11} {_12} (fun (_ret:Int8.t) ->  [ &_10 <- _ret ] s1)
      | s1 =  [ &_5 <- _6 = _10 ] s2
      | s2 = any [ br0 -> {_5 = false} (! bb6) | br1 -> {_5} (! bb5) ]  ]
    
    | bb5 = s0 [ s0 = wrapping_div {a'0} {b'0} (fun (_ret:Int8.t) ->  [ &_20 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 =  [ &_24 <- a'0 ] s1
      | s1 =  [ &_25 <- b'0 ] s2
      | s2 =  [ &_26 <- _25 = ([%#schecked_ops'0] (0: Int8.t)) ] s3
      | s3 = {[@expl:division by zero] [%#schecked_ops'0] not _26} s4
      | s4 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_27 <- _25 = ([%#schecked_ops'0] (-1: Int8.t)) ] s1
      | s1 =  [ &_28 <- _24 = ([%#schecked_ops'0] (-128: Int8.t)) ] s2
      | s2 =  [ &_29 <- Bool.bw_and _27 _28 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops'0] not _29} s4
      | s4 = bb9 ]
    
    | bb9 = s0
      [ s0 = Int8.div {_24} {_25} (fun (_ret:Int8.t) ->  [ &_23 <- _ret ] s1)
      | s1 =  [ &_19 <- _20 = _23 ] s2
      | s2 = any [ br0 -> {_19 = false} (! bb11) | br1 -> {_19} (! bb10) ]  ]
    
    | bb10 = s0 [ s0 = saturating_div {a'0} {b'0} (fun (_ret:Int8.t) ->  [ &_33 <- _ret ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 =  [ &_37 <- a'0 ] s1
      | s1 =  [ &_38 <- b'0 ] s2
      | s2 =  [ &_39 <- _38 = ([%#schecked_ops'1] (0: Int8.t)) ] s3
      | s3 = {[@expl:division by zero] [%#schecked_ops'1] not _39} s4
      | s4 = bb13 ]
    
    | bb13 = s0
      [ s0 =  [ &_40 <- _38 = ([%#schecked_ops'1] (-1: Int8.t)) ] s1
      | s1 =  [ &_41 <- _37 = ([%#schecked_ops'1] (-128: Int8.t)) ] s2
      | s2 =  [ &_42 <- Bool.bw_and _40 _41 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops'1] not _42} s4
      | s4 = bb14 ]
    
    | bb14 = s0
      [ s0 = Int8.div {_37} {_38} (fun (_ret:Int8.t) ->  [ &_36 <- _ret ] s1)
      | s1 =  [ &_32 <- _33 = _36 ] s2
      | s2 = any [ br0 -> {_32 = false} (! bb16) | br1 -> {_32} (! bb15) ]  ]
    
    | bb15 = s0 [ s0 = overflowing_div {a'0} {b'0} (fun (_ret:tuple) ->  [ &res <- _ret ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 =  [ &_51 <- a'0 ] s1
      | s1 =  [ &_52 <- b'0 ] s2
      | s2 =  [ &_53 <- _52 = ([%#schecked_ops'2] (0: Int8.t)) ] s3
      | s3 = {[@expl:division by zero] [%#schecked_ops'2] not _53} s4
      | s4 = bb18 ]
    
    | bb18 = s0
      [ s0 =  [ &_54 <- _52 = ([%#schecked_ops'2] (-1: Int8.t)) ] s1
      | s1 =  [ &_55 <- _51 = ([%#schecked_ops'2] (-128: Int8.t)) ] s2
      | s2 =  [ &_56 <- Bool.bw_and _54 _55 ] s3
      | s3 = {[@expl:Div overflow] [%#schecked_ops'2] not _56} s4
      | s4 = bb19 ]
    
    | bb19 = s0
      [ s0 = Int8.div {_51} {_52} (fun (_ret:Int8.t) ->  [ &_50 <- _ret ] s1)
      | s1 =  [ &_48 <- res._p0 = _50 ] s2
      | s2 = any [ br0 -> {_48 = false} (! bb23) | br1 -> {_48} (! bb20) ]  ]
    
    | bb20 = s0
      [ s0 =  [ &_57 <- res._p1 = ([%#schecked_ops'3] false) ] s1
      | s1 = any [ br0 -> {_57 = false} (! bb22) | br1 -> {_57} (! bb21) ]  ]
    
    | bb21 = return''0 {_0}
    | bb22 = bb24
    | bb23 = bb24
    | bb24 = {[%#schecked_ops'4] false} any
    | bb16 = {[%#schecked_ops'5] false} any
    | bb11 = {[%#schecked_ops'6] false} any
    | bb6 = {[%#schecked_ops'7] false} any ]
    )
    [ & _0: () = Any.any_l ()
    | & a'0: Int8.t = a
    | & b'0: Int8.t = b
    | & _5: bool = Any.any_l ()
    | & _6: Int8.t = Any.any_l ()
    | & _7: t_Option = Any.any_l ()
    | & _10: Int8.t = Any.any_l ()
    | & _11: Int8.t = Any.any_l ()
    | & _12: Int8.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: Int8.t = Any.any_l ()
    | & _23: Int8.t = Any.any_l ()
    | & _24: Int8.t = Any.any_l ()
    | & _25: Int8.t = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _33: Int8.t = Any.any_l ()
    | & _36: Int8.t = Any.any_l ()
    | & _37: Int8.t = Any.any_l ()
    | & _38: Int8.t = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & _41: bool = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & res: tuple = Any.any_l ()
    | & _48: bool = Any.any_l ()
    | & _50: Int8.t = Any.any_l ()
    | & _51: Int8.t = Any.any_l ()
    | & _52: Int8.t = Any.any_l ()
    | & _53: bool = Any.any_l ()
    | & _54: bool = Any.any_l ()
    | & _55: bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _57: bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_checked_ops__test_i8_div_zero [#"checked_ops.rs" 322 0 322 30]
  let%span schecked_ops = "checked_ops.rs" 323 26 323 27
  let%span schecked_ops'0 = "checked_ops.rs" 323 4 323 39
  let%span snum = "../../creusot-contracts/src/std/num.rs" 141 26 141 97
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 143 26 143 83
  let%span soption = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  
  use creusot.int.Int8
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option  =
    | C_None
    | C_Some Int8.t
  
  constant v_MIN: Int8.t = (-128: Int8.t)
  
  let rec checked_div (self_:Int8.t) (rhs:Int8.t) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#snum] (result = C_None)
      = (Int8.to_int rhs = 0 \/ Int8.to_int self_ = Int8.to_int (v_MIN: Int8.t) /\ Int8.to_int rhs = - 1)}
      {[%#snum'0] forall r: Int8.t. result = C_Some r  -> Int8.to_int r = Int.div (Int8.to_int self_) (Int8.to_int rhs)}
      (! return' {result}) ]
  
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (self_ = C_None)} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec test_i8_div_zero[#"checked_ops.rs" 322 0 322 30] (a:Int8.t) (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = checked_div {a'0} {[%#schecked_ops] (0: Int8.t)} (fun (_ret:t_Option) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ]
    
    | bb1 = s0 [ s0 = is_none {_5} (fun (_ret:bool) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ] 
    | bb3 = return''0 {_0}
    | bb4 = {[%#schecked_ops'0] false} any ]
    ) [ & _0: () = Any.any_l () | & a'0: Int8.t = a | & _3: bool = Any.any_l () | & _5: t_Option = Any.any_l () ] 
    [ return''0 (result:())-> (! return' {result}) ]

end
