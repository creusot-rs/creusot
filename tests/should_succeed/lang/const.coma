module M_const__foo [#"const.rs" 10 0 10 27]
  let%span sconst = "const.rs" 11 4 11 7
  let%span sconst'0 = "const.rs" 9 10 9 27
  
  use creusot.int.UInt64
  use creusot.prelude.Any

  meta "compute_max_steps" 1000000

  let rec foo (return'  )= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sconst] (42 : UInt64.t) ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () ]  [ return''0 (result:UInt64.t)-> (! return' {result}) ]
end
module M_const__array [#"const.rs" 16 0 16 29]
  let%span sconst = "const.rs" 15 10 15 27
  let%span sconst'0 = "const.rs" 17 24 17 30
  let%span sconst'1 = "const.rs" 17 25 17 26
  let%span sconst'2 = "const.rs" 18 30 18 42
  let%span sconst'3 = "const.rs" 18 31 18 32
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 238 18 238 40
  let%span sslice'0 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'1 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span smodel = "../../../creusot-contracts/src/model.rs" 54 8 54 22

  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.int.UInt64
  use creusot.prelude.Any
  use seq.Seq
  use mach.int.Int

  constant c_X : Slice64.array Int32.t

  let rec setter (return'  (x:Slice64.array Int32.t))= bb0
    [ bb0 = s0
      [ s0 = Slice64.create <Int32.t> {[%#sconst'0] (9 : UInt64.t)} {fun (_ : int) -> [%#sconst'1] (1 : Int32.t)}
          (fun (_res:Slice64.array Int32.t) ->  [ &_0 <- _res ] s1)
      | s1 = return''0 {_0} ]
     ]
     [ & _0 : Slice64.array Int32.t = Any.any_l () ]
    [ return''0 (result:Slice64.array Int32.t)-> -{c_X = result}- return' ]


  let rec promoted1__array (return'  (x:Slice64.array Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- c_X ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0 : Slice64.array Int32.t = Any.any_l () ]  [ return''0 (result:Slice64.array Int32.t)-> return' {result} ]

  constant c_MAX : UInt64.t = (18446744073709551615 : UInt64.t)

  function view (self : Slice64.slice Int32.t) : Seq.seq Int32.t

  axiom view_spec : forall self : Slice64.slice Int32.t . ([%#sslice'0] Seq.length (view self)
  <= UInt64.t'int (c_MAX : UInt64.t))
  && ([%#sslice'1] view self = Slice64.id self)

  function view'0 (self : Slice64.slice Int32.t) : Seq.seq Int32.t =
    [%#smodel] view self

  let rec len (self_:Slice64.slice Int32.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sslice] Seq.length (view'0 self_) = UInt64.t'int result} (! return' {result}) ]


  constant c_Y : Slice64.array Int32.t

  let rec setter'0 (return'  (x:Slice64.array Int32.t))= bb0
    [ bb0 = s0
      [ s0 = Slice64.create <Int32.t> {[%#sconst'2] (43 : UInt64.t)} {fun (_ : int) -> [%#sconst'3] (1 : Int32.t)}
          (fun (_res:Slice64.array Int32.t) ->  [ &_0 <- _res ] s1)
      | s1 = return''0 {_0} ]
     ]
     [ & _0 : Slice64.array Int32.t = Any.any_l () ]
    [ return''0 (result:Slice64.array Int32.t)-> -{c_Y = result}- return' ]


  let rec promoted0__array (return'  (x:Slice64.array Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- c_Y ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0 : Slice64.array Int32.t = Any.any_l () ]  [ return''0 (result:Slice64.array Int32.t)-> return' {result} ]

  meta "compute_max_steps" 1000000

  let rec array (return'  )= setter'0
      (setter
        ((! bb0
        [ bb0 = s0
          [ s0 = promoted1__array (fun (pr1:Slice64.array Int32.t) ->  [ &_11 <- pr1 ] s1)
          | s1 = len {_11} (fun (_ret:UInt64.t) ->  [ &_2 <- _ret ] s2)
          | s2 = bb1 ]

        | bb1 = s0
          [ s0 = promoted0__array (fun (pr0:Slice64.array Int32.t) ->  [ &_10 <- pr0 ] s1)
          | s1 = len {_10} (fun (_ret:UInt64.t) ->  [ &_6 <- _ret ] s2)
          | s2 = bb2 ]

        | bb2 = s0 [ s0 = UInt64.add {_2} {_6} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = return''0 {_0} ]  ]
        )
        [ & _0 : UInt64.t = Any.any_l ()
        | & _2 : UInt64.t = Any.any_l ()
        | & _6 : UInt64.t = Any.any_l ()
        | & _10 : Slice64.array Int32.t = Any.any_l ()
        | & _11 : Slice64.array Int32.t = Any.any_l () ]
         [ return''0 (result:UInt64.t)-> (! return' {result}) ] ))
end
module M_const__array_param [#"const.rs" 24 0 24 51]
  let%span sconst = "const.rs" 23 10 23 21
  let%span sconst'0 = "const.rs" 25 30 25 36
  let%span sconst'1 = "const.rs" 25 31 25 32
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 238 18 238 40
  let%span sslice'0 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'1 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span smodel = "../../../creusot-contracts/src/model.rs" 54 8 54 22

  use creusot.int.UInt32
  use creusot.int.UInt64
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use seq.Seq
  use mach.int.Int

  type t__const_ty_

  constant v_N : UInt64.t

  constant _const_block : t__const_ty_

  let rec setter (return'  (x:Slice64.array UInt32.t))= bb0
    [ bb0 = s0
      [ s0 = Slice64.create <UInt32.t> {[%#sconst'0] v_N} {fun (_ : int) -> [%#sconst'1] (1 : UInt32.t)}
          (fun (_res:Slice64.array UInt32.t) ->  [ &_0 <- _res ] s1)
      | s1 = return''0 {_0} ]
     ]
     [ & _0 : Slice64.array UInt32.t = Any.any_l () ]
    [ return''0 (result:Slice64.array UInt32.t)-> -{_const_block = result}- return' ]


  constant c_MAX : UInt64.t = (18446744073709551615 : UInt64.t)

  function view (self : Slice64.slice UInt32.t) : Seq.seq UInt32.t

  axiom view_spec : forall self : Slice64.slice UInt32.t . ([%#sslice'0] Seq.length (view self)
  <= UInt64.t'int (c_MAX : UInt64.t))
  && ([%#sslice'1] view self = Slice64.id self)

  function view'0 (self : Slice64.slice UInt32.t) : Seq.seq UInt32.t =
    [%#smodel] view self

  let rec len (self_:Slice64.slice UInt32.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sslice] Seq.length (view'0 self_) = UInt64.t'int result} (! return' {result}) ]


  meta "compute_max_steps" 1000000

  let rec array_param (return'  )= setter
      ((! bb0
      [ bb0 = s0
        [ s0 =  [ &x <- _const_block ] s1 | s1 = len {x} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s2) | s2 = bb1 ]

      | bb1 = return''0 {_0} ]
      ) [ & _0 : UInt64.t = Any.any_l () | & x : Slice64.array UInt32.t = Any.any_l () ]
      [ return''0 (result:UInt64.t)-> (! return' {result}) ]
      )
end
module M_const__add_one [#"const.rs" 32 0 32 47]
  let%span sconst = "const.rs" 30 11 30 25
  let%span sconst'0 = "const.rs" 31 10 31 27
  let%span sconst'1 = "const.rs" 33 16 33 17
  let%span sconst'2 = "const.rs" 33 12 33 13
  let%span sconst'3 = "const.rs" 33 12 33 17
  let%span sord = "../../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../../creusot-contracts/src/logic/ord.rs" 230 16 236 17

  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int

  type t__const_ty_

  constant v_N : UInt64.t

  type tuple  =
    { _p0: UInt64.t; _p1: bool }

  constant _const_block : t__const_ty_

  let rec setter (return'  (x:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =
        [ &_1 <- let (fst, snd) = UInt64.add_with_overflow ([%#sconst'2] v_N) ([%#sconst'1] (1 : UInt64.t)) in { _p0 = fst;
                                                                                                                 _p1 = snd } ]

        s1
      | s1 = {[@expl:Add overflow] [%#sconst'3] not _1._p1} s2
      | s2 = bb1 ]

    | bb1 = s0 [ s0 =  [ &_0 <- _1._p0 ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0 : UInt64.t = Any.any_l () | & _1 : tuple = Any.any_l () ]
    [ return''0 (result:UInt64.t)-> -{_const_block = result}- return' ]


  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater

  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater

  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()

  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)

  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()

  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)

  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()

  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)

  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()

  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)

  function refl (x : UInt64.t) : ()

  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal

  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()

  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)

  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()

  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)

  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()

  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)

  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()

  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)

  constant c_MAX : UInt64.t = (18446744073709551615 : UInt64.t)

  meta "compute_max_steps" 1000000

  let rec add_one (return'  )= setter
      ((! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- _const_block ] s1 | s1 = return''0 {_0} ]  ] )
      [ & _0 : UInt64.t = Any.any_l () ]
       [ return''0 (result:UInt64.t)-> (! return' {result}) ] )
end
module M_const__nat [#"const.rs" 42 0 42 35]
  let%span sconst = "const.rs" 41 10 41 28

  use creusot.int.UInt64
  use creusot.prelude.Any

  type t__const_ty_

  constant c_VALUE : UInt64.t

  constant _const_block : t__const_ty_

  let rec setter (return'  (x:UInt64.t))= bb0 [ bb0 = s0 [ s0 =  [ &_0 <- c_VALUE ] s1 | s1 = return''0 {_0} ]  ]
    [ & _0 : UInt64.t = Any.any_l () ]
     [ return''0 (result:UInt64.t)-> -{_const_block = result}- return' ]

  meta "compute_max_steps" 1000000

  let rec nat (return'  )= setter
      ((! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- _const_block ] s1 | s1 = return''0 {_0} ]  ] )
      [ & _0 : UInt64.t = Any.any_l () ]
       [ return''0 (result:UInt64.t)-> (! return' {result}) ] )
end
module M_const__nat_i [#"const.rs" 55 0 55 59]
  let%span sconst = "const.rs" 54 10 54 21
  let%span sconst'0 = "const.rs" 41 10 41 28

  use creusot.int.UInt64
  use creusot.prelude.Any

  type t__const_ty_

  constant v_N : UInt64.t

  constant c_VALUE : UInt64.t = v_N

  let rec nat (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sconst'0] result = (c_VALUE : UInt64.t)} (! return' {result}) ]


  constant _const_block : t__const_ty_

  let rec setter (return'  (x:UInt64.t))= bb0
    [ bb0 = s0 [ s0 = nat (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb1 ]  | bb1 = return''0 {_0} ]
     [ & _0 : UInt64.t = Any.any_l () ]  [ return''0 (result:UInt64.t)-> -{_const_block = result}- return' ]

  meta "compute_max_steps" 1000000

  let rec nat_i (return'  )= setter
      ((! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- _const_block ] s1 | s1 = return''0 {_0} ]  ] )
      [ & _0 : UInt64.t = Any.any_l () ]
       [ return''0 (result:UInt64.t)-> (! return' {result}) ] )
end
module M_const__nat_i2 [#"const.rs" 66 0 66 38]
  let%span sconst = "const.rs" 65 10 65 28

  use creusot.int.UInt64
  use creusot.prelude.Any

  type t__const_ty_

  constant c_VALUE : UInt64.t

  constant c_VALUE'0 : UInt64.t = c_VALUE : UInt64.t

  constant _const_block : t__const_ty_

  let rec setter (return'  (x:UInt64.t))= bb0 [ bb0 = s0 [ s0 =  [ &_0 <- c_VALUE'0 ] s1 | s1 = return''0 {_0} ]  ]
    [ & _0 : UInt64.t = Any.any_l () ]
     [ return''0 (result:UInt64.t)-> -{_const_block = result}- return' ]

  meta "compute_max_steps" 1000000

  let rec nat_i2 (return'  )= setter
      ((! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- _const_block ] s1 | s1 = return''0 {_0} ]  ] )
      [ & _0 : UInt64.t = Any.any_l () ]
       [ return''0 (result:UInt64.t)-> (! return' {result}) ] )
end
module M_const__tuple [#"const.rs" 74 0 74 36]
  let%span sconst = "const.rs" 72 11 72 27
  let%span sconst'0 = "const.rs" 73 10 73 24
  let%span sconst'1 = "const.rs" 70 0 70 23

  use creusot.int.UInt64
  use creusot.int.Int32
  use creusot.prelude.Any

  type tuple  =
    { _p0: UInt64.t; _p1: Int32.t }

  constant c_TUP : tuple = [%#sconst'1] { _p0 = (42 : UInt64.t); _p1 = (24 : Int32.t) }

  meta "compute_max_steps" 1000000

  let rec tuple (return'  )= (! bb0 [ bb0 = s0 [ s0 =  [ &_0 <- c_TUP ] s1 | s1 = return''0 {_0} ]  ] )
    [ & _0 : tuple = Any.any_l () ]
     [ return''0 (result:tuple)-> (! return' {result}) ]
end
module M_const__inline_tuple [#"const.rs" 78 0 78 27]
  let%span sconst = "const.rs" 80 18 80 29
  let%span sconst'0 = "const.rs" 79 4 79 28
  let%span sconst'1 = "const.rs" 70 0 70 23

  use creusot.int.UInt64
  use creusot.int.Int32
  use creusot.prelude.Any

  type tuple  =
    { _p0: UInt64.t; _p1: Int32.t }

  constant c_ITUP : tuple = [%#sconst'0] { _p0 = (42 : UInt64.t); _p1 = (24 : Int32.t) }

  constant c_TUP : tuple = [%#sconst'1] { _p0 = (42 : UInt64.t); _p1 = (24 : Int32.t) }

  meta "compute_max_steps" 1000000

  let rec inline_tuple (return'  )= (! bb0
    [ bb0 = s0 [ s0 = {[@expl:assertion] [%#sconst] c_ITUP = c_TUP} s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ]
end
module M_const__nat_i3 [#"const.rs" 89 0 89 29]
  let%span sconst = "const.rs" 90 19 90 66
  let%span sconst'0 = "const.rs" 86 33 86 52

  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int

  type t__const_ty_

  constant c_VALUE : UInt64.t

  type tuple  =
    { _p0: UInt64.t; _p1: bool }

  constant _const_block : t__const_ty_

  let rec setter (return'  (x:UInt64.t))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- let (fst, snd) = UInt64.add_with_overflow c_VALUE c_VALUE in { _p0 = fst; _p1 = snd } ] s1
      | s1 = {[@expl:Add overflow] [%#sconst'0] not _1._p1} s2
      | s2 = bb1 ]

    | bb1 = s0 [ s0 =  [ &_0 <- _1._p0 ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0 : UInt64.t = Any.any_l () | & _1 : tuple = Any.any_l () ]
    [ return''0 (result:UInt64.t)-> -{_const_block = result}- return' ]


  constant c_VALUE'0 : UInt64.t = _const_block

  meta "compute_max_steps" 1000000

  let rec nat_i3 (return'  )= setter
      ((! bb0
      [ bb0 = s0
        [ s0 = {[@expl:assertion] [%#sconst] UInt64.t'int (c_VALUE'0 : UInt64.t)
          = UInt64.t'int (c_VALUE : UInt64.t) + UInt64.t'int (c_VALUE : UInt64.t)}
          s1
        | s1 = return''0 {_0} ]
       ]
      ) [ & _0 : () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ] )
end
module M_const__is_zst [#"const.rs" 72 0 72 65]
  let%span sconst = "const.rs" 71 10 71 29

  use creusot.prelude.Any

  constant v_IS_ZST  : bool

  let rec _get_IS_ZST (ret  (x:bool))= ret {v_IS_ZST}

  let rec _const_block (return'  (x:bool))= bb0
    [ bb0 = s0 [ s0 = _get_IS_ZST (fun (_CONST:bool) ->  [ &_0 <- _CONST ] s1) | s1 = return''0 {_0} ]  ]
     [ & _0 : bool = Any.any_l () ]  [ return''0 (result:bool)-> return' {result} ]

  meta "compute_max_steps" 1000000

  let rec is_zst[#"const.rs" 72 0 72 65] (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 = _const_block (fun (_CONST:bool) ->  [ &_0 <- _CONST ] s1) | s1 = return''0 {_0} ]  ]
    ) [ & _0 : bool = Any.any_l () ]
    [ return''0 (result:bool)-> {[@expl:is_zst ensures] [%#sconst] result = (v_IS_ZST : bool)} (! return' {result}) ]

end
module M_const__is_zst_z [#"const.rs" 80 0 80 31]
  let%span sconst = "const.rs" 81 4 81 27
  let%span sconst'0 = "const.rs" 79 10 79 16

  use creusot.prelude.Any

  meta "compute_max_steps" 1000000

  let rec is_zst_z[#"const.rs" 80 0 80 31] (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sconst] true ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : bool = Any.any_l () ]
    [ return''0 (result:bool)-> {[@expl:is_zst_z ensures] [%#sconst'0] result} (! return' {result}) ]

end
