module M_impl_Clone_for_Color__clone (* <Color as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type tup2_Color_Color = { f0: t_Color; f1: t_Color }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Color (self: t_Color) (return (x: t_Color)) = (! bb0
    [ bb0 = any [ br0 -> {self = Red} (! bb4) | br1 -> {self = Black} (! bb3) ]
    | bb3 = s0 [ s0 = [ &_0 <- Black ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- Red ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: t_Color = Any.any_l () | & self: t_Color = self ])
    [ return (result: t_Color) -> {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = Red; f1 = Red} -> true
        | {f0 = Black; f1 = Black} -> true
        | _ -> false
        end}
      (! return {result}) ]
end
module M_impl_Tree_K_V__model_acc_has_mapping (* Tree<K, V> *)
  use map.Map
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant accu : Map.map t_DeepModelTy t_Option_V
  
  constant k : t_DeepModelTy
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : ()
  
  goal vc_model_acc_has_mapping_K: match self with
      | {node = None} -> [@expl:model_acc_has_mapping ensures] Map.get (model_acc_K self accu) k = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> Map.get (model_acc_K left'0 accu) k
          = Map.get accu k
        \/ (exists v: t_V. Map.get (model_acc_K left'0 accu) k = Some'0 v /\ has_mapping_K left'0 k v)
      -> (let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in Map.get (model_acc_K right'0 accu2) k
          = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc_K right'0 accu2) k = Some'0 v /\ has_mapping_K right'0 k v)
      -> ([@expl:model_acc_has_mapping ensures] Map.get (model_acc_K self accu) k = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)))
      end
end
module M_impl_Tree_K_V_0__has_mapping_model_acc (* Tree<K, V> *)
  use map.Map
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant accu : Map.map t_DeepModelTy t_Option_V
  
  constant k : t_DeepModelTy
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model_acc_K: bst_invariant_K self
    -> match self with
      | {node = None} -> [@expl:has_mapping_model_acc ensures] forall v: t_V. has_mapping_K self k v
        -> Map.get (model_acc_K self accu) k = Some'0 v
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> ([@expl:has_mapping_model_acc requires] bst_invariant_K left'0)
      /\ ((forall v: t_V. has_mapping_K left'0 k v -> Map.get (model_acc_K left'0 accu) k = Some'0 v)
      -> (let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in ([@expl:has_mapping_model_acc requires] bst_invariant_K right'0)
      /\ ((forall v: t_V. has_mapping_K right'0 k v -> Map.get (model_acc_K right'0 accu2) k = Some'0 v)
      -> (let _ = has_mapping_model_acc_K right'0 accu2 k in Map.get (model_acc_K right'0 accu2) k = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc_K right'0 accu2) k = Some'0 v /\ has_mapping_K right'0 k v)
      -> ([@expl:has_mapping_model_acc ensures] forall v: t_V. has_mapping_K self k v
        -> Map.get (model_acc_K self accu) k = Some'0 v)))))
      end
end
module M_impl_Tree_K_V_0__has_mapping_model (* Tree<K, V> *)
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant k : t_DeepModelTy
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model_K: bst_invariant_K self
    -> Map.get (model_acc_K self (Const.const (None'0))) k = Map.get (Const.const (None'0)) k
      \/ (exists v: t_V. Map.get (model_acc_K self (Const.const (None'0))) k = Some'0 v /\ has_mapping_K self k v)
    -> (let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in ([@expl:has_mapping_model_acc requires] bst_invariant_K self)
    /\ ((forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self (Const.const (None'0))) k = Some'0 v)
    -> ([@expl:has_mapping_model ensures] forall v: t_V. has_mapping_K self k v
      = (Map.get (view_Tree_K_V self) k = Some'0 v))))
end
module M_impl_Tree_K_V_0__has_mapping_inj (* Tree<K, V> *)
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant k : t_DeepModelTy
  
  constant v1 : t_V
  
  constant v2 : t_V
  
  function has_mapping_inj_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : ()
  
  goal vc_has_mapping_inj_K: bst_invariant_K self
    -> has_mapping_K self k v1
    -> has_mapping_K self k v2
    -> ([@expl:has_mapping_model requires] bst_invariant_K self)
    /\ ((forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
    -> ([@expl:has_mapping_inj ensures] v1 = v2))
end
module M_impl_Node_K_V__has_mapping (* Node<K, V> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node_K_V
  
  constant k : t_DeepModelTy
  
  constant v : t_V
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V)
  
  goal vc_has_mapping_K: if has_mapping_K self.left k v then
      [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
        -> true = has_mapping_K { node = Some node'0 } k v
    else
      if has_mapping_K self.right k v then
        [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
          -> true = has_mapping_K { node = Some node'0 } k v
      else
        if k = deep_model_K self.key then
          [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
            -> (v = self.val') = has_mapping_K { node = Some node'0 } k v
        else
          [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
            -> false = has_mapping_K { node = Some node'0 } k v
      
    

end
module M_impl_Resolve_for_Tree_K_V__resolve_coherence (* <Tree<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  axiom resolve_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  predicate structural_resolve_Tree_K_V (_1: t_Tree_K_V) = resolve_Option_Box_Node_K_V_Global _1.node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  function resolve_coherence_Tree_K_V (self: t_Tree_K_V) : ()
  
  goal vc_resolve_coherence_Tree_K_V: structural_resolve_Tree_K_V self
    -> ([@expl:resolve_coherence ensures] resolve_Tree_K_V self)
end
module M_impl_Resolve_for_Node_K_V__resolve_coherence (* <Node<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Node_K_V (_1: t_Node_K_V) =
    resolve_Tree_K_V'0 _1.left /\ resolve_K _1.key /\ resolve_V _1.val' /\ resolve_Tree_K_V'0 _1.right
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node_K_V
  
  function resolve_coherence_Node_K_V (self: t_Node_K_V) : ()
  
  goal vc_resolve_coherence_Node_K_V: structural_resolve_Node_K_V self
    -> ([@expl:resolve_coherence ensures] resolve_Node_K_V self)
end
module M_impl_Tree_K_V_3__height (* Tree<K, V> *)
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  function height_K (self: t_Tree_K_V) : int
  
  goal vc_height_K: match self with
      | {node = None} -> [@expl:height ensures] 0 >= 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0 >= 0
      -> ([@expl:height ensures] height_K left'0 >= 0)
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 >= 0
      -> ([@expl:height ensures] height_K left'0 + 1 >= 0)
      end
end
module M_impl_Node_K_V_2__height (* Node<K, V> *)
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node_K_V
  
  function height_K'0 (self: t_Node_K_V) : int
  
  goal vc_height_K: match self.color with
      | Red -> height_K self.left >= 0
      -> ([@expl:height ensures] forall node'0: t_Node_K_V. self = node'0
        -> height_K self.left = height_K { node = Some node'0 })
      | Black -> height_K self.left >= 0
      -> ([@expl:height ensures] forall node'0: t_Node_K_V. self = node'0
        -> height_K self.left + 1 = height_K { node = Some node'0 })
      end
end
module M_impl_Tree_K_V_5__is_red (* Tree<K, V> *)
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  let rec elim_Some (input: t_Option_Box_Node_K_V_Global) (ret (f0: t_Node_K_V)) = any
    [ good (f0: t_Node_K_V) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Node_K_V [Some f0: t_Option_Box_Node_K_V_Global]. Some f0 <> input} (! {false} any) ]
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    (! bb0
    [ bb0 = any [ br0 -> {self.node = None} (! bb1) | br1 (x0: t_Node_K_V) -> {self.node = Some x0} (! bb2) ]
    | bb2 = elim_Some {self.node}
        (fun (r0: t_Node_K_V) -> any [ br0 -> {r0.color = Red} (! bb4) | br1 -> {r0.color = Black} (! bb1) ])
    | bb1 = s0 [ s0 = [ &_0 <- false ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- true ] s1 | s1 = bb5 ]
    | bb5 = return {_0} ] [ & _0: bool = Any.any_l () | & self: t_Tree_K_V = self ])
    [ return (result: bool) -> {[@expl:is_red ensures] result = (color_K self = Red)} (! return {result}) ]
end
module M_impl_Node_K_V_4__rotate_right (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec swap_Tree_K_V (x: MutBorrow.t t_Tree_K_V) (y: MutBorrow.t t_Tree_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Tree_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Tree_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec swap_Node_K_V (x: MutBorrow.t t_Node_K_V) (y: MutBorrow.t t_Node_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Node_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Node_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  let rec swap_Color (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Color [@inline:trivial] (_1: MutBorrow.t t_Color) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Color
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_16 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with left = { node = _ret.final } } } ] s1)
      | s1 = {inv_Option_Box_Node_K_V_Global _16.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_15 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &_16 <- { _16 with current = _ret.final } ] s2)
      | s2 = take_Option_Box_Node_K_V_Global {_15} (fun (_ret: t_Option_Box_Node_K_V_Global) -> [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _16} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _16}- s2
      | s2 = unwrap_Box_Node_K_V_Global {_14} (fun (_ret: t_Node_K_V) -> [ &x <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Tree_K_V self.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.left}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_19 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &self <- { self with current = { self.current with left = _ret.final } } ] s1)
      | s1 = {inv_Tree_K_V x.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {x.right}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_21 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &x <- { x with right = _ret.final } ] s2)
      | s2 = {inv_Tree_K_V _19.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_18 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s3)
      | s3 = {inv_Tree_K_V _21.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_20 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &_21 <- { _21 with current = _ret.final } ] s4)
      | s4 = swap_Tree_K_V {_18} {_20} (fun (_ret: ()) -> [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Tree_K_V _21} s1
      | s1 = -{resolve_ref_Tree_K_V _21}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V _19} s3
      | s3 = -{resolve_ref_Tree_K_V _19}- s4
      | s4 = {inv_Box_Node_K_V_Global x}
        MutBorrow.borrow_mut <t_Node_K_V> {x}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_25 <- _ret ] -{inv_Box_Node_K_V_Global _ret.final}-
            [ &x <- _ret.final ] s5)
      | s5 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_23 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s6)
      | s6 = {inv_Node_K_V _25.current}
        MutBorrow.borrow_final <t_Node_K_V> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_24 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_25 <- { _25 with current = _ret.final } ] s7)
      | s7 = swap_Node_K_V {_23} {_24} (fun (_ret: ()) -> [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _25} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _25}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {self.current.color} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_28 <- _ret ] [ &self <- { self with current = { self.current with color = _ret.final } } ] s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.color}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_30 <- _ret ] [ &x <- { x with color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_27 <- _ret ] [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_29 <- _ret ] [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap_Color {_27} {_29} (fun (_ret: ()) -> [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve_ref_Color _30}- s1
      | s1 = -{resolve_ref_Color _28}- s2
      | s2 = {[@expl:assertion] has_mapping_K old_self.current.left (deep_model_K self.current.key) self.current.val'}
        s3
      | s3 = [ &_34 <- Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_33 <- { node = _34 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V self.current.right} s1
      | s1 = -{resolve_Tree_K_V'0 self.current.right}- s2
      | s2 = [ &self <- { self with current = { self.current with right = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_K_V self} s4
      | s4 = -{resolve_ref_Node_K_V self}- s5
      | s5 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & old_self: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & x: t_Node_K_V = Any.any_l ()
    | & _14: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _15: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _16: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _19: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _20: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _21: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _24: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _25: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree_K_V = Any.any_l ()
    | & _34: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:rotate_right ensures #0] same_mappings_K self.current self.final}
      {[@expl:rotate_right ensures #1] internal_invariant_K self.final}
      {[@expl:rotate_right ensures #2] height_K'0 self.current = height_K'0 self.final}
      {[@expl:rotate_right ensures #3] lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {[@expl:rotate_right ensures #4] color_K self.final.right = Red}
      {[@expl:rotate_right ensures #5] self.final.color = self.current.color}
      {[@expl:rotate_right ensures #6] exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__rotate_left (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec swap_Tree_K_V (x: MutBorrow.t t_Tree_K_V) (y: MutBorrow.t t_Tree_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Tree_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Tree_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec swap_Node_K_V (x: MutBorrow.t t_Node_K_V) (y: MutBorrow.t t_Node_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Node_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Node_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  let rec swap_Color (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Color [@inline:trivial] (_1: MutBorrow.t t_Color) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Color
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_left_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_left requires #0] internal_invariant_K self.current}
    {[@expl:rotate_left requires #1] color_K self.current.right = Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_16 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with right = { node = _ret.final } } } ] s1)
      | s1 = {inv_Option_Box_Node_K_V_Global _16.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_15 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &_16 <- { _16 with current = _ret.final } ] s2)
      | s2 = take_Option_Box_Node_K_V_Global {_15} (fun (_ret: t_Option_Box_Node_K_V_Global) -> [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _16} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _16}- s2
      | s2 = unwrap_Box_Node_K_V_Global {_14} (fun (_ret: t_Node_K_V) -> [ &x <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Tree_K_V self.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.right}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_19 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &self <- { self with current = { self.current with right = _ret.final } } ] s1)
      | s1 = {inv_Tree_K_V x.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {x.left}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_21 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &x <- { x with left = _ret.final } ] s2)
      | s2 = {inv_Tree_K_V _19.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_18 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s3)
      | s3 = {inv_Tree_K_V _21.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_20 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &_21 <- { _21 with current = _ret.final } ] s4)
      | s4 = swap_Tree_K_V {_18} {_20} (fun (_ret: ()) -> [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Tree_K_V _21} s1
      | s1 = -{resolve_ref_Tree_K_V _21}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V _19} s3
      | s3 = -{resolve_ref_Tree_K_V _19}- s4
      | s4 = {inv_Box_Node_K_V_Global x}
        MutBorrow.borrow_mut <t_Node_K_V> {x}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_25 <- _ret ] -{inv_Box_Node_K_V_Global _ret.final}-
            [ &x <- _ret.final ] s5)
      | s5 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_23 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s6)
      | s6 = {inv_Node_K_V _25.current}
        MutBorrow.borrow_final <t_Node_K_V> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_24 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_25 <- { _25 with current = _ret.final } ] s7)
      | s7 = swap_Node_K_V {_23} {_24} (fun (_ret: ()) -> [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _25} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _25}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {self.current.color} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_28 <- _ret ] [ &self <- { self with current = { self.current with color = _ret.final } } ] s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.color}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_30 <- _ret ] [ &x <- { x with color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_27 <- _ret ] [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_29 <- _ret ] [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap_Color {_27} {_29} (fun (_ret: ()) -> [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve_ref_Color _30}- s1
      | s1 = -{resolve_ref_Color _28}- s2
      | s2 = {[@expl:assertion] has_mapping_K old_self.current.right (deep_model_K self.current.key) self.current.val'}
        s3
      | s3 = [ &_34 <- Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_33 <- { node = _34 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V self.current.left} s1
      | s1 = -{resolve_Tree_K_V'0 self.current.left}- s2
      | s2 = [ &self <- { self with current = { self.current with left = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_K_V self} s4
      | s4 = -{resolve_ref_Node_K_V self}- s5
      | s5 = bb12 ]
    | bb12 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & old_self: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & x: t_Node_K_V = Any.any_l ()
    | & _14: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _15: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _16: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _19: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _20: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _21: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _24: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _25: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree_K_V = Any.any_l ()
    | & _34: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:rotate_left ensures #0] same_mappings_K self.current self.final}
      {[@expl:rotate_left ensures #1] internal_invariant_K self.final}
      {[@expl:rotate_left ensures #2] height_K'0 self.current = height_K'0 self.final}
      {[@expl:rotate_left ensures #3] lt_log_DeepModelTy (deep_model_K self.current.key) (deep_model_K self.final.key)}
      {[@expl:rotate_left ensures #4] color_K self.final.left = Red}
      {[@expl:rotate_left ensures #5] self.final.color = self.current.color}
      {[@expl:rotate_left ensures #6] exists l: t_Node_K_V, r: t_Node_K_V. self.current.right.node = Some r
        /\ self.final.left.node = Some l
        /\ { f0 = l.left; f1 = l.right; f2 = self.final.right } = { f0 = self.current.left; f1 = r.left; f2 = r.right }
        /\ l.key = self.current.key}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__flip_colors (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  let rec swap_Color (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Color [@inline:trivial] (_1: MutBorrow.t t_Color) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Color
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_15 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with left = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_15} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_14} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_13 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_13 <- { _13 with current = { _13.current with color = self.current.color } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _13} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _13}- s3
      | s3 = MutBorrow.borrow_final <t_Color> {self.current.color} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_18 <- _ret ] [ &self <- { self with current = { self.current with color = _ret.final } } ] s4)
      | s4 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_23 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with right = { node = _ret.final } } } ] s5)
      | s5 = as_mut_Box_Node_K_V_Global {_23} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_22 <- _ret ] s6)
      | s6 = bb3 ]
    | bb3 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_22} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_21 <- _ret ] s1)
      | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_final <t_Color> {_21.current.color} {MutBorrow.inherit_id (MutBorrow.get_id _21) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_20 <- _ret ] [ &_21 <- { _21 with current = { _21.current with color = _ret.final } } ] s1)
      | s1 = MutBorrow.borrow_final <t_Color> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_17 <- _ret ] [ &_18 <- { _18 with current = _ret.final } ] s2)
      | s2 = MutBorrow.borrow_final <t_Color> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s3)
      | s3 = swap_Color {_17} {_19} (fun (_ret: ()) -> [ &_16 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _21} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _21}- s2
      | s2 = -{resolve_ref_Color _20}- s3
      | s3 = -{resolve_ref_Color _18}- s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V self} s5
      | s5 = -{resolve_ref_Node_K_V self}- s6
      | s6 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _13: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _14: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _15: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: MutBorrow.t t_Color = Any.any_l ()
    | & _18: MutBorrow.t t_Color = Any.any_l ()
    | & _19: MutBorrow.t t_Color = Any.any_l ()
    | & _20: MutBorrow.t t_Color = Any.any_l ()
    | & _21: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _22: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _23: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:flip_colors ensures #0] internal_invariant_K self.final}
      {[@expl:flip_colors ensures #1] height_K'0 self.current = height_K'0 self.final}
      {[@expl:flip_colors ensures #2] same_mappings_K self.current self.final}
      {[@expl:flip_colors ensures #3] self.current.key = self.final.key}
      {[@expl:flip_colors ensures #4] exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {[@expl:flip_colors ensures #5] exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__balance (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_left_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_left requires #0] internal_invariant_K self.current}
    {[@expl:rotate_left requires #1] color_K self.current.right = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.current.key) (deep_model_K self.final.key)}
      {color_K self.final.left = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.right.node = Some r
        /\ self.final.left.node = Some l
        /\ { f0 = l.left; f1 = l.right; f2 = self.final.right } = { f0 = self.current.left; f1 = r.left; f2 = r.right }
        /\ l.key = self.current.key}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 t_Node_K_V
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: t_Node_K_V) = inv_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_ref_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_ref 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_ = None -> result = None'0}
      {self_ = None \/ (exists r: t_Node_K_V. result = Some'0 r /\ self_ = Some r)}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result} {Some'0 result = self_} (! return {result}) ]
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {same_mappings_K self.current self.final}
      {self.current.key = self.final.key}
      {exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    (! bb0
    [ bb0 = s0 [ s0 = is_red_K {self.current.right} (fun (_ret: bool) -> [ &_15 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb2) ]
    | bb2 = s0 [ s0 = is_red_K {self.current.left} (fun (_ret: bool) -> [ &_17 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb9) ]
    | bb5 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_20 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = rotate_left_K {_20} (fun (_ret: ()) -> [ &_19 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red_K {self.current.left} (fun (_ret: bool) -> [ &_22 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb20) | br1 -> {_22} (! bb11) ]
    | bb11 = s0
      [ s0 = as_ref_Box_Node_K_V_Global {self.current.left.node}
          (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_27 <- _ret ] s1)
      | s1 = bb12 ]
    | bb12 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_27} (fun (_ret: t_Node_K_V) -> [ &_26 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = is_red_K {_26.left} (fun (_ret: bool) -> [ &_24 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb15) ]
    | bb15 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_30 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = rotate_right_K {_30} (fun (_ret: ()) -> [ &_29 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = is_red_K {self.current.left} (fun (_ret: bool) -> [ &_31 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ]
    | bb22 = s0 [ s0 = is_red_K {self.current.right} (fun (_ret: bool) -> [ &_33 <- _ret ] s1) | s1 = bb23 ]
    | bb23 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ]
    | bb24 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_final <t_Node_K_V> {self.current} {MutBorrow.get_id self}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_36 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors_K {_36} (fun (_ret: ()) -> [ &_35 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb29 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb29 ]
    | bb27 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb29 ]
    | bb29 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _15: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _20: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Node_K_V = Any.any_l ()
    | & _27: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: () = Any.any_l ()
    | & _36: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: ()) -> {[@expl:balance ensures #0] same_mappings_K self.current self.final}
      {[@expl:balance ensures #1] internal_invariant_K self.final}
      {[@expl:balance ensures #2] height_K'0 self.current = height_K'0 self.final}
      {[@expl:balance ensures #3] color_invariant_K self.current.left /\ color_K self.current.right = Black
      -> self.current = self.final}
      {[@expl:balance ensures #4] match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {[@expl:balance ensures #5] match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {[@expl:balance ensures #6] match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {[@expl:balance ensures #7] match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current
      -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__move_red_left (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {same_mappings_K self.current self.final}
      {self.current.key = self.final.key}
      {exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  let rec rotate_left_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_left requires #0] internal_invariant_K self.current}
    {[@expl:rotate_left requires #1] color_K self.current.right = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.current.key) (deep_model_K self.final.key)}
      {color_K self.final.left = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.right.node = Some r
        /\ self.final.left.node = Some l
        /\ { f0 = l.left; f1 = l.right; f2 = self.final.right } = { f0 = self.current.left; f1 = r.left; f2 = r.right }
        /\ l.key = self.current.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_left_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_left requires #0] self.current.right.node <> None}
    {[@expl:move_red_left requires #1] internal_invariant_K self.current}
    {[@expl:move_red_left requires #2] match_n_K (cpn (Red) (cpn (Black) (CPL (Black)) (CPL (Black))) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_16 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors_K {_16} (fun (_ret: ()) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_22 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with right = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_22} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_21} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_20 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _20} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _20}- s2
      | s2 = is_red_K {_20.current.left} (fun (_ret: bool) -> [ &_18 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_28 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with right = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_28} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_27 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_27} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_26 <- _ret ] s1)
      | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {inv_Node_K_V _26.current}
        MutBorrow.borrow_final <t_Node_K_V> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_25 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_26 <- { _26 with current = _ret.final } ] s1)
      | s1 = rotate_right_K {_25} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _26} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _26}- s2
      | s2 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_30 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s3)
      | s3 = rotate_left_K {_30} (fun (_ret: ()) -> [ &_29 <- _ret ] s4)
      | s4 = bb9 ]
    | bb9 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_32 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors_K {_32} (fun (_ret: ()) -> [ &_31 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_35 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with left = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_35} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_34 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_34} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_33 <- _ret ] s1)
      | s1 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Node_K_V _33.current}
        MutBorrow.borrow_final <t_Node_K_V> {_33.current} {MutBorrow.get_id _33}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_0 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_33 <- { _33 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _33} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _33}- s3
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb14 ]
    | bb13 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = bb14 ]
    | bb14 = return {_0} ]
    [ & _0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _21: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _22: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _26: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _27: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _28: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _32: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _33: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _34: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _35: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: MutBorrow.t t_Node_K_V) -> {[@expl:move_red_left result type invariant] inv_ref_Node_K_V result}
      {[@expl:move_red_left ensures #0] internal_invariant_K result.current}
      {[@expl:move_red_left ensures #1] internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {[@expl:move_red_left ensures #2] height_K'0 result.current = height_K'0 result.final
      -> height_K'0 self.current = height_K'0 self.final}
      {[@expl:move_red_left ensures #3] self.current.key = result.current.key}
      {[@expl:move_red_left ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v
        -> has_mapping_K'0 self.current k v}
      {[@expl:move_red_left ensures #5] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy k (deep_model_K self.current.key) -> has_mapping_K'0 result.current k v}
      {[@expl:move_red_left ensures #6] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {[@expl:move_red_left ensures #7] match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {[@expl:move_red_left ensures #8] color_invariant_K'0 result.final
        /\ (color_K result.current.right = Black -> result.final.color = Black) -> color_invariant_K'0 self.final}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__move_red_right (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {same_mappings_K self.current self.final}
      {self.current.key = self.final.key}
      {exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_right_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_right requires #0] self.current.left.node <> None}
    {[@expl:move_red_right requires #1] internal_invariant_K self.current}
    {[@expl:move_red_right requires #2] match_n_K (cpn (Red) (CPL (Black)) (cpn (Black) (CPL (Black)) (CPL (Black)))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_16 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors_K {_16} (fun (_ret: ()) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_22 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with left = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_22} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_21} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_20 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _20} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _20}- s2
      | s2 = is_red_K {_20.current.left} (fun (_ret: bool) -> [ &_18 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_25 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = rotate_right_K {_25} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_27 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &self <- { self with current = _ret.final } ] s1)
      | s1 = flip_colors_K {_27} (fun (_ret: ()) -> [ &_26 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_30 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { self.current with right = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_30} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_29 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_29} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_28 <- _ret ] s1)
      | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {inv_Node_K_V _28.current}
        MutBorrow.borrow_final <t_Node_K_V> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_0 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_28 <- { _28 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _28} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _28}- s3
      | s3 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb11 ]
    | bb10 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = bb11 ]
    | bb11 = return {_0} ]
    [ & _0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _21: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _22: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _28: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _29: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _30: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: MutBorrow.t t_Node_K_V) -> {[@expl:move_red_right result type invariant] inv_ref_Node_K_V result}
      {[@expl:move_red_right ensures #0] internal_invariant_K result.current}
      {[@expl:move_red_right ensures #1] internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {[@expl:move_red_right ensures #2] height_K'0 result.current = height_K'0 result.final
      -> height_K'0 self.current = height_K'0 self.final}
      {[@expl:move_red_right ensures #3] result.current.key = self.current.key}
      {[@expl:move_red_right ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v
        -> has_mapping_K'0 self.current k v}
      {[@expl:move_red_right ensures #5] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy (deep_model_K self.current.key) k -> has_mapping_K'0 result.current k v}
      {[@expl:move_red_right ensures #6] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {[@expl:move_red_right ensures #7] match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {[@expl:move_red_right ensures #8] color_invariant_K'0 result.final
        /\ (color_K result.current.left = Black -> result.final.color = Black) -> color_invariant_K'0 self.final}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__insert_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  axiom resolve_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  let rec elim_Some (input: t_Option_Box_Node_K_V_Global) (ret (f0: t_Node_K_V)) = any
    [ good (f0: t_Node_K_V) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: t_Node_K_V [Some f0: t_Option_Box_Node_K_V_Global]. Some f0 <> input} (! {false} any) ]
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_ref_K_ref_K = { f0: t_K; f1: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (val''0: t_V) (return (x: ())) =
    {[@expl:insert_rec 'self' type invariant] inv_ref_Tree_K_V self}
    {[@expl:insert_rec 'key' type invariant] inv_K key'0}
    {[@expl:insert_rec 'val' type invariant] inv_V val''0}
    {[@expl:insert_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:insert_rec requires #1] color_invariant_K self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_11 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { node = _ret.final } } ] s1)
      | s1 = any [ br0 -> {_11.current = None} (! bb17) | br1 (x0: t_Node_K_V) -> {_11.current = Some x0} (! bb2) ] ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _11} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _11}- s2
      | s2 = [ &_34 <- None ] s3
      | s3 = [ &_33 <- { node = _34 } ] s4
      | s4 = bb18 ]
    | bb18 = s0 [ s0 = [ &_35 <- Red ] s1 | s1 = [ &_39 <- None ] s2 | s2 = [ &_38 <- { node = _39 } ] s3 | s3 = bb19 ]
    | bb19 = s0 [ s0 = [ &_32 <- { left = _33; color = _35; key = key'0; val' = val''0; right = _38 } ] s1 | s1 = bb24 ]
    | bb24 = s0 [ s0 = [ &_30 <- Some _32 ] s1 | s1 = bb26 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv_Option_Box_Node_K_V_Global self.current.node} s1
      | s1 = -{resolve_Option_Box_Node_K_V_Global self.current.node}- s2
      | s2 = [ &self <- { self with current = { node = _30 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Tree_K_V self} s4
      | s4 = -{resolve_ref_Tree_K_V self}- s5
      | s5 = bb32 ]
    | bb2 = s0
      [ s0 = elim_Some {_11.current}
          (fun (r0: t_Node_K_V) ->
            {inv_Box_Node_K_V_Global r0}
            MutBorrow.borrow_final <t_Node_K_V> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _11) 1}
              (fun (_ret: MutBorrow.t t_Node_K_V) ->
                [ &node'0 <- _ret ] -{inv_Box_Node_K_V_Global _ret.final}-
                [ &_11 <- { _11 with current = Some _ret.final } ] s1))
      | s1 = [ &_18 <- node'0.current.key ] s2
      | s2 = cmp_K {key'0} {_18} (fun (_ret: t_Ordering) -> [ &_15 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = any [ br0 -> {_15 = Less} (! bb9) | br1 -> {_15 = Equal} (! bb6) | br2 -> {_15 = Greater} (! bb7) ]
    | bb7 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_25 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _ret.final } } ] s1)
      | s1 = insert_rec_K {_25} {key'0} {val''0} (fun (_ret: ()) -> [ &_14 <- _ret ] s2)
      | s2 = bb15 ]
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv_K key'0} s1 | s1 = -{resolve_K key'0}- s2 | s2 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_V node'0.current.val'} s1
      | s1 = -{resolve_V node'0.current.val'}- s2
      | s2 = [ &node'0 <- { node'0 with current = { node'0.current with val' = val''0 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s4
      | s4 = -{resolve_ref_Box_Node_K_V_Global node'0}- s5
      | s5 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _11} s6
      | s6 = -{resolve_ref_Option_Box_Node_K_V_Global _11}- s7
      | s7 = {[@expl:type invariant] inv_ref_Tree_K_V self} s8
      | s8 = -{resolve_ref_Tree_K_V self}- s9
      | s9 = bb32 ]
    | bb9 = s0
      [ s0 = {inv_Tree_K_V node'0.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.left}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_20 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with left = _ret.final } } ] s1)
      | s1 = insert_rec_K {_20} {key'0} {val''0} (fun (_ret: ()) -> [ &_14 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_29 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = balance_K {_29} (fun (_ret: ()) -> [ &_28 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _11} s3
      | s3 = -{resolve_ref_Option_Box_Node_K_V_Global _11}- s4
      | s4 = {[@expl:type invariant] inv_ref_Tree_K_V self} s5
      | s5 = -{resolve_ref_Tree_K_V self}- s6
      | s6 = bb32 ]
    | bb32 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & key'0: t_K = key'0
    | & val''0: t_V = val''0
    | & _11: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & _15: t_Ordering = Any.any_l ()
    | & _18: t_K = Any.any_l ()
    | & _20: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _25: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _28: () = Any.any_l ()
    | & _29: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _30: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _32: t_Node_K_V = Any.any_l ()
    | & _33: t_Tree_K_V = Any.any_l ()
    | & _34: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _35: t_Color = Any.any_l ()
    | & _38: t_Tree_K_V = Any.any_l ()
    | & _39: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:insert_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:insert_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:insert_rec ensures #2] match_t_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final
        /\ color_K self.current = Red
      \/ color_invariant_K self.final}
      {[@expl:insert_rec ensures #3] has_mapping_K self.final (deep_model_K key'0) val''0}
      {[@expl:insert_rec ensures #4] forall k: t_DeepModelTy, v: t_V. k = deep_model_K key'0
        \/ has_mapping_K self.current k v = has_mapping_K self.final k v}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__delete_max_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec as_mut_Box_Node_K_V_Global'0 (self_: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  let rec elim_Some (input: t_Option_Box_Node_K_V_Global) (ret (f0'1: t_Node_K_V)) = any
    [ good (f0'1: t_Node_K_V) -> {Some f0'1 = input} (! ret {f0'1})
    | bad -> {forall f0'1: t_Node_K_V [Some f0'1: t_Option_Box_Node_K_V_Global]. Some f0'1 <> input} (! {false} any) ]
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec move_red_right_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_right requires #0] self.current.left.node <> None}
    {[@expl:move_red_right requires #1] internal_invariant_K self.current}
    {[@expl:move_red_right requires #2] match_n_K (cpn (Red) (CPL (Black)) (cpn (Black) (CPL (Black)) (CPL (Black)))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {result.current.key = self.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy (deep_model_K self.current.key) k -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.left = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_max_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_max_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_max_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_15 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { node = _ret.final } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_15} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_14} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_13 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Box_Node_K_V_Global _13.current}
        MutBorrow.borrow_final <t_Node_K_V> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_12 <- _ret ] -{inv_Box_Node_K_V_Global _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global'0 {_12} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &node'0 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _13} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _13}- s2
      | s2 = is_red_K {node'0.current.left} (fun (_ret: bool) -> [ &_17 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_17 = false} (! bb8) | br1 -> {_17} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_mut <t_Node_K_V> {node'0.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_19 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = rotate_right_K {_19} (fun (_ret: ()) -> [ &_16 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0 [ s0 = is_red_K {node'0.current.right} (fun (_ret: bool) -> [ &_21 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = any [ br0 -> {_21 = false} (! bb11) | br1 -> {_21} (! bb24) ]
    | bb11 = s0
      [ s0 = [ &_31 <- node'0.current.right.node ] s1
      | s1 = any [ br0 -> {_31 = None} (! bb18) | br1 (x0: t_Node_K_V) -> {_31 = Some x0} (! bb17) ] ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.node}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_27 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { node = _ret.final } } ] s3)
      | s3 = {inv_Option_Box_Node_K_V_Global _27.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_27.current} {MutBorrow.get_id _27}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_26 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &_27 <- { _27 with current = _ret.final } ] s4)
      | s4 = take_Option_Box_Node_K_V_Global {_26} (fun (_ret: t_Option_Box_Node_K_V_Global) -> [ &_25 <- _ret ] s5)
      | s5 = bb12 ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _27} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _27}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = unwrap_Box_Node_K_V_Global {_25} (fun (_ret: t_Node_K_V) -> [ &node'1 <- _ret ] s5)
      | s5 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V node'1.right} s1
      | s1 = -{resolve_Tree_K_V'0 node'1.right}- s2
      | s2 = {[@expl:type invariant] inv_Tree_K_V node'1.left} s3
      | s3 = -{resolve_Tree_K_V'0 node'1.left}- s4
      | s4 = [ &_0 <- { f0'0 = node'1.key; f1'0 = node'1.val' } ] s5
      | s5 = bb29 ]
    | bb17 = s0
      [ s0 = elim_Some {_31} (fun (r0: t_Node_K_V) -> [ &right'0 <- r0 ] s1)
      | s1 = is_red_K {right'0.left} (fun (_ret: bool) -> [ &_33 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = any [ br0 -> {_33 = false} (! bb21) | br1 -> {_33} (! bb24) ]
    | bb21 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_37 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = move_red_right_K {_37} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_36 <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = s0
      [ s0 = {inv_Node_K_V _36.current}
        MutBorrow.borrow_final <t_Node_K_V> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_35 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_36 <- { _36 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _35 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _36} s5
      | s5 = -{resolve_ref_Node_K_V _36}- s6
      | s6 = bb24 ]
    | bb24 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_39 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _ret.final } } ] s1)
      | s1 = delete_max_rec_K {_39} (fun (_ret: tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_41 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = balance_K {_41} (fun (_ret: ()) -> [ &_40 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb29 ]
    | bb29 = return {_0} ]
    [ & _0: tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _12: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _13: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _14: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _15: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & node'1: t_Node_K_V = Any.any_l ()
    | & _25: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _26: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _27: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & right'0: t_Node_K_V = Any.any_l ()
    | & _31: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _36: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _37: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _39: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _40: () = Any.any_l ()
    | & _41: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: tup2_K_V) -> {[@expl:delete_max_rec result type invariant] inv_tup2_K_V result}
      {[@expl:delete_max_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:delete_max_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:delete_max_rec ensures #2] has_mapping_K self.current (deep_model_K result.f0'0) result.f1'0}
      {[@expl:delete_max_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy k (deep_model_K result.f0'0)}
      {[@expl:delete_max_rec ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'0 <> k /\ has_mapping_K self.current k v)}
      {[@expl:delete_max_rec ensures #5] color_invariant_K self.final}
      {[@expl:delete_max_rec ensures #6] color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__delete_min_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec as_mut_Box_Node_K_V_Global'0 (self_: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  let rec elim_Some (input: t_Option_Box_Node_K_V_Global) (ret (f0'0: t_Node_K_V)) = any
    [ good (f0'0: t_Node_K_V) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Node_K_V [Some f0'0: t_Option_Box_Node_K_V_Global]. Some f0'0 <> input} (! {false} any) ]
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  let rec move_red_left_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_left requires #0] self.current.right.node <> None}
    {[@expl:move_red_left requires #1] internal_invariant_K self.current}
    {[@expl:move_red_left requires #2] match_n_K (cpn (Red) (cpn (Black) (CPL (Black)) (CPL (Black))) (CPL (Black))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {self.current.key = result.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy k (deep_model_K self.current.key) -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.right = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_min_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_min_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_min_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_15 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { node = _ret.final } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_15} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_14} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_13 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Box_Node_K_V_Global _13.current}
        MutBorrow.borrow_final <t_Node_K_V> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_12 <- _ret ] -{inv_Box_Node_K_V_Global _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global'0 {_12} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &node'0 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _13} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _13}- s2
      | s2 = is_red_K {node'0.current.left} (fun (_ret: bool) -> [ &_17 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_17 = false} (! bb6) | br1 -> {_17} (! bb19) ]
    | bb6 = s0
      [ s0 = [ &_27 <- node'0.current.left.node ] s1
      | s1 = any [ br0 -> {_27 = None} (! bb13) | br1 (x0: t_Node_K_V) -> {_27 = Some x0} (! bb12) ] ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.node}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_23 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { node = _ret.final } } ] s3)
      | s3 = {inv_Option_Box_Node_K_V_Global _23.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_23.current} {MutBorrow.get_id _23}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_22 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &_23 <- { _23 with current = _ret.final } ] s4)
      | s4 = take_Option_Box_Node_K_V_Global {_22} (fun (_ret: t_Option_Box_Node_K_V_Global) -> [ &_21 <- _ret ] s5)
      | s5 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _23} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _23}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = unwrap_Box_Node_K_V_Global {_21} (fun (_ret: t_Node_K_V) -> [ &node'1 <- _ret ] s5)
      | s5 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V node'1.right} s1
      | s1 = -{resolve_Tree_K_V'0 node'1.right}- s2
      | s2 = {[@expl:type invariant] inv_Tree_K_V node'1.left} s3
      | s3 = -{resolve_Tree_K_V'0 node'1.left}- s4
      | s4 = [ &_0 <- { f0 = node'1.key; f1 = node'1.val' } ] s5
      | s5 = bb24 ]
    | bb12 = s0
      [ s0 = elim_Some {_27} (fun (r0: t_Node_K_V) -> [ &left'0 <- r0 ] s1)
      | s1 = is_red_K {left'0.left} (fun (_ret: bool) -> [ &_29 <- _ret ] s2)
      | s2 = bb14 ]
    | bb14 = any [ br0 -> {_29 = false} (! bb16) | br1 -> {_29} (! bb19) ]
    | bb16 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_33 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = move_red_left_K {_33} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_32 <- _ret ] s2)
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = {inv_Node_K_V _32.current}
        MutBorrow.borrow_final <t_Node_K_V> {_32.current} {MutBorrow.get_id _32}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_31 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_32 <- { _32 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _31 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _32} s5
      | s5 = -{resolve_ref_Node_K_V _32}- s6
      | s6 = bb19 ]
    | bb19 = s0
      [ s0 = {inv_Tree_K_V node'0.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.left}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_35 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with left = _ret.final } } ] s1)
      | s1 = delete_min_rec_K {_35} (fun (_ret: tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_37 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = balance_K {_37} (fun (_ret: ()) -> [ &_36 <- _ret ] s2)
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb24 ]
    | bb24 = return {_0} ]
    [ & _0: tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _12: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _13: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _14: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _15: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & node'1: t_Node_K_V = Any.any_l ()
    | & _21: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _22: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _23: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & left'0: t_Node_K_V = Any.any_l ()
    | & _27: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _31: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _32: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _33: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _35: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _36: () = Any.any_l ()
    | & _37: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: tup2_K_V) -> {[@expl:delete_min_rec result type invariant] inv_tup2_K_V result}
      {[@expl:delete_min_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:delete_min_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:delete_min_rec ensures #2] has_mapping_K self.current (deep_model_K result.f0) result.f1}
      {[@expl:delete_min_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy (deep_model_K result.f0) k}
      {[@expl:delete_min_rec ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0 <> k /\ has_mapping_K self.current k v)}
      {[@expl:delete_min_rec ensures #5] color_invariant_K self.final}
      {[@expl:delete_min_rec ensures #6] color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__delete_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec as_mut_Box_Node_K_V_Global'0 (self_: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_ref_K_ref_K = { f0: t_K; f1: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0'0: t_Tree_K_V; f1'0: t_Tree_K_V; f2'0: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0'0 = self.final.left; f1'0 = r.left; f2'0 = r.right }
          = { f0'0 = l.left; f1'0 = l.right; f2'0 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  type t_Option_tup2_K_V = None'1 | Some'1 tup2_K_V
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  type t_Option_ref_Box_Node_K_V_Global'0 = None'2 | Some'2 t_Node_K_V
  
  predicate invariant_ref_Option_Box_Node_K_V_Global'0 [@inline:trivial] (self: t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global'0
  
  predicate inv_ref_Option_Box_Node_K_V_Global'0 [@inline:trivial] (_1: t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global'0 _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global'0
  
  predicate invariant_ref_Box_Node_K_V_Global'0 [@inline:trivial] (self: t_Node_K_V) = inv_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global'0
  
  predicate inv_ref_Box_Node_K_V_Global'0 [@inline:trivial] (_1: t_Node_K_V) = invariant_ref_Box_Node_K_V_Global'0 _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global'0
  
  predicate inv_Option_ref_Box_Node_K_V_Global'0 (_1: t_Option_ref_Box_Node_K_V_Global'0)
  
  axiom inv_axiom'3 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global'0 [inv_Option_ref_Box_Node_K_V_Global'0 x]. inv_Option_ref_Box_Node_K_V_Global'0 x
      = match x with
        | None'2 -> true
        | Some'2 f0'2 -> inv_ref_Box_Node_K_V_Global'0 f0'2
        end
  
  let rec as_ref_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global'0)) =
    {[@expl:as_ref 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global'0 self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global'0) -> {inv_Option_ref_Box_Node_K_V_Global'0 result}
      {self_ = None -> result = None'2}
      {self_ = None \/ (exists r: t_Node_K_V. result = Some'2 r /\ self_ = Some r)}
      (! return {result}) ]
  
  type t_Option_Infallible = None'3 | Some'3 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Continue t_Node_K_V | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'3 -> true
        | Some'3 f0'2 -> inv_Infallible f0'2
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'2 -> inv_ref_Box_Node_K_V_Global'0 f0'2
        | Break f0'2 -> inv_Option_Infallible f0'2
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global'0)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global'0 self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'2 v -> result = Continue v
        | None'2 -> result = Break (None'3)
        end}
      (! return {result}) ]
  
  let rec elim_Break (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (ret (f0'2: t_Option_Infallible)) = any
    [ good (f0'2: t_Option_Infallible) -> {Break f0'2 = input} (! ret {f0'2})
    | bad ->
    {forall f0'2: t_Option_Infallible [Break f0'2: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Break f0'2
        <> input}
      (! {false}
      any) ]
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'1 /\ inv_V _1.f1'1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'1 -> true
        | Some'1 f0'2 -> inv_tup2_K_V f0'2
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'1} (! return {result}) ]
  
  let rec elim_Continue (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) (ret (f0'2: t_Node_K_V)) = any
    [ good (f0'2: t_Node_K_V) -> {Continue f0'2 = input} (! ret {f0'2})
    | bad ->
    {forall f0'2: t_Node_K_V [Continue f0'2: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Continue f0'2
        <> input}
      (! {false}
      any) ]
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec move_red_right_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_right requires #0] self.current.left.node <> None}
    {[@expl:move_red_right requires #1] internal_invariant_K self.current}
    {[@expl:move_red_right requires #2] match_n_K (cpn (Red) (CPL (Black)) (cpn (Black) (CPL (Black)) (CPL (Black)))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {result.current.key = self.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy (deep_model_K self.current.key) k -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.left = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  let rec elim_Some (input: t_Option_Box_Node_K_V_Global) (ret (f0'2: t_Node_K_V)) = any
    [ good (f0'2: t_Node_K_V) -> {Some f0'2 = input} (! ret {f0'2})
    | bad -> {forall f0'2: t_Node_K_V [Some f0'2: t_Option_Box_Node_K_V_Global]. Some f0'2 <> input} (! {false} any) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  let rec delete_min_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_min_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_min_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_min_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: tup2_K_V) -> {inv_tup2_K_V result}
      {internal_invariant_K'0 self.final}
      {height_K self.current = height_K self.final}
      {has_mapping_K self.current (deep_model_K result.f0'1) result.f1'1}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy (deep_model_K result.f0'1) k}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'1 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  type t_Option_V = None'4 | Some'4 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'4 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'4))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'4 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'4 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'4 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'4 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'4)) k in has_mapping_model_acc_K self (Const.const (None'4)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'4 v))
  
  function has_mapping_inj_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : () = has_mapping_model_K self k
  
  axiom has_mapping_inj_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy, v1: t_V, v2: t_V. bst_invariant_K self
      -> has_mapping_K self k v1 -> has_mapping_K self k v2 -> v1 = v2
  
  predicate invariant_ref_K'0 [@inline:trivial] (self: MutBorrow.t t_K) = inv_K self.current /\ inv_K self.final
  
  meta "rewrite_def" predicate invariant_ref_K'0
  
  predicate inv_ref_K'0 [@inline:trivial] (_1: MutBorrow.t t_K) = invariant_ref_K'0 _1
  
  meta "rewrite_def" predicate inv_ref_K'0
  
  let rec swap_K (x: MutBorrow.t t_K) (y: MutBorrow.t t_K) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_K'0 x}
    {[@expl:swap 'y' type invariant] inv_ref_K'0 y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_K [@inline:trivial] (_1: MutBorrow.t t_K) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: MutBorrow.t t_V) = inv_V self.current /\ inv_V self.final
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  let rec swap_V (x: MutBorrow.t t_V) (y: MutBorrow.t t_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_V x}
    {[@expl:swap 'y' type invariant] inv_ref_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_V
  
  let rec move_red_left_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_left requires #0] self.current.right.node <> None}
    {[@expl:move_red_left requires #1] internal_invariant_K self.current}
    {[@expl:move_red_left requires #2] match_n_K (cpn (Red) (cpn (Black) (CPL (Black)) (CPL (Black))) (CPL (Black))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {self.current.key = result.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy k (deep_model_K self.current.key) -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.right = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_rec 'key' type invariant] inv_ref_K key'0}
    {[@expl:delete_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_15 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { node = _ret.final } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_15} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_14} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_13 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Box_Node_K_V_Global _13.current}
        MutBorrow.borrow_final <t_Node_K_V> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_12 <- _ret ] -{inv_Box_Node_K_V_Global _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global'0 {_12} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &node'0 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _13} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _13}- s2
      | s2 = [ &_20 <- node'0.current.key ] s3
      | s3 = cmp_K {key'0} {_20} (fun (_ret: t_Ordering) -> [ &_17 <- _ret ] s4)
      | s4 = bb4 ]
    | bb4 = any [ br0 -> {_17 = Less} (! bb13) | br1 -> {_17 = Equal} (! bb12) | br2 -> {_17 = Greater} (! bb12) ]
    | bb12 = s0 [ s0 = is_red_K {node'0.current.left} (fun (_ret: bool) -> [ &_43 <- _ret ] s1) | s1 = bb31 ]
    | bb31 = any [ br0 -> {_43 = false} (! bb7) | br1 -> {_43} (! bb32) ]
    | bb32 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_mut <t_Node_K_V> {node'0.current}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_46 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = rotate_right_K {_46} (fun (_ret: ()) -> [ &_45 <- _ret ] s2)
      | s2 = bb34 ]
    | bb34 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_47 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _ret.final } } ] s1)
      | s1 = delete_rec_K {_47} {key'0} (fun (_ret: t_Option_tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb68 ]
    | bb7 = any [ br0 -> {_17 = Less} (! bb8) | br1 -> {_17 = Equal} (! bb11) | br2 -> {_17 = Greater} (! bb10) ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = {false} any ]
    | bb10 = s0
      [ s0 = as_ref_Box_Node_K_V_Global {node'0.current.right.node}
          (fun (_ret: t_Option_ref_Box_Node_K_V_Global'0) -> [ &_86 <- _ret ] s1)
      | s1 = bb55 ]
    | bb55 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_86}
          (fun (_ret: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_85 <- _ret ] s1)
      | s1 = bb56 ]
    | bb56 = any
      [ br0 (x0: t_Node_K_V) -> {_85 = Continue x0} (! bb59)
      | br1 (x0: t_Option_Infallible) -> {_85 = Break x0} (! bb58) ]
    | bb58 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1 | s1 = -{resolve_ref_Node_K_V node'0}- s2 | s2 = bb60 ]
    | bb60 = s0
      [ s0 = elim_Break {_85} (fun (r0: t_Option_Infallible) -> [ &residual'0 <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s2
      | s2 = -{resolve_ref_Tree_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual'0} (fun (_ret: t_Option_tup2_K_V) -> [ &_0 <- _ret ] s4)
      | s4 = bb73 ]
    | bb59 = s0
      [ s0 = elim_Continue {_85} (fun (r0: t_Node_K_V) -> [ &val''1 <- r0 ] s1)
      | s1 = [ &_84 <- val''1 ] s2
      | s2 = is_red_K {_84.left} (fun (_ret: bool) -> [ &_82 <- _ret ] s3)
      | s3 = bb62 ]
    | bb62 = any [ br0 -> {_82 = false} (! bb64) | br1 -> {_82} (! bb66) ]
    | bb64 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_95 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = move_red_right_K {_95} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_94 <- _ret ] s2)
      | s2 = bb65 ]
    | bb65 = s0
      [ s0 = {inv_Node_K_V _94.current}
        MutBorrow.borrow_final <t_Node_K_V> {_94.current} {MutBorrow.get_id _94}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_93 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_94 <- { _94 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _93 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _94} s5
      | s5 = -{resolve_ref_Node_K_V _94}- s6
      | s6 = bb66 ]
    | bb66 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_96 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _ret.final } } ] s1)
      | s1 = delete_rec_K {_96} {key'0} (fun (_ret: t_Option_tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb68 ]
    | bb11 = s0
      [ s0 = [ &_58 <- node'0.current.right.node ] s1
      | s1 = any [ br0 -> {_58 = None} (! bb43) | br1 (x0: t_Node_K_V) -> {_58 = Some x0} (! bb42) ] ]
    | bb43 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.node}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_53 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { node = _ret.final } } ] s3)
      | s3 = {inv_Option_Box_Node_K_V_Global _53.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_53.current} {MutBorrow.get_id _53}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_52 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &_53 <- { _53 with current = _ret.final } ] s4)
      | s4 = take_Option_Box_Node_K_V_Global {_52} (fun (_ret: t_Option_Box_Node_K_V_Global) -> [ &_51 <- _ret ] s5)
      | s5 = bb36 ]
    | bb36 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _53} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _53}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = unwrap_Box_Node_K_V_Global {_51} (fun (_ret: t_Node_K_V) -> [ &node'1 <- _ret ] s5)
      | s5 = bb37 ]
    | bb37 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V node'1.right} s1
      | s1 = -{resolve_Tree_K_V'0 node'1.right}- s2
      | s2 = {[@expl:type invariant] inv_Tree_K_V node'1.left} s3
      | s3 = -{resolve_Tree_K_V'0 node'1.left}- s4
      | s4 = [ &_54 <- { f0'1 = node'1.key; f1'1 = node'1.val' } ] s5
      | s5 = bb39 ]
    | bb39 = s0 [ s0 = [ &_0 <- Some'1 _54 ] s1 | s1 = bb73 ]
    | bb42 = s0
      [ s0 = elim_Some {_58} (fun (r0: t_Node_K_V) -> [ &right'0 <- r0 ] s1)
      | s1 = is_red_K {right'0.left} (fun (_ret: bool) -> [ &_61 <- _ret ] s2)
      | s2 = bb44 ]
    | bb44 = any [ br0 -> {_61 = false} (! bb46) | br1 -> {_61} (! bb48) ]
    | bb46 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_65 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = move_red_right_K {_65} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_64 <- _ret ] s2)
      | s2 = bb47 ]
    | bb47 = s0
      [ s0 = {inv_Node_K_V _64.current}
        MutBorrow.borrow_final <t_Node_K_V> {_64.current} {MutBorrow.get_id _64}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_63 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_64 <- { _64 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _63 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _64} s5
      | s5 = -{resolve_ref_Node_K_V _64}- s6
      | s6 = bb48 ]
    | bb48 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_67 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _ret.final } } ] s1)
      | s1 = delete_min_rec_K {_67} (fun (_ret: tup2_K_V) -> [ &kv <- _ret ] s2)
      | s2 = bb49 ]
    | bb49 = s0 [ s0 = [ &_68 <- () ] s1 | s1 = bb50 ]
    | bb50 = s0
      [ s0 = {inv_K node'0.current.key}
        MutBorrow.borrow_mut <t_K> {node'0.current.key}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_72 <- _ret ] -{inv_K _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with key = _ret.final } } ] s1)
      | s1 = {inv_K kv.f0'1}
        MutBorrow.borrow_mut <t_K> {kv.f0'1}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_74 <- _ret ] -{inv_K _ret.final}-
            [ &kv <- { kv with f0'1 = _ret.final } ] s2)
      | s2 = {inv_K _72.current}
        MutBorrow.borrow_final <t_K> {_72.current} {MutBorrow.get_id _72}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_71 <- _ret ] -{inv_K _ret.final}-
            [ &_72 <- { _72 with current = _ret.final } ] s3)
      | s3 = {inv_K _74.current}
        MutBorrow.borrow_final <t_K> {_74.current} {MutBorrow.get_id _74}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_73 <- _ret ] -{inv_K _ret.final}-
            [ &_74 <- { _74 with current = _ret.final } ] s4)
      | s4 = swap_K {_71} {_73} (fun (_ret: ()) -> [ &_70 <- _ret ] s5)
      | s5 = bb51 ]
    | bb51 = s0
      [ s0 = {[@expl:type invariant] inv_ref_K'0 _74} s1
      | s1 = -{resolve_ref_K _74}- s2
      | s2 = {[@expl:type invariant] inv_ref_K'0 _72} s3
      | s3 = -{resolve_ref_K _72}- s4
      | s4 = {inv_V node'0.current.val'}
        MutBorrow.borrow_mut <t_V> {node'0.current.val'}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_77 <- _ret ] -{inv_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with val' = _ret.final } } ] s5)
      | s5 = {inv_V kv.f1'1}
        MutBorrow.borrow_mut <t_V> {kv.f1'1}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_79 <- _ret ] -{inv_V _ret.final}-
            [ &kv <- { kv with f1'1 = _ret.final } ] s6)
      | s6 = {inv_V _77.current}
        MutBorrow.borrow_final <t_V> {_77.current} {MutBorrow.get_id _77}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_76 <- _ret ] -{inv_V _ret.final}-
            [ &_77 <- { _77 with current = _ret.final } ] s7)
      | s7 = {inv_V _79.current}
        MutBorrow.borrow_final <t_V> {_79.current} {MutBorrow.get_id _79}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_78 <- _ret ] -{inv_V _ret.final}-
            [ &_79 <- { _79 with current = _ret.final } ] s8)
      | s8 = swap_V {_76} {_78} (fun (_ret: ()) -> [ &_75 <- _ret ] s9)
      | s9 = bb52 ]
    | bb52 = s0
      [ s0 = {[@expl:type invariant] inv_ref_V _79} s1
      | s1 = -{resolve_ref_V _79}- s2
      | s2 = {[@expl:type invariant] inv_ref_V _77} s3
      | s3 = -{resolve_ref_V _77}- s4
      | s4 = [ &r <- Some'1 kv ] s5
      | s5 = bb68 ]
    | bb13 = s0 [ s0 = is_red_K {node'0.current.left} (fun (_ret: bool) -> [ &_25 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_25 = false} (! bb16) | br1 -> {_25} (! bb29) ]
    | bb16 = s0
      [ s0 = as_ref_Box_Node_K_V_Global {node'0.current.left.node}
          (fun (_ret: t_Option_ref_Box_Node_K_V_Global'0) -> [ &_31 <- _ret ] s1)
      | s1 = bb17 ]
    | bb17 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_31}
          (fun (_ret: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_30 <- _ret ] s1)
      | s1 = bb18 ]
    | bb18 = any
      [ br0 (x0: t_Node_K_V) -> {_30 = Continue x0} (! bb21)
      | br1 (x0: t_Option_Infallible) -> {_30 = Break x0} (! bb20) ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1 | s1 = -{resolve_ref_Node_K_V node'0}- s2 | s2 = bb22 ]
    | bb22 = s0
      [ s0 = elim_Break {_30} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s2
      | s2 = -{resolve_ref_Tree_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_ret: t_Option_tup2_K_V) -> [ &_0 <- _ret ] s4)
      | s4 = bb73 ]
    | bb21 = s0
      [ s0 = elim_Continue {_30} (fun (r0: t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &_29 <- val''0 ] s2
      | s2 = is_red_K {_29.left} (fun (_ret: bool) -> [ &_27 <- _ret ] s3)
      | s3 = bb24 ]
    | bb24 = any [ br0 -> {_27 = false} (! bb26) | br1 -> {_27} (! bb29) ]
    | bb26 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_40 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = move_red_left_K {_40} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_39 <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = s0
      [ s0 = {inv_Node_K_V _39.current}
        MutBorrow.borrow_final <t_Node_K_V> {_39.current} {MutBorrow.get_id _39}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_38 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &_39 <- { _39 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _38 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _39} s5
      | s5 = -{resolve_ref_Node_K_V _39}- s6
      | s6 = bb29 ]
    | bb29 = s0
      [ s0 = {inv_Tree_K_V node'0.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.left}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_41 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with left = _ret.final } } ] s1)
      | s1 = delete_rec_K {_41} {key'0} (fun (_ret: t_Option_tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb68 ]
    | bb68 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_ret: MutBorrow.t t_Node_K_V) ->
            [ &_99 <- _ret ] -{inv_Node_K_V _ret.final}-
            [ &node'0 <- { node'0 with current = _ret.final } ] s1)
      | s1 = balance_K {_99} (fun (_ret: ()) -> [ &_98 <- _ret ] s2)
      | s2 = bb69 ]
    | bb69 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb73 ]
    | bb73 = return {_0} ]
    [ & _0: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & key'0: t_K = key'0
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _12: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _13: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _14: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _15: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & r: t_Option_tup2_K_V = Any.any_l ()
    | & _17: t_Ordering = Any.any_l ()
    | & _20: t_K = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _27: bool = Any.any_l ()
    | & _29: t_Node_K_V = Any.any_l ()
    | & _30: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _31: t_Option_ref_Box_Node_K_V_Global'0 = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: t_Node_K_V = Any.any_l ()
    | & _38: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _39: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _40: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _41: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _43: bool = Any.any_l ()
    | & _45: () = Any.any_l ()
    | & _46: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _47: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & node'1: t_Node_K_V = Any.any_l ()
    | & _51: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _52: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _53: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _54: tup2_K_V = Any.any_l ()
    | & right'0: t_Node_K_V = Any.any_l ()
    | & _58: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _61: bool = Any.any_l ()
    | & _63: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _64: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _65: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & kv: tup2_K_V = Any.any_l ()
    | & _67: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _68: () = Any.any_l ()
    | & _70: () = Any.any_l ()
    | & _71: MutBorrow.t t_K = Any.any_l ()
    | & _72: MutBorrow.t t_K = Any.any_l ()
    | & _73: MutBorrow.t t_K = Any.any_l ()
    | & _74: MutBorrow.t t_K = Any.any_l ()
    | & _75: () = Any.any_l ()
    | & _76: MutBorrow.t t_V = Any.any_l ()
    | & _77: MutBorrow.t t_V = Any.any_l ()
    | & _78: MutBorrow.t t_V = Any.any_l ()
    | & _79: MutBorrow.t t_V = Any.any_l ()
    | & _82: bool = Any.any_l ()
    | & _84: t_Node_K_V = Any.any_l ()
    | & _85: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _86: t_Option_ref_Box_Node_K_V_Global'0 = Any.any_l ()
    | & residual'0: t_Option_Infallible = Any.any_l ()
    | & val''1: t_Node_K_V = Any.any_l ()
    | & _93: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _94: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _95: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _96: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _98: () = Any.any_l ()
    | & _99: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete_rec result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:delete_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:delete_rec ensures #2] match result with
        | None'1 -> forall v: t_V. not has_mapping_K self.current (deep_model_ref_K key'0) v
        | Some'1 {f0'1 = k; f1'1 = v} -> deep_model_ref_K key'0 = deep_model_K k
        /\ has_mapping_K self.current (deep_model_K k) v
        end}
      {[@expl:delete_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_ref_K key'0 <> k /\ has_mapping_K self.current k v)}
      {[@expl:delete_rec ensures #4] color_invariant_K self.final}
      {[@expl:delete_rec ensures #5] color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
end
module M_impl_Resolve_for_Map_K_V__resolve_coherence (* <Map<K, V> as creusot_contracts::resolve::Resolve> *)
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Map_K_V (_1: t_Map_K_V) = resolve_Tree_K_V'0 _1.f0
  
  type t_Option_V = None'0 | Some'0 t_V
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom'2 [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_V x0
        end
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  predicate resolve_Map_K_V (self: t_Map_K_V) =
    forall k: t_DeepModelTy. resolve_Option_V (Map.get (view_Map_K_V self) k)
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map_K_V
  
  function resolve_coherence_Map_K_V (self: t_Map_K_V) : ()
  
  goal vc_resolve_coherence_Map_K_V: structural_resolve_Map_K_V self
    -> ([@expl:resolve_coherence ensures] resolve_Map_K_V self)
end
module M_impl_Map_K_V__new (* Map<K, V> *)
  use creusot.prelude.Any
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_K (return (x: t_Map_K_V)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- None ] s1 | s1 = [ &_2 <- { node = _3 } ] s2 | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { f0 = _2 } ] s1 | s1 = bb2 ]
    | bb2 = return {_0} ]
    [ & _0: t_Map_K_V = Any.any_l ()
    | & _2: t_Tree_K_V = Any.any_l ()
    | & _3: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: t_Map_K_V) -> {[@expl:new result type invariant] inv_Map_K_V result}
      {[@expl:new ensures] view_Map_K_V result = Const.const (None'0)}
      (! return {result}) ]
end
module M_impl_Map_K_V__insert (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec insert_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (val''0: t_V) (return (x: ())) =
    {[@expl:insert_rec 'self' type invariant] inv_ref_Tree_K_V self}
    {[@expl:insert_rec 'key' type invariant] inv_K key'0}
    {[@expl:insert_rec 'val' type invariant] inv_V val''0}
    {[@expl:insert_rec requires #0] internal_invariant_K self.current}
    {[@expl:insert_rec requires #1] color_invariant_K self.current}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {match_t_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final /\ color_K self.current = Red
      \/ color_invariant_K self.final}
      {has_mapping_K self.final (deep_model_K key'0) val''0}
      {forall k: t_DeepModelTy, v: t_V. k = deep_model_K key'0
        \/ has_mapping_K self.current k v = has_mapping_K self.final k v}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'1 | Some'1 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_K (self: MutBorrow.t t_Map_K_V) (key'0: t_K) (val''0: t_V) (return (x: ())) =
    {[@expl:insert 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:insert 'key' type invariant] inv_K key'0}
    {[@expl:insert 'val' type invariant] inv_V val''0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_8 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &self <- { self with current = { f0 = _ret.final } } ] s1)
      | s1 = insert_rec_K {_8} {key'0} {val''0} (fun (_ret: ()) -> [ &_7 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_11 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_14 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { f0 = { node = _ret.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_14} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_13 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_13} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_12 <- _ret ] s1)
      | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_12 <- { _12 with current = { _12.current with color = _11 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _12} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _12}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & key'0: t_K = key'0
    | & val''0: t_V = val''0
    | & _5: () = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _8: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _11: t_Color = Any.any_l ()
    | & _12: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _13: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _14: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:insert ensures] view_Map_K_V self.final
      = Map.set (view_Map_K_V self.current) (deep_model_K key'0) (Some'0 val''0)}
      (! return {result}) ]
end
module M_impl_Map_K_V__delete_max (* Map<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  type t_Option_Infallible = None'1 | Some'1 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global =
    | Continue (MutBorrow.t t_Node_K_V)
    | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_Infallible f0'0
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        | Break f0'0 -> inv_Option_Infallible f0'0
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'0 v -> result = Continue v
        | None'0 -> result = Break (None'1)
        end}
      (! return {result}) ]
  
  let rec elim_Break (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (ret (f0'0: t_Option_Infallible)) = any
    [ good (f0'0: t_Option_Infallible) -> {Break f0'0 = input} (! ret {f0'0})
    | bad ->
    {forall f0'0: t_Option_Infallible [Break f0'0: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Break f0'0
        <> input}
      (! {false}
      any) ]
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  type t_Option_tup2_K_V = None'2 | Some'2 tup2_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'2 -> true
        | Some'2 f0'1 -> inv_tup2_K_V f0'1
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'2} (! return {result}) ]
  
  let rec elim_Continue (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (ret (f0'1: MutBorrow.t t_Node_K_V)) = any
    [ good (f0'1: MutBorrow.t t_Node_K_V) -> {Continue f0'1 = input} (! ret {f0'1})
    | bad ->
    {forall f0'1: MutBorrow.t t_Node_K_V [Continue f0'1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Continue f0'1
        <> input}
      (! {false}
      any) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec delete_max_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_max_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_max_rec requires #0] internal_invariant_K self.current}
    {[@expl:delete_max_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: tup2_K_V) -> {inv_tup2_K_V result}
      {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {has_mapping_K self.current (deep_model_K result.f0'0) result.f1'0}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy k (deep_model_K result.f0'0)}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'0 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  type t_Option_V = None'3 | Some'3 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'3 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'3))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'3 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'3 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'3 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'3 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'3)) k in has_mapping_model_acc_K self (Const.const (None'3)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'3 v))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max_K (self: MutBorrow.t t_Map_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_max 'self' type invariant] inv_ref_Map_K_V self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_6 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { f0 = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_6} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_5 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_5}
          (fun (_ret: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_4 <- _ret ] s1)
      | s1 = bb2 ]
    | bb2 = any
      [ br0 (x0: MutBorrow.t t_Node_K_V) -> {_4 = Continue x0} (! bb5)
      | br1 (x0: t_Option_Infallible) -> {_4 = Break x0} (! bb6) ]
    | bb6 = s0
      [ s0 = elim_Break {_4} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Map_K_V self} s2
      | s2 = -{resolve_ref_Map_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_ret: t_Option_tup2_K_V) -> [ &_0 <- _ret ] s4)
      | s4 = bb22 ]
    | bb5 = s0
      [ s0 = elim_Continue {_4} (fun (r0: MutBorrow.t t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &node'0 <- val''0 ] s2
      | s2 = is_red_K {node'0.current.left} (fun (_ret: bool) -> [ &_13 <- _ret ] s3)
      | s3 = bb8 ]
    | bb8 = any [ br0 -> {_13 = false} (! bb10) | br1 -> {_13} (! bb9) ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = bb11 ]
    | bb10 = s0
      [ s0 = [ &_15 <- Red ] s1
      | s1 = [ &node'0 <- { node'0 with current = { node'0.current with color = _15 } } ] s2
      | s2 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s3
      | s3 = -{resolve_ref_Box_Node_K_V_Global node'0}- s4
      | s4 = bb11 ]
    | bb11 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_17 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &self <- { self with current = { f0 = _ret.final } } ] s1)
      | s1 = delete_max_rec_K {_17} (fun (_ret: tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb12 ]
    | bb12 = s0 [ s0 = is_red_K {self.current.f0} (fun (_ret: bool) -> [ &_19 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = any [ br0 -> {_19 = false} (! bb17) | br1 -> {_19} (! bb14) ]
    | bb14 = s0
      [ s0 = [ &_21 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_24 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { f0 = { node = _ret.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_24} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_23 <- _ret ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_23} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_22 <- _ret ] s1)
      | s1 = bb16 ]
    | bb16 = s0
      [ s0 = [ &_22 <- { _22 with current = { _22.current with color = _21 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _22} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _22}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb18 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Map_K_V self} s1 | s1 = -{resolve_ref_Map_K_V self}- s2 | s2 = bb18 ]
    | bb18 = s0 [ s0 = [ &_25 <- () ] s1 | s1 = bb19 ]
    | bb19 = s0 [ s0 = [ &_0 <- Some'2 r ] s1 | s1 = bb22 ]
    | bb22 = return {_0} ]
    [ & _0: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _4: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _5: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _6: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Color = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _17: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Color = Any.any_l ()
    | & _22: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _23: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _24: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _25: () = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete_max result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete_max ensures] match result with
        | Some'2 {f0'0 = k; f1'0 = v} -> Map.get (view_Map_K_V self.current) (deep_model_K k) = Some'3 v
        /\ (forall k2: t_DeepModelTy. Map.get (view_Map_K_V self.current) k2 = None'3
            \/ le_log_DeepModelTy k2 (deep_model_K k))
        /\ view_Map_K_V self.final = Map.set (view_Map_K_V self.current) (deep_model_K k) (None'3)
        | None'2 -> view_Map_K_V self.final = view_Map_K_V self.current
        /\ view_Map_K_V self.current = Const.const (None'3)
        end}
      (! return {result}) ]
end
module M_impl_Map_K_V__delete_min (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'1 | Some'1 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  type t_Option_Infallible = None'2 | Some'2 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global =
    | Continue (MutBorrow.t t_Node_K_V)
    | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'2 -> true
        | Some'2 f0'0 -> inv_Infallible f0'0
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        | Break f0'0 -> inv_Option_Infallible f0'0
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'1 v -> result = Continue v
        | None'1 -> result = Break (None'2)
        end}
      (! return {result}) ]
  
  let rec elim_Break (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (ret (f0'0: t_Option_Infallible)) = any
    [ good (f0'0: t_Option_Infallible) -> {Break f0'0 = input} (! ret {f0'0})
    | bad ->
    {forall f0'0: t_Option_Infallible [Break f0'0: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Break f0'0
        <> input}
      (! {false}
      any) ]
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  type t_Option_tup2_K_V = None'3 | Some'3 tup2_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'3 -> true
        | Some'3 f0'1 -> inv_tup2_K_V f0'1
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'3} (! return {result}) ]
  
  let rec elim_Continue (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (ret (f0'1: MutBorrow.t t_Node_K_V)) = any
    [ good (f0'1: MutBorrow.t t_Node_K_V) -> {Continue f0'1 = input} (! ret {f0'1})
    | bad ->
    {forall f0'1: MutBorrow.t t_Node_K_V [Continue f0'1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Continue f0'1
        <> input}
      (! {false}
      any) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec delete_min_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_min_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_min_rec requires #0] internal_invariant_K self.current}
    {[@expl:delete_min_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: tup2_K_V) -> {inv_tup2_K_V result}
      {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {has_mapping_K self.current (deep_model_K result.f0'0) result.f1'0}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy (deep_model_K result.f0'0) k}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'0 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min_K (self: MutBorrow.t t_Map_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_min 'self' type invariant] inv_ref_Map_K_V self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_8 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { f0 = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_8} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_7 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_7}
          (fun (_ret: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_6 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = any
      [ br0 (x0: MutBorrow.t t_Node_K_V) -> {_6 = Continue x0} (! bb6)
      | br1 (x0: t_Option_Infallible) -> {_6 = Break x0} (! bb7) ]
    | bb7 = s0
      [ s0 = elim_Break {_6} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Map_K_V self} s2
      | s2 = -{resolve_ref_Map_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_ret: t_Option_tup2_K_V) -> [ &_0 <- _ret ] s4)
      | s4 = bb22 ]
    | bb6 = s0
      [ s0 = elim_Continue {_6} (fun (r0: MutBorrow.t t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &node'0 <- val''0 ] s2
      | s2 = is_red_K {node'0.current.left} (fun (_ret: bool) -> [ &_15 <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = any [ br0 -> {_15 = false} (! bb11) | br1 -> {_15} (! bb10) ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = bb12 ]
    | bb11 = s0
      [ s0 = [ &_17 <- Red ] s1
      | s1 = [ &node'0 <- { node'0 with current = { node'0.current with color = _17 } } ] s2
      | s2 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s3
      | s3 = -{resolve_ref_Box_Node_K_V_Global node'0}- s4
      | s4 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_19 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &self <- { self with current = { f0 = _ret.final } } ] s1)
      | s1 = delete_min_rec_K {_19} (fun (_ret: tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0 [ s0 = is_red_K {self.current.f0} (fun (_ret: bool) -> [ &_21 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_21 = false} (! bb18) | br1 -> {_21} (! bb15) ]
    | bb15 = s0
      [ s0 = [ &_23 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_26 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { f0 = { node = _ret.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_26} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_25 <- _ret ] s3)
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_25} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_24 <- _ret ] s1)
      | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_24 <- { _24 with current = { _24.current with color = _23 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _24} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _24}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb19 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Map_K_V self} s1 | s1 = -{resolve_ref_Map_K_V self}- s2 | s2 = bb19 ]
    | bb19 = s0 [ s0 = [ &_0 <- Some'3 r ] s1 | s1 = bb22 ]
    | bb22 = return {_0} ]
    [ & _0: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & _3: () = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _6: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _7: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _8: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _17: t_Color = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _19: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: t_Color = Any.any_l ()
    | & _24: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _25: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _26: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete_min result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete_min ensures] match result with
        | Some'3 {f0'0 = k; f1'0 = v} -> Map.get (view_Map_K_V self.current) (deep_model_K k) = Some'0 v
        /\ (forall k2: t_DeepModelTy. Map.get (view_Map_K_V self.current) k2 = None'0
            \/ le_log_DeepModelTy (deep_model_K k) k2)
        /\ view_Map_K_V self.final = Map.set (view_Map_K_V self.current) (deep_model_K k) (None'0)
        | None'3 -> view_Map_K_V self.final = view_Map_K_V self.current
        /\ view_Map_K_V self.current = Const.const (None'0)
        end}
      (! return {result}) ]
end
module M_impl_Map_K_V__delete (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'1 | Some'1 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  type t_Option_Infallible = None'2 | Some'2 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global =
    | Continue (MutBorrow.t t_Node_K_V)
    | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'2 -> true
        | Some'2 f0'0 -> inv_Infallible f0'0
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        | Break f0'0 -> inv_Option_Infallible f0'0
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'1 v -> result = Continue v
        | None'1 -> result = Break (None'2)
        end}
      (! return {result}) ]
  
  let rec elim_Break (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (ret (f0'0: t_Option_Infallible)) = any
    [ good (f0'0: t_Option_Infallible) -> {Break f0'0 = input} (! ret {f0'0})
    | bad ->
    {forall f0'0: t_Option_Infallible [Break f0'0: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Break f0'0
        <> input}
      (! {false}
      any) ]
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  type t_Option_tup2_K_V = None'3 | Some'3 tup2_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'3 -> true
        | Some'3 f0'1 -> inv_tup2_K_V f0'1
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'3} (! return {result}) ]
  
  let rec elim_Continue (input: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (ret (f0'1: MutBorrow.t t_Node_K_V)) = any
    [ good (f0'1: MutBorrow.t t_Node_K_V) -> {Continue f0'1 = input} (! ret {f0'1})
    | bad ->
    {forall f0'1: MutBorrow.t t_Node_K_V [Continue f0'1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global]. Continue f0'1
        <> input}
      (! {false}
      any) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  let rec delete_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_rec 'key' type invariant] inv_ref_K key'0}
    {[@expl:delete_rec requires #0] internal_invariant_K self.current}
    {[@expl:delete_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result}
      {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {match result with
        | None'3 -> forall v: t_V. not has_mapping_K self.current (deep_model_ref_K key'0) v
        | Some'3 {f0'0 = k; f1'0 = v} -> deep_model_ref_K key'0 = deep_model_K k
        /\ has_mapping_K self.current (deep_model_K k) v
        end}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_ref_K key'0 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_K (self: MutBorrow.t t_Map_K_V) (key'0: t_K) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:delete 'key' type invariant] inv_ref_K key'0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_10 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { f0 = { node = _ret.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_10} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_9 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_9}
          (fun (_ret: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_8 <- _ret ] s1)
      | s1 = bb3 ]
    | bb3 = any
      [ br0 (x0: MutBorrow.t t_Node_K_V) -> {_8 = Continue x0} (! bb6)
      | br1 (x0: t_Option_Infallible) -> {_8 = Break x0} (! bb7) ]
    | bb7 = s0
      [ s0 = elim_Break {_8} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Map_K_V self} s2
      | s2 = -{resolve_ref_Map_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_ret: t_Option_tup2_K_V) -> [ &_0 <- _ret ] s4)
      | s4 = bb21 ]
    | bb6 = s0
      [ s0 = elim_Continue {_8} (fun (r0: MutBorrow.t t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &node'0 <- val''0 ] s2
      | s2 = is_red_K {node'0.current.left} (fun (_ret: bool) -> [ &_17 <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = any [ br0 -> {_17 = false} (! bb11) | br1 -> {_17} (! bb10) ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = bb12 ]
    | bb11 = s0
      [ s0 = [ &_19 <- Red ] s1
      | s1 = [ &node'0 <- { node'0 with current = { node'0.current with color = _19 } } ] s2
      | s2 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s3
      | s3 = -{resolve_ref_Box_Node_K_V_Global node'0}- s4
      | s4 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &_21 <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &self <- { self with current = { f0 = _ret.final } } ] s1)
      | s1 = delete_rec_K {_21} {key'0} (fun (_ret: t_Option_tup2_K_V) -> [ &r <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0 [ s0 = is_red_K {self.current.f0} (fun (_ret: bool) -> [ &_24 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_24 = false} (! bb18) | br1 -> {_24} (! bb15) ]
    | bb15 = s0
      [ s0 = [ &_26 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_29 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
            [ &self <- { self with current = { f0 = { node = _ret.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_29} (fun (_ret: t_Option_ref_Box_Node_K_V_Global) -> [ &_28 <- _ret ] s3)
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_28} (fun (_ret: MutBorrow.t t_Node_K_V) -> [ &_27 <- _ret ] s1)
      | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_27 <- { _27 with current = { _27.current with color = _26 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _27} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _27}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb19 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Map_K_V self} s1 | s1 = -{resolve_ref_Map_K_V self}- s2 | s2 = bb19 ]
    | bb19 = s0 [ s0 = [ &_0 <- r ] s1 | s1 = bb21 ]
    | bb21 = return {_0} ]
    [ & _0: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & key'0: t_K = key'0
    | & _5: () = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _8: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _9: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _10: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: t_Color = Any.any_l ()
    | & r: t_Option_tup2_K_V = Any.any_l ()
    | & _21: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Color = Any.any_l ()
    | & _27: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _28: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _29: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete ensures #0] match result with
        | Some'3 {f0'0 = k; f1'0 = v} -> deep_model_K k = deep_model_ref_K key'0
        /\ Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = Some'0 v
        | None'3 -> Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = None'0
        end}
      {[@expl:delete ensures #1] view_Map_K_V self.final
      = Map.set (view_Map_K_V self.current) (deep_model_ref_K key'0) (None'0)}
      (! return {result}) ]
end
module M_impl_Map_K_V__get (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec elim_Some (input: t_Option_Box_Node_K_V_Global) (ret (f0'0: t_Node_K_V)) = any
    [ good (f0'0: t_Node_K_V) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Node_K_V [Some f0'0: t_Option_Box_Node_K_V_Global]. Some f0'0 <> input} (! {false} any) ]
  
  type tup2_ref_K_ref_K = { f0'0: t_K; f1'0: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0'0 = self_; f1'0 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0'0 = self_; f1'0 = rhs } result}
      (! return {result}) ]
  
  type t_Option_ref_V = None'1 | Some'1 t_V
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: t_Map_K_V) = inv_Map_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_ref_V f0'1
        end
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_K (self: t_Map_K_V) (key'0: t_K) (return (x: t_Option_ref_V)) =
    {[@expl:get 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:get 'key' type invariant] inv_ref_K key'0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &tree <- self.f0 ] s1 | s1 = bb2 ]
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant #0] inv_ref_Tree_K_V tree}
        {[@expl:loop invariant #1] bst_invariant_K tree}
        {[@expl:loop invariant #2] forall v: t_V. has_mapping_K self.f0 (deep_model_ref_K key'0) v
          = has_mapping_K tree (deep_model_ref_K key'0) v}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_14 <- tree.node ] s1
          | s1 = any [ br0 -> {_14 = None} (! bb14) | br1 (x0: t_Node_K_V) -> {_14 = Some x0} (! bb5) ] ]
        | bb5 = s0
          [ s0 = elim_Some {_14} (fun (r0: t_Node_K_V) -> [ &node'0 <- r0 ] s1)
          | s1 = [ &_20 <- node'0.key ] s2
          | s2 = cmp_K {key'0} {_20} (fun (_ret: t_Ordering) -> [ &_17 <- _ret ] s3)
          | s3 = bb6 ]
        | bb6 = any [ br0 -> {_17 = Less} (! bb12) | br1 -> {_17 = Equal} (! bb11) | br2 -> {_17 = Greater} (! bb10) ]
        | bb10 = s0 [ s0 = [ &_28 <- node'0.right ] s1 | s1 = [ &tree <- _28 ] s2 | s2 = bb2 ]
        | bb12 = s0 [ s0 = [ &_23 <- node'0.left ] s1 | s1 = [ &tree <- _23 ] s2 | s2 = bb2 ] ] ]
    | bb14 = s0 [ s0 = [ &_0 <- None'1 ] s1 | s1 = bb15 ]
    | bb11 = s0 [ s0 = [ &_26 <- node'0.val' ] s1 | s1 = [ &_0 <- Some'1 _26 ] s2 | s2 = bb15 ]
    | bb15 = return {_0} ]
    [ & _0: t_Option_ref_V = Any.any_l ()
    | & self: t_Map_K_V = self
    | & key'0: t_K = key'0
    | & _5: () = Any.any_l ()
    | & tree: t_Tree_K_V = Any.any_l ()
    | & _14: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & node'0: t_Node_K_V = Any.any_l ()
    | & _17: t_Ordering = Any.any_l ()
    | & _20: t_K = Any.any_l ()
    | & _23: t_Tree_K_V = Any.any_l ()
    | & _26: t_V = Any.any_l ()
    | & _28: t_Tree_K_V = Any.any_l () ])
    [ return (result: t_Option_ref_V) -> {[@expl:get result type invariant] inv_Option_ref_V result}
      {[@expl:get ensures] match result with
        | Some'1 v -> Map.get (view_Map_K_V self) (deep_model_ref_K key'0) = Some'0 v
        | None'1 -> Map.get (view_Map_K_V self) (deep_model_ref_K key'0) = None'0
        end}
      (! return {result}) ]
end
module M_impl_Map_K_V__get_mut (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec elim_Some (input: t_Option_Box_Node_K_V_Global) (ret (f0'0: t_Node_K_V)) = any
    [ good (f0'0: t_Node_K_V) -> {Some f0'0 = input} (! ret {f0'0})
    | bad -> {forall f0'0: t_Node_K_V [Some f0'0: t_Option_Box_Node_K_V_Global]. Some f0'0 <> input} (! {false} any) ]
  
  type tup2_ref_K_ref_K = { f0'0: t_K; f1'0: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0'0 = self_; f1'0 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0'0 = self_; f1'0 = rhs } result}
      (! return {result}) ]
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  type t_Option_ref_V = None'1 | Some'1 (MutBorrow.t t_V)
  
  predicate invariant_ref_V [@inline:trivial] (self: MutBorrow.t t_V) = inv_V self.current /\ inv_V self.final
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate resolve_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_V
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_ref_V f0'1
        end
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_mut_K (self: MutBorrow.t t_Map_K_V) (key'0: t_K) (return (x: t_Option_ref_V)) =
    {[@expl:get_mut 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:get_mut 'key' type invariant] inv_ref_K key'0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_final <t_Tree_K_V> {self.current.f0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Tree_K_V) ->
            [ &tree <- _ret ] -{inv_Tree_K_V _ret.final}-
            [ &self <- { self with current = { f0 = _ret.final } } ] s1)
      | s1 = [ &old_tree <- tree ] s2
      | s2 = bb3 ]
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant #0] inv_ref_Tree_K_V tree}
        {[@expl:loop invariant #1] bst_invariant_K tree.current}
        {[@expl:loop invariant #2] height_invariant_K tree.current}
        {[@expl:loop invariant #3] color_invariant_K tree.current}
        {[@expl:loop invariant #4] forall v: t_V. has_mapping_K tree.final (deep_model_ref_K key'0) v
          = has_mapping_K old_tree.final (deep_model_ref_K key'0) v}
        {[@expl:loop invariant #5] forall v: t_V. has_mapping_K tree.current (deep_model_ref_K key'0) v
          = has_mapping_K old_tree.current (deep_model_ref_K key'0) v}
        {[@expl:loop invariant #6] (forall k: t_DeepModelTy, v: t_V. k = deep_model_ref_K key'0
            \/ has_mapping_K tree.current k v = has_mapping_K tree.final k v)
        -> bst_invariant_K tree.final -> bst_invariant_K old_tree.final}
        {[@expl:loop invariant #7] height_K tree.current = height_K tree.final /\ height_invariant_K tree.final
        -> height_invariant_K old_tree.final}
        {[@expl:loop invariant #8] match_t_K (CPL (color_K tree.current)) tree.final
        -> match_t_K (CPL (Black)) old_tree.final}
        {[@expl:loop invariant #9] forall k: t_DeepModelTy, v: t_V. has_mapping_K tree.current k v
            = has_mapping_K tree.final k v -> has_mapping_K old_tree.current k v = has_mapping_K old_tree.final k v}
        (! s0)
        [ s0 = bb4 ]
        [ bb4 = s0
          [ s0 = {inv_Option_Box_Node_K_V_Global tree.current.node}
            MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {tree.current.node}
              {MutBorrow.inherit_id (MutBorrow.get_id tree) 1}
              (fun (_ret: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
                [ &_23 <- _ret ] -{inv_Option_Box_Node_K_V_Global _ret.final}-
                [ &tree <- { tree with current = { node = _ret.final } } ] s1)
          | s1 = any
            [ br0 -> {_23.current = None} (! bb15) | br1 (x0: t_Node_K_V) -> {_23.current = Some x0} (! bb6) ] ]
        | bb6 = s0
          [ s0 = elim_Some {_23.current}
              (fun (r0: t_Node_K_V) ->
                {inv_Box_Node_K_V_Global r0}
                MutBorrow.borrow_final <t_Node_K_V> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _23) 1}
                  (fun (_ret: MutBorrow.t t_Node_K_V) ->
                    [ &node'0 <- _ret ] -{inv_Box_Node_K_V_Global _ret.final}-
                    [ &_23 <- { _23 with current = Some _ret.final } ] s1))
          | s1 = [ &_29 <- node'0.current.key ] s2
          | s2 = cmp_K {key'0} {_29} (fun (_ret: t_Ordering) -> [ &_26 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = any [ br0 -> {_26 = Less} (! bb13) | br1 -> {_26 = Equal} (! bb12) | br2 -> {_26 = Greater} (! bb11) ]
        | bb11 = s0
          [ s0 = {inv_Tree_K_V node'0.current.right}
            MutBorrow.borrow_final <t_Tree_K_V> {node'0.current.right}
              {MutBorrow.inherit_id (MutBorrow.get_id node'0) 5}
              (fun (_ret: MutBorrow.t t_Tree_K_V) ->
                [ &_37 <- _ret ] -{inv_Tree_K_V _ret.final}-
                [ &node'0 <- { node'0 with current = { node'0.current with right = _ret.final } } ] s1)
          | s1 = {inv_Tree_K_V _37.current}
            MutBorrow.borrow_final <t_Tree_K_V> {_37.current} {MutBorrow.get_id _37}
              (fun (_ret: MutBorrow.t t_Tree_K_V) ->
                [ &_36 <- _ret ] -{inv_Tree_K_V _ret.final}-
                [ &_37 <- { _37 with current = _ret.final } ] s2)
          | s2 = {[@expl:type invariant] inv_ref_Tree_K_V tree} s3
          | s3 = -{resolve_ref_Tree_K_V tree}- s4
          | s4 = [ &tree <- _36 ] s5
          | s5 = {[@expl:type invariant] inv_ref_Tree_K_V _37} s6
          | s6 = -{resolve_ref_Tree_K_V _37}- s7
          | s7 = bb14 ]
        | bb13 = s0
          [ s0 = {inv_Tree_K_V node'0.current.left}
            MutBorrow.borrow_final <t_Tree_K_V> {node'0.current.left} {MutBorrow.inherit_id (MutBorrow.get_id node'0) 1}
              (fun (_ret: MutBorrow.t t_Tree_K_V) ->
                [ &_32 <- _ret ] -{inv_Tree_K_V _ret.final}-
                [ &node'0 <- { node'0 with current = { node'0.current with left = _ret.final } } ] s1)
          | s1 = {inv_Tree_K_V _32.current}
            MutBorrow.borrow_final <t_Tree_K_V> {_32.current} {MutBorrow.get_id _32}
              (fun (_ret: MutBorrow.t t_Tree_K_V) ->
                [ &_31 <- _ret ] -{inv_Tree_K_V _ret.final}-
                [ &_32 <- { _32 with current = _ret.final } ] s2)
          | s2 = {[@expl:type invariant] inv_ref_Tree_K_V tree} s3
          | s3 = -{resolve_ref_Tree_K_V tree}- s4
          | s4 = [ &tree <- _31 ] s5
          | s5 = {[@expl:type invariant] inv_ref_Tree_K_V _32} s6
          | s6 = -{resolve_ref_Tree_K_V _32}- s7
          | s7 = bb14 ]
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
          | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
          | s2 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _23} s3
          | s3 = -{resolve_ref_Option_Box_Node_K_V_Global _23}- s4
          | s4 = bb3 ] ] ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _23} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _23}- s2
      | s2 = [ &_0 <- None'1 ] s3
      | s3 = bb16 ]
    | bb12 = s0
      [ s0 = {inv_V node'0.current.val'}
        MutBorrow.borrow_final <t_V> {node'0.current.val'} {MutBorrow.inherit_id (MutBorrow.get_id node'0) 4}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_35 <- _ret ] -{inv_V _ret.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with val' = _ret.final } } ] s1)
      | s1 = {inv_V _35.current}
        MutBorrow.borrow_final <t_V> {_35.current} {MutBorrow.get_id _35}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_34 <- _ret ] -{inv_V _ret.final}-
            [ &_35 <- { _35 with current = _ret.final } ] s2)
      | s2 = [ &_0 <- Some'1 _34 ] s3
      | s3 = {[@expl:type invariant] inv_ref_V _35} s4
      | s4 = -{resolve_ref_V _35}- s5
      | s5 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s6
      | s6 = -{resolve_ref_Box_Node_K_V_Global node'0}- s7
      | s7 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _23} s8
      | s8 = -{resolve_ref_Option_Box_Node_K_V_Global _23}- s9
      | s9 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Tree_K_V tree} s1
      | s1 = -{resolve_ref_Tree_K_V tree}- s2
      | s2 = {[@expl:type invariant] inv_ref_Map_K_V self} s3
      | s3 = -{resolve_ref_Map_K_V self}- s4
      | s4 = return {_0} ] ]
    [ & _0: t_Option_ref_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & key'0: t_K = key'0
    | & _5: () = Any.any_l ()
    | & tree: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & old_tree: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _23: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _26: t_Ordering = Any.any_l ()
    | & _29: t_K = Any.any_l ()
    | & _31: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _32: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _34: MutBorrow.t t_V = Any.any_l ()
    | & _35: MutBorrow.t t_V = Any.any_l ()
    | & _36: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _37: MutBorrow.t t_Tree_K_V = Any.any_l () ])
    [ return (result: t_Option_ref_V) -> {[@expl:get_mut result type invariant] inv_Option_ref_V result}
      {[@expl:get_mut ensures] match result with
        | Some'1 v -> Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = Some'0 (v.current)
        /\ view_Map_K_V self.final = Map.set (view_Map_K_V self.current) (deep_model_ref_K key'0) (Some'0 (v.final))
        | None'1 -> Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = None'0
        /\ view_Map_K_V self.final = view_Map_K_V self.current
        end}
      (! return {result}) ]
end
module M_impl_Resolve_for_Tree_K_V__resolve_coherence__refines (* <Tree<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  axiom resolve_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  predicate structural_resolve_Tree_K_V (_1: t_Tree_K_V) = resolve_Option_Box_Node_K_V_Global _1.node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Tree_K_V. inv_Tree_K_V self /\ structural_resolve_Tree_K_V self
      -> structural_resolve_Tree_K_V self /\ (forall result: (). resolve_Tree_K_V self -> resolve_Tree_K_V self)
end
module M_impl_Resolve_for_Node_K_V__resolve_coherence__refines (* <Node<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Node_K_V (_1: t_Node_K_V) =
    resolve_Tree_K_V'0 _1.left /\ resolve_K _1.key /\ resolve_V _1.val' /\ resolve_Tree_K_V'0 _1.right
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Node_K_V. inv_Node_K_V self /\ structural_resolve_Node_K_V self
      -> structural_resolve_Node_K_V self /\ (forall result: (). resolve_Node_K_V self -> resolve_Node_K_V self)
end
module M_impl_Resolve_for_Map_K_V__resolve_coherence__refines (* <Map<K, V> as creusot_contracts::resolve::Resolve> *)
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Map_K_V (_1: t_Map_K_V) = resolve_Tree_K_V'0 _1.f0
  
  type t_Option_V = None'0 | Some'0 t_V
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom'2 [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_V x0
        end
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  predicate resolve_Map_K_V (self: t_Map_K_V) =
    forall k: t_DeepModelTy. resolve_Option_V (Map.get (view_Map_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map_K_V. inv_Map_K_V self /\ structural_resolve_Map_K_V self
      -> structural_resolve_Map_K_V self /\ (forall result: (). resolve_Map_K_V self -> resolve_Map_K_V self)
end
