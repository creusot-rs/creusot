module M_red_black_tree__qyi11959472507597060150__clone [#"red_black_tree.rs" 13 9 13 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree = "red_black_tree.rs" 13 9 13 14
  
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type tuple  =
    { _p0: t_Color; _p1: t_Color }
  
  meta "compute_max_steps" 1000000
  
  let rec clone'[#"red_black_tree.rs" 13 9 13 14] (self:t_Color) (return'  (x:t_Color))= (! bb0
    [ bb0 = any [ br0 -> {self'0 = C_Red} (! bb2) | br1 -> {self'0 = C_Black} (! bb3) ] 
    | bb3 = s0 [ s0 =  [ &_0 <- C_Black ] s1 | s1 = bb5 ] 
    | bb2 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- C_Red ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: t_Color = Any.any_l () | & self'0: t_Color = self ] 
    [ return''0 (result:t_Color)-> {[@expl:clone ensures] [%#sred_black_tree] match { _p0 = self; _p1 = result } with
        | {_p0 = C_Red ; _p1 = C_Red} -> true
        | {_p0 = C_Black ; _p1 = C_Black} -> true
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'0 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'1 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'2 = "red_black_tree.rs" 38 12 42 13
  
  use map.Map
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'1] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'2] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  constant self  : t_Tree
  
  constant accu  : Map.map t_DeepModelTy t_Option'0
  
  constant k  : t_DeepModelTy
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self'0: t_Tree) (accu'0: Map.map t_DeepModelTy t_Option'0) (k'0: t_DeepModelTy) : ()
  
  
  goal vc_model_acc_has_mapping: match self with
    | {t_Tree__node = C_None} -> [%#sred_black_tree] Map.get (model_acc self accu) k = Map.get accu k
    \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
    | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> ([%#sred_black_tree] Map.get (model_acc left accu) k
    = Map.get accu k
    \/ (exists v: t_V. Map.get (model_acc left accu) k = C_Some'0 v /\ has_mapping left k v))
     -> (let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in ([%#sred_black_tree] Map.get (model_acc right accu2) k
    = Map.get accu2 k
    \/ (exists v: t_V. Map.get (model_acc right accu2) k = C_Some'0 v /\ has_mapping right k v))
     -> ([%#sred_black_tree] Map.get (model_acc self accu) k = Map.get accu k
    \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)))
    end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'0 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'1 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'2 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'3 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'4 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'5 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'6 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 210 12 211 104
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use map.Map
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'7] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'3] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'5] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'1] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  constant self  : t_Tree
  
  constant accu  : Map.map t_DeepModelTy t_Option'0
  
  constant k  : t_DeepModelTy
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self'0: t_Tree) (accu'0: Map.map t_DeepModelTy t_Option'0) (k'0: t_DeepModelTy) : ()
  
  
  goal vc_has_mapping_model_acc: ([%#sred_black_tree] bst_invariant self)
   -> match self with
    | {t_Tree__node = C_None} -> [%#sred_black_tree'0] forall v: t_V. has_mapping self k v
     -> Map.get (model_acc self accu) k = C_Some'0 v
    | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> ([@expl:has_mapping_model_acc requires] [%#sred_black_tree] bst_invariant left)
    /\ (([%#sred_black_tree'0] forall v: t_V. has_mapping left k v  -> Map.get (model_acc left accu) k = C_Some'0 v)
     -> (let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in ([@expl:has_mapping_model_acc requires] [%#sred_black_tree] bst_invariant right)
    /\ (([%#sred_black_tree'0] forall v: t_V. has_mapping right k v  -> Map.get (model_acc right accu2) k = C_Some'0 v)
     -> (let _ = has_mapping_model_acc right accu2 k in ([%#sred_black_tree'1] Map.get (model_acc right accu2) k
    = Map.get accu2 k
    \/ (exists v: t_V. Map.get (model_acc right accu2) k = C_Some'0 v /\ has_mapping right k v))
     -> ([%#sred_black_tree'0] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)))))
    end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'0 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'1 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'2 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'3 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'4 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'5 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'6 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'8 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'10 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'11 = "red_black_tree.rs" 210 12 211 104
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use map.Map
  use map.Const
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'11] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'5] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'9] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'7] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'8] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'1] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'10] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'2] bst_invariant self)
   -> ([%#sred_black_tree'3] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  constant self  : t_Tree
  
  constant k  : t_DeepModelTy
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self'0: t_Tree) (k'0: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model: ([%#sred_black_tree] bst_invariant self)
   -> ([%#sred_black_tree'1] Map.get (model_acc self (Const.const (C_None'0))) k = Map.get (Const.const (C_None'0)) k
  \/ (exists v: t_V. Map.get (model_acc self (Const.const (C_None'0))) k = C_Some'0 v /\ has_mapping self k v))
   -> (let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in ([@expl:has_mapping_model_acc requires] [%#sred_black_tree'2] bst_invariant self)
  /\ (([%#sred_black_tree'3] forall v: t_V. has_mapping self k v
   -> Map.get (model_acc self (Const.const (C_None'0))) k = C_Some'0 v)
   -> ([%#sred_black_tree'0] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))))
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_inj [#"red_black_tree.rs" 123 4 125 33] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 119 15 119 35
  let%span sred_black_tree'0 = "red_black_tree.rs" 120 15 120 38
  let%span sred_black_tree'1 = "red_black_tree.rs" 121 15 121 38
  let%span sred_black_tree'2 = "red_black_tree.rs" 122 14 122 22
  let%span sred_black_tree'3 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'4 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'5 = "red_black_tree.rs" 128 12 128 37
  let%span sred_black_tree'6 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'8 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'9 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'10 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'11 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'12 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'13 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'14 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'15 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'16 = "red_black_tree.rs" 56 12 63 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  
  use map.Map
  use map.Const
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'7] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'10] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'16] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'9] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'12] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'11] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'15] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'13] bst_invariant self)
   -> ([%#sred_black_tree'14] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'8] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'3] bst_invariant self)
   -> ([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  constant self  : t_Tree
  
  constant k  : t_DeepModelTy
  
  constant v1  : t_V
  
  constant v2  : t_V
  
  function has_mapping_inj [#"red_black_tree.rs" 123 4 125 33] (self'0: t_Tree) (k'0: t_DeepModelTy) (v1'0: t_V) (v2'0: t_V) : ()
  
  
  goal vc_has_mapping_inj: ([%#sred_black_tree] bst_invariant self)
   -> ([%#sred_black_tree'0] has_mapping self k v1)
   -> ([%#sred_black_tree'1] has_mapping self k v2)
   -> ([@expl:has_mapping_model requires] [%#sred_black_tree'3] bst_invariant self)
  /\ (([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
   -> (let _ = has_mapping_model self k in match Map.get (view self) k with
    | C_None'0 -> [%#sred_black_tree'2] v1 = v2
    | C_Some'0 _v -> [%#sred_black_tree'2] v1 = v2
    end))
end
module M_red_black_tree__qyi3665871523867809084__has_mapping [#"red_black_tree.rs" 138 4 138 57] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'0 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'1 = "red_black_tree.rs" 38 12 42 13
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'1] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  constant self  : t_Node
  
  constant k  : t_DeepModelTy
  
  constant v  : t_V
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self'0: t_Node) (k'0: t_DeepModelTy) (v'0: t_V)
  
  goal vc_has_mapping: if has_mapping self.t_Node__left k v then
    [%#sred_black_tree] forall node: t_Node. self = node  -> true = has_mapping { t_Tree__node = C_Some node } k v
  else
    if has_mapping self.t_Node__right k v then
      [%#sred_black_tree] forall node: t_Node. self = node  -> true = has_mapping { t_Tree__node = C_Some node } k v
    else
      if k = deep_model self.t_Node__key then
        [%#sred_black_tree] forall node: t_Node. self = node
         -> (v = self.t_Node__val) = has_mapping { t_Tree__node = C_Some node } k v
      else
        [%#sred_black_tree] forall node: t_Node. self = node  -> false = has_mapping { t_Tree__node = C_Some node } k v
    
  

end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence [#"red_black_tree.rs" 184 4 184 31] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 182 15 182 39
  let%span sred_black_tree'0 = "red_black_tree.rs" 183 14 183 31
  let%span sred_black_tree'1 = "red_black_tree.rs" 184 32 184 34
  let%span sred_black_tree'2 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'3 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'4 = "red_black_tree.rs" 191 12 191 63
  let%span sred_black_tree'5 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'6 = "red_black_tree.rs" 139 8 142 9
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 62 8 62 23
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'3] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'6] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'5] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 189 4 189 28] (self: t_Node) =
    [%#sred_black_tree'4] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v  -> resolve v
  
  predicate resolve'1 (_0: t_Node) =
    resolve'0 _0
  
  predicate resolve'2 (self: t_Node) =
    [%#sresolve'0] resolve'1 self
  
  predicate resolve'3 (_0: t_Node) =
    resolve'2 _0
  
  predicate resolve'4 (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve'3 x
      | C_None -> true
      end
  
  predicate resolve'5 (_0: t_Option) =
    resolve'4 _0
  
  predicate structural_resolve (_0: t_Tree) =
    match _0 with
      | {t_Tree__node = x0} -> resolve'5 x0
      end
  
  predicate resolve'6 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve v
  
  constant self  : t_Tree
  
  function resolve_coherence [#"red_black_tree.rs" 184 4 184 31] (self'0: t_Tree) : ()
  
  goal vc_resolve_coherence: ([%#sred_black_tree] structural_resolve self)  -> ([%#sred_black_tree'0] resolve'6 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence [#"red_black_tree.rs" 198 4 198 31] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 196 15 196 39
  let%span sred_black_tree'0 = "red_black_tree.rs" 197 14 197 31
  let%span sred_black_tree'1 = "red_black_tree.rs" 198 32 198 34
  let%span sred_black_tree'2 = "red_black_tree.rs" 191 12 191 63
  let%span sred_black_tree'3 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'4 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'5 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'6 = "red_black_tree.rs" 38 12 42 13
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'5] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve v
  
  predicate resolve'1 (_0: t_Tree) =
    resolve'0 _0
  
  predicate resolve'2 (_0: t_K)
  
  predicate structural_resolve (_0: t_Node) =
    match _0 with
      | {t_Node__left = x0 ; t_Node__color = x1 ; t_Node__key = x2 ; t_Node__val = x3 ; t_Node__right = x4} -> resolve'1 x4
      /\ resolve x3 /\ resolve'2 x2 /\ resolve'1 x0
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'3] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'3 [#"red_black_tree.rs" 189 4 189 28] (self: t_Node) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v  -> resolve v
  
  constant self  : t_Node
  
  function resolve_coherence [#"red_black_tree.rs" 198 4 198 31] (self'0: t_Node) : ()
  
  goal vc_resolve_coherence: ([%#sred_black_tree] structural_resolve self)  -> ([%#sred_black_tree'0] resolve'3 self)
end
module M_red_black_tree__qyi3529752165842986389__height [#"red_black_tree.rs" 320 4 320 26] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'0 = "red_black_tree.rs" 322 12 330 13
  
  use mach.int.Int
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  constant self  : t_Tree
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self'0: t_Tree) : int
  
  goal vc_height: match self with
    | {t_Tree__node = C_None} -> [%#sred_black_tree] 0 >= 0
    | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
      | C_Red -> ([%#sred_black_tree] height left >= 0)  -> ([%#sred_black_tree] height left >= 0)
      | C_Black -> ([%#sred_black_tree] height left >= 0)  -> ([%#sred_black_tree] height left + 1 >= 0)
      end
    end
end
module M_red_black_tree__qyi3665871523867809084__height [#"red_black_tree.rs" 352 4 352 26] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'0 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'1 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'2 = "red_black_tree.rs" 322 12 330 13
  
  use mach.int.Int
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'2] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'0] height self >= 0
  
  constant self  : t_Node
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self'0: t_Node) : int
  
  goal vc_height: match self.t_Node__color with
    | C_Red -> ([%#sred_black_tree'0] height self.t_Node__left >= 0)
     -> ([%#sred_black_tree] forall node: t_Node. self = node
     -> height self.t_Node__left = height { t_Tree__node = C_Some node })
    | C_Black -> ([%#sred_black_tree'0] height self.t_Node__left >= 0)
     -> ([%#sred_black_tree] forall node: t_Node. self = node
     -> height self.t_Node__left + 1 = height { t_Tree__node = C_Some node })
    end
end
module M_red_black_tree__qyi3529752165842986389__is_red [#"red_black_tree.rs" 405 4 405 28] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 408 17 408 22
  let%span sred_black_tree'0 = "red_black_tree.rs" 407 49 407 53
  let%span sred_black_tree'1 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'2 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'3 = "red_black_tree.rs" 282 12 285 13
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Node))= any
    [ good (field_0:t_Node)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  predicate invariant''0 (self: t_Tree) =
    [%#sinvariant] inv'2 self
  
  predicate inv'5 (_0: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'3] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  meta "compute_max_steps" 1000000
  
  let rec is_red[#"red_black_tree.rs" 405 4 405 28] (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'1] inv'5 self}
    (! bb0
    [ bb0 = any
      [ br0 -> {self'0.t_Tree__node = C_None} (! bb6) | br1 (x0:t_Node)-> {self'0.t_Tree__node = C_Some x0} (! bb2) ]
    
    | bb6 = bb1
    | bb2 = v_Some {self'0.t_Tree__node}
        (fun (r0:t_Node) ->
          any [ br0 -> {r0.t_Node__color = C_Red} (! bb3) | br1 -> {r0.t_Node__color = C_Black} (! bb1) ] )
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree] false ] s1 | s1 = bb5 ] 
    | bb3 = bb4
    | bb4 = s0 [ s0 =  [ &_0 <- [%#sred_black_tree'0] true ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    ) [ & _0: bool = Any.any_l () | & self'0: t_Tree = self ] 
    [ return''0 (result:bool)-> {[@expl:is_red ensures] [%#sred_black_tree'2] result = (color self = C_Red)}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__rotate_right [#"red_black_tree.rs" 429 4 429 30] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 430 23 430 41
  let%span sred_black_tree'0 = "red_black_tree.rs" 458 8 458 90
  let%span sred_black_tree'1 = "red_black_tree.rs" 429 25 429 29
  let%span sred_black_tree'2 = "red_black_tree.rs" 417 15 417 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 418 15 418 42
  let%span sred_black_tree'4 = "red_black_tree.rs" 419 14 419 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 421 14 421 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 422 14 422 65
  let%span sred_black_tree'8 = "red_black_tree.rs" 423 14 423 42
  let%span sred_black_tree'9 = "red_black_tree.rs" 424 14 424 44
  let%span sred_black_tree'10 = "red_black_tree.rs" 425 14 428 34
  let%span sred_black_tree'11 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'13 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'15 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'16 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'17 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'18 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'19 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'20 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'21 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'22 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'23 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'25 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'27 = "red_black_tree.rs" 337 12 343 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 602 18 602 32
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  predicate resolve (_0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  let rec default (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {inv'2 result} {[%#soption'2] result = C_None} (! return' {result}) ]
  
  
  let rec take (dest:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result:t_Option)-> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'0 (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 (_0: MutBorrow.t t_Option) =
    resolve'0 _0
  
  let rec unwrap (self_:t_Option) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any [ return''0 (result:t_Node)-> {inv'4 result} {[%#soption'1] C_Some result = self_} (! return' {result}) ] 
  
  predicate invariant''1 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  let rec swap (x:MutBorrow.t t_Tree) (y:MutBorrow.t t_Tree) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'2] inv'6 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'6 y}
    any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'2 (self: MutBorrow.t t_Tree) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'3 (_0: MutBorrow.t t_Tree) =
    resolve'2 _0
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  let rec swap'0 (x:MutBorrow.t t_Node) (y:MutBorrow.t t_Node) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'2] inv'7 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'7 y}
    any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate invariant''3 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'4 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'5 (_0: MutBorrow.t t_Node) =
    resolve'4 _0
  
  let rec swap'1 (x:MutBorrow.t t_Color) (y:MutBorrow.t t_Color) (return'  (x'0:()))= any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'6 (self: MutBorrow.t t_Color) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_Color) =
    resolve'6 _0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'17] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve'8 v
  
  predicate resolve'10 (_0: t_Tree) =
    resolve'9 _0
  
  predicate resolve'11 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'12 (_0: MutBorrow.t t_Node) =
    resolve'11 _0
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'24] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'18] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'22] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'26] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'27] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'19] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'12] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'13] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'21] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'20] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'14] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'16] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'15] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple  =
    { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_right[#"red_black_tree.rs" 429 4 429 30] (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'1] inv'7 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'2] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'3] color (self.current).t_Node__left = C_Red}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree] self'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__left).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_16 <- _ret ] 
            -{inv'2 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = {inv'2 _16.current}
        MutBorrow.borrow_final <t_Option> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &_16 <- { _16 with current = _ret.final } ] 
            s2)
      | s2 = take {_15} (fun (_ret:t_Option) ->  [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap {_14} (fun (_ret:t_Node) ->  [ &x <- _ret ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'1 (self'0.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Node__left}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_19 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = _ret.final } } ] 
            s1)
      | s1 = {inv'1 x.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {x.t_Node__right}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_21 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &x <- { x with t_Node__right = _ret.final } ] 
            s2)
      | s2 = {inv'1 _19.current}
        MutBorrow.borrow_final <t_Tree> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_18 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &_19 <- { _19 with current = _ret.final } ] 
            s3)
      | s3 = {inv'1 _21.current}
        MutBorrow.borrow_final <t_Tree> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_20 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &_21 <- { _21 with current = _ret.final } ] 
            s4)
      | s4 = swap {_18} {_20} (fun (_ret:()) ->  [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'3 _21}- s2
      | s2 = {[@expl:type invariant] inv'6 _19} s3
      | s3 = -{resolve'3 _19}- s4
      | s4 = {inv'4 x}
        MutBorrow.borrow_mut <t_Node> {x}
          (fun (_ret:MutBorrow.t t_Node) ->  [ &_25 <- _ret ] -{inv'4 _ret.final}-  [ &x <- _ret.final ] s5)
      | s5 = {inv'3 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_23 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s6)
      | s6 = {inv'3 _25.current}
        MutBorrow.borrow_final <t_Node> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_24 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_25 <- { _25 with current = _ret.final } ] 
            s7)
      | s7 = swap'0 {_23} {_24} (fun (_ret:()) ->  [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'8 _25} s1
      | s1 = -{resolve'5 _25}- s2
      | s2 = MutBorrow.borrow_final
          <t_Color>
          {(self'0.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_Color) ->
             [ &_28 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Node__color = _ret.final } } ] 
            s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.t_Node__color}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_30 <- _ret ]  [ &x <- { x with t_Node__color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_27 <- _ret ]  [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_29 <- _ret ]  [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap'1 {_27} {_29} (fun (_ret:()) ->  [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    
    | bb6 = s0
      [ s0 = -{resolve'7 _30}- s1
      | s1 = -{resolve'7 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree'0] has_mapping (old_self.current).t_Node__left (deep_model (self'0.current).t_Node__key) (self'0.current).t_Node__val}
        s3
      | s3 =  [ &_34 <- C_Some x ] s4
      | s4 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &_33 <- { t_Tree__node = _34 } ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self'0 with
          | {current = {t_Node__right = x'0}} -> inv'1 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self'0 with
          | {current = {t_Node__right = x'0}} -> resolve'10 x'0
          | _ -> true
          end}-
        s2
      | s2 =  [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'12 self'0}- s5
      | s5 = bb11 ]
    
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & old_self: MutBorrow.t t_Node = Any.any_l ()
    | & x: t_Node = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: MutBorrow.t t_Tree = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _21: MutBorrow.t t_Tree = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node = Any.any_l ()
    | & _24: MutBorrow.t t_Node = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree = Any.any_l ()
    | & _34: t_Option = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:rotate_right ensures #0] [%#sred_black_tree'4] same_mappings self.current self.final}
      {[@expl:rotate_right ensures #1] [%#sred_black_tree'5] internal_invariant self.final}
      {[@expl:rotate_right ensures #2] [%#sred_black_tree'6] height'0 self.current = height'0 self.final}
      {[@expl:rotate_right ensures #3] [%#sred_black_tree'7] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[@expl:rotate_right ensures #4] [%#sred_black_tree'8] color (self.final).t_Node__right = C_Red}
      {[@expl:rotate_right ensures #5] [%#sred_black_tree'9] (self.final).t_Node__color = (self.current).t_Node__color}
      {[@expl:rotate_right ensures #6] [%#sred_black_tree'10] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node
      = C_Some l
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
      /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
      /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__rotate_left [#"red_black_tree.rs" 479 4 479 29] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 480 23 480 41
  let%span sred_black_tree'0 = "red_black_tree.rs" 485 8 485 91
  let%span sred_black_tree'1 = "red_black_tree.rs" 479 24 479 28
  let%span sred_black_tree'2 = "red_black_tree.rs" 467 15 467 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 468 15 468 43
  let%span sred_black_tree'4 = "red_black_tree.rs" 469 14 469 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 470 14 470 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 471 14 471 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 472 14 472 65
  let%span sred_black_tree'8 = "red_black_tree.rs" 473 14 473 41
  let%span sred_black_tree'9 = "red_black_tree.rs" 474 14 474 44
  let%span sred_black_tree'10 = "red_black_tree.rs" 475 14 478 34
  let%span sred_black_tree'11 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'13 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'15 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'16 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'17 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'18 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'19 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'20 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'21 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'22 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'23 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'25 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'27 = "red_black_tree.rs" 337 12 343 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span soption = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 602 18 602 32
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  predicate resolve (_0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  let rec default (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {inv'2 result} {[%#soption'2] result = C_None} (! return' {result}) ]
  
  
  let rec take (dest:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result:t_Option)-> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'0 (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'1 (_0: MutBorrow.t t_Option) =
    resolve'0 _0
  
  let rec unwrap (self_:t_Option) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any [ return''0 (result:t_Node)-> {inv'4 result} {[%#soption'1] C_Some result = self_} (! return' {result}) ] 
  
  predicate invariant''1 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  let rec swap (x:MutBorrow.t t_Tree) (y:MutBorrow.t t_Tree) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'2] inv'6 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'6 y}
    any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'2 (self: MutBorrow.t t_Tree) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'3 (_0: MutBorrow.t t_Tree) =
    resolve'2 _0
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  let rec swap'0 (x:MutBorrow.t t_Node) (y:MutBorrow.t t_Node) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'2] inv'7 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'7 y}
    any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate invariant''3 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'4 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'5 (_0: MutBorrow.t t_Node) =
    resolve'4 _0
  
  let rec swap'1 (x:MutBorrow.t t_Color) (y:MutBorrow.t t_Color) (return'  (x'0:()))= any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'6 (self: MutBorrow.t t_Color) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_Color) =
    resolve'6 _0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'17] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve'8 v
  
  predicate resolve'10 (_0: t_Tree) =
    resolve'9 _0
  
  predicate resolve'11 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'12 (_0: MutBorrow.t t_Node) =
    resolve'11 _0
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'24] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'18] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'22] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'26] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'27] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'19] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'12] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'13] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'21] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'20] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'14] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'16] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'15] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple  =
    { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  meta "compute_max_steps" 1000000
  
  let rec rotate_left[#"red_black_tree.rs" 479 4 479 29] (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree'1] inv'7 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree'2] internal_invariant self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree'3] color (self.current).t_Node__right = C_Red}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree] self'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_16 <- _ret ] 
            -{inv'2 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = {inv'2 _16.current}
        MutBorrow.borrow_final <t_Option> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &_16 <- { _16 with current = _ret.final } ] 
            s2)
      | s2 = take {_15} (fun (_ret:t_Option) ->  [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap {_14} (fun (_ret:t_Node) ->  [ &x <- _ret ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = {inv'1 (self'0.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Node__right}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_19 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = _ret.final } } ] 
            s1)
      | s1 = {inv'1 x.t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {x.t_Node__left}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_21 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &x <- { x with t_Node__left = _ret.final } ] 
            s2)
      | s2 = {inv'1 _19.current}
        MutBorrow.borrow_final <t_Tree> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_18 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &_19 <- { _19 with current = _ret.final } ] 
            s3)
      | s3 = {inv'1 _21.current}
        MutBorrow.borrow_final <t_Tree> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_20 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &_21 <- { _21 with current = _ret.final } ] 
            s4)
      | s4 = swap {_18} {_20} (fun (_ret:()) ->  [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'3 _21}- s2
      | s2 = {[@expl:type invariant] inv'6 _19} s3
      | s3 = -{resolve'3 _19}- s4
      | s4 = {inv'4 x}
        MutBorrow.borrow_mut <t_Node> {x}
          (fun (_ret:MutBorrow.t t_Node) ->  [ &_25 <- _ret ] -{inv'4 _ret.final}-  [ &x <- _ret.final ] s5)
      | s5 = {inv'3 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_23 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s6)
      | s6 = {inv'3 _25.current}
        MutBorrow.borrow_final <t_Node> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_24 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_25 <- { _25 with current = _ret.final } ] 
            s7)
      | s7 = swap'0 {_23} {_24} (fun (_ret:()) ->  [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'8 _25} s1
      | s1 = -{resolve'5 _25}- s2
      | s2 = MutBorrow.borrow_final
          <t_Color>
          {(self'0.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_Color) ->
             [ &_28 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Node__color = _ret.final } } ] 
            s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.t_Node__color}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_30 <- _ret ]  [ &x <- { x with t_Node__color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_27 <- _ret ]  [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_29 <- _ret ]  [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap'1 {_27} {_29} (fun (_ret:()) ->  [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    
    | bb6 = s0
      [ s0 = -{resolve'7 _30}- s1
      | s1 = -{resolve'7 _28}- s2
      | s2 = {[@expl:assertion] [%#sred_black_tree'0] has_mapping (old_self.current).t_Node__right (deep_model (self'0.current).t_Node__key) (self'0.current).t_Node__val}
        s3
      | s3 =  [ &_34 <- C_Some x ] s4
      | s4 = bb7 ]
    
    | bb7 = s0 [ s0 =  [ &_33 <- { t_Tree__node = _34 } ] s1 | s1 = bb8 ] 
    | bb8 = bb9
    | bb9 = s0
      [ s0 = {[@expl:type invariant] match self'0 with
          | {current = {t_Node__left = x'0}} -> inv'1 x'0
          | _ -> true
          end}
        s1
      | s1 = -{match self'0 with
          | {current = {t_Node__left = x'0}} -> resolve'10 x'0
          | _ -> true
          end}-
        s2
      | s2 =  [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'12 self'0}- s5
      | s5 = bb11 ]
    
    | bb11 = bb12
    | bb12 = return''0 {_0} ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & old_self: MutBorrow.t t_Node = Any.any_l ()
    | & x: t_Node = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: MutBorrow.t t_Tree = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _21: MutBorrow.t t_Tree = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node = Any.any_l ()
    | & _24: MutBorrow.t t_Node = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree = Any.any_l ()
    | & _34: t_Option = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:rotate_left ensures #0] [%#sred_black_tree'4] same_mappings self.current self.final}
      {[@expl:rotate_left ensures #1] [%#sred_black_tree'5] internal_invariant self.final}
      {[@expl:rotate_left ensures #2] [%#sred_black_tree'6] height'0 self.current = height'0 self.final}
      {[@expl:rotate_left ensures #3] [%#sred_black_tree'7] lt_log (deep_model (self.current).t_Node__key) (deep_model (self.final).t_Node__key)}
      {[@expl:rotate_left ensures #4] [%#sred_black_tree'8] color (self.final).t_Node__left = C_Red}
      {[@expl:rotate_left ensures #5] [%#sred_black_tree'9] (self.final).t_Node__color = (self.current).t_Node__color}
      {[@expl:rotate_left ensures #6] [%#sred_black_tree'10] exists l: t_Node, r: t_Node. ((self.current).t_Node__right).t_Tree__node
      = C_Some r
      /\ ((self.final).t_Node__left).t_Tree__node = C_Some l
      /\ { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.final).t_Node__right }
      = { _p0 = (self.current).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      /\ l.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__flip_colors [#"red_black_tree.rs" 503 4 503 29] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 503 24 503 28
  let%span sred_black_tree'0 = "red_black_tree.rs" 489 15 489 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 490 15 490 40
  let%span sred_black_tree'2 = "red_black_tree.rs" 491 15 491 41
  let%span sred_black_tree'3 = "red_black_tree.rs" 492 15 492 60
  let%span sred_black_tree'4 = "red_black_tree.rs" 493 14 493 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 494 14 494 50
  let%span sred_black_tree'6 = "red_black_tree.rs" 495 14 495 42
  let%span sred_black_tree'7 = "red_black_tree.rs" 496 14 496 40
  let%span sred_black_tree'8 = "red_black_tree.rs" 497 14 499 68
  let%span sred_black_tree'9 = "red_black_tree.rs" 500 14 502 88
  let%span sred_black_tree'10 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'11 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'13 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'15 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'16 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'17 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'18 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'19 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'20 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'21 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'22 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'24 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 38 12 42 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'7 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  let rec swap (x:MutBorrow.t t_Color) (y:MutBorrow.t t_Color) (return'  (x'0:()))= any
    [ return''0 (result:())-> {[%#smem] x.final = y.current} {[%#smem'0] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_Color) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Color) =
    resolve'1 _0
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  predicate resolve'3 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Node) =
    resolve'3 _0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'21] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'22] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'15] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'18] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'17] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'23] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'16] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'10] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'11] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'13] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'12] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'20] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'19] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'14] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  meta "compute_max_steps" 1000000
  
  let rec flip_colors[#"red_black_tree.rs" 503 4 503 29] (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree] inv'8 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'0] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'1] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'2] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'3] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Node__left).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = as_mut {_15} (fun (_ret:t_Option'0) ->  [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret:MutBorrow.t t_Node) ->  [ &_13 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &_13 <- { _13 with current = { _13.current with t_Node__color = (self'0.current).t_Node__color } } ] s1
      | s1 = {[@expl:type invariant] inv'6 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = MutBorrow.borrow_final
          <t_Color>
          {(self'0.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_Color) ->
             [ &_18 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Node__color = _ret.final } } ] 
            s4)
      | s4 = {inv'2 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Node__right).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 5) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_23 <- _ret ] 
            -{inv'2 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            
            s5)
      | s5 = as_mut {_23} (fun (_ret:t_Option'0) ->  [ &_22 <- _ret ] s6)
      | s6 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap {_22} (fun (_ret:MutBorrow.t t_Node) ->  [ &_21 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = MutBorrow.borrow_final
          <t_Color>
          {(_21.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id _21) 2}
          (fun (_ret:MutBorrow.t t_Color) ->
             [ &_20 <- _ret ] 
             [ &_21 <- { _21 with current = { _21.current with t_Node__color = _ret.final } } ] 
            s1)
      | s1 = MutBorrow.borrow_final <t_Color> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_17 <- _ret ]  [ &_18 <- { _18 with current = _ret.final } ] s2)
      | s2 = MutBorrow.borrow_final <t_Color> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret:MutBorrow.t t_Color) ->  [ &_19 <- _ret ]  [ &_20 <- { _20 with current = _ret.final } ] s3)
      | s3 = swap {_17} {_19} (fun (_ret:()) ->  [ &_16 <- _ret ] s4)
      | s4 = bb5 ]
    
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = -{resolve'2 _20}- s3
      | s3 = -{resolve'2 _18}- s4
      | s4 = {[@expl:type invariant] inv'8 self'0} s5
      | s5 = -{resolve'4 self'0}- s6
      | s6 = return''0 {_0} ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: MutBorrow.t t_Color = Any.any_l ()
    | & _18: MutBorrow.t t_Color = Any.any_l ()
    | & _19: MutBorrow.t t_Color = Any.any_l ()
    | & _20: MutBorrow.t t_Color = Any.any_l ()
    | & _21: MutBorrow.t t_Node = Any.any_l ()
    | & _22: t_Option'0 = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:flip_colors ensures #0] [%#sred_black_tree'4] internal_invariant self.final}
      {[@expl:flip_colors ensures #1] [%#sred_black_tree'5] height'0 self.current = height'0 self.final}
      {[@expl:flip_colors ensures #2] [%#sred_black_tree'6] same_mappings self.current self.final}
      {[@expl:flip_colors ensures #3] [%#sred_black_tree'7] (self.current).t_Node__key = (self.final).t_Node__key}
      {[@expl:flip_colors ensures #4] [%#sred_black_tree'8] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node
      = C_Some l1
      /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
      /\ l1.t_Node__left = l2.t_Node__left
      /\ l1.t_Node__right = l2.t_Node__right
      /\ l1.t_Node__key = l2.t_Node__key
      /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[@expl:flip_colors ensures #5] [%#sred_black_tree'9] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node
      = C_Some r1
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
      /\ r1.t_Node__left = r2.t_Node__left
      /\ r1.t_Node__right = r2.t_Node__right
      /\ r1.t_Node__key = r2.t_Node__key
      /\ (self.current).t_Node__color = r2.t_Node__color
      /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__balance [#"red_black_tree.rs" 527 4 527 25] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 527 20 527 24
  let%span sred_black_tree'0 = "red_black_tree.rs" 508 15 508 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 509 15 510 45
  let%span sred_black_tree'2 = "red_black_tree.rs" 511 15 512 46
  let%span sred_black_tree'3 = "red_black_tree.rs" 513 15 513 108
  let%span sred_black_tree'4 = "red_black_tree.rs" 514 14 514 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 515 14 515 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 516 14 516 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 517 14 518 32
  let%span sred_black_tree'8 = "red_black_tree.rs" 519 14 520 37
  let%span sred_black_tree'9 = "red_black_tree.rs" 521 14 522 61
  let%span sred_black_tree'10 = "red_black_tree.rs" 523 14 524 59
  let%span sred_black_tree'11 = "red_black_tree.rs" 525 14 526 37
  let%span sred_black_tree'12 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'13 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'14 = "red_black_tree.rs" 479 24 479 28
  let%span sred_black_tree'15 = "red_black_tree.rs" 467 15 467 43
  let%span sred_black_tree'16 = "red_black_tree.rs" 468 15 468 43
  let%span sred_black_tree'17 = "red_black_tree.rs" 469 14 469 42
  let%span sred_black_tree'18 = "red_black_tree.rs" 470 14 470 42
  let%span sred_black_tree'19 = "red_black_tree.rs" 471 14 471 50
  let%span sred_black_tree'20 = "red_black_tree.rs" 472 14 472 65
  let%span sred_black_tree'21 = "red_black_tree.rs" 473 14 473 41
  let%span sred_black_tree'22 = "red_black_tree.rs" 474 14 474 44
  let%span sred_black_tree'23 = "red_black_tree.rs" 475 14 478 34
  let%span sred_black_tree'24 = "red_black_tree.rs" 429 25 429 29
  let%span sred_black_tree'25 = "red_black_tree.rs" 417 15 417 43
  let%span sred_black_tree'26 = "red_black_tree.rs" 418 15 418 42
  let%span sred_black_tree'27 = "red_black_tree.rs" 419 14 419 42
  let%span sred_black_tree'28 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'29 = "red_black_tree.rs" 421 14 421 50
  let%span sred_black_tree'30 = "red_black_tree.rs" 422 14 422 65
  let%span sred_black_tree'31 = "red_black_tree.rs" 423 14 423 42
  let%span sred_black_tree'32 = "red_black_tree.rs" 424 14 424 44
  let%span sred_black_tree'33 = "red_black_tree.rs" 425 14 428 34
  let%span sred_black_tree'34 = "red_black_tree.rs" 503 24 503 28
  let%span sred_black_tree'35 = "red_black_tree.rs" 489 15 489 43
  let%span sred_black_tree'36 = "red_black_tree.rs" 490 15 490 40
  let%span sred_black_tree'37 = "red_black_tree.rs" 491 15 491 41
  let%span sred_black_tree'38 = "red_black_tree.rs" 492 15 492 60
  let%span sred_black_tree'39 = "red_black_tree.rs" 493 14 493 42
  let%span sred_black_tree'40 = "red_black_tree.rs" 494 14 494 50
  let%span sred_black_tree'41 = "red_black_tree.rs" 495 14 495 42
  let%span sred_black_tree'42 = "red_black_tree.rs" 496 14 496 40
  let%span sred_black_tree'43 = "red_black_tree.rs" 497 14 499 68
  let%span sred_black_tree'44 = "red_black_tree.rs" 500 14 502 88
  let%span sred_black_tree'45 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'46 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'47 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'48 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'49 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'50 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 270 12 273 13
  let%span sred_black_tree'52 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'53 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'54 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'55 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'56 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'57 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'58 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'59 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'60 = "red_black_tree.rs" 311 8 311 112
  let%span sred_black_tree'61 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'62 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'63 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'64 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'65 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'66 = "red_black_tree.rs" 38 12 42 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 90 16 90 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 91 26 91 58
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 93 20 93 89
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  predicate invariant''0 (self: t_Tree) =
    [%#sinvariant'0] inv'2 self
  
  predicate inv'5 (_0: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'46] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'12] inv'5 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'13] result = (color self = C_Red)} (! return' {result}) ] 
  
  predicate invariant''1 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'66] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'62] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'63] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'53] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'59] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'58] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'64] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'65] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'54] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'45] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'57] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'56] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'48] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'50] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'49] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple  =
    { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_left (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree'14] inv'6 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree'15] internal_invariant self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree'16] color (self.current).t_Node__right = C_Red}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'17] same_mappings self.current self.final}
      {[%#sred_black_tree'18] internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] lt_log (deep_model (self.current).t_Node__key) (deep_model (self.final).t_Node__key)}
      {[%#sred_black_tree'21] color (self.final).t_Node__left = C_Red}
      {[%#sred_black_tree'22] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'23] exists l: t_Node, r: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r
      /\ ((self.final).t_Node__left).t_Tree__node = C_Some l
      /\ { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.final).t_Node__right }
      = { _p0 = (self.current).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      /\ l.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Node
  
  predicate invariant''2 (self: t_Option) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'7 (_0: t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate invariant''3 (self: t_Node) =
    [%#sinvariant'0] inv'3 self
  
  predicate inv'8 (_0: t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate inv'9 (_0: t_Option'0)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Option'0 [inv'9 x]. inv'9 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'8 a_0
    end
  
  let rec as_ref (self_:t_Option) (return'  (x:t_Option'0))= {[@expl:as_ref 'self_' type invariant] [%#soption] inv'7 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'9 result}
      {[%#soption'0] self_ = C_None  -> result = C_None'0}
      {[%#soption'1] self_ = C_None \/ (exists r: t_Node. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'9 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any [ return''0 (result:t_Node)-> {inv'8 result} {[%#soption'4] C_Some'0 result = self_} (! return' {result}) ] 
  
  let rec rotate_right (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'24] inv'6 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'25] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'26] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'27] same_mappings self.current self.final}
      {[%#sred_black_tree'28] internal_invariant self.final}
      {[%#sred_black_tree'29] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'30] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'31] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'32] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'33] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
      /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
      /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  
  let rec flip_colors (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree'34] inv'6 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'35] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'36] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'37] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'38] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'39] internal_invariant self.final}
      {[%#sred_black_tree'40] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'41] same_mappings self.current self.final}
      {[%#sred_black_tree'42] (self.current).t_Node__key = (self.final).t_Node__key}
      {[%#sred_black_tree'43] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l1
      /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
      /\ l1.t_Node__left = l2.t_Node__left
      /\ l1.t_Node__right = l2.t_Node__right
      /\ l1.t_Node__key = l2.t_Node__key
      /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[%#sred_black_tree'44] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r1
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
      /\ r1.t_Node__left = r2.t_Node__left
      /\ r1.t_Node__right = r2.t_Node__right
      /\ r1.t_Node__key = r2.t_Node__key
      /\ (self.current).t_Node__color = r2.t_Node__color
      /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'55] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'47] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant'0 [#"red_black_tree.rs" 310 4 310 36] (self: t_Node) =
    [%#sred_black_tree'60] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'61] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 268 4 268 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'51] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'52] C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  let rec balance[#"red_black_tree.rs" 527 4 527 25] (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree] inv'6 self}
    {[@expl:balance requires #0] [%#sred_black_tree'0] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'1] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__left = C_Red  -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'2] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red  -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'3] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red  -> false}
    (! bb0
    [ bb0 = s0 [ s0 = is_red {(self'0.current).t_Node__right} (fun (_ret:bool) ->  [ &_15 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_15 = false} (! bb7) | br1 -> {_15} (! bb2) ] 
    | bb2 = s0 [ s0 = is_red {(self'0.current).t_Node__left} (fun (_ret:bool) ->  [ &_17 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb4) ] 
    | bb4 = bb8
    | bb5 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_20 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = rotate_left {_20} (fun (_ret:()) ->  [ &_19 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = bb9
    | bb7 = bb8
    | bb8 = bb9
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Node__left} (fun (_ret:bool) ->  [ &_22 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_22 = false} (! bb18) | br1 -> {_22} (! bb11) ] 
    | bb11 = s0
      [ s0 = as_ref {((self'0.current).t_Node__left).t_Tree__node} (fun (_ret:t_Option'0) ->  [ &_27 <- _ret ] s1)
      | s1 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap {_27} (fun (_ret:t_Node) ->  [ &_26 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0 [ s0 = is_red {_26.t_Node__left} (fun (_ret:bool) ->  [ &_24 <- _ret ] s1) | s1 = bb14 ] 
    | bb14 = any [ br0 -> {_24 = false} (! bb17) | br1 -> {_24} (! bb15) ] 
    | bb15 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_30 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = rotate_right {_30} (fun (_ret:()) ->  [ &_29 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb16 = bb20
    | bb17 = bb19
    | bb18 = bb19
    | bb19 = bb20
    | bb20 = s0 [ s0 = is_red {(self'0.current).t_Node__left} (fun (_ret:bool) ->  [ &_31 <- _ret ] s1) | s1 = bb21 ] 
    | bb21 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ] 
    | bb22 = s0 [ s0 = is_red {(self'0.current).t_Node__right} (fun (_ret:bool) ->  [ &_33 <- _ret ] s1) | s1 = bb23 ] 
    | bb23 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ] 
    | bb24 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_final <t_Node> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_36 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = flip_colors {_36} (fun (_ret:()) ->  [ &_35 <- _ret ] s2)
      | s2 = bb25 ]
    
    | bb25 = s0 [ s0 = {[@expl:type invariant] inv'6 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb29 ] 
    | bb26 = s0 [ s0 = {[@expl:type invariant] inv'6 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb28 ] 
    | bb27 = s0 [ s0 = {[@expl:type invariant] inv'6 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb28 ] 
    | bb28 = bb29
    | bb29 = return''0 {_0} ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _15: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Node = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: () = Any.any_l ()
    | & _36: MutBorrow.t t_Node = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:balance ensures #0] [%#sred_black_tree'4] same_mappings self.current self.final}
      {[@expl:balance ensures #1] [%#sred_black_tree'5] internal_invariant self.final}
      {[@expl:balance ensures #2] [%#sred_black_tree'6] height'0 self.current = height'0 self.final}
      {[@expl:balance ensures #3] [%#sred_black_tree'7] color_invariant (self.current).t_Node__left
      /\ color (self.current).t_Node__right = C_Black  -> self.current = self.final}
      {[@expl:balance ensures #4] [%#sred_black_tree'8] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      {[@expl:balance ensures #5] [%#sred_black_tree'9] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[@expl:balance ensures #6] [%#sred_black_tree'10] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[@expl:balance ensures #7] [%#sred_black_tree'11] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__move_red_left [#"red_black_tree.rs" 559 4 559 44] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 559 26 559 30
  let%span sred_black_tree'0 = "red_black_tree.rs" 541 15 541 41
  let%span sred_black_tree'1 = "red_black_tree.rs" 542 15 542 43
  let%span sred_black_tree'2 = "red_black_tree.rs" 543 15 543 86
  let%span sred_black_tree'3 = "red_black_tree.rs" 559 35 559 44
  let%span sred_black_tree'4 = "red_black_tree.rs" 544 14 544 44
  let%span sred_black_tree'5 = "red_black_tree.rs" 545 14 547 46
  let%span sred_black_tree'6 = "red_black_tree.rs" 548 14 548 95
  let%span sred_black_tree'7 = "red_black_tree.rs" 549 14 549 42
  let%span sred_black_tree'8 = "red_black_tree.rs" 550 14 550 103
  let%span sred_black_tree'9 = "red_black_tree.rs" 551 14 552 45
  let%span sred_black_tree'10 = "red_black_tree.rs" 553 14 554 106
  let%span sred_black_tree'11 = "red_black_tree.rs" 555 14 556 61
  let%span sred_black_tree'12 = "red_black_tree.rs" 557 14 558 43
  let%span sred_black_tree'13 = "red_black_tree.rs" 503 24 503 28
  let%span sred_black_tree'14 = "red_black_tree.rs" 489 15 489 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 490 15 490 40
  let%span sred_black_tree'16 = "red_black_tree.rs" 491 15 491 41
  let%span sred_black_tree'17 = "red_black_tree.rs" 492 15 492 60
  let%span sred_black_tree'18 = "red_black_tree.rs" 493 14 493 42
  let%span sred_black_tree'19 = "red_black_tree.rs" 494 14 494 50
  let%span sred_black_tree'20 = "red_black_tree.rs" 495 14 495 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 496 14 496 40
  let%span sred_black_tree'22 = "red_black_tree.rs" 497 14 499 68
  let%span sred_black_tree'23 = "red_black_tree.rs" 500 14 502 88
  let%span sred_black_tree'24 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'25 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'26 = "red_black_tree.rs" 429 25 429 29
  let%span sred_black_tree'27 = "red_black_tree.rs" 417 15 417 43
  let%span sred_black_tree'28 = "red_black_tree.rs" 418 15 418 42
  let%span sred_black_tree'29 = "red_black_tree.rs" 419 14 419 42
  let%span sred_black_tree'30 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'31 = "red_black_tree.rs" 421 14 421 50
  let%span sred_black_tree'32 = "red_black_tree.rs" 422 14 422 65
  let%span sred_black_tree'33 = "red_black_tree.rs" 423 14 423 42
  let%span sred_black_tree'34 = "red_black_tree.rs" 424 14 424 44
  let%span sred_black_tree'35 = "red_black_tree.rs" 425 14 428 34
  let%span sred_black_tree'36 = "red_black_tree.rs" 479 24 479 28
  let%span sred_black_tree'37 = "red_black_tree.rs" 467 15 467 43
  let%span sred_black_tree'38 = "red_black_tree.rs" 468 15 468 43
  let%span sred_black_tree'39 = "red_black_tree.rs" 469 14 469 42
  let%span sred_black_tree'40 = "red_black_tree.rs" 470 14 470 42
  let%span sred_black_tree'41 = "red_black_tree.rs" 471 14 471 50
  let%span sred_black_tree'42 = "red_black_tree.rs" 472 14 472 65
  let%span sred_black_tree'43 = "red_black_tree.rs" 473 14 473 41
  let%span sred_black_tree'44 = "red_black_tree.rs" 474 14 474 44
  let%span sred_black_tree'45 = "red_black_tree.rs" 475 14 478 34
  let%span sred_black_tree'46 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'47 = "red_black_tree.rs" 270 12 273 13
  let%span sred_black_tree'48 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'49 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'50 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'52 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'53 = "red_black_tree.rs" 311 8 311 112
  let%span sred_black_tree'54 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'55 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'56 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'57 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'58 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'59 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'60 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'61 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'62 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'63 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'64 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'65 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'66 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'67 = "red_black_tree.rs" 337 12 343 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'4 (_0: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
  = match x with
    | {t_Tree__node = node} -> inv'3 node
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'4 left
    /\ inv key /\ inv'0 val' /\ inv'4 right
    end
  
  predicate invariant''0 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Node [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'61] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'64] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'65] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'56] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'60] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'59] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'66] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'67] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'57] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'46] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'54] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'50] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'49] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'52] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'51] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'55] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree'13] inv'5 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'15] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'16] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'17] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'18] internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] same_mappings self.current self.final}
      {[%#sred_black_tree'21] (self.current).t_Node__key = (self.final).t_Node__key}
      {[%#sred_black_tree'22] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l1
      /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
      /\ l1.t_Node__left = l2.t_Node__left
      /\ l1.t_Node__right = l2.t_Node__right
      /\ l1.t_Node__key = l2.t_Node__key
      /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[%#sred_black_tree'23] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r1
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
      /\ r1.t_Node__left = r2.t_Node__left
      /\ r1.t_Node__right = r2.t_Node__right
      /\ r1.t_Node__key = r2.t_Node__key
      /\ (self.current).t_Node__color = r2.t_Node__color
      /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'7 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'6 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'8 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'8 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'7 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  
  predicate invariant''3 (self: t_Tree) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'24] inv'9 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'25] result = (color self = C_Red)} (! return' {result}) ] 
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  type tuple  =
    { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'26] inv'5 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'27] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'28] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'29] same_mappings self.current self.final}
      {[%#sred_black_tree'30] internal_invariant self.final}
      {[%#sred_black_tree'31] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'32] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'33] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'34] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'35] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
      /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
      /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  
  let rec rotate_left (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree'36] inv'5 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree'37] internal_invariant self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree'38] color (self.current).t_Node__right = C_Red}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'39] same_mappings self.current self.final}
      {[%#sred_black_tree'40] internal_invariant self.final}
      {[%#sred_black_tree'41] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'42] lt_log (deep_model (self.current).t_Node__key) (deep_model (self.final).t_Node__key)}
      {[%#sred_black_tree'43] color (self.final).t_Node__left = C_Red}
      {[%#sred_black_tree'44] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'45] exists l: t_Node, r: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r
      /\ ((self.final).t_Node__left).t_Tree__node = C_Some l
      /\ { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.final).t_Node__right }
      = { _p0 = (self.current).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      /\ l.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Node) =
    resolve'1 _0
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'62] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'63] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 310 4 310 36] (self: t_Node) =
    [%#sred_black_tree'53] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'58] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 268 4 268 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'47] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'48] C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_left[#"red_black_tree.rs" 559 4 559 44] (self:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree] inv'5 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree'0] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] [%#sred_black_tree'1] internal_invariant self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree'2] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_16 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = flip_colors {_16} (fun (_ret:()) ->  [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_22 <- _ret ] 
            -{inv'3 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = as_mut {_22} (fun (_ret:t_Option'0) ->  [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = unwrap {_21} (fun (_ret:MutBorrow.t t_Node) ->  [ &_20 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = is_red {(_20.current).t_Node__left} (fun (_ret:bool) ->  [ &_18 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'7 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_28 <- _ret ] 
            -{inv'3 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = as_mut {_28} (fun (_ret:t_Option'0) ->  [ &_27 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0 [ s0 = unwrap {_27} (fun (_ret:MutBorrow.t t_Node) ->  [ &_26 <- _ret ] s1) | s1 = bb7 ] 
    | bb7 = s0
      [ s0 = {inv'1 _26.current}
        MutBorrow.borrow_final <t_Node> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_25 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &_26 <- { _26 with current = _ret.final } ] 
            s1)
      | s1 = rotate_right {_25} (fun (_ret:()) ->  [ &_24 <- _ret ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'7 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_30 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s3)
      | s3 = rotate_left {_30} (fun (_ret:()) ->  [ &_29 <- _ret ] s4)
      | s4 = bb9 ]
    
    | bb9 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_32 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = flip_colors {_32} (fun (_ret:()) ->  [ &_31 <- _ret ] s2)
      | s2 = bb10 ]
    
    | bb10 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Node__left).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_35 <- _ret ] 
            -{inv'3 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = as_mut {_35} (fun (_ret:t_Option'0) ->  [ &_34 <- _ret ] s2)
      | s2 = bb11 ]
    
    | bb11 = s0 [ s0 = unwrap {_34} (fun (_ret:MutBorrow.t t_Node) ->  [ &_33 <- _ret ] s1) | s1 = bb12 ] 
    | bb12 = s0
      [ s0 = {inv'1 _33.current}
        MutBorrow.borrow_final <t_Node> {_33.current} {MutBorrow.get_id _33}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_0 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &_33 <- { _33 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'7 _33} s2
      | s2 = -{resolve'0 _33}- s3
      | s3 = bb16 ]
    
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'5 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb14 ] 
    | bb13 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = bb14 ] 
    | bb14 = return''0 {_0} ]
    )
    [ & _0: MutBorrow.t t_Node = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _21: t_Option'0 = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: MutBorrow.t t_Node = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _28: MutBorrow.t t_Option = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _32: MutBorrow.t t_Node = Any.any_l ()
    | & _33: MutBorrow.t t_Node = Any.any_l ()
    | & _34: t_Option'0 = Any.any_l ()
    | & _35: MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_Node)-> {[@expl:move_red_left result type invariant] [%#sred_black_tree'3] inv'5 result}
      {[@expl:move_red_left ensures #0] [%#sred_black_tree'4] internal_invariant result.current}
      {[@expl:move_red_left ensures #1] [%#sred_black_tree'5] internal_invariant result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant self.final}
      {[@expl:move_red_left ensures #2] [%#sred_black_tree'6] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_left ensures #3] [%#sred_black_tree'7] (self.current).t_Node__key = (result.current).t_Node__key}
      {[@expl:move_red_left ensures #4] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:move_red_left ensures #5] [%#sred_black_tree'9] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
      /\ le_log k (deep_model (self.current).t_Node__key)  -> has_mapping'0 result.current k v}
      {[@expl:move_red_left ensures #6] [%#sred_black_tree'10] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_left ensures #7] [%#sred_black_tree'11] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[@expl:move_red_left ensures #8] [%#sred_black_tree'12] color_invariant'0 result.final
      /\ (color (result.current).t_Node__right = C_Black  -> (result.final).t_Node__color = C_Black)
       -> color_invariant'0 self.final}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3665871523867809084__move_red_right [#"red_black_tree.rs" 588 4 588 45] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 588 27 588 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 570 15 570 40
  let%span sred_black_tree'1 = "red_black_tree.rs" 571 15 571 43
  let%span sred_black_tree'2 = "red_black_tree.rs" 572 15 572 86
  let%span sred_black_tree'3 = "red_black_tree.rs" 588 36 588 45
  let%span sred_black_tree'4 = "red_black_tree.rs" 573 14 573 44
  let%span sred_black_tree'5 = "red_black_tree.rs" 574 14 576 46
  let%span sred_black_tree'6 = "red_black_tree.rs" 577 14 577 95
  let%span sred_black_tree'7 = "red_black_tree.rs" 578 14 578 42
  let%span sred_black_tree'8 = "red_black_tree.rs" 579 14 579 103
  let%span sred_black_tree'9 = "red_black_tree.rs" 580 14 581 45
  let%span sred_black_tree'10 = "red_black_tree.rs" 582 14 583 106
  let%span sred_black_tree'11 = "red_black_tree.rs" 584 14 585 61
  let%span sred_black_tree'12 = "red_black_tree.rs" 586 14 587 43
  let%span sred_black_tree'13 = "red_black_tree.rs" 503 24 503 28
  let%span sred_black_tree'14 = "red_black_tree.rs" 489 15 489 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 490 15 490 40
  let%span sred_black_tree'16 = "red_black_tree.rs" 491 15 491 41
  let%span sred_black_tree'17 = "red_black_tree.rs" 492 15 492 60
  let%span sred_black_tree'18 = "red_black_tree.rs" 493 14 493 42
  let%span sred_black_tree'19 = "red_black_tree.rs" 494 14 494 50
  let%span sred_black_tree'20 = "red_black_tree.rs" 495 14 495 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 496 14 496 40
  let%span sred_black_tree'22 = "red_black_tree.rs" 497 14 499 68
  let%span sred_black_tree'23 = "red_black_tree.rs" 500 14 502 88
  let%span sred_black_tree'24 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'25 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'26 = "red_black_tree.rs" 429 25 429 29
  let%span sred_black_tree'27 = "red_black_tree.rs" 417 15 417 43
  let%span sred_black_tree'28 = "red_black_tree.rs" 418 15 418 42
  let%span sred_black_tree'29 = "red_black_tree.rs" 419 14 419 42
  let%span sred_black_tree'30 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'31 = "red_black_tree.rs" 421 14 421 50
  let%span sred_black_tree'32 = "red_black_tree.rs" 422 14 422 65
  let%span sred_black_tree'33 = "red_black_tree.rs" 423 14 423 42
  let%span sred_black_tree'34 = "red_black_tree.rs" 424 14 424 44
  let%span sred_black_tree'35 = "red_black_tree.rs" 425 14 428 34
  let%span sred_black_tree'36 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'37 = "red_black_tree.rs" 270 12 273 13
  let%span sred_black_tree'38 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'39 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'40 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'41 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'42 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'43 = "red_black_tree.rs" 311 8 311 112
  let%span sred_black_tree'44 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'45 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'46 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'47 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'48 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'49 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'50 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'52 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'53 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'54 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'55 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'56 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'57 = "red_black_tree.rs" 337 12 343 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'4 (_0: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
  = match x with
    | {t_Tree__node = node} -> inv'3 node
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'4 left
    /\ inv key /\ inv'0 val' /\ inv'4 right
    end
  
  predicate invariant''0 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Node [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'51] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'54] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'55] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'46] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'50] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'49] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'56] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'57] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'47] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'36] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'44] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'40] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'39] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'42] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'41] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'45] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree'13] inv'5 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'15] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'16] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'17] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'18] internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] same_mappings self.current self.final}
      {[%#sred_black_tree'21] (self.current).t_Node__key = (self.final).t_Node__key}
      {[%#sred_black_tree'22] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l1
      /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
      /\ l1.t_Node__left = l2.t_Node__left
      /\ l1.t_Node__right = l2.t_Node__right
      /\ l1.t_Node__key = l2.t_Node__key
      /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[%#sred_black_tree'23] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r1
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
      /\ r1.t_Node__left = r2.t_Node__left
      /\ r1.t_Node__right = r2.t_Node__right
      /\ r1.t_Node__key = r2.t_Node__key
      /\ (self.current).t_Node__color = r2.t_Node__color
      /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'7 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'6 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'8 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'8 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'7 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  
  predicate invariant''3 (self: t_Tree) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'24] inv'9 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'25] result = (color self = C_Red)} (! return' {result}) ] 
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  type tuple  =
    { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'26] inv'5 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'27] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'28] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'29] same_mappings self.current self.final}
      {[%#sred_black_tree'30] internal_invariant self.final}
      {[%#sred_black_tree'31] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'32] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'33] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'34] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'35] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
      /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
      /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Node) =
    resolve'1 _0
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'52] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'53] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 310 4 310 36] (self: t_Node) =
    [%#sred_black_tree'43] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'48] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 268 4 268 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'37] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'38] C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  let rec move_red_right[#"red_black_tree.rs" 588 4 588 45] (self:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree] inv'5 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree'0] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] [%#sred_black_tree'1] internal_invariant self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree'2] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_16 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = flip_colors {_16} (fun (_ret:()) ->  [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__left).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_22 <- _ret ] 
            -{inv'3 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = as_mut {_22} (fun (_ret:t_Option'0) ->  [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0 [ s0 = unwrap {_21} (fun (_ret:MutBorrow.t t_Node) ->  [ &_20 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = is_red {(_20.current).t_Node__left} (fun (_ret:bool) ->  [ &_18 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'7 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ]  ]
    
    | bb5 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_25 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = rotate_right {_25} (fun (_ret:()) ->  [ &_24 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_27 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = flip_colors {_27} (fun (_ret:()) ->  [ &_26 <- _ret ] s2)
      | s2 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Node__right).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 5) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_30 <- _ret ] 
            -{inv'3 _ret.final}-
            
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            
            s1)
      | s1 = as_mut {_30} (fun (_ret:t_Option'0) ->  [ &_29 <- _ret ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0 [ s0 = unwrap {_29} (fun (_ret:MutBorrow.t t_Node) ->  [ &_28 <- _ret ] s1) | s1 = bb9 ] 
    | bb9 = s0
      [ s0 = {inv'1 _28.current}
        MutBorrow.borrow_final <t_Node> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_0 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &_28 <- { _28 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'7 _28} s2
      | s2 = -{resolve'0 _28}- s3
      | s3 = bb13 ]
    
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'5 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb11 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = bb11 ] 
    | bb11 = return''0 {_0} ]
    )
    [ & _0: MutBorrow.t t_Node = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _21: t_Option'0 = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Node = Any.any_l ()
    | & _28: MutBorrow.t t_Node = Any.any_l ()
    | & _29: t_Option'0 = Any.any_l ()
    | & _30: MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t t_Node)-> {[@expl:move_red_right result type invariant] [%#sred_black_tree'3] inv'5 result}
      {[@expl:move_red_right ensures #0] [%#sred_black_tree'4] internal_invariant result.current}
      {[@expl:move_red_right ensures #1] [%#sred_black_tree'5] internal_invariant result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant self.final}
      {[@expl:move_red_right ensures #2] [%#sred_black_tree'6] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_right ensures #3] [%#sred_black_tree'7] (result.current).t_Node__key
      = (self.current).t_Node__key}
      {[@expl:move_red_right ensures #4] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[@expl:move_red_right ensures #5] [%#sred_black_tree'9] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
      /\ le_log (deep_model (self.current).t_Node__key) k  -> has_mapping'0 result.current k v}
      {[@expl:move_red_right ensures #6] [%#sred_black_tree'10] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_right ensures #7] [%#sred_black_tree'11] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[@expl:move_red_right ensures #8] [%#sred_black_tree'12] color_invariant'0 result.final
      /\ (color (result.current).t_Node__left = C_Black  -> (result.final).t_Node__color = C_Black)
       -> color_invariant'0 self.final}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__insert_rec [#"red_black_tree.rs" 611 4 611 44] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 611 23 611 27
  let%span sred_black_tree'0 = "red_black_tree.rs" 611 29 611 32
  let%span sred_black_tree'1 = "red_black_tree.rs" 611 37 611 40
  let%span sred_black_tree'2 = "red_black_tree.rs" 603 15 603 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 604 15 604 40
  let%span sred_black_tree'4 = "red_black_tree.rs" 605 14 605 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 606 14 606 50
  let%span sred_black_tree'6 = "red_black_tree.rs" 607 14 608 39
  let%span sred_black_tree'7 = "red_black_tree.rs" 609 14 609 56
  let%span sred_black_tree'8 = "red_black_tree.rs" 610 14 610 125
  let%span sred_black_tree'9 = "red_black_tree.rs" 527 20 527 24
  let%span sred_black_tree'10 = "red_black_tree.rs" 508 15 508 43
  let%span sred_black_tree'11 = "red_black_tree.rs" 509 15 510 45
  let%span sred_black_tree'12 = "red_black_tree.rs" 511 15 512 46
  let%span sred_black_tree'13 = "red_black_tree.rs" 513 15 513 108
  let%span sred_black_tree'14 = "red_black_tree.rs" 514 14 514 42
  let%span sred_black_tree'15 = "red_black_tree.rs" 515 14 515 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 516 14 516 50
  let%span sred_black_tree'17 = "red_black_tree.rs" 517 14 518 32
  let%span sred_black_tree'18 = "red_black_tree.rs" 519 14 520 37
  let%span sred_black_tree'19 = "red_black_tree.rs" 521 14 522 61
  let%span sred_black_tree'20 = "red_black_tree.rs" 523 14 524 59
  let%span sred_black_tree'21 = "red_black_tree.rs" 525 14 526 37
  let%span sred_black_tree'22 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'23 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'25 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'28 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'29 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'31 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'32 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'33 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'34 = "red_black_tree.rs" 270 12 273 13
  let%span sred_black_tree'35 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'36 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'38 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'39 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'40 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'41 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'42 = "red_black_tree.rs" 311 8 311 112
  let%span sred_black_tree'43 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'44 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'45 = "red_black_tree.rs" 191 12 191 63
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sresolve'1 = "../../creusot-contracts/src/resolve.rs" 62 8 62 23
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Option) =
    resolve _0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'41] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'40] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'1 (_0: t_V)
  
  predicate resolve'2 [#"red_black_tree.rs" 189 4 189 28] (self: t_Node) =
    [%#sred_black_tree'45] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v  -> resolve'1 v
  
  predicate resolve'3 (_0: t_Node) =
    resolve'2 _0
  
  predicate resolve'4 (self: t_Node) =
    [%#sresolve'1] resolve'3 self
  
  predicate resolve'5 (_0: t_Node) =
    resolve'4 _0
  
  predicate resolve'6 (self: t_Option) =
    [%#sresolve'0] match self with
      | C_Some x -> resolve'5 x
      | C_None -> true
      end
  
  predicate resolve'7 (_0: t_Option) =
    resolve'6 _0
  
  predicate invariant''1 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate resolve'8 (self: MutBorrow.t t_Tree) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'9 (_0: MutBorrow.t t_Tree) =
    resolve'8 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Node))= any
    [ good (field_0:t_Node)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_K; _p1: t_K }
  
  predicate invariant''2 (self: t_K) =
    [%#sinvariant'0] inv self
  
  predicate inv'7 (_0: t_K)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_K [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'7 rhs
  /\ inv'7 self_)  -> precondition () args
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef: forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_:t_K) (rhs:t_K) (return'  (x:t_Ordering))= {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                       _p1 = rhs }}
    any
    [ return''0 (result:t_Ordering)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  predicate resolve'10 (_0: t_K)
  
  predicate invariant''3 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'11 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'12 (_0: MutBorrow.t t_Node) =
    resolve'11 _0
  
  predicate invariant''4 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'43] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'35] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'38] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'24] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'44] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'39] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'30] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'28] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'37] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'31] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'33] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'32] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant'0 [#"red_black_tree.rs" 310 4 310 36] (self: t_Node) =
    [%#sred_black_tree'42] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'26] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 268 4 268 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'34] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'27] C_CPN c l r
  
  let rec balance (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree'9] inv'9 self}
    {[@expl:balance requires #0] [%#sred_black_tree'10] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'11] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__left = C_Red  -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'12] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red  -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'13] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red  -> false}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'14] same_mappings self.current self.final}
      {[%#sred_black_tree'15] internal_invariant self.final}
      {[%#sred_black_tree'16] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'17] color_invariant (self.current).t_Node__left
      /\ color (self.current).t_Node__right = C_Black  -> self.current = self.final}
      {[%#sred_black_tree'18] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'19] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'20] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'21] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'22] bst_invariant self /\ height_invariant self
  
  meta "compute_max_steps" 1000000
  
  let rec insert_rec[#"red_black_tree.rs" 611 4 611 44] (self:MutBorrow.t t_Tree) (key:t_K) (val':t_V) (return'  (x:()))= {[@expl:insert_rec 'self' type invariant] [%#sred_black_tree] inv'6 self}
    {[@expl:insert_rec 'key' type invariant] [%#sred_black_tree'0] inv key}
    {[@expl:insert_rec 'val' type invariant] [%#sred_black_tree'1] inv'0 val'}
    {[@expl:insert_rec requires #0] [%#sred_black_tree'2] internal_invariant'0 self.current}
    {[@expl:insert_rec requires #1] [%#sred_black_tree'3] color_invariant self.current}
    (! bb0
    [ bb0 = bb1
    | bb1 = bb2
    | bb2 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_11 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] 
            s1)
      | s1 = any [ br0 -> {_11.current = C_None} (! bb19) | br1 (x0:t_Node)-> {_11.current = C_Some x0} (! bb3) ]  ]
    
    | bb19 = s0
      [ s0 = {[@expl:type invariant] inv'5 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 =  [ &_35 <- C_None ] s3
      | s3 =  [ &_34 <- { t_Tree__node = _35 } ] s4
      | s4 = bb20 ]
    
    | bb20 = s0
      [ s0 =  [ &_36 <- C_Red ] s1
      | s1 =  [ &_40 <- C_None ] s2
      | s2 =  [ &_39 <- { t_Tree__node = _40 } ] s3
      | s3 = bb21 ]
    
    | bb21 = s0
      [ s0 = 
        [ &_33 <- { t_Node__left = _34;
                    t_Node__color = _36;
                    t_Node__key = key'0;
                    t_Node__val = val''0;
                    t_Node__right = _39 } ]
        
        s1
      | s1 = bb22 ]
    
    | bb22 = bb23
    | bb23 = bb24
    | bb24 = bb25
    | bb25 = bb26
    | bb26 = s0 [ s0 =  [ &_31 <- C_Some _33 ] s1 | s1 = bb27 ] 
    | bb27 = bb28
    | bb28 = s0
      [ s0 = {[@expl:type invariant] match self'0 with
          | {current = {t_Tree__node = x}} -> inv'2 x
          | _ -> true
          end}
        s1
      | s1 = -{match self'0 with
          | {current = {t_Tree__node = x}} -> resolve'7 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &self'0 <- { self'0 with current = { t_Tree__node = _31 } } ] s3
      | s3 = {[@expl:type invariant] inv'6 self'0} s4
      | s4 = -{resolve'9 self'0}- s5
      | s5 = bb30 ]
    
    | bb30 = bb32
    | bb3 = bb4
    | bb4 = s0
      [ s0 = v_Some {_11.current}
          (fun (r0:t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _11) 1}
              (fun (_ret:MutBorrow.t t_Node) ->
                 [ &node <- _ret ] 
                -{inv'4 _ret.final}-
                 [ &_11 <- { _11 with current = C_Some _ret.final } ] 
                s1))
      | s1 =  [ &_18 <- (node.current).t_Node__key ] s2
      | s2 = cmp {key'0} {_18} (fun (_ret:t_Ordering) ->  [ &_15 <- _ret ] s3)
      | s3 = bb5 ]
    
    | bb5 = any [ br0 -> {_15 = C_Less} (! bb7) | br1 -> {_15 = C_Equal} (! bb8) | br2 -> {_15 = C_Greater} (! bb9) ] 
    | bb9 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_25 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] 
            s1)
      | s1 = insert_rec {_25} {key'0} {val''0} (fun (_ret:()) ->  [ &_14 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb16 = bb17
    | bb8 = s0 [ s0 = {[@expl:type invariant] inv key'0} s1 | s1 = -{resolve'10 key'0}- s2 | s2 = bb10 ] 
    | bb10 = bb13
    | bb13 = s0
      [ s0 = {[@expl:type invariant] match node with
          | {current = {t_Node__val = x}} -> inv'0 x
          | _ -> true
          end}
        s1
      | s1 = -{match node with
          | {current = {t_Node__val = x}} -> resolve'1 x
          | _ -> true
          end}-
        s2
      | s2 =  [ &node <- { node with current = { node.current with t_Node__val = val''0 } } ] s3
      | s3 = {[@expl:type invariant] inv'8 node} s4
      | s4 = -{resolve'12 node}- s5
      | s5 = {[@expl:type invariant] inv'5 _11} s6
      | s6 = -{resolve'0 _11}- s7
      | s7 = {[@expl:type invariant] inv'6 self'0} s8
      | s8 = -{resolve'9 self'0}- s9
      | s9 = bb15 ]
    
    | bb15 = bb32
    | bb32 = bb33
    | bb33 = bb34
    | bb7 = bb11
    | bb11 = s0
      [ s0 = {inv'1 (node.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__left}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_20 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] 
            s1)
      | s1 = insert_rec {_20} {key'0} {val''0} (fun (_ret:()) ->  [ &_14 <- _ret ] s2)
      | s2 = bb12 ]
    
    | bb12 = bb17
    | bb17 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_29 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = balance {_29} (fun (_ret:()) ->  [ &_28 <- _ret ] s2)
      | s2 = bb18 ]
    
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'12 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _11} s3
      | s3 = -{resolve'0 _11}- s4
      | s4 = {[@expl:type invariant] inv'6 self'0} s5
      | s5 = -{resolve'9 self'0}- s6
      | s6 = bb31 ]
    
    | bb31 = bb34
    | bb34 = return''0 {_0} ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & key'0: t_K = key
    | & val''0: t_V = val'
    | & _11: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & _15: t_Ordering = Any.any_l ()
    | & _18: t_K = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _25: MutBorrow.t t_Tree = Any.any_l ()
    | & _28: () = Any.any_l ()
    | & _29: MutBorrow.t t_Node = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _33: t_Node = Any.any_l ()
    | & _34: t_Tree = Any.any_l ()
    | & _35: t_Option = Any.any_l ()
    | & _36: t_Color = Any.any_l ()
    | & _39: t_Tree = Any.any_l ()
    | & _40: t_Option = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:insert_rec ensures #0] [%#sred_black_tree'4] internal_invariant'0 self.final}
      {[@expl:insert_rec ensures #1] [%#sred_black_tree'5] height self.current = height self.final}
      {[@expl:insert_rec ensures #2] [%#sred_black_tree'6] match_t (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final
      /\ color self.current = C_Red
      \/ color_invariant self.final}
      {[@expl:insert_rec ensures #3] [%#sred_black_tree'7] has_mapping self.final (deep_model key) val'}
      {[@expl:insert_rec ensures #4] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. k = deep_model key
      \/ has_mapping self.current k v = has_mapping self.final k v}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__delete_max_rec [#"red_black_tree.rs" 645 4 645 42] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 645 27 645 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 634 15 634 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 635 15 636 62
  let%span sred_black_tree'2 = "red_black_tree.rs" 645 36 645 42
  let%span sred_black_tree'3 = "red_black_tree.rs" 637 14 637 42
  let%span sred_black_tree'4 = "red_black_tree.rs" 638 14 638 50
  let%span sred_black_tree'5 = "red_black_tree.rs" 639 14 639 66
  let%span sred_black_tree'6 = "red_black_tree.rs" 640 14 640 102
  let%span sred_black_tree'7 = "red_black_tree.rs" 641 14 642 71
  let%span sred_black_tree'8 = "red_black_tree.rs" 643 14 643 39
  let%span sred_black_tree'9 = "red_black_tree.rs" 644 14 644 67
  let%span sred_black_tree'10 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'11 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'12 = "red_black_tree.rs" 429 25 429 29
  let%span sred_black_tree'13 = "red_black_tree.rs" 417 15 417 43
  let%span sred_black_tree'14 = "red_black_tree.rs" 418 15 418 42
  let%span sred_black_tree'15 = "red_black_tree.rs" 419 14 419 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'17 = "red_black_tree.rs" 421 14 421 50
  let%span sred_black_tree'18 = "red_black_tree.rs" 422 14 422 65
  let%span sred_black_tree'19 = "red_black_tree.rs" 423 14 423 42
  let%span sred_black_tree'20 = "red_black_tree.rs" 424 14 424 44
  let%span sred_black_tree'21 = "red_black_tree.rs" 425 14 428 34
  let%span sred_black_tree'22 = "red_black_tree.rs" 588 27 588 31
  let%span sred_black_tree'23 = "red_black_tree.rs" 570 15 570 40
  let%span sred_black_tree'24 = "red_black_tree.rs" 571 15 571 43
  let%span sred_black_tree'25 = "red_black_tree.rs" 572 15 572 86
  let%span sred_black_tree'26 = "red_black_tree.rs" 588 36 588 45
  let%span sred_black_tree'27 = "red_black_tree.rs" 573 14 573 44
  let%span sred_black_tree'28 = "red_black_tree.rs" 574 14 576 46
  let%span sred_black_tree'29 = "red_black_tree.rs" 577 14 577 95
  let%span sred_black_tree'30 = "red_black_tree.rs" 578 14 578 42
  let%span sred_black_tree'31 = "red_black_tree.rs" 579 14 579 103
  let%span sred_black_tree'32 = "red_black_tree.rs" 580 14 581 45
  let%span sred_black_tree'33 = "red_black_tree.rs" 582 14 583 106
  let%span sred_black_tree'34 = "red_black_tree.rs" 584 14 585 61
  let%span sred_black_tree'35 = "red_black_tree.rs" 586 14 587 43
  let%span sred_black_tree'36 = "red_black_tree.rs" 527 20 527 24
  let%span sred_black_tree'37 = "red_black_tree.rs" 508 15 508 43
  let%span sred_black_tree'38 = "red_black_tree.rs" 509 15 510 45
  let%span sred_black_tree'39 = "red_black_tree.rs" 511 15 512 46
  let%span sred_black_tree'40 = "red_black_tree.rs" 513 15 513 108
  let%span sred_black_tree'41 = "red_black_tree.rs" 514 14 514 42
  let%span sred_black_tree'42 = "red_black_tree.rs" 515 14 515 42
  let%span sred_black_tree'43 = "red_black_tree.rs" 516 14 516 50
  let%span sred_black_tree'44 = "red_black_tree.rs" 517 14 518 32
  let%span sred_black_tree'45 = "red_black_tree.rs" 519 14 520 37
  let%span sred_black_tree'46 = "red_black_tree.rs" 521 14 522 61
  let%span sred_black_tree'47 = "red_black_tree.rs" 523 14 524 59
  let%span sred_black_tree'48 = "red_black_tree.rs" 525 14 526 37
  let%span sred_black_tree'49 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'50 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'52 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'53 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'54 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'55 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'56 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'57 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'58 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'59 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'60 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'61 = "red_black_tree.rs" 270 12 273 13
  let%span sred_black_tree'62 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'63 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'64 = "red_black_tree.rs" 311 8 311 112
  let%span sred_black_tree'65 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'66 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'67 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'68 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'69 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'70 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'71 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'72 = "red_black_tree.rs" 363 20 363 61
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 47 16 47 17
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 48 26 48 43
  let%span sboxed'1 = "../../creusot-contracts/src/std/boxed.rs" 49 26 49 43
  let%span sboxed'2 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 90 16 90 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 91 26 91 58
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 93 20 93 89
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 602 18 602 32
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed'2] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'7 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:as_mut 'self_' type invariant] [%#sboxed] inv'6 self_}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'8 result}
      {[%#sboxed'0] self_.current = result.current}
      {[%#sboxed'1] self_.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  predicate invariant''3 (self: t_Tree) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'56] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'10] inv'9 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'11] result = (color self = C_Red)} (! return' {result}) ] 
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'54] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'71] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'66] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'69] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'53] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'52] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'72] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'67] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'70] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'57] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'63] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'62] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'58] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'60] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'59] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple  =
    { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'12] inv'8 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'13] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'14] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'15] same_mappings self.current self.final}
      {[%#sred_black_tree'16] internal_invariant self.final}
      {[%#sred_black_tree'17] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'18] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'19] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'20] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'21] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
      /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
      = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
      /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Node
  
  predicate invariant''4 (self: t_Option) =
    [%#sinvariant'0] inv'2 self
  
  predicate inv'10 (_0: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate invariant''5 (self: t_Node) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'11 (_0: t_Node)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Node [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'11 a_0
    end
  
  let rec as_ref (self_:t_Option) (return'  (x:t_Option'1))= {[@expl:as_ref 'self_' type invariant] [%#soption'5] inv'10 self_}
    any
    [ return''0 (result:t_Option'1)-> {inv'12 result}
      {[%#soption'6] self_ = C_None  -> result = C_None'1}
      {[%#soption'7] self_ = C_None \/ (exists r: t_Node. result = C_Some'1 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self_:t_Option'1) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'1}
    any [ return''0 (result:t_Node)-> {inv'11 result} {[%#soption'4] C_Some'1 result = self_} (! return' {result}) ] 
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'68] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'55] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 310 4 310 36] (self: t_Node) =
    [%#sred_black_tree'64] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'50] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 268 4 268 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'61] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'51] C_CPN c l r
  
  let rec move_red_right (self:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree'22] inv'8 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree'23] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] [%#sred_black_tree'24] internal_invariant self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree'25] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {[%#sred_black_tree'26] inv'8 result}
      {[%#sred_black_tree'27] internal_invariant result.current}
      {[%#sred_black_tree'28] internal_invariant result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant self.final}
      {[%#sred_black_tree'29] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'30] (result.current).t_Node__key = (self.current).t_Node__key}
      {[%#sred_black_tree'31] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'32] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
      /\ le_log (deep_model (self.current).t_Node__key) k  -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'33] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'34] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'35] color_invariant'0 result.final
      /\ (color (result.current).t_Node__left = C_Black  -> (result.final).t_Node__color = C_Black)
       -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Node) =
    resolve'1 _0
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  let rec balance (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree'36] inv'8 self}
    {[@expl:balance requires #0] [%#sred_black_tree'37] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'38] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__left = C_Red  -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'39] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red  -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'40] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red  -> false}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'41] same_mappings self.current self.final}
      {[%#sred_black_tree'42] internal_invariant self.final}
      {[%#sred_black_tree'43] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'44] color_invariant (self.current).t_Node__left
      /\ color (self.current).t_Node__right = C_Black  -> self.current = self.final}
      {[%#sred_black_tree'45] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'46] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'47] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'48] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  
  predicate invariant''6 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'13 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'13 x]. inv'13 x = invariant''6 x
  
  predicate resolve'3 (self: MutBorrow.t t_Tree) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Tree) =
    resolve'3 _0
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  predicate resolve'5 (_0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'5 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  let rec default (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {inv'2 result} {[%#soption'8] result = C_None} (! return' {result}) ]
  
  
  let rec take (dest:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result:t_Option)-> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_Option) =
    resolve'6 _0
  
  let rec unwrap'1 (self_:t_Option) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None}
    any [ return''0 (result:t_Node)-> {inv'4 result} {[%#soption'4] C_Some result = self_} (! return' {result}) ] 
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'65] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve'8 v
  
  predicate resolve'10 (_0: t_Tree) =
    resolve'9 _0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'49] bst_invariant self /\ height_invariant self
  
  predicate inv'14 (_0: tuple'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: tuple'0 [inv'14 x]. inv'14 x
  = (let {_p0'0 = x0 ; _p1'0 = x1} = x in inv x0 /\ inv'0 x1)
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max_rec[#"red_black_tree.rs" 645 4 645 42] (self:MutBorrow.t t_Tree) (return'  (x:tuple'0))= {[@expl:delete_max_rec 'self' type invariant] [%#sred_black_tree] inv'13 self}
    {[@expl:delete_max_rec requires #0] [%#sred_black_tree'0] internal_invariant'0 self.current}
    {[@expl:delete_max_rec requires #1] [%#sred_black_tree'1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] 
            s1)
      | s1 = as_mut {_15} (fun (_ret:t_Option'0) ->  [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret:MutBorrow.t t_Node) ->  [ &_13 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'4 _13.current}
        MutBorrow.borrow_final <t_Node> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_12 <- _ret ] 
            -{inv'4 _ret.final}-
             [ &_13 <- { _13 with current = _ret.final } ] 
            s1)
      | s1 = as_mut'0 {_12} (fun (_ret:MutBorrow.t t_Node) ->  [ &node <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = is_red {(node.current).t_Node__left} (fun (_ret:bool) ->  [ &_17 <- _ret ] s3)
      | s3 = bb4 ]
    
    | bb4 = any [ br0 -> {_17 = false} (! bb7) | br1 -> {_17} (! bb5) ] 
    | bb5 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node> {node.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_19 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = rotate_right {_19} (fun (_ret:()) ->  [ &_16 <- _ret ] s2)
      | s2 = bb6 ]
    
    | bb6 = bb8
    | bb7 = bb8
    | bb8 = any
      [ br0 -> {((node.current).t_Node__right).t_Tree__node = C_None} (! bb9)
      | br1 (x0:t_Node)-> {((node.current).t_Node__right).t_Tree__node = C_Some x0} (! bb15) ]
    
    | bb15 = s0 [ s0 = is_red {(node.current).t_Node__right} (fun (_ret:bool) ->  [ &_30 <- _ret ] s1) | s1 = bb16 ] 
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb25
    | bb18 = s0
      [ s0 = as_ref {((node.current).t_Node__right).t_Tree__node} (fun (_ret:t_Option'1) ->  [ &_35 <- _ret ] s1)
      | s1 = bb19 ]
    
    | bb19 = s0 [ s0 = unwrap'0 {_35} (fun (_ret:t_Node) ->  [ &_34 <- _ret ] s1) | s1 = bb20 ] 
    | bb20 = s0 [ s0 = is_red {_34.t_Node__left} (fun (_ret:bool) ->  [ &_32 <- _ret ] s1) | s1 = bb21 ] 
    | bb21 = any [ br0 -> {_32 = false} (! bb23) | br1 -> {_32} (! bb22) ] 
    | bb22 = bb25
    | bb25 = bb26
    | bb23 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_39 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = move_red_right {_39} (fun (_ret:MutBorrow.t t_Node) ->  [ &_38 <- _ret ] s2)
      | s2 = bb24 ]
    
    | bb24 = s0
      [ s0 = {inv'3 _38.current}
        MutBorrow.borrow_final <t_Node> {_38.current} {MutBorrow.get_id _38}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_37 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_38 <- { _38 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 =  [ &node <- _37 ] s4
      | s4 = {[@expl:type invariant] inv'8 _38} s5
      | s5 = -{resolve'2 _38}- s6
      | s6 = bb26 ]
    
    | bb26 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_41 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] 
            s1)
      | s1 = delete_max_rec {_41} (fun (_ret:tuple'0) ->  [ &r <- _ret ] s2)
      | s2 = bb27 ]
    
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_43 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = balance {_43} (fun (_ret:()) ->  [ &_42 <- _ret ] s2)
      | s2 = bb28 ]
    
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb29 ]
    
    | bb29 = bb31
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'8 node} s1 | s1 = -{resolve'2 node}- s2 | s2 = bb10 ] 
    | bb10 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {(self'0.current).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_26 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] 
            s1)
      | s1 = {inv'2 _26.current}
        MutBorrow.borrow_final <t_Option> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_25 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &_26 <- { _26 with current = _ret.final } ] 
            s2)
      | s2 = take {_25} (fun (_ret:t_Option) ->  [ &_24 <- _ret ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'5 _26} s1
      | s1 = -{resolve'7 _26}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 = unwrap'1 {_24} (fun (_ret:t_Node) ->  [ &node'0 <- _ret ] s5)
      | s5 = bb12 ]
    
    | bb12 = s0
      [ s0 = {[@expl:type invariant] match node'0 with
          | {t_Node__right = x} -> inv'1 x
          | _ -> true
          end}
        s1
      | s1 = -{match node'0 with
          | {t_Node__right = x} -> resolve'10 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node'0 with
          | {t_Node__left = x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match node'0 with
          | {t_Node__left = x} -> resolve'10 x
          | _ -> true
          end}-
        s4
      | s4 =  [ &_0 <- { _p0'0 = node'0.t_Node__key; _p1'0 = node'0.t_Node__val } ] s5
      | s5 = bb13 ]
    
    | bb13 = bb14
    | bb14 = bb30
    | bb30 = bb31
    | bb31 = return''0 {_0} ]
    )
    [ & _0: tuple'0 = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _12: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _25: MutBorrow.t t_Option = Any.any_l ()
    | & _26: MutBorrow.t t_Option = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _34: t_Node = Any.any_l ()
    | & _35: t_Option'1 = Any.any_l ()
    | & _37: MutBorrow.t t_Node = Any.any_l ()
    | & _38: MutBorrow.t t_Node = Any.any_l ()
    | & _39: MutBorrow.t t_Node = Any.any_l ()
    | & r: tuple'0 = Any.any_l ()
    | & _41: MutBorrow.t t_Tree = Any.any_l ()
    | & _42: () = Any.any_l ()
    | & _43: MutBorrow.t t_Node = Any.any_l () ]
    
    [ return''0 (result:tuple'0)-> {[@expl:delete_max_rec result type invariant] [%#sred_black_tree'2] inv'14 result}
      {[@expl:delete_max_rec ensures #0] [%#sred_black_tree'3] internal_invariant'0 self.final}
      {[@expl:delete_max_rec ensures #1] [%#sred_black_tree'4] height self.current = height self.final}
      {[@expl:delete_max_rec ensures #2] [%#sred_black_tree'5] has_mapping self.current (deep_model result._p0'0) result._p1'0}
      {[@expl:delete_max_rec ensures #3] [%#sred_black_tree'6] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
       -> le_log k (deep_model result._p0'0)}
      {[@expl:delete_max_rec ensures #4] [%#sred_black_tree'7] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
      = (deep_model result._p0'0 <> k /\ has_mapping self.current k v)}
      {[@expl:delete_max_rec ensures #5] [%#sred_black_tree'8] color_invariant self.final}
      {[@expl:delete_max_rec ensures #6] [%#sred_black_tree'9] color self.current = C_Black
       -> color self.final = C_Black}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__delete_min_rec [#"red_black_tree.rs" 673 4 673 42] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 673 27 673 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 662 15 662 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 663 15 664 62
  let%span sred_black_tree'2 = "red_black_tree.rs" 673 36 673 42
  let%span sred_black_tree'3 = "red_black_tree.rs" 665 14 665 42
  let%span sred_black_tree'4 = "red_black_tree.rs" 666 14 666 50
  let%span sred_black_tree'5 = "red_black_tree.rs" 667 14 667 66
  let%span sred_black_tree'6 = "red_black_tree.rs" 668 14 668 102
  let%span sred_black_tree'7 = "red_black_tree.rs" 669 14 670 71
  let%span sred_black_tree'8 = "red_black_tree.rs" 671 14 671 39
  let%span sred_black_tree'9 = "red_black_tree.rs" 672 14 672 67
  let%span sred_black_tree'10 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'11 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'12 = "red_black_tree.rs" 559 26 559 30
  let%span sred_black_tree'13 = "red_black_tree.rs" 541 15 541 41
  let%span sred_black_tree'14 = "red_black_tree.rs" 542 15 542 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 543 15 543 86
  let%span sred_black_tree'16 = "red_black_tree.rs" 559 35 559 44
  let%span sred_black_tree'17 = "red_black_tree.rs" 544 14 544 44
  let%span sred_black_tree'18 = "red_black_tree.rs" 545 14 547 46
  let%span sred_black_tree'19 = "red_black_tree.rs" 548 14 548 95
  let%span sred_black_tree'20 = "red_black_tree.rs" 549 14 549 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 550 14 550 103
  let%span sred_black_tree'22 = "red_black_tree.rs" 551 14 552 45
  let%span sred_black_tree'23 = "red_black_tree.rs" 553 14 554 106
  let%span sred_black_tree'24 = "red_black_tree.rs" 555 14 556 61
  let%span sred_black_tree'25 = "red_black_tree.rs" 557 14 558 43
  let%span sred_black_tree'26 = "red_black_tree.rs" 527 20 527 24
  let%span sred_black_tree'27 = "red_black_tree.rs" 508 15 508 43
  let%span sred_black_tree'28 = "red_black_tree.rs" 509 15 510 45
  let%span sred_black_tree'29 = "red_black_tree.rs" 511 15 512 46
  let%span sred_black_tree'30 = "red_black_tree.rs" 513 15 513 108
  let%span sred_black_tree'31 = "red_black_tree.rs" 514 14 514 42
  let%span sred_black_tree'32 = "red_black_tree.rs" 515 14 515 42
  let%span sred_black_tree'33 = "red_black_tree.rs" 516 14 516 50
  let%span sred_black_tree'34 = "red_black_tree.rs" 517 14 518 32
  let%span sred_black_tree'35 = "red_black_tree.rs" 519 14 520 37
  let%span sred_black_tree'36 = "red_black_tree.rs" 521 14 522 61
  let%span sred_black_tree'37 = "red_black_tree.rs" 523 14 524 59
  let%span sred_black_tree'38 = "red_black_tree.rs" 525 14 526 37
  let%span sred_black_tree'39 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'40 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'41 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'42 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'43 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'44 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'45 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'46 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'47 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'48 = "red_black_tree.rs" 270 12 273 13
  let%span sred_black_tree'49 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'50 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'52 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'53 = "red_black_tree.rs" 311 8 311 112
  let%span sred_black_tree'54 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'55 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'56 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'57 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'58 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'59 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'60 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'61 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'62 = "red_black_tree.rs" 363 20 363 61
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 47 16 47 17
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 48 26 48 43
  let%span sboxed'1 = "../../creusot-contracts/src/std/boxed.rs" 49 26 49 43
  let%span sboxed'2 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 90 16 90 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 91 26 91 58
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 93 20 93 89
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 602 18 602 32
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed'2] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'7 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:as_mut 'self_' type invariant] [%#sboxed] inv'6 self_}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'8 result}
      {[%#sboxed'0] self_.current = result.current}
      {[%#sboxed'1] self_.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  predicate invariant''3 (self: t_Tree) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'46] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'10] inv'9 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'11] result = (color self = C_Red)} (! return' {result}) ] 
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_Node
  
  predicate invariant''4 (self: t_Option) =
    [%#sinvariant'0] inv'2 self
  
  predicate inv'10 (_0: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate invariant''5 (self: t_Node) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'11 (_0: t_Node)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Node [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'11 a_0
    end
  
  let rec as_ref (self_:t_Option) (return'  (x:t_Option'1))= {[@expl:as_ref 'self_' type invariant] [%#soption'5] inv'10 self_}
    any
    [ return''0 (result:t_Option'1)-> {inv'12 result}
      {[%#soption'6] self_ = C_None  -> result = C_None'1}
      {[%#soption'7] self_ = C_None \/ (exists r: t_Node. result = C_Some'1 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  
  let rec unwrap'0 (self_:t_Option'1) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'1}
    any [ return''0 (result:t_Node)-> {inv'11 result} {[%#soption'4] C_Some'1 result = self_} (! return' {result}) ] 
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'44] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'61] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'56] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'59] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'43] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'42] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'62] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'57] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'60] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'47] bst_invariant'0 self /\ height_invariant'0 self
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'58] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'45] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 310 4 310 36] (self: t_Node) =
    [%#sred_black_tree'53] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'40] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 268 4 268 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'48] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'41] C_CPN c l r
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'50] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'49] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'52] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'51] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  let rec move_red_left (self:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree'12] inv'8 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree'13] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree'15] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {[%#sred_black_tree'16] inv'8 result}
      {[%#sred_black_tree'17] internal_invariant result.current}
      {[%#sred_black_tree'18] internal_invariant result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] (self.current).t_Node__key = (result.current).t_Node__key}
      {[%#sred_black_tree'21] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'22] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
      /\ le_log k (deep_model (self.current).t_Node__key)  -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'23] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'24] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'25] color_invariant'0 result.final
      /\ (color (result.current).t_Node__right = C_Black  -> (result.final).t_Node__color = C_Black)
       -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Node) =
    resolve'1 _0
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'54] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec balance (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree'26] inv'8 self}
    {[@expl:balance requires #0] [%#sred_black_tree'27] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'28] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__left = C_Red  -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'29] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red  -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'30] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red  -> false}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'31] same_mappings self.current self.final}
      {[%#sred_black_tree'32] internal_invariant self.final}
      {[%#sred_black_tree'33] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'34] color_invariant (self.current).t_Node__left
      /\ color (self.current).t_Node__right = C_Black  -> self.current = self.final}
      {[%#sred_black_tree'35] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'36] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'37] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'38] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  
  predicate invariant''6 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'13 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'13 x]. inv'13 x = invariant''6 x
  
  predicate resolve'3 (self: MutBorrow.t t_Tree) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Tree) =
    resolve'3 _0
  
  predicate postcondition_once (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  predicate resolve'5 (_0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve'5 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  let rec default (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {inv'2 result} {[%#soption'8] result = C_None} (! return' {result}) ]
  
  
  let rec take (dest:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result:t_Option)-> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'6 (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_Option) =
    resolve'6 _0
  
  let rec unwrap'1 (self_:t_Option) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None}
    any [ return''0 (result:t_Node)-> {inv'4 result} {[%#soption'4] C_Some result = self_} (! return' {result}) ] 
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'55] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve'8 v
  
  predicate resolve'10 (_0: t_Tree) =
    resolve'9 _0
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'39] bst_invariant self /\ height_invariant self
  
  predicate inv'14 (_0: tuple)
  
  axiom inv_axiom'12 [@rewrite]: forall x: tuple [inv'14 x]. inv'14 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min_rec[#"red_black_tree.rs" 673 4 673 42] (self:MutBorrow.t t_Tree) (return'  (x:tuple))= {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree] inv'13 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree'0] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree'1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_15 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] 
            s1)
      | s1 = as_mut {_15} (fun (_ret:t_Option'0) ->  [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret:MutBorrow.t t_Node) ->  [ &_13 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'4 _13.current}
        MutBorrow.borrow_final <t_Node> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_12 <- _ret ] 
            -{inv'4 _ret.final}-
             [ &_13 <- { _13 with current = _ret.final } ] 
            s1)
      | s1 = as_mut'0 {_12} (fun (_ret:MutBorrow.t t_Node) ->  [ &node <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = any
        [ br0 -> {((node.current).t_Node__left).t_Tree__node = C_None} (! bb4)
        | br1 (x0:t_Node)-> {((node.current).t_Node__left).t_Tree__node = C_Some x0} (! bb10) ]
       ]
    
    | bb10 = s0 [ s0 = is_red {(node.current).t_Node__left} (fun (_ret:bool) ->  [ &_26 <- _ret ] s1) | s1 = bb11 ] 
    | bb11 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = as_ref {((node.current).t_Node__left).t_Tree__node} (fun (_ret:t_Option'1) ->  [ &_31 <- _ret ] s1)
      | s1 = bb14 ]
    
    | bb14 = s0 [ s0 = unwrap'0 {_31} (fun (_ret:t_Node) ->  [ &_30 <- _ret ] s1) | s1 = bb15 ] 
    | bb15 = s0 [ s0 = is_red {_30.t_Node__left} (fun (_ret:bool) ->  [ &_28 <- _ret ] s1) | s1 = bb16 ] 
    | bb16 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_35 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = move_red_left {_35} (fun (_ret:MutBorrow.t t_Node) ->  [ &_34 <- _ret ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0
      [ s0 = {inv'3 _34.current}
        MutBorrow.borrow_final <t_Node> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_33 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_34 <- { _34 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 =  [ &node <- _33 ] s4
      | s4 = {[@expl:type invariant] inv'8 _34} s5
      | s5 = -{resolve'2 _34}- s6
      | s6 = bb21 ]
    
    | bb21 = s0
      [ s0 = {inv'1 (node.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__left}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_37 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] 
            s1)
      | s1 = delete_min_rec {_37} (fun (_ret:tuple) ->  [ &r <- _ret ] s2)
      | s2 = bb22 ]
    
    | bb22 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_39 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = balance {_39} (fun (_ret:()) ->  [ &_38 <- _ret ] s2)
      | s2 = bb23 ]
    
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb24 ]
    
    | bb24 = bb26
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'8 node} s1 | s1 = -{resolve'2 node}- s2 | s2 = bb5 ] 
    | bb5 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {(self'0.current).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_22 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] 
            s1)
      | s1 = {inv'2 _22.current}
        MutBorrow.borrow_final <t_Option> {_22.current} {MutBorrow.get_id _22}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_21 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &_22 <- { _22 with current = _ret.final } ] 
            s2)
      | s2 = take {_21} (fun (_ret:t_Option) ->  [ &_20 <- _ret ] s3)
      | s3 = bb6 ]
    
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'5 _22} s1
      | s1 = -{resolve'7 _22}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 = unwrap'1 {_20} (fun (_ret:t_Node) ->  [ &node'0 <- _ret ] s5)
      | s5 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] match node'0 with
          | {t_Node__right = x} -> inv'1 x
          | _ -> true
          end}
        s1
      | s1 = -{match node'0 with
          | {t_Node__right = x} -> resolve'10 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node'0 with
          | {t_Node__left = x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match node'0 with
          | {t_Node__left = x} -> resolve'10 x
          | _ -> true
          end}-
        s4
      | s4 =  [ &_0 <- { _p0 = node'0.t_Node__key; _p1 = node'0.t_Node__val } ] s5
      | s5 = bb8 ]
    
    | bb8 = bb9
    | bb9 = bb25
    | bb25 = bb26
    | bb26 = return''0 {_0} ]
    )
    [ & _0: tuple = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _12: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _20: t_Option = Any.any_l ()
    | & _21: MutBorrow.t t_Option = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: t_Node = Any.any_l ()
    | & _31: t_Option'1 = Any.any_l ()
    | & _33: MutBorrow.t t_Node = Any.any_l ()
    | & _34: MutBorrow.t t_Node = Any.any_l ()
    | & _35: MutBorrow.t t_Node = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _37: MutBorrow.t t_Tree = Any.any_l ()
    | & _38: () = Any.any_l ()
    | & _39: MutBorrow.t t_Node = Any.any_l () ]
    
    [ return''0 (result:tuple)-> {[@expl:delete_min_rec result type invariant] [%#sred_black_tree'2] inv'14 result}
      {[@expl:delete_min_rec ensures #0] [%#sred_black_tree'3] internal_invariant'0 self.final}
      {[@expl:delete_min_rec ensures #1] [%#sred_black_tree'4] height self.current = height self.final}
      {[@expl:delete_min_rec ensures #2] [%#sred_black_tree'5] has_mapping self.current (deep_model result._p0) result._p1}
      {[@expl:delete_min_rec ensures #3] [%#sred_black_tree'6] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
       -> le_log (deep_model result._p0) k}
      {[@expl:delete_min_rec ensures #4] [%#sred_black_tree'7] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
      = (deep_model result._p0 <> k /\ has_mapping self.current k v)}
      {[@expl:delete_min_rec ensures #5] [%#sred_black_tree'8] color_invariant self.final}
      {[@expl:delete_min_rec ensures #6] [%#sred_black_tree'9] color self.current = C_Black
       -> color self.final = C_Black}
      (! return' {result}) ]

end
module M_red_black_tree__qyi3529752165842986389__delete_rec [#"red_black_tree.rs" 699 4 699 55] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 729 24 729 59
  let%span sred_black_tree'0 = "red_black_tree.rs" 699 23 699 27
  let%span sred_black_tree'1 = "red_black_tree.rs" 699 29 699 32
  let%span sred_black_tree'2 = "red_black_tree.rs" 687 15 687 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 688 15 689 62
  let%span sred_black_tree'4 = "red_black_tree.rs" 699 41 699 55
  let%span sred_black_tree'5 = "red_black_tree.rs" 690 14 690 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 691 14 691 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 692 14 695 5
  let%span sred_black_tree'8 = "red_black_tree.rs" 696 14 696 127
  let%span sred_black_tree'9 = "red_black_tree.rs" 697 14 697 39
  let%span sred_black_tree'10 = "red_black_tree.rs" 698 14 698 67
  let%span sred_black_tree'11 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'12 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'13 = "red_black_tree.rs" 429 25 429 29
  let%span sred_black_tree'14 = "red_black_tree.rs" 417 15 417 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 418 15 418 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 419 14 419 42
  let%span sred_black_tree'17 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'18 = "red_black_tree.rs" 421 14 421 50
  let%span sred_black_tree'19 = "red_black_tree.rs" 422 14 422 65
  let%span sred_black_tree'20 = "red_black_tree.rs" 423 14 423 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 424 14 424 44
  let%span sred_black_tree'22 = "red_black_tree.rs" 425 14 428 34
  let%span sred_black_tree'23 = "red_black_tree.rs" 588 27 588 31
  let%span sred_black_tree'24 = "red_black_tree.rs" 570 15 570 40
  let%span sred_black_tree'25 = "red_black_tree.rs" 571 15 571 43
  let%span sred_black_tree'26 = "red_black_tree.rs" 572 15 572 86
  let%span sred_black_tree'27 = "red_black_tree.rs" 588 36 588 45
  let%span sred_black_tree'28 = "red_black_tree.rs" 573 14 573 44
  let%span sred_black_tree'29 = "red_black_tree.rs" 574 14 576 46
  let%span sred_black_tree'30 = "red_black_tree.rs" 577 14 577 95
  let%span sred_black_tree'31 = "red_black_tree.rs" 578 14 578 42
  let%span sred_black_tree'32 = "red_black_tree.rs" 579 14 579 103
  let%span sred_black_tree'33 = "red_black_tree.rs" 580 14 581 45
  let%span sred_black_tree'34 = "red_black_tree.rs" 582 14 583 106
  let%span sred_black_tree'35 = "red_black_tree.rs" 584 14 585 61
  let%span sred_black_tree'36 = "red_black_tree.rs" 586 14 587 43
  let%span sred_black_tree'37 = "red_black_tree.rs" 673 27 673 31
  let%span sred_black_tree'38 = "red_black_tree.rs" 662 15 662 43
  let%span sred_black_tree'39 = "red_black_tree.rs" 663 15 664 62
  let%span sred_black_tree'40 = "red_black_tree.rs" 673 36 673 42
  let%span sred_black_tree'41 = "red_black_tree.rs" 665 14 665 42
  let%span sred_black_tree'42 = "red_black_tree.rs" 666 14 666 50
  let%span sred_black_tree'43 = "red_black_tree.rs" 667 14 667 66
  let%span sred_black_tree'44 = "red_black_tree.rs" 668 14 668 102
  let%span sred_black_tree'45 = "red_black_tree.rs" 669 14 670 71
  let%span sred_black_tree'46 = "red_black_tree.rs" 671 14 671 39
  let%span sred_black_tree'47 = "red_black_tree.rs" 672 14 672 67
  let%span sred_black_tree'48 = "red_black_tree.rs" 119 15 119 35
  let%span sred_black_tree'49 = "red_black_tree.rs" 120 15 120 38
  let%span sred_black_tree'50 = "red_black_tree.rs" 121 15 121 38
  let%span sred_black_tree'51 = "red_black_tree.rs" 122 14 122 22
  let%span sred_black_tree'52 = "red_black_tree.rs" 128 12 128 37
  let%span sred_black_tree'53 = "red_black_tree.rs" 559 26 559 30
  let%span sred_black_tree'54 = "red_black_tree.rs" 541 15 541 41
  let%span sred_black_tree'55 = "red_black_tree.rs" 542 15 542 43
  let%span sred_black_tree'56 = "red_black_tree.rs" 543 15 543 86
  let%span sred_black_tree'57 = "red_black_tree.rs" 559 35 559 44
  let%span sred_black_tree'58 = "red_black_tree.rs" 544 14 544 44
  let%span sred_black_tree'59 = "red_black_tree.rs" 545 14 547 46
  let%span sred_black_tree'60 = "red_black_tree.rs" 548 14 548 95
  let%span sred_black_tree'61 = "red_black_tree.rs" 549 14 549 42
  let%span sred_black_tree'62 = "red_black_tree.rs" 550 14 550 103
  let%span sred_black_tree'63 = "red_black_tree.rs" 551 14 552 45
  let%span sred_black_tree'64 = "red_black_tree.rs" 553 14 554 106
  let%span sred_black_tree'65 = "red_black_tree.rs" 555 14 556 61
  let%span sred_black_tree'66 = "red_black_tree.rs" 557 14 558 43
  let%span sred_black_tree'67 = "red_black_tree.rs" 527 20 527 24
  let%span sred_black_tree'68 = "red_black_tree.rs" 508 15 508 43
  let%span sred_black_tree'69 = "red_black_tree.rs" 509 15 510 45
  let%span sred_black_tree'70 = "red_black_tree.rs" 511 15 512 46
  let%span sred_black_tree'71 = "red_black_tree.rs" 513 15 513 108
  let%span sred_black_tree'72 = "red_black_tree.rs" 514 14 514 42
  let%span sred_black_tree'73 = "red_black_tree.rs" 515 14 515 42
  let%span sred_black_tree'74 = "red_black_tree.rs" 516 14 516 50
  let%span sred_black_tree'75 = "red_black_tree.rs" 517 14 518 32
  let%span sred_black_tree'76 = "red_black_tree.rs" 519 14 520 37
  let%span sred_black_tree'77 = "red_black_tree.rs" 521 14 522 61
  let%span sred_black_tree'78 = "red_black_tree.rs" 523 14 524 59
  let%span sred_black_tree'79 = "red_black_tree.rs" 525 14 526 37
  let%span sred_black_tree'80 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'81 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'82 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'83 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'84 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'85 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'86 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'87 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'88 = "red_black_tree.rs" 396 12 396 59
  let%span sred_black_tree'89 = "red_black_tree.rs" 148 12 148 89
  let%span sred_black_tree'90 = "red_black_tree.rs" 350 14 351 75
  let%span sred_black_tree'91 = "red_black_tree.rs" 354 12 357 13
  let%span sred_black_tree'92 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'93 = "red_black_tree.rs" 270 12 273 13
  let%span sred_black_tree'94 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'95 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'96 = "red_black_tree.rs" 311 8 311 112
  let%span sred_black_tree'97 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'98 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'99 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'100 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'101 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'102 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'103 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'104 = "red_black_tree.rs" 217 8 219 9
  let%span sred_black_tree'105 = "red_black_tree.rs" 368 8 368 115
  let%span sred_black_tree'106 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'107 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'108 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'109 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'110 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'111 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'112 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'113 = "red_black_tree.rs" 363 20 363 61
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 47 16 47 17
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 48 26 48 43
  let%span sboxed'1 = "../../creusot-contracts/src/std/boxed.rs" 49 26 49 43
  let%span sboxed'2 = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 81 16 81 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 82 26 82 51
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 90 16 90 17
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 91 26 91 58
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 93 20 93 89
  let%span soption'10 = "../../creusot-contracts/src/std/option.rs" 602 18 602 32
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 158 14 158 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 163 14 163 101
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 168 14 168 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 122 15 122 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 123 14 123 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 128 14 128 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 134 15 134 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 135 14 135 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 140 14 141 105
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed'2] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'6 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'7 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:as_mut 'self_' type invariant] [%#sboxed] inv'6 self_}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'8 result}
      {[%#sboxed'0] self_.current = result.current}
      {[%#sboxed'1] self_.final = result.final}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  type tuple  =
    { _p0: t_K; _p1: t_K }
  
  predicate invariant''3 (self: t_K) =
    [%#sinvariant'0] inv self
  
  predicate inv'9 (_0: t_K)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_K [inv'9 x]. inv'9 x = invariant''3 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'9 rhs
  /\ inv'9 self_)  -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef: forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_:t_K) (rhs:t_K) (return'  (x:t_Ordering))= {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                       _p1 = rhs }}
    any
    [ return''0 (result:t_Ordering)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  predicate invariant''4 (self: t_Tree) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'10 (_0: t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Tree [inv'10 x]. inv'10 x = invariant''4 x
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'87] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'11] inv'10 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'12] result = (color self = C_Red)} (! return' {result}) ] 
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'85] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'106] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'97] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 216 4 216 34] (self: t_Node) =
    [%#sred_black_tree'104] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'84] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'83] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'113] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'102] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 367 4 367 37] (self: t_Node) =
    [%#sred_black_tree'105] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 394 4 394 39] (self: t_Node) =
    [%#sred_black_tree'88] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'95] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'94] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 146 4 146 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'89] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 352 4 352 26] (self: t_Node) : int =
    [%#sred_black_tree'91] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'90] forall node: t_Node. self = node
   -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple'0  =
    { _p0'0: t_Tree; _p1'0: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'13] inv'8 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'15] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'16] same_mappings self.current self.final}
      {[%#sred_black_tree'17] internal_invariant self.final}
      {[%#sred_black_tree'18] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'19] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'20] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'21] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'22] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
      /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
      /\ { _p0'0 = (self.final).t_Node__left; _p1'0 = r.t_Node__left; _p2 = r.t_Node__right }
      = { _p0'0 = l.t_Node__left; _p1'0 = l.t_Node__right; _p2 = (self.current).t_Node__right }
      /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  
  type tuple'1  =
    { _p0'1: t_K; _p1'1: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 tuple'1
  
  predicate invariant''5 (self: t_Option) =
    [%#sinvariant'0] inv'2 self
  
  predicate inv'11 (_0: t_Option)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Option [inv'11 x]. inv'11 x = invariant''5 x
  
  let rec is_none (self_:t_Option) (return'  (x:bool))= {[@expl:is_none 'self_' type invariant] [%#soption'5] inv'11 self_}
    any [ return''0 (result:bool)-> {[%#soption'6] result = (self_ = C_None)} (! return' {result}) ] 
  
  predicate resolve'1 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Node) =
    resolve'1 _0
  
  predicate postcondition_once'0 (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  predicate resolve'3 (_0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once'0 self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once'0 self args res
  = (postcondition self args res /\ resolve'3 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec: forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  let rec default (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {inv'2 result} {[%#soption'10] result = C_None} (! return' {result}) ]
  
  
  let rec take (dest:MutBorrow.t t_Option) (return'  (x:t_Option))= {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result:t_Option)-> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  
  predicate resolve'4 (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'5 (_0: MutBorrow.t t_Option) =
    resolve'4 _0
  
  predicate invariant''6 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'12 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'12 x]. inv'12 x = invariant''6 x
  
  predicate resolve'6 (self: MutBorrow.t t_Tree) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'7 (_0: MutBorrow.t t_Tree) =
    resolve'6 _0
  
  let rec unwrap'0 (self_:t_Option) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None}
    any [ return''0 (result:t_Node)-> {inv'4 result} {[%#soption'4] C_Some result = self_} (! return' {result}) ] 
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'92] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve'8 v
  
  predicate resolve'10 (_0: t_Tree) =
    resolve'9 _0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_Node
  
  predicate invariant''7 (self: t_Node) =
    [%#sinvariant'0] inv'4 self
  
  predicate inv'13 (_0: t_Node)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Node [inv'13 x]. inv'13 x = invariant''7 x
  
  predicate inv'14 (_0: t_Option'2)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'2 [inv'14 x]. inv'14 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'13 a_0
    end
  
  let rec as_ref (self_:t_Option) (return'  (x:t_Option'2))= {[@expl:as_ref 'self_' type invariant] [%#soption'7] inv'11 self_}
    any
    [ return''0 (result:t_Option'2)-> {inv'14 result}
      {[%#soption'8] self_ = C_None  -> result = C_None'2}
      {[%#soption'9] self_ = C_None \/ (exists r: t_Node. result = C_Some'2 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  
  let rec unwrap'1 (self_:t_Option'2) (return'  (x:t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'14 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'2}
    any [ return''0 (result:t_Node)-> {inv'13 result} {[%#soption'4] C_Some'2 result = self_} (! return' {result}) ] 
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'103] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'86] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 310 4 310 36] (self: t_Node) =
    [%#sred_black_tree'96] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'81] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 268 4 268 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'93] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'82] C_CPN c l r
  
  let rec move_red_right (self:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree'23] inv'8 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree'24] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] [%#sred_black_tree'25] internal_invariant self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree'26] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {[%#sred_black_tree'27] inv'8 result}
      {[%#sred_black_tree'28] internal_invariant result.current}
      {[%#sred_black_tree'29] internal_invariant result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant self.final}
      {[%#sred_black_tree'30] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'31] (result.current).t_Node__key = (self.current).t_Node__key}
      {[%#sred_black_tree'32] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'33] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
      /\ le_log (deep_model (self.current).t_Node__key) k  -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'34] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'35] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'36] color_invariant'0 result.final
      /\ (color (result.current).t_Node__left = C_Black  -> (result.final).t_Node__color = C_Black)
       -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'80] bst_invariant self /\ height_invariant self
  
  predicate inv'15 (_0: tuple'1)
  
  axiom inv_axiom'13 [@rewrite]: forall x: tuple'1 [inv'15 x]. inv'15 x
  = (let {_p0'1 = x0 ; _p1'1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_min_rec (self:MutBorrow.t t_Tree) (return'  (x:tuple'1))= {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree'37] inv'12 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree'38] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree'39] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result:tuple'1)-> {[%#sred_black_tree'40] inv'15 result}
      {[%#sred_black_tree'41] internal_invariant'0 self.final}
      {[%#sred_black_tree'42] height self.current = height self.final}
      {[%#sred_black_tree'43] has_mapping self.current (deep_model result._p0'1) result._p1'1}
      {[%#sred_black_tree'44] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
       -> le_log (deep_model result._p0'1) k}
      {[%#sred_black_tree'45] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
      = (deep_model result._p0'1 <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'46] color_invariant self.final}
      {[%#sred_black_tree'47] color self.current = C_Black  -> color self.final = C_Black}
      (! return' {result}) ]
  
  
  type t_Option'3  =
    | C_None'3
    | C_Some'3 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) : Map.map t_DeepModelTy t_Option'3
  
   =
    [%#sred_black_tree'112] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'3 =
    [%#sred_black_tree'101] model_acc self (Const.const (C_None'3))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'108] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'3, k: t_DeepModelTy. [%#sred_black_tree'107] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'3 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'111] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'3, k: t_DeepModelTy. ([%#sred_black_tree'109] bst_invariant self)
   -> ([%#sred_black_tree'110] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'3 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'100] let _ = model_acc_has_mapping self (Const.const (C_None'3)) k in has_mapping_model_acc self (Const.const (C_None'3)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'98] bst_invariant self)
   -> ([%#sred_black_tree'99] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'3 v))
  
  function has_mapping_inj [#"red_black_tree.rs" 123 4 125 33] (self: t_Tree) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : ()
  
   =
    [%#sred_black_tree'52] let _ = has_mapping_model self k in match Map.get (view self) k with
      | C_None'3 -> ()
      | C_Some'3 _v -> ()
      end
  
  axiom has_mapping_inj_spec: forall self: t_Tree, k: t_DeepModelTy, v1: t_V, v2: t_V. ([%#sred_black_tree'48] bst_invariant self)
   -> ([%#sred_black_tree'49] has_mapping self k v1)
   -> ([%#sred_black_tree'50] has_mapping self k v2)  -> ([%#sred_black_tree'51] v1 = v2)
  
  predicate invariant''8 (self: MutBorrow.t t_K) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'16 (_0: MutBorrow.t t_K)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_K [inv'16 x]. inv'16 x = invariant''8 x
  
  let rec swap (x:MutBorrow.t t_K) (y:MutBorrow.t t_K) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'2] inv'16 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'16 y}
    any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'11 (self: MutBorrow.t t_K) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'12 (_0: MutBorrow.t t_K) =
    resolve'11 _0
  
  predicate invariant''9 (self: MutBorrow.t t_V) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'17 (_0: MutBorrow.t t_V)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_V [inv'17 x]. inv'17 x = invariant''9 x
  
  let rec swap'0 (x:MutBorrow.t t_V) (y:MutBorrow.t t_V) (return'  (x'0:()))= {[@expl:swap 'x' type invariant] [%#smem'2] inv'17 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'17 y}
    any
    [ return''0 (result:())-> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  
  predicate resolve'13 (self: MutBorrow.t t_V) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'14 (_0: MutBorrow.t t_V) =
    resolve'13 _0
  
  let rec move_red_left (self:MutBorrow.t t_Node) (return'  (x:MutBorrow.t t_Node))= {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree'53] inv'8 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree'54] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] [%#sred_black_tree'55] internal_invariant self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree'56] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {[%#sred_black_tree'57] inv'8 result}
      {[%#sred_black_tree'58] internal_invariant result.current}
      {[%#sred_black_tree'59] internal_invariant result.final
      /\ height'0 result.current = height'0 result.final
      /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v  -> has_mapping'0 result.current k v)
       -> internal_invariant self.final}
      {[%#sred_black_tree'60] height'0 result.current = height'0 result.final
       -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'61] (self.current).t_Node__key = (result.current).t_Node__key}
      {[%#sred_black_tree'62] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
       -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'63] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
      /\ le_log k (deep_model (self.current).t_Node__key)  -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'64] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
      = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'65] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'66] color_invariant'0 result.final
      /\ (color (result.current).t_Node__right = C_Black  -> (result.final).t_Node__color = C_Black)
       -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  
  let rec balance (self:MutBorrow.t t_Node) (return'  (x:()))= {[@expl:balance 'self' type invariant] [%#sred_black_tree'67] inv'8 self}
    {[@expl:balance requires #0] [%#sred_black_tree'68] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'69] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__left = C_Red  -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'70] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red  -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'71] (self.current).t_Node__color = C_Red
    /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red  -> false}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'72] same_mappings self.current self.final}
      {[%#sred_black_tree'73] internal_invariant self.final}
      {[%#sred_black_tree'74] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'75] color_invariant (self.current).t_Node__left
      /\ color (self.current).t_Node__right = C_Black  -> self.current = self.final}
      {[%#sred_black_tree'76] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'77] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'78] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
       -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'79] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
       -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  
  predicate inv'18 (_0: t_Option'1)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Option'1 [inv'18 x]. inv'18 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'15 a_0
    end
  
  function deep_model'0 (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  let rec delete_rec[#"red_black_tree.rs" 699 4 699 55] (self:MutBorrow.t t_Tree) (key:t_K) (return'  (x:t_Option'1))= {[@expl:delete_rec 'self' type invariant] [%#sred_black_tree'0] inv'12 self}
    {[@expl:delete_rec 'key' type invariant] [%#sred_black_tree'1] inv'9 key}
    {[@expl:delete_rec requires #0] [%#sred_black_tree'2] internal_invariant'0 self.current}
    {[@expl:delete_rec requires #1] [%#sred_black_tree'3] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_16 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] 
            s1)
      | s1 = as_mut {_16} (fun (_ret:t_Option'0) ->  [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 = unwrap {_15} (fun (_ret:MutBorrow.t t_Node) ->  [ &_14 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = {inv'4 _14.current}
        MutBorrow.borrow_final <t_Node> {_14.current} {MutBorrow.get_id _14}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_13 <- _ret ] 
            -{inv'4 _ret.final}-
             [ &_14 <- { _14 with current = _ret.final } ] 
            s1)
      | s1 = as_mut'0 {_13} (fun (_ret:MutBorrow.t t_Node) ->  [ &node <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 =  [ &_21 <- (node.current).t_Node__key ] s3
      | s3 = cmp {key'0} {_21} (fun (_ret:t_Ordering) ->  [ &_18 <- _ret ] s4)
      | s4 = bb4 ]
    
    | bb4 = any [ br0 -> {_18 = C_Less} (! bb6) | br1 -> {_18 = C_Equal} (! bb5) | br2 -> {_18 = C_Greater} (! bb5) ] 
    | bb5 = s0
      [ s0 =  [ &ord <- _18 ] s1
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret:bool) ->  [ &_42 <- _ret ] s2)
      | s2 = bb26 ]
    
    | bb26 = any [ br0 -> {_42 = false} (! bb33) | br1 -> {_42} (! bb27) ] 
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node> {node.current}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_45 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = rotate_right {_45} (fun (_ret:()) ->  [ &_44 <- _ret ] s2)
      | s2 = bb28 ]
    
    | bb28 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_47 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] 
            s1)
      | s1 = delete_rec {_47} {key'0} (fun (_ret:t_Option'1) ->  [ &_46 <- _ret ] s2)
      | s2 = bb29 ]
    
    | bb29 = bb30
    | bb30 = s0 [ s0 =  [ &r <- _46 ] s1 | s1 = bb32 ] 
    | bb32 = bb68
    | bb33 = s0
      [ s0 = is_none {((node.current).t_Node__right).t_Tree__node} (fun (_ret:bool) ->  [ &_50 <- _ret ] s1)
      | s1 = bb34 ]
    
    | bb34 = any [ br0 -> {_50 = false} (! bb44) | br1 -> {_50} (! bb35) ] 
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = any
        [ br0 -> {ord = C_Less} (! bb38) | br1 -> {ord = C_Equal} (! bb38) | br2 -> {ord = C_Greater} (! bb36) ]
       ]
    
    | bb38 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {(self'0.current).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_59 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] 
            s1)
      | s1 = {inv'2 _59.current}
        MutBorrow.borrow_final <t_Option> {_59.current} {MutBorrow.get_id _59}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_58 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &_59 <- { _59 with current = _ret.final } ] 
            s2)
      | s2 = take {_58} (fun (_ret:t_Option) ->  [ &_57 <- _ret ] s3)
      | s3 = bb39 ]
    
    | bb39 = s0
      [ s0 = {[@expl:type invariant] inv'5 _59} s1
      | s1 = -{resolve'5 _59}- s2
      | s2 = {[@expl:type invariant] inv'12 self'0} s3
      | s3 = -{resolve'7 self'0}- s4
      | s4 = unwrap'0 {_57} (fun (_ret:t_Node) ->  [ &node'0 <- _ret ] s5)
      | s5 = bb40 ]
    
    | bb40 = s0
      [ s0 = {[@expl:type invariant] match node'0 with
          | {t_Node__right = x} -> inv'1 x
          | _ -> true
          end}
        s1
      | s1 = -{match node'0 with
          | {t_Node__right = x} -> resolve'10 x
          | _ -> true
          end}-
        s2
      | s2 = {[@expl:type invariant] match node'0 with
          | {t_Node__left = x} -> inv'1 x
          | _ -> true
          end}
        s3
      | s3 = -{match node'0 with
          | {t_Node__left = x} -> resolve'10 x
          | _ -> true
          end}-
        s4
      | s4 =  [ &_60 <- { _p0'1 = node'0.t_Node__key; _p1'1 = node'0.t_Node__val } ] s5
      | s5 = bb41 ]
    
    | bb41 = bb42
    | bb42 = s0 [ s0 =  [ &_0 <- C_Some'1 _60 ] s1 | s1 = bb43 ] 
    | bb43 = bb72
    | bb72 = bb73
    | bb36 = s0 [ s0 = {[@expl:type invariant] inv'12 self'0} s1 | s1 = -{resolve'7 self'0}- s2 | s2 = bb37 ] 
    | bb37 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb73 ] 
    | bb73 = bb74
    | bb44 = s0
      [ s0 = as_ref {((node.current).t_Node__right).t_Tree__node} (fun (_ret:t_Option'2) ->  [ &_67 <- _ret ] s1)
      | s1 = bb45 ]
    
    | bb45 = s0 [ s0 = unwrap'1 {_67} (fun (_ret:t_Node) ->  [ &_66 <- _ret ] s1) | s1 = bb46 ] 
    | bb46 = s0 [ s0 = is_red {_66.t_Node__left} (fun (_ret:bool) ->  [ &_64 <- _ret ] s1) | s1 = bb47 ] 
    | bb47 = any [ br0 -> {_64 = false} (! bb49) | br1 -> {_64} (! bb48) ] 
    | bb48 = bb51
    | bb49 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_71 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = move_red_right {_71} (fun (_ret:MutBorrow.t t_Node) ->  [ &_70 <- _ret ] s2)
      | s2 = bb50 ]
    
    | bb50 = s0
      [ s0 = {inv'3 _70.current}
        MutBorrow.borrow_final <t_Node> {_70.current} {MutBorrow.get_id _70}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_69 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_70 <- { _70 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 =  [ &node <- _69 ] s4
      | s4 = {[@expl:type invariant] inv'8 _70} s5
      | s5 = -{resolve'2 _70}- s6
      | s6 = bb51 ]
    
    | bb51 = any
      [ br0 -> {ord = C_Less} (! bb63) | br1 -> {ord = C_Equal} (! bb52) | br2 -> {ord = C_Greater} (! bb63) ]
    
    | bb63 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_90 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] 
            s1)
      | s1 = delete_rec {_90} {key'0} (fun (_ret:t_Option'1) ->  [ &_89 <- _ret ] s2)
      | s2 = bb64 ]
    
    | bb64 = bb65
    | bb65 = s0 [ s0 =  [ &r <- _89 ] s1 | s1 = bb67 ] 
    | bb67 = bb68
    | bb52 = bb53
    | bb53 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_74 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] 
            s1)
      | s1 = delete_min_rec {_74} (fun (_ret:tuple'1) ->  [ &kv <- _ret ] s2)
      | s2 = bb54 ]
    
    | bb54 = s0 [ s0 =  [ &_75 <- [%#sred_black_tree] () ] s1 | s1 = bb55 ] 
    | bb55 = s0
      [ s0 = {inv (node.current).t_Node__key}
        MutBorrow.borrow_mut <t_K> {(node.current).t_Node__key}
          (fun (_ret:MutBorrow.t t_K) ->
             [ &_79 <- _ret ] 
            -{inv _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__key = _ret.final } } ] 
            s1)
      | s1 = {inv kv._p0'1}
        MutBorrow.borrow_mut <t_K> {kv._p0'1}
          (fun (_ret:MutBorrow.t t_K) ->
             [ &_81 <- _ret ] 
            -{inv _ret.final}-
             [ &kv <- { kv with _p0'1 = _ret.final } ] 
            s2)
      | s2 = {inv _79.current}
        MutBorrow.borrow_final <t_K> {_79.current} {MutBorrow.get_id _79}
          (fun (_ret:MutBorrow.t t_K) ->
             [ &_78 <- _ret ] 
            -{inv _ret.final}-
             [ &_79 <- { _79 with current = _ret.final } ] 
            s3)
      | s3 = {inv _81.current}
        MutBorrow.borrow_final <t_K> {_81.current} {MutBorrow.get_id _81}
          (fun (_ret:MutBorrow.t t_K) ->
             [ &_80 <- _ret ] 
            -{inv _ret.final}-
             [ &_81 <- { _81 with current = _ret.final } ] 
            s4)
      | s4 = swap {_78} {_80} (fun (_ret:()) ->  [ &_77 <- _ret ] s5)
      | s5 = bb56 ]
    
    | bb56 = s0
      [ s0 = {[@expl:type invariant] inv'16 _81} s1
      | s1 = -{resolve'12 _81}- s2
      | s2 = {[@expl:type invariant] inv'16 _79} s3
      | s3 = -{resolve'12 _79}- s4
      | s4 = {inv'0 (node.current).t_Node__val}
        MutBorrow.borrow_mut <t_V> {(node.current).t_Node__val}
          (fun (_ret:MutBorrow.t t_V) ->
             [ &_84 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__val = _ret.final } } ] 
            s5)
      | s5 = {inv'0 kv._p1'1}
        MutBorrow.borrow_mut <t_V> {kv._p1'1}
          (fun (_ret:MutBorrow.t t_V) ->
             [ &_86 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &kv <- { kv with _p1'1 = _ret.final } ] 
            s6)
      | s6 = {inv'0 _84.current}
        MutBorrow.borrow_final <t_V> {_84.current} {MutBorrow.get_id _84}
          (fun (_ret:MutBorrow.t t_V) ->
             [ &_83 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_84 <- { _84 with current = _ret.final } ] 
            s7)
      | s7 = {inv'0 _86.current}
        MutBorrow.borrow_final <t_V> {_86.current} {MutBorrow.get_id _86}
          (fun (_ret:MutBorrow.t t_V) ->
             [ &_85 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_86 <- { _86 with current = _ret.final } ] 
            s8)
      | s8 = swap'0 {_83} {_85} (fun (_ret:()) ->  [ &_82 <- _ret ] s9)
      | s9 = bb57 ]
    
    | bb57 = s0
      [ s0 = {[@expl:type invariant] inv'17 _86} s1
      | s1 = -{resolve'14 _86}- s2
      | s2 = {[@expl:type invariant] inv'17 _84} s3
      | s3 = -{resolve'14 _84}- s4
      | s4 =  [ &_87 <- C_Some'1 kv ] s5
      | s5 = bb58 ]
    
    | bb58 = bb59
    | bb59 = s0 [ s0 =  [ &r <- _87 ] s1 | s1 = bb61 ] 
    | bb61 = bb62
    | bb62 = bb68
    | bb68 = bb69
    | bb6 = bb7
    | bb7 = s0
      [ s0 = is_none {((node.current).t_Node__left).t_Tree__node} (fun (_ret:bool) ->  [ &_24 <- _ret ] s1) | s1 = bb8 ]
    
    | bb8 = any [ br0 -> {_24 = false} (! bb10) | br1 -> {_24} (! bb9) ] 
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'12 self'0} s3
      | s3 = -{resolve'7 self'0}- s4
      | s4 =  [ &_0 <- C_None'1 ] s5
      | s5 = bb74 ]
    
    | bb74 = bb75
    | bb75 = bb76
    | bb10 = s0 [ s0 = is_red {(node.current).t_Node__left} (fun (_ret:bool) ->  [ &_28 <- _ret ] s1) | s1 = bb11 ] 
    | bb11 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb12) ] 
    | bb12 = bb20
    | bb13 = s0
      [ s0 = as_ref {((node.current).t_Node__left).t_Tree__node} (fun (_ret:t_Option'2) ->  [ &_33 <- _ret ] s1)
      | s1 = bb14 ]
    
    | bb14 = s0 [ s0 = unwrap'1 {_33} (fun (_ret:t_Node) ->  [ &_32 <- _ret ] s1) | s1 = bb15 ] 
    | bb15 = s0 [ s0 = is_red {_32.t_Node__left} (fun (_ret:bool) ->  [ &_30 <- _ret ] s1) | s1 = bb16 ] 
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb17) ] 
    | bb17 = bb20
    | bb20 = bb21
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_37 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = move_red_left {_37} (fun (_ret:MutBorrow.t t_Node) ->  [ &_36 <- _ret ] s2)
      | s2 = bb19 ]
    
    | bb19 = s0
      [ s0 = {inv'3 _36.current}
        MutBorrow.borrow_final <t_Node> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_35 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &_36 <- { _36 with current = _ret.final } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 =  [ &node <- _35 ] s4
      | s4 = {[@expl:type invariant] inv'8 _36} s5
      | s5 = -{resolve'2 _36}- s6
      | s6 = bb21 ]
    
    | bb21 = s0
      [ s0 = {inv'1 (node.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__left}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_39 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] 
            s1)
      | s1 = delete_rec {_39} {key'0} (fun (_ret:t_Option'1) ->  [ &_38 <- _ret ] s2)
      | s2 = bb22 ]
    
    | bb22 = bb23
    | bb23 = s0 [ s0 =  [ &r <- _38 ] s1 | s1 = bb25 ] 
    | bb25 = bb69
    | bb69 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret:MutBorrow.t t_Node) ->
             [ &_93 <- _ret ] 
            -{inv'3 _ret.final}-
             [ &node <- { node with current = _ret.final } ] 
            s1)
      | s1 = balance {_93} (fun (_ret:()) ->  [ &_92 <- _ret ] s2)
      | s2 = bb70 ]
    
    | bb70 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'12 self'0} s3
      | s3 = -{resolve'7 self'0}- s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb71 ]
    
    | bb71 = bb76
    | bb76 = return''0 {_0} ]
    )
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & key'0: t_K = key
    | & r: t_Option'1 = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: MutBorrow.t t_Node = Any.any_l ()
    | & _15: t_Option'0 = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _18: t_Ordering = Any.any_l ()
    | & _21: t_K = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _32: t_Node = Any.any_l ()
    | & _33: t_Option'2 = Any.any_l ()
    | & _35: MutBorrow.t t_Node = Any.any_l ()
    | & _36: MutBorrow.t t_Node = Any.any_l ()
    | & _37: MutBorrow.t t_Node = Any.any_l ()
    | & _38: t_Option'1 = Any.any_l ()
    | & _39: MutBorrow.t t_Tree = Any.any_l ()
    | & ord: t_Ordering = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: () = Any.any_l ()
    | & _45: MutBorrow.t t_Node = Any.any_l ()
    | & _46: t_Option'1 = Any.any_l ()
    | & _47: MutBorrow.t t_Tree = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _57: t_Option = Any.any_l ()
    | & _58: MutBorrow.t t_Option = Any.any_l ()
    | & _59: MutBorrow.t t_Option = Any.any_l ()
    | & _60: tuple'1 = Any.any_l ()
    | & _64: bool = Any.any_l ()
    | & _66: t_Node = Any.any_l ()
    | & _67: t_Option'2 = Any.any_l ()
    | & _69: MutBorrow.t t_Node = Any.any_l ()
    | & _70: MutBorrow.t t_Node = Any.any_l ()
    | & _71: MutBorrow.t t_Node = Any.any_l ()
    | & kv: tuple'1 = Any.any_l ()
    | & _74: MutBorrow.t t_Tree = Any.any_l ()
    | & _75: () = Any.any_l ()
    | & _77: () = Any.any_l ()
    | & _78: MutBorrow.t t_K = Any.any_l ()
    | & _79: MutBorrow.t t_K = Any.any_l ()
    | & _80: MutBorrow.t t_K = Any.any_l ()
    | & _81: MutBorrow.t t_K = Any.any_l ()
    | & _82: () = Any.any_l ()
    | & _83: MutBorrow.t t_V = Any.any_l ()
    | & _84: MutBorrow.t t_V = Any.any_l ()
    | & _85: MutBorrow.t t_V = Any.any_l ()
    | & _86: MutBorrow.t t_V = Any.any_l ()
    | & _87: t_Option'1 = Any.any_l ()
    | & _89: t_Option'1 = Any.any_l ()
    | & _90: MutBorrow.t t_Tree = Any.any_l ()
    | & _92: () = Any.any_l ()
    | & _93: MutBorrow.t t_Node = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:delete_rec result type invariant] [%#sred_black_tree'4] inv'18 result}
      {[@expl:delete_rec ensures #0] [%#sred_black_tree'5] internal_invariant'0 self.final}
      {[@expl:delete_rec ensures #1] [%#sred_black_tree'6] height self.current = height self.final}
      {[@expl:delete_rec ensures #2] [%#sred_black_tree'7] match result with
        | C_None'1 -> forall v: t_V. not has_mapping self.current (deep_model'0 key) v
        | C_Some'1 {_p0'1 = k ; _p1'1 = v} -> deep_model'0 key = deep_model k
        /\ has_mapping self.current (deep_model k) v
        end}
      {[@expl:delete_rec ensures #3] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
      = (deep_model'0 key <> k /\ has_mapping self.current k v)}
      {[@expl:delete_rec ensures #4] [%#sred_black_tree'9] color_invariant self.final}
      {[@expl:delete_rec ensures #5] [%#sred_black_tree'10] color self.current = C_Black  -> color self.final = C_Black}
      (! return' {result}) ]

end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence [#"red_black_tree.rs" 783 4 783 31] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 780 15 780 39
  let%span sred_black_tree'0 = "red_black_tree.rs" 781 14 781 31
  let%span sred_black_tree'1 = "red_black_tree.rs" 784 8 784 39
  let%span sred_black_tree'2 = "red_black_tree.rs" 776 20 776 68
  let%span sred_black_tree'3 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'4 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'5 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'6 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'7 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'8 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'10 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'11 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'13 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'14 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'15 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'16 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'17 = "red_black_tree.rs" 56 12 63 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  
  use map.Map
  use map.Const
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'8] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'15] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve v
  
  predicate resolve'1 (_0: t_Tree) =
    resolve'0 _0
  
  predicate structural_resolve (_0: t_Map) =
    match _0 with
      | {t_Map__0 = x0} -> resolve'1 x0
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  predicate resolve'2 (self: t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  predicate resolve'3 (_0: t_Option'0) =
    resolve'2 _0
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'17] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'9] model_acc self (Const.const (C_None'0))
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'6] view self.t_Map__0
  
  predicate resolve'4 [#"red_black_tree.rs" 775 4 775 28] (self: t_Map) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy. resolve'3 (Map.get (view'0 self) k)
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'16] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'7] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'10] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'14] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'12] bst_invariant self)
   -> ([%#sred_black_tree'13] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'5] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'3] bst_invariant self)
   -> ([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  constant self  : t_Map
  
  function resolve_coherence [#"red_black_tree.rs" 783 4 783 31] (self'0: t_Map) : ()
  
  goal vc_resolve_coherence: ([%#sred_black_tree] structural_resolve self)
   -> (let _ = has_mapping_model in [%#sred_black_tree'0] resolve'4 self)
end
module M_red_black_tree__qyi1722927563742988856__new [#"red_black_tree.rs" 793 4 793 24] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 793 20 793 24
  let%span sred_black_tree'0 = "red_black_tree.rs" 792 14 792 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'2 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'3 = "red_black_tree.rs" 763 8 765 9
  let%span sred_black_tree'4 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'5 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'6 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'8 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'10 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'11 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'12 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'13 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'15 = "red_black_tree.rs" 322 12 330 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'13] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'11] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'8] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'15] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'14] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'12] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'9] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'5] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'7] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'10] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant' [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'3] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color'0 ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant''0 (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  predicate inv'5 (_0: t_Map)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map [inv'5 x]. inv'5 x
  = (invariant' x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'2 a_0
    end)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'4] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'2] model_acc self (Const.const (C_None'0))
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'1] view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  let rec new[#"red_black_tree.rs" 793 4 793 24] (return'  (x:t_Map))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- C_None ] s1 | s1 =  [ &_2 <- { t_Tree__node = _3 } ] s2 | s2 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_0 <- { t_Map__0 = _2 } ] s1 | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: t_Map = Any.any_l () | & _2: t_Tree = Any.any_l () | & _3: t_Option = Any.any_l () ] 
    [ return''0 (result:t_Map)-> {[@expl:new result type invariant] [%#sred_black_tree] inv'5 result}
      {[@expl:new ensures] [%#sred_black_tree'0] view'0 result = Const.const (C_None'0)}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__insert [#"red_black_tree.rs" 798 4 798 44] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 801 8 801 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 798 23 798 27
  let%span sred_black_tree'1 = "red_black_tree.rs" 798 29 798 32
  let%span sred_black_tree'2 = "red_black_tree.rs" 798 37 798 40
  let%span sred_black_tree'3 = "red_black_tree.rs" 797 14 797 64
  let%span sred_black_tree'4 = "red_black_tree.rs" 611 23 611 27
  let%span sred_black_tree'5 = "red_black_tree.rs" 611 29 611 32
  let%span sred_black_tree'6 = "red_black_tree.rs" 611 37 611 40
  let%span sred_black_tree'7 = "red_black_tree.rs" 603 15 603 43
  let%span sred_black_tree'8 = "red_black_tree.rs" 604 15 604 40
  let%span sred_black_tree'9 = "red_black_tree.rs" 605 14 605 42
  let%span sred_black_tree'10 = "red_black_tree.rs" 606 14 606 50
  let%span sred_black_tree'11 = "red_black_tree.rs" 607 14 608 39
  let%span sred_black_tree'12 = "red_black_tree.rs" 609 14 609 56
  let%span sred_black_tree'13 = "red_black_tree.rs" 610 14 610 125
  let%span sred_black_tree'14 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'15 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'16 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'17 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'18 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'19 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'20 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'21 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'22 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'24 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'28 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'29 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'31 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'32 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'33 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'34 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'35 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'36 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'38 = "red_black_tree.rs" 763 8 765 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  predicate invariant''0 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'35] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'26] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'21] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'20] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'37] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'33] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'18] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'24] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'34] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'19] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'22] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'23] C_CPN c l r
  
  let rec insert_rec (self:MutBorrow.t t_Tree) (key:t_K) (val':t_V) (return'  (x:()))= {[@expl:insert_rec 'self' type invariant] [%#sred_black_tree'4] inv'5 self}
    {[@expl:insert_rec 'key' type invariant] [%#sred_black_tree'5] inv key}
    {[@expl:insert_rec 'val' type invariant] [%#sred_black_tree'6] inv'0 val'}
    {[@expl:insert_rec requires #0] [%#sred_black_tree'7] internal_invariant self.current}
    {[@expl:insert_rec requires #1] [%#sred_black_tree'8] color_invariant self.current}
    any
    [ return''0 (result:())-> {[%#sred_black_tree'9] internal_invariant self.final}
      {[%#sred_black_tree'10] height self.current = height self.final}
      {[%#sred_black_tree'11] match_t (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final
      /\ color self.current = C_Red
      \/ color_invariant self.final}
      {[%#sred_black_tree'12] has_mapping self.final (deep_model key) val'}
      {[%#sred_black_tree'13] forall k: t_DeepModelTy, v: t_V. k = deep_model key
      \/ has_mapping self.current k v = has_mapping self.final k v}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'6 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'7 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'0))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'6 self_}
    any
    [ return''0 (result:t_Option'0)-> {inv'8 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'0) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'8 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'7 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  predicate invariant''3 [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'38] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'9 (_0: t_Map)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Map [inv'9 x]. inv'9 x
  = (invariant''3 x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant''4 (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'9 self.current /\ inv'9 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Map [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate resolve'1 (self: MutBorrow.t t_Map) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Map) =
    resolve'1 _0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) : Map.map t_DeepModelTy t_Option'1
  
   =
    [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'1 =
    [%#sred_black_tree'27] model_acc self (Const.const (C_None'1))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'1, k: t_DeepModelTy. [%#sred_black_tree'28] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'1 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'32] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'1, k: t_DeepModelTy. ([%#sred_black_tree'30] bst_invariant self)
   -> ([%#sred_black_tree'31] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'1 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'16] let _ = model_acc_has_mapping self (Const.const (C_None'1)) k in has_mapping_model_acc self (Const.const (C_None'1)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'14] bst_invariant self)
   -> ([%#sred_black_tree'15] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'1 v))
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'1 =
    [%#sred_black_tree'17] view self.t_Map__0
  
  function view'1 (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'1 =
    [%#smodel] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec insert[#"red_black_tree.rs" 798 4 798 44] (self:MutBorrow.t t_Map) (key:t_K) (val':t_V) (return'  (x:()))= {[@expl:insert 'self' type invariant] [%#sred_black_tree'0] inv'10 self}
    {[@expl:insert 'key' type invariant] [%#sred_black_tree'1] inv key}
    {[@expl:insert 'val' type invariant] [%#sred_black_tree'2] inv'0 val'}
    (! bb0
    [ bb0 = bb1
    | bb1 = s0
      [ s0 = {inv'2 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_6 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] 
            s1)
      | s1 = insert_rec {_6} {key'0} {val''0} (fun (_ret:()) ->  [ &_5 <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 =  [ &_9 <- C_Black ] s1
      | s1 = {inv'4 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_12 <- _ret ] 
            -{inv'4 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] 
            s2)
      | s2 = as_mut {_12} (fun (_ret:t_Option'0) ->  [ &_11 <- _ret ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0 [ s0 = unwrap {_11} (fun (_ret:MutBorrow.t t_Node) ->  [ &_10 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 =  [ &_10 <- { _10 with current = { _10.current with t_Node__color = _9 } } ] s1
      | s1 = {[@expl:type invariant] inv'7 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'10 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 =  [ &_13 <- [%#sred_black_tree] () ] s6
      | s6 = bb5 ]
    
    | bb5 = bb6
    | bb6 = bb7
    | bb7 = return''0 {_0} ]
    )
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & key'0: t_K = key
    | & val''0: t_V = val'
    | & _5: () = Any.any_l ()
    | & _6: MutBorrow.t t_Tree = Any.any_l ()
    | & _9: t_Color = Any.any_l ()
    | & _10: MutBorrow.t t_Node = Any.any_l ()
    | & _11: t_Option'0 = Any.any_l ()
    | & _12: MutBorrow.t t_Option = Any.any_l ()
    | & _13: () = Any.any_l () ]
    
    [ return''0 (result:())-> {[@expl:insert ensures] [%#sred_black_tree'3] view'0 self.final
      = Map.set (view'1 self) (deep_model key) (C_Some'1 val')}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__delete_max [#"red_black_tree.rs" 810 4 810 50] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 811 23 811 41
  let%span sred_black_tree'0 = "red_black_tree.rs" 819 8 819 58
  let%span sred_black_tree'1 = "red_black_tree.rs" 824 8 824 53
  let%span sred_black_tree'2 = "red_black_tree.rs" 810 27 810 31
  let%span sred_black_tree'3 = "red_black_tree.rs" 810 36 810 50
  let%span sred_black_tree'4 = "red_black_tree.rs" 804 14 809 5
  let%span sred_black_tree'5 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'6 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'7 = "red_black_tree.rs" 49 12 49 89
  let%span sred_black_tree'8 = "red_black_tree.rs" 645 27 645 31
  let%span sred_black_tree'9 = "red_black_tree.rs" 634 15 634 43
  let%span sred_black_tree'10 = "red_black_tree.rs" 635 15 636 62
  let%span sred_black_tree'11 = "red_black_tree.rs" 645 36 645 42
  let%span sred_black_tree'12 = "red_black_tree.rs" 637 14 637 42
  let%span sred_black_tree'13 = "red_black_tree.rs" 638 14 638 50
  let%span sred_black_tree'14 = "red_black_tree.rs" 639 14 639 66
  let%span sred_black_tree'15 = "red_black_tree.rs" 640 14 640 102
  let%span sred_black_tree'16 = "red_black_tree.rs" 641 14 642 71
  let%span sred_black_tree'17 = "red_black_tree.rs" 643 14 643 39
  let%span sred_black_tree'18 = "red_black_tree.rs" 644 14 644 67
  let%span sred_black_tree'19 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'20 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'21 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'22 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'23 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'26 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'28 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'29 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'31 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'32 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'33 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'34 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'35 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'36 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'37 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'38 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'39 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'40 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'41 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'42 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'43 = "red_black_tree.rs" 763 8 765 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Option) =
    resolve _0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'40] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'31] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'28] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'42] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'38] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'25] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'23] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'39] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'30] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'43] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_0: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
  = (invariant''1 x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'1 a_0
    end)
  
  predicate invariant''2 (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 (self: MutBorrow.t t_Map) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Map) =
    resolve'1 _0
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 tuple
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Node))= any
    [ good (field_0:t_Node)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant''3 (self: t_Tree) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'8 (_0: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'5] inv'8 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'6] result = (color self = C_Red)} (! return' {result}) ] 
  
  predicate invariant''4 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Node) =
    resolve'3 _0
  
  predicate same_mappings [#"red_black_tree.rs" 47 4 47 43] (self: t_Tree) (o: t_Tree) =
    [%#sred_black_tree'7] forall k: t_DeepModelTy, v: t_V. has_mapping self k v = has_mapping o k v
  
  predicate invariant''5 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'26] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'27] C_CPN c l r
  
  predicate inv'11 (_0: tuple)
  
  axiom inv_axiom'9 [@rewrite]: forall x: tuple [inv'11 x]. inv'11 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_max_rec (self:MutBorrow.t t_Tree) (return'  (x:tuple))= {[@expl:delete_max_rec 'self' type invariant] [%#sred_black_tree'8] inv'10 self}
    {[@expl:delete_max_rec requires #0] [%#sred_black_tree'9] internal_invariant self.current}
    {[@expl:delete_max_rec requires #1] [%#sred_black_tree'10] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result:tuple)-> {[%#sred_black_tree'11] inv'11 result}
      {[%#sred_black_tree'12] internal_invariant self.final}
      {[%#sred_black_tree'13] height self.current = height self.final}
      {[%#sred_black_tree'14] has_mapping self.current (deep_model result._p0) result._p1}
      {[%#sred_black_tree'15] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
       -> le_log k (deep_model result._p0)}
      {[%#sred_black_tree'16] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
      = (deep_model result._p0 <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'17] color_invariant self.final}
      {[%#sred_black_tree'18] color self.current = C_Black  -> color self.final = C_Black}
      (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_Node)
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'9 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'1))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result:t_Option'1)-> {inv'12 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'1 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'1 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'1) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'1}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'9 result}
      {[%#soption'4] C_Some'1 result = self_}
      (! return' {result}) ]
  
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) : Map.map t_DeepModelTy t_Option'2
  
   =
    [%#sred_black_tree'41] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'2 =
    [%#sred_black_tree'32] model_acc self (Const.const (C_None'2))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'34] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'2, k: t_DeepModelTy. [%#sred_black_tree'33] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'2 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'37] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'2, k: t_DeepModelTy. ([%#sred_black_tree'35] bst_invariant self)
   -> ([%#sred_black_tree'36] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'2 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'21] let _ = model_acc_has_mapping self (Const.const (C_None'2)) k in has_mapping_model_acc self (Const.const (C_None'2)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'19] bst_invariant self)
   -> ([%#sred_black_tree'20] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'2 v))
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
  = match x with
    | C_None'0 -> true
    | C_Some'0 a_0 -> inv'11 a_0
    end
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'2 =
    [%#sred_black_tree'22] view self.t_Map__0
  
  function view'1 (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'2 =
    [%#smodel] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec delete_max[#"red_black_tree.rs" 810 4 810 50] (self:MutBorrow.t t_Map) (return'  (x:t_Option'0))= {[@expl:delete_max 'self' type invariant] [%#sred_black_tree'2] inv'7 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &old_self <- [%#sred_black_tree] self'0 ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_6 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] 
            s1)
      | s1 = any [ br0 -> {_6.current = C_None} (! bb8) | br1 (x0:t_Node)-> {_6.current = C_Some x0} (! bb2) ]  ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'7 self'0} s3
      | s3 = -{resolve'2 self'0}- s4
      | s4 =  [ &_0 <- C_None'0 ] s5
      | s5 = bb19 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some {_6.current}
          (fun (r0:t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret:MutBorrow.t t_Node) ->
                 [ &node <- _ret ] 
                -{inv'4 _ret.final}-
                 [ &_6 <- { _6 with current = C_Some _ret.final } ] 
                s1))
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret:bool) ->  [ &_9 <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    
    | bb6 = s0
      [ s0 =  [ &_11 <- C_Red ] s1
      | s1 =  [ &node <- { node with current = { node.current with t_Node__color = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:assertion] [%#sred_black_tree'0] same_mappings (old_self.current).t_Map__0 (self'0.current).t_Map__0}
        s1
      | s1 = {inv'1 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_16 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] 
            s2)
      | s2 = delete_max_rec {_16} (fun (_ret:tuple) ->  [ &r <- _ret ] s3)
      | s3 = bb9 ]
    
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Map__0} (fun (_ret:bool) ->  [ &_18 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_18 = false} (! bb14) | br1 -> {_18} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_20 <- C_Black ] s1
      | s1 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_23 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] 
            s2)
      | s2 = as_mut {_23} (fun (_ret:t_Option'1) ->  [ &_22 <- _ret ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap {_22} (fun (_ret:MutBorrow.t t_Node) ->  [ &_21 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_21 <- { _21 with current = { _21.current with t_Node__color = _20 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _21} s2
      | s2 = -{resolve'4 _21}- s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 = bb15 ]
    
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_24 <- [%#sred_black_tree'1] () ] s1 | s1 = bb16 ] 
    | bb16 = s0 [ s0 =  [ &_0 <- C_Some'0 r ] s1 | s1 = bb17 ] 
    | bb17 = bb18
    | bb18 = bb19
    | bb19 = return''0 {_0} ]
    )
    [ & _0: t_Option'0 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & old_self: MutBorrow.t t_Map = Any.any_l ()
    | & _6: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _11: t_Color = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _16: MutBorrow.t t_Tree = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: t_Color = Any.any_l ()
    | & _21: MutBorrow.t t_Node = Any.any_l ()
    | & _22: t_Option'1 = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l () ]
    
    [ return''0 (result:t_Option'0)-> {[@expl:delete_max result type invariant] [%#sred_black_tree'3] inv'13 result}
      {[@expl:delete_max ensures] [%#sred_black_tree'4] match result with
        | C_Some'0 {_p0 = k ; _p1 = v} -> Map.get (view'1 self) (deep_model k) = C_Some'2 v
        /\ (forall k2: t_DeepModelTy. Map.get (view'1 self) k2 = C_None'2 \/ le_log k2 (deep_model k))
        /\ view'0 self.final = Map.set (view'1 self) (deep_model k) (C_None'2)
        | C_None'0 -> view'0 self.final = view'1 self /\ view'1 self = Const.const (C_None'2)
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__delete_min [#"red_black_tree.rs" 835 4 835 50] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 836 8 836 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 835 27 835 31
  let%span sred_black_tree'1 = "red_black_tree.rs" 835 36 835 50
  let%span sred_black_tree'2 = "red_black_tree.rs" 828 14 834 5
  let%span sred_black_tree'3 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'4 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'5 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'6 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'7 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'8 = "red_black_tree.rs" 673 27 673 31
  let%span sred_black_tree'9 = "red_black_tree.rs" 662 15 662 43
  let%span sred_black_tree'10 = "red_black_tree.rs" 663 15 664 62
  let%span sred_black_tree'11 = "red_black_tree.rs" 673 36 673 42
  let%span sred_black_tree'12 = "red_black_tree.rs" 665 14 665 42
  let%span sred_black_tree'13 = "red_black_tree.rs" 666 14 666 50
  let%span sred_black_tree'14 = "red_black_tree.rs" 667 14 667 66
  let%span sred_black_tree'15 = "red_black_tree.rs" 668 14 668 102
  let%span sred_black_tree'16 = "red_black_tree.rs" 669 14 670 71
  let%span sred_black_tree'17 = "red_black_tree.rs" 671 14 671 39
  let%span sred_black_tree'18 = "red_black_tree.rs" 672 14 672 67
  let%span sred_black_tree'19 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'20 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'21 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'22 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'23 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'24 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'26 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'27 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'28 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'29 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'30 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'31 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'32 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'33 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'34 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'35 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'36 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'38 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'39 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'40 = "red_black_tree.rs" 763 8 765 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'21] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'35] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'20] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'22] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'23] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'27] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'25] bst_invariant self)
   -> ([%#sred_black_tree'26] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'5] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'3] bst_invariant self)
   -> ([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Option) =
    resolve _0
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'33] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'32] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'39] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'37] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'29] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'28] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'38] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'34] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'40] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_0: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
  = (invariant''1 x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'1 a_0
    end)
  
  predicate invariant''2 (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 (self: MutBorrow.t t_Map) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Map) =
    resolve'1 _0
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 tuple
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Node))= any
    [ good (field_0:t_Node)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant''3 (self: t_Tree) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'8 (_0: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'6] inv'8 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'7] result = (color self = C_Red)} (! return' {result}) ] 
  
  predicate invariant''4 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Node) =
    resolve'3 _0
  
  predicate invariant''5 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'30] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'31] C_CPN c l r
  
  predicate inv'11 (_0: tuple)
  
  axiom inv_axiom'9 [@rewrite]: forall x: tuple [inv'11 x]. inv'11 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_min_rec (self:MutBorrow.t t_Tree) (return'  (x:tuple))= {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree'8] inv'10 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree'9] internal_invariant self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree'10] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result:tuple)-> {[%#sred_black_tree'11] inv'11 result}
      {[%#sred_black_tree'12] internal_invariant self.final}
      {[%#sred_black_tree'13] height self.current = height self.final}
      {[%#sred_black_tree'14] has_mapping self.current (deep_model result._p0) result._p1}
      {[%#sred_black_tree'15] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
       -> le_log (deep_model result._p0) k}
      {[%#sred_black_tree'16] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
      = (deep_model result._p0 <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'17] color_invariant self.final}
      {[%#sred_black_tree'18] color self.current = C_Black  -> color self.final = C_Black}
      (! return' {result}) ]
  
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (MutBorrow.t t_Node)
  
  predicate inv'12 (_0: t_Option'2)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'2 [inv'12 x]. inv'12 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'9 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'2))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result:t_Option'2)-> {inv'12 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'2 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'2 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'2) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'2}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'9 result}
      {[%#soption'4] C_Some'2 result = self_}
      (! return' {result}) ]
  
  
  predicate inv'13 (_0: t_Option'1)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'1 [inv'13 x]. inv'13 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'11 a_0
    end
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'19] view self.t_Map__0
  
  function view'1 (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#smodel] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec delete_min[#"red_black_tree.rs" 835 4 835 50] (self:MutBorrow.t t_Map) (return'  (x:t_Option'1))= {[@expl:delete_min 'self' type invariant] [%#sred_black_tree'0] inv'7 self}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_3 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_6 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] 
            s1)
      | s1 = any [ br0 -> {_6.current = C_None} (! bb8) | br1 (x0:t_Node)-> {_6.current = C_Some x0} (! bb2) ]  ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'7 self'0} s3
      | s3 = -{resolve'2 self'0}- s4
      | s4 =  [ &_0 <- C_None'1 ] s5
      | s5 = bb18 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some {_6.current}
          (fun (r0:t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret:MutBorrow.t t_Node) ->
                 [ &node <- _ret ] 
                -{inv'4 _ret.final}-
                 [ &_6 <- { _6 with current = C_Some _ret.final } ] 
                s1))
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret:bool) ->  [ &_9 <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    
    | bb6 = s0
      [ s0 =  [ &_11 <- C_Red ] s1
      | s1 =  [ &node <- { node with current = { node.current with t_Node__color = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'1 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_14 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] 
            s1)
      | s1 = delete_min_rec {_14} (fun (_ret:tuple) ->  [ &r <- _ret ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Map__0} (fun (_ret:bool) ->  [ &_16 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_18 <- C_Black ] s1
      | s1 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_21 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] 
            s2)
      | s2 = as_mut {_21} (fun (_ret:t_Option'2) ->  [ &_20 <- _ret ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap {_20} (fun (_ret:MutBorrow.t t_Node) ->  [ &_19 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_19 <- { _19 with current = { _19.current with t_Node__color = _18 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _19} s2
      | s2 = -{resolve'4 _19}- s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 = bb15 ]
    
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- C_Some'1 r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = bb18
    | bb18 = return''0 {_0} ]
    )
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & _3: () = Any.any_l ()
    | & _6: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _11: t_Color = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _14: MutBorrow.t t_Tree = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: t_Color = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & _20: t_Option'2 = Any.any_l ()
    | & _21: MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:delete_min result type invariant] [%#sred_black_tree'1] inv'13 result}
      {[@expl:delete_min ensures] [%#sred_black_tree'2] match result with
        | C_Some'1 {_p0 = k ; _p1 = v} -> Map.get (view'1 self) (deep_model k) = C_Some'0 v
        /\ (forall k2: t_DeepModelTy. Map.get (view'1 self) k2 = C_None'0 \/ le_log (deep_model k) k2)
        /\ view'0 self.final = Map.set (view'1 self) (deep_model k) (C_None'0)
        | C_None'1 -> view'0 self.final = view'1 self /\ view'1 self = Const.const (C_None'0)
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__delete [#"red_black_tree.rs" 858 4 858 55] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 859 8 859 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 858 23 858 27
  let%span sred_black_tree'1 = "red_black_tree.rs" 858 29 858 32
  let%span sred_black_tree'2 = "red_black_tree.rs" 858 41 858 55
  let%span sred_black_tree'3 = "red_black_tree.rs" 852 14 856 5
  let%span sred_black_tree'4 = "red_black_tree.rs" 857 14 857 59
  let%span sred_black_tree'5 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'6 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'7 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'8 = "red_black_tree.rs" 405 15 405 19
  let%span sred_black_tree'9 = "red_black_tree.rs" 404 14 404 45
  let%span sred_black_tree'10 = "red_black_tree.rs" 699 23 699 27
  let%span sred_black_tree'11 = "red_black_tree.rs" 699 29 699 32
  let%span sred_black_tree'12 = "red_black_tree.rs" 687 15 687 43
  let%span sred_black_tree'13 = "red_black_tree.rs" 688 15 689 62
  let%span sred_black_tree'14 = "red_black_tree.rs" 699 41 699 55
  let%span sred_black_tree'15 = "red_black_tree.rs" 690 14 690 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 691 14 691 50
  let%span sred_black_tree'17 = "red_black_tree.rs" 692 14 695 5
  let%span sred_black_tree'18 = "red_black_tree.rs" 696 14 696 127
  let%span sred_black_tree'19 = "red_black_tree.rs" 697 14 697 39
  let%span sred_black_tree'20 = "red_black_tree.rs" 698 14 698 67
  let%span sred_black_tree'21 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'22 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'25 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'26 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'28 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'29 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'31 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'32 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'33 = "red_black_tree.rs" 251 16 251 48
  let%span sred_black_tree'34 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'35 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'36 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'38 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'39 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'40 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'41 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'42 = "red_black_tree.rs" 763 8 765 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span soption = "../../creusot-contracts/src/std/option.rs" 102 16 102 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 103 26 103 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 105 20 106 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 152 16 152 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 153 27 153 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 154 26 154 46
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'37] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'22] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'38] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'24] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'26] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'25] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'27] bst_invariant self)
   -> ([%#sred_black_tree'28] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'7] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'5] bst_invariant self)
   -> ([%#sred_black_tree'6] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
  = match x with
    | {t_Tree__node = node} -> inv'2 node
    end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'1 left
    /\ inv key /\ inv'0 val' /\ inv'1 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'4 a_0
    end
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  predicate invariant''0 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Option) =
    resolve _0
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'35] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'34] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'41] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'39] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'31] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'30] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'40] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'42] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_0: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
  = (invariant''1 x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'1 a_0
    end)
  
  predicate invariant''2 (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 (self: MutBorrow.t t_Map) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Map) =
    resolve'1 _0
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 tuple
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Node))= any
    [ good (field_0:t_Node)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate invariant''3 (self: t_Tree) =
    [%#sinvariant'0] inv'1 self
  
  predicate inv'8 (_0: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self:t_Tree) (return'  (x:bool))= {[@expl:is_red 'self' type invariant] [%#sred_black_tree'8] inv'8 self}
    any [ return''0 (result:bool)-> {[%#sred_black_tree'9] result = (color self = C_Red)} (! return' {result}) ] 
  
  predicate invariant''4 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Node) =
    resolve'3 _0
  
  predicate invariant''5 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  predicate inv'10 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  predicate invariant''6 (self: t_K) =
    [%#sinvariant'0] inv self
  
  predicate inv'11 (_0: t_K)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_K [inv'11 x]. inv'11 x = invariant''6 x
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'32] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 250 0 250 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'33] C_CPN c l r
  
  predicate inv'12 (_0: tuple)
  
  axiom inv_axiom'10 [@rewrite]: forall x: tuple [inv'12 x]. inv'12 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate inv'13 (_0: t_Option'1)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'1 [inv'13 x]. inv'13 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'12 a_0
    end
  
  function deep_model'0 (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  let rec delete_rec (self:MutBorrow.t t_Tree) (key:t_K) (return'  (x:t_Option'1))= {[@expl:delete_rec 'self' type invariant] [%#sred_black_tree'10] inv'10 self}
    {[@expl:delete_rec 'key' type invariant] [%#sred_black_tree'11] inv'11 key}
    {[@expl:delete_rec requires #0] [%#sred_black_tree'12] internal_invariant self.current}
    {[@expl:delete_rec requires #1] [%#sred_black_tree'13] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result:t_Option'1)-> {[%#sred_black_tree'14] inv'13 result}
      {[%#sred_black_tree'15] internal_invariant self.final}
      {[%#sred_black_tree'16] height self.current = height self.final}
      {[%#sred_black_tree'17] match result with
        | C_None'1 -> forall v: t_V. not has_mapping self.current (deep_model'0 key) v
        | C_Some'1 {_p0 = k ; _p1 = v} -> deep_model'0 key = deep_model k /\ has_mapping self.current (deep_model k) v
        end}
      {[%#sred_black_tree'18] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
      = (deep_model'0 key <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'19] color_invariant self.final}
      {[%#sred_black_tree'20] color self.current = C_Black  -> color self.final = C_Black}
      (! return' {result}) ]
  
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 (MutBorrow.t t_Node)
  
  predicate inv'14 (_0: t_Option'2)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'2 [inv'14 x]. inv'14 x
  = match x with
    | C_None'2 -> true
    | C_Some'2 a_0 -> inv'9 a_0
    end
  
  let rec as_mut (self_:MutBorrow.t t_Option) (return'  (x:t_Option'2))= {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result:t_Option'2)-> {inv'14 result}
      {[%#soption'0] self_.current = C_None  -> result = C_None'2 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'2 r
      /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  
  let rec unwrap (self_:t_Option'2) (return'  (x:MutBorrow.t t_Node))= {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'14 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'2}
    any
    [ return''0 (result:MutBorrow.t t_Node)-> {inv'9 result}
      {[%#soption'4] C_Some'2 result = self_}
      (! return' {result}) ]
  
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'21] view self.t_Map__0
  
  function view'1 (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#smodel'0] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec delete[#"red_black_tree.rs" 858 4 858 55] (self:MutBorrow.t t_Map) (key:t_K) (return'  (x:t_Option'1))= {[@expl:delete 'self' type invariant] [%#sred_black_tree'0] inv'7 self}
    {[@expl:delete 'key' type invariant] [%#sred_black_tree'1] inv'11 key}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_8 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] 
            s1)
      | s1 = any [ br0 -> {_8.current = C_None} (! bb8) | br1 (x0:t_Node)-> {_8.current = C_Some x0} (! bb2) ]  ]
    
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _8} s1
      | s1 = -{resolve'0 _8}- s2
      | s2 = {[@expl:type invariant] inv'7 self'0} s3
      | s3 = -{resolve'2 self'0}- s4
      | s4 =  [ &_0 <- C_None'1 ] s5
      | s5 = bb17 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some {_8.current}
          (fun (r0:t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _8) 1}
              (fun (_ret:MutBorrow.t t_Node) ->
                 [ &node <- _ret ] 
                -{inv'4 _ret.final}-
                 [ &_8 <- { _8 with current = C_Some _ret.final } ] 
                s1))
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret:bool) ->  [ &_11 <- _ret ] s2)
      | s2 = bb4 ]
    
    | bb4 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ] 
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _8} s3
      | s3 = -{resolve'0 _8}- s4
      | s4 = bb7 ]
    
    | bb6 = s0
      [ s0 =  [ &_13 <- C_Red ] s1
      | s1 =  [ &node <- { node with current = { node.current with t_Node__color = _13 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _8} s5
      | s5 = -{resolve'0 _8}- s6
      | s6 = bb7 ]
    
    | bb7 = s0
      [ s0 = {inv'1 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &_16 <- _ret ] 
            -{inv'1 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] 
            s1)
      | s1 = delete_rec {_16} {key'0} (fun (_ret:t_Option'1) ->  [ &r <- _ret ] s2)
      | s2 = bb9 ]
    
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Map__0} (fun (_ret:bool) ->  [ &_19 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = any [ br0 -> {_19 = false} (! bb14) | br1 -> {_19} (! bb11) ] 
    | bb11 = s0
      [ s0 =  [ &_21 <- C_Black ] s1
      | s1 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final
          <t_Option>
          {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret:MutBorrow.t t_Option) ->
             [ &_24 <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] 
            s2)
      | s2 = as_mut {_24} (fun (_ret:t_Option'2) ->  [ &_23 <- _ret ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0 [ s0 = unwrap {_23} (fun (_ret:MutBorrow.t t_Node) ->  [ &_22 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = s0
      [ s0 =  [ &_22 <- { _22 with current = { _22.current with t_Node__color = _21 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _22} s2
      | s2 = -{resolve'4 _22}- s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 = bb15 ]
    
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb15 ] 
    | bb15 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb16 ] 
    | bb16 = bb17
    | bb17 = return''0 {_0} ]
    )
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & key'0: t_K = key
    | & _5: () = Any.any_l ()
    | & _8: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: t_Color = Any.any_l ()
    | & r: t_Option'1 = Any.any_l ()
    | & _16: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Color = Any.any_l ()
    | & _22: MutBorrow.t t_Node = Any.any_l ()
    | & _23: t_Option'2 = Any.any_l ()
    | & _24: MutBorrow.t t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:delete result type invariant] [%#sred_black_tree'2] inv'13 result}
      {[@expl:delete ensures #0] [%#sred_black_tree'3] match result with
        | C_Some'1 {_p0 = k ; _p1 = v} -> deep_model k = deep_model'0 key
        /\ Map.get (view'1 self) (deep_model'0 key) = C_Some'0 v
        | C_None'1 -> Map.get (view'1 self) (deep_model'0 key) = C_None'0
        end}
      {[@expl:delete ensures #1] [%#sred_black_tree'4] view'0 self.final
      = Map.set (view'1 self) (deep_model'0 key) (C_None'0)}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__get [#"red_black_tree.rs" 879 4 879 44] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 880 8 880 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 885 20 885 116
  let%span sred_black_tree'1 = "red_black_tree.rs" 884 20 884 40
  let%span sred_black_tree'2 = "red_black_tree.rs" 883 20 883 29
  let%span sred_black_tree'3 = "red_black_tree.rs" 879 16 879 20
  let%span sred_black_tree'4 = "red_black_tree.rs" 879 22 879 25
  let%span sred_black_tree'5 = "red_black_tree.rs" 879 34 879 44
  let%span sred_black_tree'6 = "red_black_tree.rs" 875 14 878 5
  let%span sred_black_tree'7 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'8 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'9 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'10 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'11 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'13 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'14 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'15 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'16 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'17 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'18 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'19 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'20 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'21 = "red_black_tree.rs" 763 8 765 9
  let%span sred_black_tree'22 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'23 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'27 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'28 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'29 = "red_black_tree.rs" 322 12 330 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 44 8 44 22
  
  use map.Map
  use map.Const
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'10] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'18] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'20] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'12] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'14] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'13] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'17] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'15] bst_invariant self)
   -> ([%#sred_black_tree'16] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'9] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'7] bst_invariant self)
   -> ([%#sred_black_tree'8] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  function deep_model'0 (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  predicate invariant''0 (self: t_Tree) =
    [%#sinvariant] inv'2 self
  
  predicate inv'5 (_0: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Node))= any
    [ good (field_0:t_Node)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type tuple  =
    { _p0: t_K; _p1: t_K }
  
  predicate invariant''1 (self: t_K) =
    [%#sinvariant] inv self
  
  predicate inv'6 (_0: t_K)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_K [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'6 rhs
  /\ inv'6 self_)  -> precondition () args
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef: forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_:t_K) (rhs:t_K) (return'  (x:t_Ordering))= {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                       _p1 = rhs }}
    any
    [ return''0 (result:t_Ordering)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'28] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'27] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'22] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'24] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'26] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''2 [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'21] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'7 (_0: t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map [inv'7 x]. inv'7 x
  = (invariant''2 x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant''3 (self: t_Map) =
    [%#sinvariant] inv'7 self
  
  predicate inv'8 (_0: t_Map)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Map [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate invariant''4 (self: t_V) =
    [%#sinvariant] inv'0 self
  
  predicate inv'9 (_0: t_V)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_V [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate inv'10 (_0: t_Option'1)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option'1 [inv'10 x]. inv'10 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'9 a_0
    end
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'19] view self.t_Map__0
  
  function view'1 (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#smodel'0] view'0 self
  
  meta "compute_max_steps" 1000000
  
  let rec get[#"red_black_tree.rs" 879 4 879 44] (self:t_Map) (key:t_K) (return'  (x:t_Option'1))= {[@expl:get 'self' type invariant] [%#sred_black_tree'3] inv'8 self}
    {[@expl:get 'key' type invariant] [%#sred_black_tree'4] inv'6 key}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &tree <- self'0.t_Map__0 ] s1 | s1 = bb2 ] 
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:loop invariant #0] [%#sred_black_tree'2] inv'5 tree}
        {[@expl:loop invariant #1] [%#sred_black_tree'1] bst_invariant tree}
        {[@expl:loop invariant #2] [%#sred_black_tree'0] forall v: t_V. has_mapping self'0.t_Map__0 (deep_model'0 key'0) v
        = has_mapping tree (deep_model'0 key'0) v}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 =  [ &_14 <- tree.t_Tree__node ] s1
          | s1 = any [ br0 -> {_14 = C_None} (! bb14) | br1 (x0:t_Node)-> {_14 = C_Some x0} (! bb4) ]  ]
        
        | bb4 = bb5
        | bb5 = s0
          [ s0 = v_Some {_14} (fun (r0:t_Node) ->  [ &node <- r0 ] s1)
          | s1 =  [ &_20 <- node.t_Node__key ] s2
          | s2 = cmp {key'0} {_20} (fun (_ret:t_Ordering) ->  [ &_17 <- _ret ] s3)
          | s3 = bb6 ]
        
        | bb6 = any
          [ br0 -> {_17 = C_Less} (! bb8) | br1 -> {_17 = C_Equal} (! bb9) | br2 -> {_17 = C_Greater} (! bb10) ]
        
        | bb10 = s0 [ s0 =  [ &_28 <- node.t_Node__right ] s1 | s1 =  [ &tree <- _28 ] s2 | s2 = bb13 ] 
        | bb8 = bb12
        | bb12 = s0 [ s0 =  [ &_23 <- node.t_Node__left ] s1 | s1 =  [ &tree <- _23 ] s2 | s2 = bb13 ] 
        | bb13 = bb2'0 ]
       ]
    
    | bb14 = s0 [ s0 =  [ &_0 <- C_None'1 ] s1 | s1 = bb15 ] 
    | bb9 = bb11
    | bb11 = s0 [ s0 =  [ &_26 <- node.t_Node__val ] s1 | s1 =  [ &_0 <- C_Some'1 _26 ] s2 | s2 = bb15 ] 
    | bb15 = return''0 {_0} ]
    )
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: t_Map = self
    | & key'0: t_K = key
    | & _5: () = Any.any_l ()
    | & tree: t_Tree = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & node: t_Node = Any.any_l ()
    | & _17: t_Ordering = Any.any_l ()
    | & _20: t_K = Any.any_l ()
    | & _23: t_Tree = Any.any_l ()
    | & _26: t_V = Any.any_l ()
    | & _28: t_Tree = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:get result type invariant] [%#sred_black_tree'5] inv'10 result}
      {[@expl:get ensures] [%#sred_black_tree'6] match result with
        | C_Some'1 v -> Map.get (view'1 self) (deep_model'0 key) = C_Some'0 v
        | C_None'1 -> Map.get (view'1 self) (deep_model'0 key) = C_None'0
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi1722927563742988856__get_mut [#"red_black_tree.rs" 900 4 900 56] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 901 8 901 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 904 23 904 41
  let%span sred_black_tree'1 = "red_black_tree.rs" 917 20 918 84
  let%span sred_black_tree'2 = "red_black_tree.rs" 916 20 916 90
  let%span sred_black_tree'3 = "red_black_tree.rs" 914 20 915 51
  let%span sred_black_tree'4 = "red_black_tree.rs" 912 20 913 80
  let%span sred_black_tree'5 = "red_black_tree.rs" 911 20 911 122
  let%span sred_black_tree'6 = "red_black_tree.rs" 910 20 910 122
  let%span sred_black_tree'7 = "red_black_tree.rs" 909 20 909 42
  let%span sred_black_tree'8 = "red_black_tree.rs" 908 20 908 43
  let%span sred_black_tree'9 = "red_black_tree.rs" 907 20 907 40
  let%span sred_black_tree'10 = "red_black_tree.rs" 906 20 906 29
  let%span sred_black_tree'11 = "red_black_tree.rs" 900 24 900 28
  let%span sred_black_tree'12 = "red_black_tree.rs" 900 30 900 33
  let%span sred_black_tree'13 = "red_black_tree.rs" 900 42 900 56
  let%span sred_black_tree'14 = "red_black_tree.rs" 896 14 899 5
  let%span sred_black_tree'15 = "red_black_tree.rs" 106 15 106 35
  let%span sred_black_tree'16 = "red_black_tree.rs" 107 14 107 78
  let%span sred_black_tree'17 = "red_black_tree.rs" 113 12 113 61
  let%span sred_black_tree'18 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'19 = "red_black_tree.rs" 258 12 263 13
  let%span sred_black_tree'20 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'21 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'22 = "red_black_tree.rs" 322 12 330 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'27 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'28 = "red_black_tree.rs" 68 14 69 91
  let%span sred_black_tree'29 = "red_black_tree.rs" 72 12 80 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 85 15 85 35
  let%span sred_black_tree'31 = "red_black_tree.rs" 86 14 86 92
  let%span sred_black_tree'32 = "red_black_tree.rs" 92 12 101 13
  let%span sred_black_tree'33 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'34 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'35 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'36 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 763 8 765 9
  let%span sred_black_tree'38 = "red_black_tree.rs" 381 12 381 59
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'18] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'34] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'27] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 70 4 70 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'28] Map.get (model_acc self accu) k
  = Map.get accu k
  \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 87 4 89 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
  
   =
    [%#sred_black_tree'32] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec: forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'30] bst_invariant self)
   -> ([%#sred_black_tree'31] forall v: t_V. has_mapping self k v  -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 108 4 110 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'17] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'15] bst_invariant self)
   -> ([%#sred_black_tree'16] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  type t_CP  =
    | C_CPL t_Color
    | C_CPN t_Color t_CP t_CP
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'20] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'35] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate match_t [#"red_black_tree.rs" 256 4 256 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'19] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
      /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'22] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'21] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'33] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  function deep_model'0 (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate invariant''0 (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  predicate inv'5 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Node))= any
    [ good (field_0:t_Node)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  type tuple  =
    { _p0: t_K; _p1: t_K }
  
  predicate invariant''1 (self: t_K) =
    [%#sinvariant'0] inv self
  
  predicate inv'6 (_0: t_K)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_K [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef: forall args: tuple [precondition () args]. (let {_p0 = self_ ; _p1 = rhs} = args in inv'6 rhs
  /\ inv'6 self_)  -> precondition () args
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef: forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
   -> (let {_p0 = self_ ; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_:t_K) (rhs:t_K) (return'  (x:t_Ordering))= {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                       _p1 = rhs }}
    any
    [ return''0 (result:t_Ordering)-> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Tree) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Tree) =
    resolve _0
  
  predicate invariant''2 (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Node) =
    resolve'1 _0
  
  predicate invariant''3 (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  predicate inv'8 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Option [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'3 (self: MutBorrow.t t_Option) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0: MutBorrow.t t_Option) =
    resolve'3 _0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V)
  
  predicate invariant''4 (self: MutBorrow.t t_V) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  predicate inv'9 (_0: MutBorrow.t t_V)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_V [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'5 (self: MutBorrow.t t_V) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'6 (_0: MutBorrow.t t_V) =
    resolve'5 _0
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'38] bst_invariant self /\ height_invariant self
  
  predicate invariant''5 [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'37] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'10 (_0: t_Map)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Map [inv'10 x]. inv'10 x
  = (invariant''5 x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant''6 (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  predicate inv'11 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_Map [inv'11 x]. inv'11 x = invariant''6 x
  
  predicate resolve'7 (self: MutBorrow.t t_Map) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'8 (_0: MutBorrow.t t_Map) =
    resolve'7 _0
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
  = match x with
    | C_None'1 -> true
    | C_Some'1 a_0 -> inv'9 a_0
    end
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'26] view self.t_Map__0
  
  function view'1 (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#smodel'0] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec get_mut[#"red_black_tree.rs" 900 4 900 56] (self:MutBorrow.t t_Map) (key:t_K) (return'  (x:t_Option'1))= {[@expl:get_mut 'self' type invariant] [%#sred_black_tree'11] inv'11 self}
    {[@expl:get_mut 'key' type invariant] [%#sred_black_tree'12] inv'6 key}
    (! bb0
    [ bb0 = s0 [ s0 =  [ &_5 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {inv'2 (self'0.current).t_Map__0}
        MutBorrow.borrow_final <t_Tree> {(self'0.current).t_Map__0} {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Tree) ->
             [ &tree <- _ret ] 
            -{inv'2 _ret.final}-
             [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] 
            s1)
      | s1 =  [ &old_tree <- [%#sred_black_tree'0] tree ] s2
      | s2 = bb2 ]
    
    | bb2 = bb3
    | bb3 = bb3'0
      [ bb3'0 = {[@expl:loop invariant #0] [%#sred_black_tree'10] inv'5 tree}
        {[@expl:loop invariant #1] [%#sred_black_tree'9] bst_invariant tree.current}
        {[@expl:loop invariant #2] [%#sred_black_tree'8] height_invariant tree.current}
        {[@expl:loop invariant #3] [%#sred_black_tree'7] color_invariant tree.current}
        {[@expl:loop invariant #4] [%#sred_black_tree'6] forall v: t_V. has_mapping tree.final (deep_model'0 key'0) v
        = has_mapping old_tree.final (deep_model'0 key'0) v}
        {[@expl:loop invariant #5] [%#sred_black_tree'5] forall v: t_V. has_mapping tree.current (deep_model'0 key'0) v
        = has_mapping old_tree.current (deep_model'0 key'0) v}
        {[@expl:loop invariant #6] [%#sred_black_tree'4] (forall k: t_DeepModelTy, v: t_V. k = deep_model'0 key'0
        \/ has_mapping tree.current k v = has_mapping tree.final k v)
         -> bst_invariant tree.final  -> bst_invariant old_tree.final}
        {[@expl:loop invariant #7] [%#sred_black_tree'3] height tree.current = height tree.final
        /\ height_invariant tree.final  -> height_invariant old_tree.final}
        {[@expl:loop invariant #8] [%#sred_black_tree'2] match_t (C_CPL (color tree.current)) tree.final
         -> match_t (C_CPL (C_Black)) old_tree.final}
        {[@expl:loop invariant #9] [%#sred_black_tree'1] forall k: t_DeepModelTy, v: t_V. has_mapping tree.current k v
        = has_mapping tree.final k v  -> has_mapping old_tree.current k v = has_mapping old_tree.final k v}
        (! s0) [ s0 = bb4 ] 
        [ bb4 = s0
          [ s0 = {inv'4 (tree.current).t_Tree__node}
            MutBorrow.borrow_final
              <t_Option>
              {(tree.current).t_Tree__node}
              {MutBorrow.inherit_id (MutBorrow.get_id tree) 1}
              (fun (_ret:MutBorrow.t t_Option) ->
                 [ &_23 <- _ret ] 
                -{inv'4 _ret.final}-
                 [ &tree <- { tree with current = { t_Tree__node = _ret.final } } ] 
                s1)
          | s1 = any [ br0 -> {_23.current = C_None} (! bb15) | br1 (x0:t_Node)-> {_23.current = C_Some x0} (! bb5) ]  ]
        
        | bb5 = bb6
        | bb6 = s0
          [ s0 = v_Some {_23.current}
              (fun (r0:t_Node) ->
                {inv'3 r0}
                MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _23) 1}
                  (fun (_ret:MutBorrow.t t_Node) ->
                     [ &node <- _ret ] 
                    -{inv'3 _ret.final}-
                     [ &_23 <- { _23 with current = C_Some _ret.final } ] 
                    s1))
          | s1 =  [ &_29 <- (node.current).t_Node__key ] s2
          | s2 = cmp {key'0} {_29} (fun (_ret:t_Ordering) ->  [ &_26 <- _ret ] s3)
          | s3 = bb7 ]
        
        | bb7 = any
          [ br0 -> {_26 = C_Less} (! bb9) | br1 -> {_26 = C_Equal} (! bb10) | br2 -> {_26 = C_Greater} (! bb11) ]
        
        | bb11 = s0
          [ s0 = {inv'2 (node.current).t_Node__right}
            MutBorrow.borrow_final
              <t_Tree>
              {(node.current).t_Node__right}
              {MutBorrow.inherit_id (MutBorrow.get_id node) 5}
              (fun (_ret:MutBorrow.t t_Tree) ->
                 [ &_37 <- _ret ] 
                -{inv'2 _ret.final}-
                 [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] 
                s1)
          | s1 = {inv'2 _37.current}
            MutBorrow.borrow_final <t_Tree> {_37.current} {MutBorrow.get_id _37}
              (fun (_ret:MutBorrow.t t_Tree) ->
                 [ &_36 <- _ret ] 
                -{inv'2 _ret.final}-
                 [ &_37 <- { _37 with current = _ret.final } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'5 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _36 ] s5
          | s5 = {[@expl:type invariant] inv'5 _37} s6
          | s6 = -{resolve'0 _37}- s7
          | s7 = bb14 ]
        
        | bb9 = bb13
        | bb13 = s0
          [ s0 = {inv'2 (node.current).t_Node__left}
            MutBorrow.borrow_final
              <t_Tree>
              {(node.current).t_Node__left}
              {MutBorrow.inherit_id (MutBorrow.get_id node) 1}
              (fun (_ret:MutBorrow.t t_Tree) ->
                 [ &_32 <- _ret ] 
                -{inv'2 _ret.final}-
                 [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] 
                s1)
          | s1 = {inv'2 _32.current}
            MutBorrow.borrow_final <t_Tree> {_32.current} {MutBorrow.get_id _32}
              (fun (_ret:MutBorrow.t t_Tree) ->
                 [ &_31 <- _ret ] 
                -{inv'2 _ret.final}-
                 [ &_32 <- { _32 with current = _ret.final } ] 
                s2)
          | s2 = {[@expl:type invariant] inv'5 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 =  [ &tree <- _31 ] s5
          | s5 = {[@expl:type invariant] inv'5 _32} s6
          | s6 = -{resolve'0 _32}- s7
          | s7 = bb14 ]
        
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv'7 node} s1
          | s1 = -{resolve'2 node}- s2
          | s2 = {[@expl:type invariant] inv'8 _23} s3
          | s3 = -{resolve'4 _23}- s4
          | s4 = bb3'0 ]
         ]
       ]
    
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'8 _23} s1
      | s1 = -{resolve'4 _23}- s2
      | s2 =  [ &_0 <- C_None'1 ] s3
      | s3 = bb16 ]
    
    | bb10 = bb12
    | bb12 = s0
      [ s0 = {inv'0 (node.current).t_Node__val}
        MutBorrow.borrow_final <t_V> {(node.current).t_Node__val} {MutBorrow.inherit_id (MutBorrow.get_id node) 4}
          (fun (_ret:MutBorrow.t t_V) ->
             [ &_35 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &node <- { node with current = { node.current with t_Node__val = _ret.final } } ] 
            s1)
      | s1 = {inv'0 _35.current}
        MutBorrow.borrow_final <t_V> {_35.current} {MutBorrow.get_id _35}
          (fun (_ret:MutBorrow.t t_V) ->
             [ &_34 <- _ret ] 
            -{inv'0 _ret.final}-
             [ &_35 <- { _35 with current = _ret.final } ] 
            s2)
      | s2 =  [ &_0 <- C_Some'1 _34 ] s3
      | s3 = {[@expl:type invariant] inv'9 _35} s4
      | s4 = -{resolve'6 _35}- s5
      | s5 = {[@expl:type invariant] inv'7 node} s6
      | s6 = -{resolve'2 node}- s7
      | s7 = {[@expl:type invariant] inv'8 _23} s8
      | s8 = -{resolve'4 _23}- s9
      | s9 = bb16 ]
    
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'5 tree} s1
      | s1 = -{resolve'0 tree}- s2
      | s2 = {[@expl:type invariant] inv'11 self'0} s3
      | s3 = -{resolve'8 self'0}- s4
      | s4 = return''0 {_0} ]
     ]
    )
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & key'0: t_K = key
    | & _5: () = Any.any_l ()
    | & tree: MutBorrow.t t_Tree = Any.any_l ()
    | & old_tree: MutBorrow.t t_Tree = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _26: t_Ordering = Any.any_l ()
    | & _29: t_K = Any.any_l ()
    | & _31: MutBorrow.t t_Tree = Any.any_l ()
    | & _32: MutBorrow.t t_Tree = Any.any_l ()
    | & _34: MutBorrow.t t_V = Any.any_l ()
    | & _35: MutBorrow.t t_V = Any.any_l ()
    | & _36: MutBorrow.t t_Tree = Any.any_l ()
    | & _37: MutBorrow.t t_Tree = Any.any_l () ]
    
    [ return''0 (result:t_Option'1)-> {[@expl:get_mut result type invariant] [%#sred_black_tree'13] inv'12 result}
      {[@expl:get_mut ensures] [%#sred_black_tree'14] match result with
        | C_Some'1 v -> Map.get (view'1 self) (deep_model'0 key) = C_Some'0 (v.current)
        /\ view'0 self.final = Map.set (view'1 self) (deep_model'0 key) (C_Some'0 (v.final))
        | C_None'1 -> Map.get (view'1 self) (deep_model'0 key) = C_None'0 /\ view'0 self.final = view'1 self
        end}
      (! return' {result}) ]

end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence__refines [#"red_black_tree.rs" 184 4 184 31] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 184 4 184 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'1 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'2 = "red_black_tree.rs" 191 12 191 63
  let%span sred_black_tree'3 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'4 = "red_black_tree.rs" 139 8 142 9
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 62 8 62 23
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'1] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'3] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 189 4 189 28] (self: t_Node) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v  -> resolve v
  
  predicate resolve'1 (_0: t_Node) =
    resolve'0 _0
  
  predicate resolve'2 (self: t_Node) =
    [%#sresolve'0] resolve'1 self
  
  predicate resolve'3 (_0: t_Node) =
    resolve'2 _0
  
  predicate resolve'4 (self: t_Option) =
    [%#sresolve] match self with
      | C_Some x -> resolve'3 x
      | C_None -> true
      end
  
  predicate resolve'5 (_0: t_Option) =
    resolve'4 _0
  
  predicate structural_resolve (_0: t_Tree) =
    match _0 with
      | {t_Tree__node = x0} -> resolve'5 x0
      end
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  predicate invariant''0 (self: t_Tree) =
    [%#sinvariant] inv'2 self
  
  predicate inv'5 (_0: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve'6 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'0] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve v
  
  goal refines: [%#sred_black_tree] forall self: t_Tree. structural_resolve self /\ inv'5 self
   -> structural_resolve self /\ (forall result: (). resolve'6 self  -> resolve'6 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence__refines [#"red_black_tree.rs" 198 4 198 31] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 198 4 198 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 191 12 191 63
  let%span sred_black_tree'1 = "red_black_tree.rs" 136 14 137 84
  let%span sred_black_tree'2 = "red_black_tree.rs" 139 8 142 9
  let%span sred_black_tree'3 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'4 = "red_black_tree.rs" 38 12 42 13
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  with t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'3] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve v
  
  predicate resolve'1 (_0: t_Tree) =
    resolve'0 _0
  
  predicate resolve'2 (_0: t_K)
  
  predicate structural_resolve (_0: t_Node) =
    match _0 with
      | {t_Node__left = x0 ; t_Node__color = x1 ; t_Node__key = x2 ; t_Node__val = x3 ; t_Node__right = x4} -> resolve'1 x4
      /\ resolve x3 /\ resolve'2 x2 /\ resolve'1 x0
      end
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate invariant' (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'2 a_0
    end
  
  predicate inv'4 (_0: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
  = match x with
    | {t_Tree__node = node} -> inv'3 node
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'4 left
    /\ inv key /\ inv'0 val' /\ inv'4 right
    end
  
  predicate invariant''0 (self: t_Node) =
    [%#sinvariant] inv'1 self
  
  predicate inv'5 (_0: t_Node)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Node [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate has_mapping'0 [#"red_black_tree.rs" 138 4 138 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'2] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'1] forall node: t_Node. self
  = node  -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'3 [#"red_black_tree.rs" 189 4 189 28] (self: t_Node) =
    [%#sred_black_tree'0] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v  -> resolve v
  
  goal refines: [%#sred_black_tree] forall self: t_Node. structural_resolve self /\ inv'5 self
   -> structural_resolve self /\ (forall result: (). resolve'3 self  -> resolve'3 self)
end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence__refines [#"red_black_tree.rs" 783 4 783 31] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 783 4 783 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 776 20 776 68
  let%span sred_black_tree'1 = "red_black_tree.rs" 753 20 753 27
  let%span sred_black_tree'2 = "red_black_tree.rs" 177 12 177 63
  let%span sred_black_tree'3 = "red_black_tree.rs" 169 20 169 54
  let%span sred_black_tree'4 = "red_black_tree.rs" 38 12 42 13
  let%span sred_black_tree'5 = "red_black_tree.rs" 56 12 63 13
  let%span sred_black_tree'6 = "red_black_tree.rs" 763 8 765 9
  let%span sred_black_tree'7 = "red_black_tree.rs" 381 12 381 59
  let%span sred_black_tree'8 = "red_black_tree.rs" 292 12 298 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 282 12 285 13
  let%span sred_black_tree'10 = "red_black_tree.rs" 230 12 236 13
  let%span sred_black_tree'11 = "red_black_tree.rs" 337 12 343 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 306 20 306 102
  let%span sred_black_tree'13 = "red_black_tree.rs" 210 12 211 104
  let%span sred_black_tree'14 = "red_black_tree.rs" 363 20 363 61
  let%span sred_black_tree'15 = "red_black_tree.rs" 319 14 319 25
  let%span sred_black_tree'16 = "red_black_tree.rs" 322 12 330 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 29 14 29 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 40 14 40 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 51 14 51 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 62 14 62 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 67 14 67 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 72 15 72 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 73 15 73 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 74 14 74 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 81 15 81 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 82 14 82 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 89 15 89 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 90 14 90 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 95 14 95 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 75 8 78 9
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 33 8 33 18
  
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color  =
    | C_Red
    | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node  =
    { t_Node__left: t_Tree; t_Node__color: t_Color; t_Node__key: t_K; t_Node__val: t_V; t_Node__right: t_Tree }
  with t_Option  =
    | C_None
    | C_Some t_Node
  with t_Tree  =
    { t_Tree__node: t_Option }
  
  type t_Map  =
    { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 36 4 36 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 175 4 175 28] (self: t_Tree) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping self k v  -> resolve v
  
  predicate resolve'1 (_0: t_Tree) =
    resolve'0 _0
  
  predicate structural_resolve (_0: t_Map) =
    match _0 with
      | {t_Map__0 = x0} -> resolve'1 x0
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
  = o)  -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 208 4 208 39] (self: t_Node) =
    [%#sred_black_tree'13] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
     -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v  -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 228 4 228 34] (self: t_Tree) =
    [%#sred_black_tree'10] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 320 4 320 26] (self: t_Tree) : int =
    [%#sred_black_tree'16] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'15] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 362 4 362 42] (self: t_Node) =
    [%#sred_black_tree'14] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 335 4 335 37] (self: t_Tree) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 379 4 379 39] (self: t_Tree) =
    [%#sred_black_tree'7] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 280 4 280 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'9] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 305 4 305 41] (self: t_Node) =
    [%#sred_black_tree'12] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 290 4 290 36] (self: t_Tree) =
    [%#sred_black_tree'8] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left ; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant' [#"red_black_tree.rs" 762 4 762 30] (self: t_Map) =
    [%#sred_black_tree'6] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
  = match x with
    | {t_Node__left = left ; t_Node__color = color'0 ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right} -> inv'2 left
    /\ inv key /\ inv'0 val' /\ inv'2 right
    end
  
  predicate invariant''0 (self: t_Node) =
    [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
  = match x with
    | C_None -> true
    | C_Some a_0 -> inv'3 a_0
    end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
  = match x with
    | {t_Tree__node = node} -> inv'4 node
    end
  
  predicate inv'5 (_0: t_Map)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map [inv'5 x]. inv'5 x
  = (invariant' x
  /\ match x with
    | {t_Map__0 = a_0} -> inv'2 a_0
    end)
  
  predicate invariant''1 (self: t_Map) =
    [%#sinvariant] inv'5 self
  
  predicate inv'6 (_0: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x = invariant''1 x
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  predicate resolve'2 (self: t_Option'0) =
    [%#sresolve] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  predicate resolve'3 (_0: t_Option'0) =
    resolve'2 _0
  
  function model_acc [#"red_black_tree.rs" 54 4 54 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
  
   =
    [%#sred_black_tree'5] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left ; t_Node__key = key ; t_Node__val = val' ; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 168 4 168 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'3] model_acc self (Const.const (C_None'0))
  
  function view'0 [#"red_black_tree.rs" 752 4 752 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'1] view self.t_Map__0
  
  predicate resolve'4 [#"red_black_tree.rs" 775 4 775 28] (self: t_Map) =
    [%#sred_black_tree'0] forall k: t_DeepModelTy. resolve'3 (Map.get (view'0 self) k)
  
  goal refines: [%#sred_black_tree] forall self: t_Map. structural_resolve self /\ inv'6 self
   -> structural_resolve self /\ (forall result: (). resolve'4 self  -> resolve'4 self)
end
