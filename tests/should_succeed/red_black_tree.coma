module M_impl_Clone_for_Color__clone (* <Color as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type tup2_Color_Color = { f0: t_Color; f1: t_Color }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Color (self: t_Color) (return (x: t_Color)) = (! bb0
    [ bb0 = any [ br0 -> {self = Red} (! bb4) | br1 -> {self = Black} (! bb3) ]
    | bb3 = s0 [ s0 = [ &_ret <- Black ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_ret <- Red ] s1 | s1 = bb5 ]
    | bb5 = return {_ret} ] [ & _ret: t_Color = Any.any_l () | & self: t_Color = self ])
    [ return (result: t_Color) -> {[@expl:clone ensures] match { f0 = self; f1 = result } with
        | {f0 = Red; f1 = Red} -> true
        | {f0 = Black; f1 = Black} -> true
        | _ -> false
        end}
      (! return {result}) ]
end
module M_impl_Tree_K_V__model_acc_has_mapping (* Tree<K, V> *)
  use map.Map
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant accu : Map.map t_DeepModelTy t_Option_V
  
  constant k : t_DeepModelTy
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : ()
  
  goal vc_model_acc_has_mapping_K: match self with
      | {node = None} -> [@expl:model_acc_has_mapping ensures] Map.get (model_acc_K self accu) k = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> Map.get (model_acc_K left'0 accu) k
          = Map.get accu k
        \/ (exists v: t_V. Map.get (model_acc_K left'0 accu) k = Some'0 v /\ has_mapping_K left'0 k v)
      -> (let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in Map.get (model_acc_K right'0 accu2) k
          = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc_K right'0 accu2) k = Some'0 v /\ has_mapping_K right'0 k v)
      -> ([@expl:model_acc_has_mapping ensures] Map.get (model_acc_K self accu) k = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)))
      end
end
module M_impl_Tree_K_V_0__has_mapping_model_acc (* Tree<K, V> *)
  use map.Map
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant accu : Map.map t_DeepModelTy t_Option_V
  
  constant k : t_DeepModelTy
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model_acc_K: bst_invariant_K self
    -> match self with
      | {node = None} -> [@expl:has_mapping_model_acc ensures] forall v: t_V. has_mapping_K self k v
        -> Map.get (model_acc_K self accu) k = Some'0 v
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> ([@expl:has_mapping_model_acc requires] bst_invariant_K left'0)
      /\ ((forall v: t_V. has_mapping_K left'0 k v -> Map.get (model_acc_K left'0 accu) k = Some'0 v)
      -> (let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in ([@expl:has_mapping_model_acc requires] bst_invariant_K right'0)
      /\ ((forall v: t_V. has_mapping_K right'0 k v -> Map.get (model_acc_K right'0 accu2) k = Some'0 v)
      -> (let _ = has_mapping_model_acc_K right'0 accu2 k in Map.get (model_acc_K right'0 accu2) k = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc_K right'0 accu2) k = Some'0 v /\ has_mapping_K right'0 k v)
      -> ([@expl:has_mapping_model_acc ensures] forall v: t_V. has_mapping_K self k v
        -> Map.get (model_acc_K self accu) k = Some'0 v)))))
      end
end
module M_impl_Tree_K_V_0__has_mapping_model (* Tree<K, V> *)
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant k : t_DeepModelTy
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model_K: bst_invariant_K self
    -> Map.get (model_acc_K self (Const.const (None'0))) k = Map.get (Const.const (None'0)) k
      \/ (exists v: t_V. Map.get (model_acc_K self (Const.const (None'0))) k = Some'0 v /\ has_mapping_K self k v)
    -> (let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in ([@expl:has_mapping_model_acc requires] bst_invariant_K self)
    /\ ((forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self (Const.const (None'0))) k = Some'0 v)
    -> ([@expl:has_mapping_model ensures] forall v: t_V. has_mapping_K self k v
      = (Map.get (view_Tree_K_V self) k = Some'0 v))))
end
module M_impl_Tree_K_V_0__has_mapping_inj (* Tree<K, V> *)
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  constant k : t_DeepModelTy
  
  constant v1 : t_V
  
  constant v2 : t_V
  
  function has_mapping_inj_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : ()
  
  goal vc_has_mapping_inj_K: bst_invariant_K self
    -> has_mapping_K self k v1
    -> has_mapping_K self k v2
    -> ([@expl:has_mapping_model requires] bst_invariant_K self)
    /\ ((forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
    -> ([@expl:has_mapping_inj ensures] v1 = v2))
end
module M_impl_Node_K_V__has_mapping (* Node<K, V> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node_K_V
  
  constant k : t_DeepModelTy
  
  constant v : t_V
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V)
  
  goal vc_has_mapping_K: if has_mapping_K self.left k v then
      [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
        -> true = has_mapping_K { node = Some node'0 } k v
    else
      if has_mapping_K self.right k v then
        [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
          -> true = has_mapping_K { node = Some node'0 } k v
      else
        if k = deep_model_K self.key then
          [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
            -> (v = self.val') = has_mapping_K { node = Some node'0 } k v
        else
          [@expl:has_mapping ensures] forall node'0: t_Node_K_V. self = node'0
            -> false = has_mapping_K { node = Some node'0 } k v
      
    

end
module M_impl_Resolve_for_Tree_K_V__resolve_coherence (* <Tree<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  axiom resolve_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  predicate structural_resolve_Tree_K_V (_1: t_Tree_K_V) = resolve_Option_Box_Node_K_V_Global _1.node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  function resolve_coherence_Tree_K_V (self: t_Tree_K_V) : ()
  
  goal vc_resolve_coherence_Tree_K_V: structural_resolve_Tree_K_V self
    -> ([@expl:resolve_coherence ensures] resolve_Tree_K_V self)
end
module M_impl_Resolve_for_Node_K_V__resolve_coherence (* <Node<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Node_K_V (_1: t_Node_K_V) =
    resolve_Tree_K_V'0 _1.left /\ resolve_K _1.key /\ resolve_V _1.val' /\ resolve_Tree_K_V'0 _1.right
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node_K_V
  
  function resolve_coherence_Node_K_V (self: t_Node_K_V) : ()
  
  goal vc_resolve_coherence_Node_K_V: structural_resolve_Node_K_V self
    -> ([@expl:resolve_coherence ensures] resolve_Node_K_V self)
end
module M_impl_Tree_K_V_3__height (* Tree<K, V> *)
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree_K_V
  
  function height_K (self: t_Tree_K_V) : int
  
  goal vc_height_K: match self with
      | {node = None} -> [@expl:height ensures] 0 >= 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0 >= 0
      -> ([@expl:height ensures] height_K left'0 >= 0)
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 >= 0
      -> ([@expl:height ensures] height_K left'0 + 1 >= 0)
      end
end
module M_impl_Node_K_V_2__height (* Node<K, V> *)
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node_K_V
  
  function height_K'0 (self: t_Node_K_V) : int
  
  goal vc_height_K: match self.color with
      | Red -> height_K self.left >= 0
      -> ([@expl:height ensures] forall node'0: t_Node_K_V. self = node'0
        -> height_K self.left = height_K { node = Some node'0 })
      | Black -> height_K self.left >= 0
      -> ([@expl:height ensures] forall node'0: t_Node_K_V. self = node'0
        -> height_K self.left + 1 = height_K { node = Some node'0 })
      end
end
module M_impl_Tree_K_V_5__is_red (* Tree<K, V> *)
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  let rec elim_Some (_x: t_Option_Box_Node_K_V_Global) (return (f0: t_Node_K_V)) = any
    [ _k (f0: t_Node_K_V) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    (! bb0
    [ bb0 = any [ br0 -> {self.node = None} (! bb1) | br1 (x0: t_Node_K_V) -> {self.node = Some x0} (! bb2) ]
    | bb2 = elim_Some {self.node}
        (fun (r0: t_Node_K_V) -> any [ br0 -> {r0.color = Red} (! bb4) | br1 -> {r0.color = Black} (! bb1) ])
    | bb1 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = bb5 ]
    | bb5 = return {_ret} ] [ & _ret: bool = Any.any_l () | & self: t_Tree_K_V = self ])
    [ return (result: bool) -> {[@expl:is_red ensures] result = (color_K self = Red)} (! return {result}) ]
end
module M_impl_Node_K_V_4__rotate_right (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec swap_Tree_K_V (x: MutBorrow.t t_Tree_K_V) (y: MutBorrow.t t_Tree_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Tree_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Tree_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec swap_Node_K_V (x: MutBorrow.t t_Node_K_V) (y: MutBorrow.t t_Node_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Node_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Node_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  let rec swap_Color (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Color [@inline:trivial] (_1: MutBorrow.t t_Color) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Color
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_26 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with left = { node = _bor.final } } } ] s1)
      | s1 = {inv_Option_Box_Node_K_V_Global _26.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_26.current} {MutBorrow.get_id _26}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_25 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &_26 <- { _26 with current = _bor.final } ] s2)
      | s2 = take_Option_Box_Node_K_V_Global {_25} (fun (_x: t_Option_Box_Node_K_V_Global) -> [ &_24 <- _x ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _26} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _26}- s2
      | s2 = unwrap_Box_Node_K_V_Global {_24} (fun (_x: t_Node_K_V) -> [ &x <- _x ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Tree_K_V self.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.left}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_29 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &self <- { self with current = { self.current with left = _bor.final } } ] s1)
      | s1 = {inv_Tree_K_V x.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {x.right}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_31 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &x <- { x with right = _bor.final } ] s2)
      | s2 = {inv_Tree_K_V _29.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_29.current} {MutBorrow.get_id _29}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_28 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &_29 <- { _29 with current = _bor.final } ] s3)
      | s3 = {inv_Tree_K_V _31.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_31.current} {MutBorrow.get_id _31}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_30 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &_31 <- { _31 with current = _bor.final } ] s4)
      | s4 = swap_Tree_K_V {_28} {_30} (fun (_x: ()) -> [ &_27 <- _x ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Tree_K_V _31} s1
      | s1 = -{resolve_ref_Tree_K_V _31}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V _29} s3
      | s3 = -{resolve_ref_Tree_K_V _29}- s4
      | s4 = {inv_Box_Node_K_V_Global x}
        MutBorrow.borrow_mut <t_Node_K_V> {x}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_35 <- _bor ] -{inv_Box_Node_K_V_Global _bor.final}-
            [ &x <- _bor.final ] s5)
      | s5 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_33 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s6)
      | s6 = {inv_Node_K_V _35.current}
        MutBorrow.borrow_final <t_Node_K_V> {_35.current} {MutBorrow.get_id _35}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_34 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_35 <- { _35 with current = _bor.final } ] s7)
      | s7 = swap_Node_K_V {_33} {_34} (fun (_x: ()) -> [ &_32 <- _x ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _35} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _35}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {self.current.color} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_bor: MutBorrow.t t_Color) ->
            [ &_38 <- _bor ] [ &self <- { self with current = { self.current with color = _bor.final } } ] s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.color}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_40 <- _bor ] [ &x <- { x with color = _bor.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_38.current} {MutBorrow.get_id _38}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_37 <- _bor ] [ &_38 <- { _38 with current = _bor.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_40.current} {MutBorrow.get_id _40}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_39 <- _bor ] [ &_40 <- { _40 with current = _bor.final } ] s6)
      | s6 = swap_Color {_37} {_39} (fun (_x: ()) -> [ &_36 <- _x ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve_ref_Color _40}- s1
      | s1 = -{resolve_ref_Color _38}- s2
      | s2 = {[@expl:assertion] has_mapping_K old_self.current.left (deep_model_K self.current.key) self.current.val'}
        s3
      | s3 = [ &_47 <- Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_46 <- { node = _47 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V self.current.right} s1
      | s1 = -{resolve_Tree_K_V'0 self.current.right}- s2
      | s2 = [ &self <- { self with current = { self.current with right = _46 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_K_V self} s4
      | s4 = -{resolve_ref_Node_K_V self}- s5
      | s5 = bb12 ]
    | bb12 = return {_ret} ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & old_self: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & x: t_Node_K_V = Any.any_l ()
    | & _24: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _25: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _26: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _27: () = Any.any_l ()
    | & _28: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _29: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _30: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _31: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _32: () = Any.any_l ()
    | & _33: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _34: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _35: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _36: () = Any.any_l ()
    | & _37: MutBorrow.t t_Color = Any.any_l ()
    | & _38: MutBorrow.t t_Color = Any.any_l ()
    | & _39: MutBorrow.t t_Color = Any.any_l ()
    | & _40: MutBorrow.t t_Color = Any.any_l ()
    | & _46: t_Tree_K_V = Any.any_l ()
    | & _47: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:rotate_right ensures #0] same_mappings_K self.current self.final}
      {[@expl:rotate_right ensures #1] internal_invariant_K self.final}
      {[@expl:rotate_right ensures #2] height_K'0 self.current = height_K'0 self.final}
      {[@expl:rotate_right ensures #3] lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {[@expl:rotate_right ensures #4] color_K self.final.right = Red}
      {[@expl:rotate_right ensures #5] self.final.color = self.current.color}
      {[@expl:rotate_right ensures #6] exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__rotate_left (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec swap_Tree_K_V (x: MutBorrow.t t_Tree_K_V) (y: MutBorrow.t t_Tree_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Tree_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Tree_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec swap_Node_K_V (x: MutBorrow.t t_Node_K_V) (y: MutBorrow.t t_Node_K_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_Node_K_V x}
    {[@expl:swap 'y' type invariant] inv_ref_Node_K_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  let rec swap_Color (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Color [@inline:trivial] (_1: MutBorrow.t t_Color) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Color
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_left_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_left requires #0] internal_invariant_K self.current}
    {[@expl:rotate_left requires #1] color_K self.current.right = Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- self ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_26 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with right = { node = _bor.final } } } ] s1)
      | s1 = {inv_Option_Box_Node_K_V_Global _26.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_26.current} {MutBorrow.get_id _26}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_25 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &_26 <- { _26 with current = _bor.final } ] s2)
      | s2 = take_Option_Box_Node_K_V_Global {_25} (fun (_x: t_Option_Box_Node_K_V_Global) -> [ &_24 <- _x ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _26} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _26}- s2
      | s2 = unwrap_Box_Node_K_V_Global {_24} (fun (_x: t_Node_K_V) -> [ &x <- _x ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv_Tree_K_V self.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.right}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_29 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &self <- { self with current = { self.current with right = _bor.final } } ] s1)
      | s1 = {inv_Tree_K_V x.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {x.left}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_31 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &x <- { x with left = _bor.final } ] s2)
      | s2 = {inv_Tree_K_V _29.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_29.current} {MutBorrow.get_id _29}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_28 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &_29 <- { _29 with current = _bor.final } ] s3)
      | s3 = {inv_Tree_K_V _31.current}
        MutBorrow.borrow_final <t_Tree_K_V> {_31.current} {MutBorrow.get_id _31}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_30 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &_31 <- { _31 with current = _bor.final } ] s4)
      | s4 = swap_Tree_K_V {_28} {_30} (fun (_x: ()) -> [ &_27 <- _x ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Tree_K_V _31} s1
      | s1 = -{resolve_ref_Tree_K_V _31}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V _29} s3
      | s3 = -{resolve_ref_Tree_K_V _29}- s4
      | s4 = {inv_Box_Node_K_V_Global x}
        MutBorrow.borrow_mut <t_Node_K_V> {x}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_35 <- _bor ] -{inv_Box_Node_K_V_Global _bor.final}-
            [ &x <- _bor.final ] s5)
      | s5 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_33 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s6)
      | s6 = {inv_Node_K_V _35.current}
        MutBorrow.borrow_final <t_Node_K_V> {_35.current} {MutBorrow.get_id _35}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_34 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_35 <- { _35 with current = _bor.final } ] s7)
      | s7 = swap_Node_K_V {_33} {_34} (fun (_x: ()) -> [ &_32 <- _x ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _35} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _35}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {self.current.color} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_bor: MutBorrow.t t_Color) ->
            [ &_38 <- _bor ] [ &self <- { self with current = { self.current with color = _bor.final } } ] s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.color}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_40 <- _bor ] [ &x <- { x with color = _bor.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_38.current} {MutBorrow.get_id _38}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_37 <- _bor ] [ &_38 <- { _38 with current = _bor.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_40.current} {MutBorrow.get_id _40}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_39 <- _bor ] [ &_40 <- { _40 with current = _bor.final } ] s6)
      | s6 = swap_Color {_37} {_39} (fun (_x: ()) -> [ &_36 <- _x ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve_ref_Color _40}- s1
      | s1 = -{resolve_ref_Color _38}- s2
      | s2 = {[@expl:assertion] has_mapping_K old_self.current.right (deep_model_K self.current.key) self.current.val'}
        s3
      | s3 = [ &_47 <- Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_46 <- { node = _47 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V self.current.left} s1
      | s1 = -{resolve_Tree_K_V'0 self.current.left}- s2
      | s2 = [ &self <- { self with current = { self.current with left = _46 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Node_K_V self} s4
      | s4 = -{resolve_ref_Node_K_V self}- s5
      | s5 = bb12 ]
    | bb12 = return {_ret} ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & old_self: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & x: t_Node_K_V = Any.any_l ()
    | & _24: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _25: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _26: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _27: () = Any.any_l ()
    | & _28: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _29: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _30: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _31: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _32: () = Any.any_l ()
    | & _33: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _34: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _35: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _36: () = Any.any_l ()
    | & _37: MutBorrow.t t_Color = Any.any_l ()
    | & _38: MutBorrow.t t_Color = Any.any_l ()
    | & _39: MutBorrow.t t_Color = Any.any_l ()
    | & _40: MutBorrow.t t_Color = Any.any_l ()
    | & _46: t_Tree_K_V = Any.any_l ()
    | & _47: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:rotate_left ensures #0] same_mappings_K self.current self.final}
      {[@expl:rotate_left ensures #1] internal_invariant_K self.final}
      {[@expl:rotate_left ensures #2] height_K'0 self.current = height_K'0 self.final}
      {[@expl:rotate_left ensures #3] lt_log_DeepModelTy (deep_model_K self.current.key) (deep_model_K self.final.key)}
      {[@expl:rotate_left ensures #4] color_K self.final.left = Red}
      {[@expl:rotate_left ensures #5] self.final.color = self.current.color}
      {[@expl:rotate_left ensures #6] exists l: t_Node_K_V, r: t_Node_K_V. self.current.right.node = Some r
        /\ self.final.left.node = Some l
        /\ { f0 = l.left; f1 = l.right; f2 = self.final.right } = { f0 = self.current.left; f1 = r.left; f2 = r.right }
        /\ l.key = self.current.key}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__flip_colors (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  let rec swap_Color (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return (x'0: ())) = any
    [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_Color [@inline:trivial] (_1: MutBorrow.t t_Color) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Color
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_23 <- self.current.color ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_26 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with left = { node = _bor.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_26} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_25 <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_25} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_24 <- _x ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_24 <- { _24 with current = { _24.current with color = _23 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _24} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _24}- s3
      | s3 = MutBorrow.borrow_final <t_Color> {self.current.color} {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_bor: MutBorrow.t t_Color) ->
            [ &_29 <- _bor ] [ &self <- { self with current = { self.current with color = _bor.final } } ] s4)
      | s4 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_34 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with right = { node = _bor.final } } } ] s5)
      | s5 = as_mut_Box_Node_K_V_Global {_34} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_33 <- _x ] s6)
      | s6 = bb3 ]
    | bb3 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_33} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_32 <- _x ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_final <t_Color> {_32.current.color} {MutBorrow.inherit_id (MutBorrow.get_id _32) 2}
          (fun (_bor: MutBorrow.t t_Color) ->
            [ &_31 <- _bor ] [ &_32 <- { _32 with current = { _32.current with color = _bor.final } } ] s1)
      | s1 = MutBorrow.borrow_final <t_Color> {_29.current} {MutBorrow.get_id _29}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_28 <- _bor ] [ &_29 <- { _29 with current = _bor.final } ] s2)
      | s2 = MutBorrow.borrow_final <t_Color> {_31.current} {MutBorrow.get_id _31}
          (fun (_bor: MutBorrow.t t_Color) -> [ &_30 <- _bor ] [ &_31 <- { _31 with current = _bor.final } ] s3)
      | s3 = swap_Color {_28} {_30} (fun (_x: ()) -> [ &_27 <- _x ] s4)
      | s4 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _32} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _32}- s2
      | s2 = -{resolve_ref_Color _31}- s3
      | s3 = -{resolve_ref_Color _29}- s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V self} s5
      | s5 = -{resolve_ref_Node_K_V self}- s6
      | s6 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _23: t_Color = Any.any_l ()
    | & _24: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _25: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _26: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _27: () = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _31: MutBorrow.t t_Color = Any.any_l ()
    | & _32: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _33: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _34: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:flip_colors ensures #0] internal_invariant_K self.final}
      {[@expl:flip_colors ensures #1] height_K'0 self.current = height_K'0 self.final}
      {[@expl:flip_colors ensures #2] same_mappings_K self.current self.final}
      {[@expl:flip_colors ensures #3] self.current.key = self.final.key}
      {[@expl:flip_colors ensures #4] exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {[@expl:flip_colors ensures #5] exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__balance (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_left_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_left requires #0] internal_invariant_K self.current}
    {[@expl:rotate_left requires #1] color_K self.current.right = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.current.key) (deep_model_K self.final.key)}
      {color_K self.final.left = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.right.node = Some r
        /\ self.final.left.node = Some l
        /\ { f0 = l.left; f1 = l.right; f2 = self.final.right } = { f0 = self.current.left; f1 = r.left; f2 = r.right }
        /\ l.key = self.current.key}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 t_Node_K_V
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: t_Node_K_V) = inv_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_ref_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_ref 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_ = None -> result = None'0}
      {self_ = None \/ (exists r: t_Node_K_V. result = Some'0 r /\ self_ = Some r)}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result} {Some'0 result = self_} (! return {result}) ]
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {same_mappings_K self.current self.final}
      {self.current.key = self.final.key}
      {exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    (! bb0
    [ bb0 = s0 [ s0 = is_red_K {self.current.right} (fun (_x: bool) -> [ &_31 <- _x ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_31 = false} (! bb9) | br1 -> {_31} (! bb2) ]
    | bb2 = s0 [ s0 = is_red_K {self.current.left} (fun (_x: bool) -> [ &_33 <- _x ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_33 = false} (! bb5) | br1 -> {_33} (! bb9) ]
    | bb5 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_36 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = rotate_left_K {_36} (fun (_x: ()) -> [ &_35 <- _x ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red_K {self.current.left} (fun (_x: bool) -> [ &_38 <- _x ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_38 = false} (! bb20) | br1 -> {_38} (! bb11) ]
    | bb11 = s0
      [ s0 = as_ref_Box_Node_K_V_Global {self.current.left.node}
          (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_43 <- _x ] s1)
      | s1 = bb12 ]
    | bb12 = s0 [ s0 = unwrap_ref_Box_Node_K_V_Global {_43} (fun (_x: t_Node_K_V) -> [ &_42 <- _x ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = is_red_K {_42.left} (fun (_x: bool) -> [ &_40 <- _x ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb15) ]
    | bb15 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_46 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = rotate_right_K {_46} (fun (_x: ()) -> [ &_45 <- _x ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = is_red_K {self.current.left} (fun (_x: bool) -> [ &_47 <- _x ] s1) | s1 = bb21 ]
    | bb21 = any [ br0 -> {_47 = false} (! bb27) | br1 -> {_47} (! bb22) ]
    | bb22 = s0 [ s0 = is_red_K {self.current.right} (fun (_x: bool) -> [ &_49 <- _x ] s1) | s1 = bb23 ]
    | bb23 = any [ br0 -> {_49 = false} (! bb26) | br1 -> {_49} (! bb24) ]
    | bb24 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_final <t_Node_K_V> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_52 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = flip_colors_K {_52} (fun (_x: ()) -> [ &_51 <- _x ] s2)
      | s2 = bb25 ]
    | bb25 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb29 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb29 ]
    | bb27 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb29 ]
    | bb29 = return {_ret} ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _31: bool = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: () = Any.any_l ()
    | & _36: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _38: bool = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & _42: t_Node_K_V = Any.any_l ()
    | & _43: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _45: () = Any.any_l ()
    | & _46: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _47: bool = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: () = Any.any_l ()
    | & _52: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: ()) -> {[@expl:balance ensures #0] same_mappings_K self.current self.final}
      {[@expl:balance ensures #1] internal_invariant_K self.final}
      {[@expl:balance ensures #2] height_K'0 self.current = height_K'0 self.final}
      {[@expl:balance ensures #3] color_invariant_K self.current.left /\ color_K self.current.right = Black
      -> self.current = self.final}
      {[@expl:balance ensures #4] match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {[@expl:balance ensures #5] match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {[@expl:balance ensures #6] match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {[@expl:balance ensures #7] match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current
      -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__move_red_left (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {same_mappings_K self.current self.final}
      {self.current.key = self.final.key}
      {exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  let rec rotate_left_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_left requires #0] internal_invariant_K self.current}
    {[@expl:rotate_left requires #1] color_K self.current.right = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.current.key) (deep_model_K self.final.key)}
      {color_K self.final.left = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.right.node = Some r
        /\ self.final.left.node = Some l
        /\ { f0 = l.left; f1 = l.right; f2 = self.final.right } = { f0 = self.current.left; f1 = r.left; f2 = r.right }
        /\ l.key = self.current.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_left_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_left requires #0] self.current.right.node <> None}
    {[@expl:move_red_left requires #1] internal_invariant_K self.current}
    {[@expl:move_red_left requires #2] match_n_K (cpn (Red) (cpn (Black) (CPL (Black)) (CPL (Black))) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_26 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = flip_colors_K {_26} (fun (_x: ()) -> [ &_25 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_32 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with right = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_32} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_31 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_31} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_30 <- _x ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _30} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _30}- s2
      | s2 = is_red_K {_30.current.left} (fun (_x: bool) -> [ &_28 <- _x ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_38 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with right = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_38} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_37 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_37} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_36 <- _x ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {inv_Node_K_V _36.current}
        MutBorrow.borrow_final <t_Node_K_V> {_36.current} {MutBorrow.get_id _36}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_35 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_36 <- { _36 with current = _bor.final } ] s1)
      | s1 = rotate_right_K {_35} (fun (_x: ()) -> [ &_34 <- _x ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _36} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _36}- s2
      | s2 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_40 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s3)
      | s3 = rotate_left_K {_40} (fun (_x: ()) -> [ &_39 <- _x ] s4)
      | s4 = bb9 ]
    | bb9 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_42 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = flip_colors_K {_42} (fun (_x: ()) -> [ &_41 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_45 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with left = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_45} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_44 <- _x ] s2)
      | s2 = bb11 ]
    | bb11 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_44} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_43 <- _x ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Node_K_V _43.current}
        MutBorrow.borrow_final <t_Node_K_V> {_43.current} {MutBorrow.get_id _43}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_ret <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_43 <- { _43 with current = _bor.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _43} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _43}- s3
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb14 ]
    | bb13 = s0 [ s0 = [ &_ret <- self ] s1 | s1 = bb14 ]
    | bb14 = return {_ret} ]
    [ & _ret: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _25: () = Any.any_l ()
    | & _26: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _31: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _32: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _34: () = Any.any_l ()
    | & _35: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _36: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _37: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _38: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _39: () = Any.any_l ()
    | & _40: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _41: () = Any.any_l ()
    | & _42: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _43: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _44: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _45: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: MutBorrow.t t_Node_K_V) -> {[@expl:move_red_left result type invariant] inv_ref_Node_K_V result}
      {[@expl:move_red_left ensures #0] internal_invariant_K result.current}
      {[@expl:move_red_left ensures #1] internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {[@expl:move_red_left ensures #2] height_K'0 result.current = height_K'0 result.final
      -> height_K'0 self.current = height_K'0 self.final}
      {[@expl:move_red_left ensures #3] self.current.key = result.current.key}
      {[@expl:move_red_left ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v
        -> has_mapping_K'0 self.current k v}
      {[@expl:move_red_left ensures #5] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy k (deep_model_K self.current.key) -> has_mapping_K'0 result.current k v}
      {[@expl:move_red_left ensures #6] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {[@expl:move_red_left ensures #7] match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {[@expl:move_red_left ensures #8] color_invariant_K'0 result.final
        /\ (color_K result.current.right = Black -> result.final.color = Black) -> color_invariant_K'0 self.final}
      (! return {result}) ]
end
module M_impl_Node_K_V_4__move_red_right (* Node<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  let rec flip_colors_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:flip_colors 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:flip_colors requires #0] internal_invariant_K self.current}
    {[@expl:flip_colors requires #1] self.current.left.node <> None}
    {[@expl:flip_colors requires #2] self.current.right.node <> None}
    {[@expl:flip_colors requires #3] color_K self.current.left = color_K self.current.right}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {same_mappings_K self.current self.final}
      {self.current.key = self.final.key}
      {exists l1: t_Node_K_V, l2: t_Node_K_V. self.current.left.node = Some l1
        /\ self.final.left.node = Some l2
        /\ l1.left = l2.left
        /\ l1.right = l2.right /\ l1.key = l2.key /\ self.current.color = l2.color /\ self.final.color = l1.color}
      {exists r1: t_Node_K_V, r2: t_Node_K_V. self.current.right.node = Some r1
        /\ self.final.right.node = Some r2
        /\ r1.left = r2.left
        /\ r1.right = r2.right
        /\ r1.key = r2.key /\ self.current.color = r2.color /\ self.final.color = r1.color /\ r1.key = r2.key}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_right_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_right requires #0] self.current.left.node <> None}
    {[@expl:move_red_right requires #1] internal_invariant_K self.current}
    {[@expl:move_red_right requires #2] match_n_K (cpn (Red) (CPL (Black)) (cpn (Black) (CPL (Black)) (CPL (Black)))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_26 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = flip_colors_K {_26} (fun (_x: ()) -> [ &_25 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.left.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.left.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_32 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with left = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_32} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_31 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_31} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_30 <- _x ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _30} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _30}- s2
      | s2 = is_red_K {_30.current.left} (fun (_x: bool) -> [ &_28 <- _x ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_28 = false} (! bb10) | br1 -> {_28} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_35 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = rotate_right_K {_35} (fun (_x: ()) -> [ &_34 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {inv_Node_K_V self.current}
        MutBorrow.borrow_mut <t_Node_K_V> {self.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_37 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = flip_colors_K {_37} (fun (_x: ()) -> [ &_36 <- _x ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.right.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.right.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 5) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_40 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { self.current with right = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_40} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_39 <- _x ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_39} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_38 <- _x ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {inv_Node_K_V _38.current}
        MutBorrow.borrow_final <t_Node_K_V> {_38.current} {MutBorrow.get_id _38}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_ret <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_38 <- { _38 with current = _bor.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _38} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _38}- s3
      | s3 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V self} s1 | s1 = -{resolve_ref_Node_K_V self}- s2 | s2 = bb11 ]
    | bb10 = s0 [ s0 = [ &_ret <- self ] s1 | s1 = bb11 ]
    | bb11 = return {_ret} ]
    [ & _ret: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Node_K_V = self
    | & _25: () = Any.any_l ()
    | & _26: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _31: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _32: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _34: () = Any.any_l ()
    | & _35: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _36: () = Any.any_l ()
    | & _37: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _38: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _39: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _40: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: MutBorrow.t t_Node_K_V) -> {[@expl:move_red_right result type invariant] inv_ref_Node_K_V result}
      {[@expl:move_red_right ensures #0] internal_invariant_K result.current}
      {[@expl:move_red_right ensures #1] internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {[@expl:move_red_right ensures #2] height_K'0 result.current = height_K'0 result.final
      -> height_K'0 self.current = height_K'0 self.final}
      {[@expl:move_red_right ensures #3] result.current.key = self.current.key}
      {[@expl:move_red_right ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v
        -> has_mapping_K'0 self.current k v}
      {[@expl:move_red_right ensures #5] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy (deep_model_K self.current.key) k -> has_mapping_K'0 result.current k v}
      {[@expl:move_red_right ensures #6] forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {[@expl:move_red_right ensures #7] match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {[@expl:move_red_right ensures #8] color_invariant_K'0 result.final
        /\ (color_K result.current.left = Black -> result.final.color = Black) -> color_invariant_K'0 self.final}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__insert_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  axiom resolve_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  let rec elim_Some (_x: t_Option_Box_Node_K_V_Global) (return (f0: t_Node_K_V)) = any
    [ _k (f0: t_Node_K_V) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_ref_K_ref_K = { f0: t_K; f1: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (val''0: t_V) (return (x: ())) =
    {[@expl:insert_rec 'self' type invariant] inv_ref_Tree_K_V self}
    {[@expl:insert_rec 'key' type invariant] inv_K key'0}
    {[@expl:insert_rec 'val' type invariant] inv_V val''0}
    {[@expl:insert_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:insert_rec requires #1] color_invariant_K self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_21 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { node = _bor.final } } ] s1)
      | s1 = any [ br0 -> {_21.current = None} (! bb17) | br1 (x0: t_Node_K_V) -> {_21.current = Some x0} (! bb2) ] ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _21} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _21}- s2
      | s2 = [ &_44 <- None ] s3
      | s3 = [ &_43 <- { node = _44 } ] s4
      | s4 = bb18 ]
    | bb18 = s0 [ s0 = [ &_45 <- Red ] s1 | s1 = [ &_49 <- None ] s2 | s2 = [ &_48 <- { node = _49 } ] s3 | s3 = bb19 ]
    | bb19 = s0 [ s0 = [ &_42 <- { left = _43; color = _45; key = key'0; val' = val''0; right = _48 } ] s1 | s1 = bb24 ]
    | bb24 = s0 [ s0 = [ &_40 <- Some _42 ] s1 | s1 = bb26 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv_Option_Box_Node_K_V_Global self.current.node} s1
      | s1 = -{resolve_Option_Box_Node_K_V_Global self.current.node}- s2
      | s2 = [ &self <- { self with current = { node = _40 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Tree_K_V self} s4
      | s4 = -{resolve_ref_Tree_K_V self}- s5
      | s5 = bb32 ]
    | bb2 = s0
      [ s0 = elim_Some {_21.current}
          (fun (r0: t_Node_K_V) ->
            {inv_Box_Node_K_V_Global r0}
            MutBorrow.borrow_final <t_Node_K_V> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _21) 1}
              (fun (_bor: MutBorrow.t t_Node_K_V) ->
                [ &node'0 <- _bor ] -{inv_Box_Node_K_V_Global _bor.final}-
                [ &_21 <- { _21 with current = Some _bor.final } ] s1))
      | s1 = [ &_28 <- node'0.current.key ] s2
      | s2 = cmp_K {key'0} {_28} (fun (_x: t_Ordering) -> [ &_25 <- _x ] s3)
      | s3 = bb3 ]
    | bb3 = any [ br0 -> {_25 = Less} (! bb9) | br1 -> {_25 = Equal} (! bb6) | br2 -> {_25 = Greater} (! bb7) ]
    | bb7 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_35 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _bor.final } } ] s1)
      | s1 = insert_rec_K {_35} {key'0} {val''0} (fun (_x: ()) -> [ &_24 <- _x ] s2)
      | s2 = bb15 ]
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv_K key'0} s1 | s1 = -{resolve_K key'0}- s2 | s2 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv_V node'0.current.val'} s1
      | s1 = -{resolve_V node'0.current.val'}- s2
      | s2 = [ &node'0 <- { node'0 with current = { node'0.current with val' = val''0 } } ] s3
      | s3 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s4
      | s4 = -{resolve_ref_Box_Node_K_V_Global node'0}- s5
      | s5 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _21} s6
      | s6 = -{resolve_ref_Option_Box_Node_K_V_Global _21}- s7
      | s7 = {[@expl:type invariant] inv_ref_Tree_K_V self} s8
      | s8 = -{resolve_ref_Tree_K_V self}- s9
      | s9 = bb32 ]
    | bb9 = s0
      [ s0 = {inv_Tree_K_V node'0.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.left}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_30 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with left = _bor.final } } ] s1)
      | s1 = insert_rec_K {_30} {key'0} {val''0} (fun (_x: ()) -> [ &_24 <- _x ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_39 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = balance_K {_39} (fun (_x: ()) -> [ &_38 <- _x ] s2)
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _21} s3
      | s3 = -{resolve_ref_Option_Box_Node_K_V_Global _21}- s4
      | s4 = {[@expl:type invariant] inv_ref_Tree_K_V self} s5
      | s5 = -{resolve_ref_Tree_K_V self}- s6
      | s6 = bb32 ]
    | bb32 = return {_ret} ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & key'0: t_K = key'0
    | & val''0: t_V = val''0
    | & _21: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: t_Ordering = Any.any_l ()
    | & _28: t_K = Any.any_l ()
    | & _30: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _35: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _38: () = Any.any_l ()
    | & _39: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _40: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _42: t_Node_K_V = Any.any_l ()
    | & _43: t_Tree_K_V = Any.any_l ()
    | & _44: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _45: t_Color = Any.any_l ()
    | & _48: t_Tree_K_V = Any.any_l ()
    | & _49: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:insert_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:insert_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:insert_rec ensures #2] match_t_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final
        /\ color_K self.current = Red
      \/ color_invariant_K self.final}
      {[@expl:insert_rec ensures #3] has_mapping_K self.final (deep_model_K key'0) val''0}
      {[@expl:insert_rec ensures #4] forall k: t_DeepModelTy, v: t_V. k = deep_model_K key'0
        \/ has_mapping_K self.current k v = has_mapping_K self.final k v}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__delete_max_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec as_mut_Box_Node_K_V_Global'0 (self_: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0: t_Tree_K_V; f1: t_Tree_K_V; f2: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0 = self.final.left; f1 = r.left; f2 = r.right } = { f0 = l.left; f1 = l.right; f2 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  let rec elim_Some (_x: t_Option_Box_Node_K_V_Global) (return (f0'1: t_Node_K_V)) = any
    [ _k (f0'1: t_Node_K_V) -> {Some f0'1 = _x} (! return {f0'1})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec move_red_right_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_right requires #0] self.current.left.node <> None}
    {[@expl:move_red_right requires #1] internal_invariant_K self.current}
    {[@expl:move_red_right requires #2] match_n_K (cpn (Red) (CPL (Black)) (cpn (Black) (CPL (Black)) (CPL (Black)))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {result.current.key = self.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy (deep_model_K self.current.key) k -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.left = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_max_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_max_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_max_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_24 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { node = _bor.final } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_24} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_23 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_23} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_22 <- _x ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Box_Node_K_V_Global _22.current}
        MutBorrow.borrow_final <t_Node_K_V> {_22.current} {MutBorrow.get_id _22}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_21 <- _bor ] -{inv_Box_Node_K_V_Global _bor.final}-
            [ &_22 <- { _22 with current = _bor.final } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global'0 {_21} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &node'0 <- _x ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _22} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _22}- s2
      | s2 = is_red_K {node'0.current.left} (fun (_x: bool) -> [ &_26 <- _x ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_26 = false} (! bb8) | br1 -> {_26} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_mut <t_Node_K_V> {node'0.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_28 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = rotate_right_K {_28} (fun (_x: ()) -> [ &_25 <- _x ] s2)
      | s2 = bb8 ]
    | bb8 = s0 [ s0 = is_red_K {node'0.current.right} (fun (_x: bool) -> [ &_30 <- _x ] s1) | s1 = bb9 ]
    | bb9 = any [ br0 -> {_30 = false} (! bb11) | br1 -> {_30} (! bb24) ]
    | bb11 = s0
      [ s0 = [ &_40 <- node'0.current.right.node ] s1
      | s1 = any [ br0 -> {_40 = None} (! bb18) | br1 (x0: t_Node_K_V) -> {_40 = Some x0} (! bb17) ] ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.node}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_36 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { node = _bor.final } } ] s3)
      | s3 = {inv_Option_Box_Node_K_V_Global _36.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_36.current} {MutBorrow.get_id _36}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_35 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &_36 <- { _36 with current = _bor.final } ] s4)
      | s4 = take_Option_Box_Node_K_V_Global {_35} (fun (_x: t_Option_Box_Node_K_V_Global) -> [ &_34 <- _x ] s5)
      | s5 = bb12 ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _36} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _36}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = unwrap_Box_Node_K_V_Global {_34} (fun (_x: t_Node_K_V) -> [ &node'1 <- _x ] s5)
      | s5 = bb13 ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V node'1.right} s1
      | s1 = -{resolve_Tree_K_V'0 node'1.right}- s2
      | s2 = {[@expl:type invariant] inv_Tree_K_V node'1.left} s3
      | s3 = -{resolve_Tree_K_V'0 node'1.left}- s4
      | s4 = [ &_ret <- { f0'0 = node'1.key; f1'0 = node'1.val' } ] s5
      | s5 = bb29 ]
    | bb17 = s0
      [ s0 = elim_Some {_40} (fun (r0: t_Node_K_V) -> [ &right'0 <- r0 ] s1)
      | s1 = is_red_K {right'0.left} (fun (_x: bool) -> [ &_42 <- _x ] s2)
      | s2 = bb19 ]
    | bb19 = any [ br0 -> {_42 = false} (! bb21) | br1 -> {_42} (! bb24) ]
    | bb21 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_46 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = move_red_right_K {_46} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_45 <- _x ] s2)
      | s2 = bb22 ]
    | bb22 = s0
      [ s0 = {inv_Node_K_V _45.current}
        MutBorrow.borrow_final <t_Node_K_V> {_45.current} {MutBorrow.get_id _45}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_44 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_45 <- { _45 with current = _bor.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _44 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _45} s5
      | s5 = -{resolve_ref_Node_K_V _45}- s6
      | s6 = bb24 ]
    | bb24 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_48 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _bor.final } } ] s1)
      | s1 = delete_max_rec_K {_48} (fun (_x: tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb25 ]
    | bb25 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_50 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = balance_K {_50} (fun (_x: ()) -> [ &_49 <- _x ] s2)
      | s2 = bb26 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = [ &_ret <- r ] s5
      | s5 = bb29 ]
    | bb29 = return {_ret} ]
    [ & _ret: tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _21: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _22: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _23: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _24: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _25: () = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & node'1: t_Node_K_V = Any.any_l ()
    | & _34: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _35: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _36: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & right'0: t_Node_K_V = Any.any_l ()
    | & _40: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _45: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _46: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _48: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _49: () = Any.any_l ()
    | & _50: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: tup2_K_V) -> {[@expl:delete_max_rec result type invariant] inv_tup2_K_V result}
      {[@expl:delete_max_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:delete_max_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:delete_max_rec ensures #2] has_mapping_K self.current (deep_model_K result.f0'0) result.f1'0}
      {[@expl:delete_max_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy k (deep_model_K result.f0'0)}
      {[@expl:delete_max_rec ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'0 <> k /\ has_mapping_K self.current k v)}
      {[@expl:delete_max_rec ensures #5] color_invariant_K self.final}
      {[@expl:delete_max_rec ensures #6] color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__delete_min_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec as_mut_Box_Node_K_V_Global'0 (self_: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  let rec elim_Some (_x: t_Option_Box_Node_K_V_Global) (return (f0'0: t_Node_K_V)) = any
    [ _k (f0'0: t_Node_K_V) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  let rec move_red_left_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_left requires #0] self.current.right.node <> None}
    {[@expl:move_red_left requires #1] internal_invariant_K self.current}
    {[@expl:move_red_left requires #2] match_n_K (cpn (Red) (cpn (Black) (CPL (Black)) (CPL (Black))) (CPL (Black))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {self.current.key = result.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy k (deep_model_K self.current.key) -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.right = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_min_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_min_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_min_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_24 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { node = _bor.final } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_24} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_23 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_23} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_22 <- _x ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Box_Node_K_V_Global _22.current}
        MutBorrow.borrow_final <t_Node_K_V> {_22.current} {MutBorrow.get_id _22}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_21 <- _bor ] -{inv_Box_Node_K_V_Global _bor.final}-
            [ &_22 <- { _22 with current = _bor.final } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global'0 {_21} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &node'0 <- _x ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _22} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _22}- s2
      | s2 = is_red_K {node'0.current.left} (fun (_x: bool) -> [ &_26 <- _x ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_26 = false} (! bb6) | br1 -> {_26} (! bb19) ]
    | bb6 = s0
      [ s0 = [ &_36 <- node'0.current.left.node ] s1
      | s1 = any [ br0 -> {_36 = None} (! bb13) | br1 (x0: t_Node_K_V) -> {_36 = Some x0} (! bb12) ] ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.node}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_32 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { node = _bor.final } } ] s3)
      | s3 = {inv_Option_Box_Node_K_V_Global _32.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_32.current} {MutBorrow.get_id _32}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_31 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &_32 <- { _32 with current = _bor.final } ] s4)
      | s4 = take_Option_Box_Node_K_V_Global {_31} (fun (_x: t_Option_Box_Node_K_V_Global) -> [ &_30 <- _x ] s5)
      | s5 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _32} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _32}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = unwrap_Box_Node_K_V_Global {_30} (fun (_x: t_Node_K_V) -> [ &node'1 <- _x ] s5)
      | s5 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V node'1.right} s1
      | s1 = -{resolve_Tree_K_V'0 node'1.right}- s2
      | s2 = {[@expl:type invariant] inv_Tree_K_V node'1.left} s3
      | s3 = -{resolve_Tree_K_V'0 node'1.left}- s4
      | s4 = [ &_ret <- { f0 = node'1.key; f1 = node'1.val' } ] s5
      | s5 = bb24 ]
    | bb12 = s0
      [ s0 = elim_Some {_36} (fun (r0: t_Node_K_V) -> [ &left'0 <- r0 ] s1)
      | s1 = is_red_K {left'0.left} (fun (_x: bool) -> [ &_38 <- _x ] s2)
      | s2 = bb14 ]
    | bb14 = any [ br0 -> {_38 = false} (! bb16) | br1 -> {_38} (! bb19) ]
    | bb16 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_42 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = move_red_left_K {_42} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_41 <- _x ] s2)
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = {inv_Node_K_V _41.current}
        MutBorrow.borrow_final <t_Node_K_V> {_41.current} {MutBorrow.get_id _41}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_40 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_41 <- { _41 with current = _bor.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _40 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _41} s5
      | s5 = -{resolve_ref_Node_K_V _41}- s6
      | s6 = bb19 ]
    | bb19 = s0
      [ s0 = {inv_Tree_K_V node'0.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.left}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_44 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with left = _bor.final } } ] s1)
      | s1 = delete_min_rec_K {_44} (fun (_x: tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb20 ]
    | bb20 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_46 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = balance_K {_46} (fun (_x: ()) -> [ &_45 <- _x ] s2)
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = [ &_ret <- r ] s5
      | s5 = bb24 ]
    | bb24 = return {_ret} ]
    [ & _ret: tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _21: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _22: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _23: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _24: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & node'1: t_Node_K_V = Any.any_l ()
    | & _30: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _31: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _32: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & left'0: t_Node_K_V = Any.any_l ()
    | & _36: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _38: bool = Any.any_l ()
    | & _40: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _41: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _42: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _44: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _45: () = Any.any_l ()
    | & _46: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: tup2_K_V) -> {[@expl:delete_min_rec result type invariant] inv_tup2_K_V result}
      {[@expl:delete_min_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:delete_min_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:delete_min_rec ensures #2] has_mapping_K self.current (deep_model_K result.f0) result.f1}
      {[@expl:delete_min_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy (deep_model_K result.f0) k}
      {[@expl:delete_min_rec ensures #4] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0 <> k /\ has_mapping_K self.current k v)}
      {[@expl:delete_min_rec ensures #5] color_invariant_K self.final}
      {[@expl:delete_min_rec ensures #6] color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
end
module M_impl_Tree_K_V_6__delete_rec (* Tree<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Box_Node_K_V_Global f0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  predicate invariant_ref_Node_K_V [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Node_K_V self.current /\ inv_Node_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Node_K_V
  
  predicate inv_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = invariant_ref_Node_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Node_K_V
  
  let rec as_mut_Box_Node_K_V_Global'0 (self_: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {self_.current = result.current}
      {self_.final = result.final}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_ref_K_ref_K = { f0: t_K; f1: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0 = self_; f1 = rhs } result} (! return {result}) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  predicate bst_invariant_K'0 (self: t_Node_K_V) =
    bst_invariant_here_K self /\ bst_invariant_K self.left /\ bst_invariant_K self.right
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate height_invariant_K'0 (self: t_Node_K_V) =
    height_invariant_here_K self /\ height_invariant_K self.left /\ height_invariant_K self.right
  
  predicate internal_invariant_K (self: t_Node_K_V) = bst_invariant_K'0 self /\ height_invariant_K'0 self
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate same_mappings_K (self: t_Node_K_V) (o: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v = has_mapping_K'0 o k v
  
  function height_K'0 (self: t_Node_K_V) : int = match self.color with
      | Red -> height_K self.left
      | Black -> height_K self.left + 1
      end
  
  axiom height_K_spec'0: forall self: t_Node_K_V. forall node'0: t_Node_K_V. self = node'0
        -> height_K'0 self = height_K { node = Some node'0 }
  
  type tup3_Tree_K_V_Tree_K_V_Tree_K_V = { f0'0: t_Tree_K_V; f1'0: t_Tree_K_V; f2'0: t_Tree_K_V }
  
  let rec rotate_right_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:rotate_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:rotate_right requires #0] internal_invariant_K self.current}
    {[@expl:rotate_right requires #1] color_K self.current.left = Red}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {lt_log_DeepModelTy (deep_model_K self.final.key) (deep_model_K self.current.key)}
      {color_K self.final.right = Red}
      {self.final.color = self.current.color}
      {exists l: t_Node_K_V, r: t_Node_K_V. self.current.left.node = Some l
        /\ self.final.right.node = Some r
        /\ { f0'0 = self.final.left; f1'0 = r.left; f2'0 = r.right }
          = { f0'0 = l.left; f1'0 = l.right; f2'0 = self.current.right }
        /\ r.key = self.current.key}
      (! return {result}) ]
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  type t_Option_tup2_K_V = None'1 | Some'1 tup2_K_V
  
  predicate resolve_ref_Node_K_V [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node_K_V
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  type t_Option_ref_Box_Node_K_V_Global'0 = None'2 | Some'2 t_Node_K_V
  
  predicate invariant_ref_Option_Box_Node_K_V_Global'0 [@inline:trivial] (self: t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global'0
  
  predicate inv_ref_Option_Box_Node_K_V_Global'0 [@inline:trivial] (_1: t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global'0 _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global'0
  
  predicate invariant_ref_Box_Node_K_V_Global'0 [@inline:trivial] (self: t_Node_K_V) = inv_Box_Node_K_V_Global self
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global'0
  
  predicate inv_ref_Box_Node_K_V_Global'0 [@inline:trivial] (_1: t_Node_K_V) = invariant_ref_Box_Node_K_V_Global'0 _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global'0
  
  predicate inv_Option_ref_Box_Node_K_V_Global'0 (_1: t_Option_ref_Box_Node_K_V_Global'0)
  
  axiom inv_axiom'3 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global'0 [inv_Option_ref_Box_Node_K_V_Global'0 x]. inv_Option_ref_Box_Node_K_V_Global'0 x
      = match x with
        | None'2 -> true
        | Some'2 f0'2 -> inv_ref_Box_Node_K_V_Global'0 f0'2
        end
  
  let rec as_ref_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global'0)) =
    {[@expl:as_ref 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global'0 self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global'0) -> {inv_Option_ref_Box_Node_K_V_Global'0 result}
      {self_ = None -> result = None'2}
      {self_ = None \/ (exists r: t_Node_K_V. result = Some'2 r /\ self_ = Some r)}
      (! return {result}) ]
  
  type t_Option_Infallible = None'3 | Some'3 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Continue t_Node_K_V | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'3 -> true
        | Some'3 f0'2 -> inv_Infallible f0'2
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'5 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'2 -> inv_ref_Box_Node_K_V_Global'0 f0'2
        | Break f0'2 -> inv_Option_Infallible f0'2
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global'0)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global'0 self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'2 v -> result = Continue v
        | None'2 -> result = Break (None'3)
        end}
      (! return {result}) ]
  
  let rec elim_Break (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (return (f0'2: t_Option_Infallible)) = any
    [ _k (f0'2: t_Option_Infallible) -> {Break f0'2 = _x} (! return {f0'2})
    | _chk -> (! {match _x with
        | Break _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'1 /\ inv_V _1.f1'1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'1 -> true
        | Some'1 f0'2 -> inv_tup2_K_V f0'2
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'1} (! return {result}) ]
  
  let rec elim_Continue (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) (return (f0'2: t_Node_K_V)) = any
    [ _k (f0'2: t_Node_K_V) -> {Continue f0'2 = _x} (! return {f0'2})
    | _chk -> (! {match _x with
        | Continue _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate color_invariant_K'0 (self: t_Node_K_V) =
    color_invariant_here_K self /\ color_invariant_K self.left /\ color_invariant_K self.right
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  predicate match_n_K (self: t_CP) (node'0: t_Node_K_V) =
    match self with
      | CPL color'0 -> node'0.color = color'0 /\ color_invariant_K'0 node'0
      | CPN color'0 l r -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec move_red_right_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_right 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_right requires #0] self.current.left.node <> None}
    {[@expl:move_red_right requires #1] internal_invariant_K self.current}
    {[@expl:move_red_right requires #2] match_n_K (cpn (Red) (CPL (Black)) (cpn (Black) (CPL (Black)) (CPL (Black)))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {result.current.key = self.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy (deep_model_K self.current.key) k -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.left = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: t_Option_Box_Node_K_V_Global) =
    let () = args in inv_Option_Box_Node_K_V_Global result /\ result = None
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_once_default_spec:
    forall self: (), args: (), res: t_Option_Box_Node_K_V_Global. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_Option_Box_Node_K_V_Global) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_Option_Box_Node_K_V_Global. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_Option_Box_Node_K_V_Global (return (x: t_Option_Box_Node_K_V_Global)) = any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = None}
      (! return {result}) ]
  
  let rec take_Option_Box_Node_K_V_Global (dest: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_Box_Node_K_V_Global)) =
    {[@expl:take 'dest' type invariant] inv_ref_Option_Box_Node_K_V_Global dest}
    any
    [ return (result: t_Option_Box_Node_K_V_Global) -> {inv_Option_Box_Node_K_V_Global result}
      {result = dest.current}
      {postcondition_default () () dest.final}
      (! return {result}) ]
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  let rec unwrap_Box_Node_K_V_Global (self_: t_Option_Box_Node_K_V_Global) (return (x: t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None}
    any [ return (result: t_Node_K_V) -> {inv_Box_Node_K_V_Global result} {Some result = self_} (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  let rec elim_Some (_x: t_Option_Box_Node_K_V_Global) (return (f0'2: t_Node_K_V)) = any
    [ _k (f0'2: t_Node_K_V) -> {Some f0'2 = _x} (! return {f0'2})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate internal_invariant_K'0 (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  let rec delete_min_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_min_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_min_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_min_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: tup2_K_V) -> {inv_tup2_K_V result}
      {internal_invariant_K'0 self.final}
      {height_K self.current = height_K self.final}
      {has_mapping_K self.current (deep_model_K result.f0'1) result.f1'1}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy (deep_model_K result.f0'1) k}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'1 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  type t_Option_V = None'4 | Some'4 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'4 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'4))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'4 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'4 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'4 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'4 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'4)) k in has_mapping_model_acc_K self (Const.const (None'4)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'4 v))
  
  function has_mapping_inj_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : () = has_mapping_model_K self k
  
  axiom has_mapping_inj_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy, v1: t_V, v2: t_V. bst_invariant_K self
      -> has_mapping_K self k v1 -> has_mapping_K self k v2 -> v1 = v2
  
  predicate invariant_ref_K'0 [@inline:trivial] (self: MutBorrow.t t_K) = inv_K self.current /\ inv_K self.final
  
  meta "rewrite_def" predicate invariant_ref_K'0
  
  predicate inv_ref_K'0 [@inline:trivial] (_1: MutBorrow.t t_K) = invariant_ref_K'0 _1
  
  meta "rewrite_def" predicate inv_ref_K'0
  
  let rec swap_K (x: MutBorrow.t t_K) (y: MutBorrow.t t_K) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_K'0 x}
    {[@expl:swap 'y' type invariant] inv_ref_K'0 y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_K [@inline:trivial] (_1: MutBorrow.t t_K) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: MutBorrow.t t_V) = inv_V self.current /\ inv_V self.final
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  let rec swap_V (x: MutBorrow.t t_V) (y: MutBorrow.t t_V) (return (x'0: ())) =
    {[@expl:swap 'x' type invariant] inv_ref_V x}
    {[@expl:swap 'y' type invariant] inv_ref_V y}
    any [ return (result: ()) -> {x.final = y.current} {y.final = x.current} (! return {result}) ]
  
  predicate resolve_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_V
  
  let rec move_red_left_K (self: MutBorrow.t t_Node_K_V) (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:move_red_left 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:move_red_left requires #0] self.current.right.node <> None}
    {[@expl:move_red_left requires #1] internal_invariant_K self.current}
    {[@expl:move_red_left requires #2] match_n_K (cpn (Red) (cpn (Black) (CPL (Black)) (CPL (Black))) (CPL (Black))) self.current}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Node_K_V result}
      {internal_invariant_K result.current}
      {internal_invariant_K result.final
        /\ height_K'0 result.current = height_K'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.final k v -> has_mapping_K'0 result.current k v)
      -> internal_invariant_K self.final}
      {height_K'0 result.current = height_K'0 result.final -> height_K'0 self.current = height_K'0 self.final}
      {self.current.key = result.current.key}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 result.current k v -> has_mapping_K'0 self.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.current k v
          /\ le_log_DeepModelTy k (deep_model_K self.current.key) -> has_mapping_K'0 result.current k v}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self.final k v
        = (has_mapping_K'0 result.final k v
        \/ has_mapping_K'0 self.current k v /\ not has_mapping_K'0 result.current k v)}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) result.current
      \/ match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) result.current}
      {color_invariant_K'0 result.final /\ (color_K result.current.right = Black -> result.final.color = Black)
      -> color_invariant_K'0 self.final}
      (! return {result}) ]
  
  let rec balance_K (self: MutBorrow.t t_Node_K_V) (return (x: ())) =
    {[@expl:balance 'self' type invariant] inv_ref_Node_K_V self}
    {[@expl:balance requires #0] internal_invariant_K self.current}
    {[@expl:balance requires #1] self.current.color = Red /\ color_K self.current.left = Red
    -> color_invariant_K self.current.left}
    {[@expl:balance requires #2] self.current.color = Red /\ color_K self.current.right = Red
    -> color_invariant_K self.current.right}
    {[@expl:balance requires #3] self.current.color = Red
      /\ color_K self.current.right = Red /\ color_K self.current.left = Red -> false}
    any
    [ return (result: ()) -> {same_mappings_K self.current self.final}
      {internal_invariant_K self.final}
      {height_K'0 self.current = height_K'0 self.final}
      {color_invariant_K self.current.left /\ color_K self.current.right = Black -> self.current = self.final}
      {match_n_K (cpn (Black) (cpn (Red) (CPL (Red)) (CPL (Black))) (CPL (Black))) self.current
      -> match_n_K (CPL (Red)) self.final}
      {match_n_K (cpn (Black) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Red) (CPL (Black)) (CPL (Red))) self.current
      -> match_n_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final}
      {match_n_K (cpn (Black) (CPL (Red)) (CPL (Red))) self.current -> match_n_K (CPL (Red)) self.final}
      (! return {result}) ]
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_rec 'key' type invariant] inv_ref_K key'0}
    {[@expl:delete_rec requires #0] internal_invariant_K'0 self.current}
    {[@expl:delete_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_25 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { node = _bor.final } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_25} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_24 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_24} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_23 <- _x ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Box_Node_K_V_Global _23.current}
        MutBorrow.borrow_final <t_Node_K_V> {_23.current} {MutBorrow.get_id _23}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_22 <- _bor ] -{inv_Box_Node_K_V_Global _bor.final}-
            [ &_23 <- { _23 with current = _bor.final } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global'0 {_22} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &node'0 <- _x ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _23} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global _23}- s2
      | s2 = [ &_30 <- node'0.current.key ] s3
      | s3 = cmp_K {key'0} {_30} (fun (_x: t_Ordering) -> [ &_27 <- _x ] s4)
      | s4 = bb4 ]
    | bb4 = any [ br0 -> {_27 = Less} (! bb13) | br1 -> {_27 = Equal} (! bb12) | br2 -> {_27 = Greater} (! bb12) ]
    | bb12 = s0 [ s0 = is_red_K {node'0.current.left} (fun (_x: bool) -> [ &_53 <- _x ] s1) | s1 = bb31 ]
    | bb31 = any [ br0 -> {_53 = false} (! bb7) | br1 -> {_53} (! bb32) ]
    | bb32 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_mut <t_Node_K_V> {node'0.current}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_56 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = rotate_right_K {_56} (fun (_x: ()) -> [ &_55 <- _x ] s2)
      | s2 = bb34 ]
    | bb34 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_57 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _bor.final } } ] s1)
      | s1 = delete_rec_K {_57} {key'0} (fun (_x: t_Option_tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb68 ]
    | bb7 = any [ br0 -> {_27 = Less} (! bb8) | br1 -> {_27 = Equal} (! bb11) | br2 -> {_27 = Greater} (! bb10) ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = {false} any ]
    | bb10 = s0
      [ s0 = as_ref_Box_Node_K_V_Global {node'0.current.right.node}
          (fun (_x: t_Option_ref_Box_Node_K_V_Global'0) -> [ &_96 <- _x ] s1)
      | s1 = bb55 ]
    | bb55 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_96}
          (fun (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_95 <- _x ] s1)
      | s1 = bb56 ]
    | bb56 = any
      [ br0 (x0: t_Node_K_V) -> {_95 = Continue x0} (! bb59)
      | br1 (x0: t_Option_Infallible) -> {_95 = Break x0} (! bb58) ]
    | bb58 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1 | s1 = -{resolve_ref_Node_K_V node'0}- s2 | s2 = bb60 ]
    | bb60 = s0
      [ s0 = elim_Break {_95} (fun (r0: t_Option_Infallible) -> [ &residual'0 <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s2
      | s2 = -{resolve_ref_Tree_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual'0} (fun (_x: t_Option_tup2_K_V) -> [ &_ret <- _x ] s4)
      | s4 = bb73 ]
    | bb59 = s0
      [ s0 = elim_Continue {_95} (fun (r0: t_Node_K_V) -> [ &val''1 <- r0 ] s1)
      | s1 = [ &_94 <- val''1 ] s2
      | s2 = is_red_K {_94.left} (fun (_x: bool) -> [ &_92 <- _x ] s3)
      | s3 = bb62 ]
    | bb62 = any [ br0 -> {_92 = false} (! bb64) | br1 -> {_92} (! bb66) ]
    | bb64 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_105 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = move_red_right_K {_105} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_104 <- _x ] s2)
      | s2 = bb65 ]
    | bb65 = s0
      [ s0 = {inv_Node_K_V _104.current}
        MutBorrow.borrow_final <t_Node_K_V> {_104.current} {MutBorrow.get_id _104}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_103 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_104 <- { _104 with current = _bor.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _103 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _104} s5
      | s5 = -{resolve_ref_Node_K_V _104}- s6
      | s6 = bb66 ]
    | bb66 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_106 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _bor.final } } ] s1)
      | s1 = delete_rec_K {_106} {key'0} (fun (_x: t_Option_tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb68 ]
    | bb11 = s0
      [ s0 = [ &_68 <- node'0.current.right.node ] s1
      | s1 = any [ br0 -> {_68 = None} (! bb43) | br1 (x0: t_Node_K_V) -> {_68 = Some x0} (! bb42) ] ]
    | bb43 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {inv_Option_Box_Node_K_V_Global self.current.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.node}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_63 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { node = _bor.final } } ] s3)
      | s3 = {inv_Option_Box_Node_K_V_Global _63.current}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {_63.current} {MutBorrow.get_id _63}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_62 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &_63 <- { _63 with current = _bor.final } ] s4)
      | s4 = take_Option_Box_Node_K_V_Global {_62} (fun (_x: t_Option_Box_Node_K_V_Global) -> [ &_61 <- _x ] s5)
      | s5 = bb36 ]
    | bb36 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _63} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _63}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = unwrap_Box_Node_K_V_Global {_61} (fun (_x: t_Node_K_V) -> [ &node'1 <- _x ] s5)
      | s5 = bb37 ]
    | bb37 = s0
      [ s0 = {[@expl:type invariant] inv_Tree_K_V node'1.right} s1
      | s1 = -{resolve_Tree_K_V'0 node'1.right}- s2
      | s2 = {[@expl:type invariant] inv_Tree_K_V node'1.left} s3
      | s3 = -{resolve_Tree_K_V'0 node'1.left}- s4
      | s4 = [ &_64 <- { f0'1 = node'1.key; f1'1 = node'1.val' } ] s5
      | s5 = bb39 ]
    | bb39 = s0 [ s0 = [ &_ret <- Some'1 _64 ] s1 | s1 = bb73 ]
    | bb42 = s0
      [ s0 = elim_Some {_68} (fun (r0: t_Node_K_V) -> [ &right'0 <- r0 ] s1)
      | s1 = is_red_K {right'0.left} (fun (_x: bool) -> [ &_71 <- _x ] s2)
      | s2 = bb44 ]
    | bb44 = any [ br0 -> {_71 = false} (! bb46) | br1 -> {_71} (! bb48) ]
    | bb46 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_75 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = move_red_right_K {_75} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_74 <- _x ] s2)
      | s2 = bb47 ]
    | bb47 = s0
      [ s0 = {inv_Node_K_V _74.current}
        MutBorrow.borrow_final <t_Node_K_V> {_74.current} {MutBorrow.get_id _74}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_73 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_74 <- { _74 with current = _bor.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _73 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _74} s5
      | s5 = -{resolve_ref_Node_K_V _74}- s6
      | s6 = bb48 ]
    | bb48 = s0
      [ s0 = {inv_Tree_K_V node'0.current.right}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.right}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_77 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with right = _bor.final } } ] s1)
      | s1 = delete_min_rec_K {_77} (fun (_x: tup2_K_V) -> [ &kv <- _x ] s2)
      | s2 = bb49 ]
    | bb49 = s0 [ s0 = [ &_78 <- () ] s1 | s1 = bb50 ]
    | bb50 = s0
      [ s0 = {inv_K node'0.current.key}
        MutBorrow.borrow_mut <t_K> {node'0.current.key}
          (fun (_bor: MutBorrow.t t_K) ->
            [ &_82 <- _bor ] -{inv_K _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with key = _bor.final } } ] s1)
      | s1 = {inv_K kv.f0'1}
        MutBorrow.borrow_mut <t_K> {kv.f0'1}
          (fun (_bor: MutBorrow.t t_K) ->
            [ &_84 <- _bor ] -{inv_K _bor.final}-
            [ &kv <- { kv with f0'1 = _bor.final } ] s2)
      | s2 = {inv_K _82.current}
        MutBorrow.borrow_final <t_K> {_82.current} {MutBorrow.get_id _82}
          (fun (_bor: MutBorrow.t t_K) ->
            [ &_81 <- _bor ] -{inv_K _bor.final}-
            [ &_82 <- { _82 with current = _bor.final } ] s3)
      | s3 = {inv_K _84.current}
        MutBorrow.borrow_final <t_K> {_84.current} {MutBorrow.get_id _84}
          (fun (_bor: MutBorrow.t t_K) ->
            [ &_83 <- _bor ] -{inv_K _bor.final}-
            [ &_84 <- { _84 with current = _bor.final } ] s4)
      | s4 = swap_K {_81} {_83} (fun (_x: ()) -> [ &_80 <- _x ] s5)
      | s5 = bb51 ]
    | bb51 = s0
      [ s0 = {[@expl:type invariant] inv_ref_K'0 _84} s1
      | s1 = -{resolve_ref_K _84}- s2
      | s2 = {[@expl:type invariant] inv_ref_K'0 _82} s3
      | s3 = -{resolve_ref_K _82}- s4
      | s4 = {inv_V node'0.current.val'}
        MutBorrow.borrow_mut <t_V> {node'0.current.val'}
          (fun (_bor: MutBorrow.t t_V) ->
            [ &_87 <- _bor ] -{inv_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with val' = _bor.final } } ] s5)
      | s5 = {inv_V kv.f1'1}
        MutBorrow.borrow_mut <t_V> {kv.f1'1}
          (fun (_bor: MutBorrow.t t_V) ->
            [ &_89 <- _bor ] -{inv_V _bor.final}-
            [ &kv <- { kv with f1'1 = _bor.final } ] s6)
      | s6 = {inv_V _87.current}
        MutBorrow.borrow_final <t_V> {_87.current} {MutBorrow.get_id _87}
          (fun (_bor: MutBorrow.t t_V) ->
            [ &_86 <- _bor ] -{inv_V _bor.final}-
            [ &_87 <- { _87 with current = _bor.final } ] s7)
      | s7 = {inv_V _89.current}
        MutBorrow.borrow_final <t_V> {_89.current} {MutBorrow.get_id _89}
          (fun (_bor: MutBorrow.t t_V) ->
            [ &_88 <- _bor ] -{inv_V _bor.final}-
            [ &_89 <- { _89 with current = _bor.final } ] s8)
      | s8 = swap_V {_86} {_88} (fun (_x: ()) -> [ &_85 <- _x ] s9)
      | s9 = bb52 ]
    | bb52 = s0
      [ s0 = {[@expl:type invariant] inv_ref_V _89} s1
      | s1 = -{resolve_ref_V _89}- s2
      | s2 = {[@expl:type invariant] inv_ref_V _87} s3
      | s3 = -{resolve_ref_V _87}- s4
      | s4 = [ &r <- Some'1 kv ] s5
      | s5 = bb68 ]
    | bb13 = s0 [ s0 = is_red_K {node'0.current.left} (fun (_x: bool) -> [ &_35 <- _x ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_35 = false} (! bb16) | br1 -> {_35} (! bb29) ]
    | bb16 = s0
      [ s0 = as_ref_Box_Node_K_V_Global {node'0.current.left.node}
          (fun (_x: t_Option_ref_Box_Node_K_V_Global'0) -> [ &_41 <- _x ] s1)
      | s1 = bb17 ]
    | bb17 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_41}
          (fun (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_40 <- _x ] s1)
      | s1 = bb18 ]
    | bb18 = any
      [ br0 (x0: t_Node_K_V) -> {_40 = Continue x0} (! bb21)
      | br1 (x0: t_Option_Infallible) -> {_40 = Break x0} (! bb20) ]
    | bb20 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1 | s1 = -{resolve_ref_Node_K_V node'0}- s2 | s2 = bb22 ]
    | bb22 = s0
      [ s0 = elim_Break {_40} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s2
      | s2 = -{resolve_ref_Tree_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_x: t_Option_tup2_K_V) -> [ &_ret <- _x ] s4)
      | s4 = bb73 ]
    | bb21 = s0
      [ s0 = elim_Continue {_40} (fun (r0: t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &_39 <- val''0 ] s2
      | s2 = is_red_K {_39.left} (fun (_x: bool) -> [ &_37 <- _x ] s3)
      | s3 = bb24 ]
    | bb24 = any [ br0 -> {_37 = false} (! bb26) | br1 -> {_37} (! bb29) ]
    | bb26 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_50 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = move_red_left_K {_50} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_49 <- _x ] s2)
      | s2 = bb27 ]
    | bb27 = s0
      [ s0 = {inv_Node_K_V _49.current}
        MutBorrow.borrow_final <t_Node_K_V> {_49.current} {MutBorrow.get_id _49}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_48 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &_49 <- { _49 with current = _bor.final } ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s2
      | s2 = -{resolve_ref_Node_K_V node'0}- s3
      | s3 = [ &node'0 <- _48 ] s4
      | s4 = {[@expl:type invariant] inv_ref_Node_K_V _49} s5
      | s5 = -{resolve_ref_Node_K_V _49}- s6
      | s6 = bb29 ]
    | bb29 = s0
      [ s0 = {inv_Tree_K_V node'0.current.left}
        MutBorrow.borrow_mut <t_Tree_K_V> {node'0.current.left}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_51 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with left = _bor.final } } ] s1)
      | s1 = delete_rec_K {_51} {key'0} (fun (_x: t_Option_tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb68 ]
    | bb68 = s0
      [ s0 = {inv_Node_K_V node'0.current}
        MutBorrow.borrow_final <t_Node_K_V> {node'0.current} {MutBorrow.get_id node'0}
          (fun (_bor: MutBorrow.t t_Node_K_V) ->
            [ &_109 <- _bor ] -{inv_Node_K_V _bor.final}-
            [ &node'0 <- { node'0 with current = _bor.final } ] s1)
      | s1 = balance_K {_109} (fun (_x: ()) -> [ &_108 <- _x ] s2)
      | s2 = bb69 ]
    | bb69 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Node_K_V node'0} s1
      | s1 = -{resolve_ref_Node_K_V node'0}- s2
      | s2 = {[@expl:type invariant] inv_ref_Tree_K_V'0 self} s3
      | s3 = -{resolve_ref_Tree_K_V self}- s4
      | s4 = [ &_ret <- r ] s5
      | s5 = bb73 ]
    | bb73 = return {_ret} ]
    [ & _ret: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Tree_K_V = self
    | & key'0: t_K = key'0
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _22: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _23: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _24: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _25: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & r: t_Option_tup2_K_V = Any.any_l ()
    | & _27: t_Ordering = Any.any_l ()
    | & _30: t_K = Any.any_l ()
    | & _35: bool = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _39: t_Node_K_V = Any.any_l ()
    | & _40: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _41: t_Option_ref_Box_Node_K_V_Global'0 = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: t_Node_K_V = Any.any_l ()
    | & _48: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _49: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _50: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _51: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _53: bool = Any.any_l ()
    | & _55: () = Any.any_l ()
    | & _56: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _57: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & node'1: t_Node_K_V = Any.any_l ()
    | & _61: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _62: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _63: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _64: tup2_K_V = Any.any_l ()
    | & right'0: t_Node_K_V = Any.any_l ()
    | & _68: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _71: bool = Any.any_l ()
    | & _73: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _74: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _75: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & kv: tup2_K_V = Any.any_l ()
    | & _77: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _78: () = Any.any_l ()
    | & _80: () = Any.any_l ()
    | & _81: MutBorrow.t t_K = Any.any_l ()
    | & _82: MutBorrow.t t_K = Any.any_l ()
    | & _83: MutBorrow.t t_K = Any.any_l ()
    | & _84: MutBorrow.t t_K = Any.any_l ()
    | & _85: () = Any.any_l ()
    | & _86: MutBorrow.t t_V = Any.any_l ()
    | & _87: MutBorrow.t t_V = Any.any_l ()
    | & _88: MutBorrow.t t_V = Any.any_l ()
    | & _89: MutBorrow.t t_V = Any.any_l ()
    | & _92: bool = Any.any_l ()
    | & _94: t_Node_K_V = Any.any_l ()
    | & _95: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _96: t_Option_ref_Box_Node_K_V_Global'0 = Any.any_l ()
    | & residual'0: t_Option_Infallible = Any.any_l ()
    | & val''1: t_Node_K_V = Any.any_l ()
    | & _103: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _104: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _105: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _106: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _108: () = Any.any_l ()
    | & _109: MutBorrow.t t_Node_K_V = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete_rec result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete_rec ensures #0] internal_invariant_K'0 self.final}
      {[@expl:delete_rec ensures #1] height_K self.current = height_K self.final}
      {[@expl:delete_rec ensures #2] match result with
        | None'1 -> forall v: t_V. not has_mapping_K self.current (deep_model_ref_K key'0) v
        | Some'1 {f0'1 = k; f1'1 = v} -> deep_model_ref_K key'0 = deep_model_K k
        /\ has_mapping_K self.current (deep_model_K k) v
        end}
      {[@expl:delete_rec ensures #3] forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_ref_K key'0 <> k /\ has_mapping_K self.current k v)}
      {[@expl:delete_rec ensures #4] color_invariant_K self.final}
      {[@expl:delete_rec ensures #5] color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
end
module M_impl_Resolve_for_Map_K_V__resolve_coherence (* <Map<K, V> as creusot_contracts::resolve::Resolve> *)
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Map_K_V (_1: t_Map_K_V) = resolve_Tree_K_V'0 _1.f0
  
  type t_Option_V = None'0 | Some'0 t_V
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom'2 [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_V x0
        end
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  predicate resolve_Map_K_V (self: t_Map_K_V) =
    forall k: t_DeepModelTy. resolve_Option_V (Map.get (view_Map_K_V self) k)
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map_K_V
  
  function resolve_coherence_Map_K_V (self: t_Map_K_V) : ()
  
  goal vc_resolve_coherence_Map_K_V: structural_resolve_Map_K_V self
    -> ([@expl:resolve_coherence ensures] resolve_Map_K_V self)
end
module M_impl_Map_K_V__new (* Map<K, V> *)
  use creusot.prelude.Any
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_K (return (x: t_Map_K_V)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- None ] s1 | s1 = [ &_2 <- { node = _3 } ] s2 | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_ret <- { f0 = _2 } ] s1 | s1 = bb2 ]
    | bb2 = return {_ret} ]
    [ & _ret: t_Map_K_V = Any.any_l ()
    | & _2: t_Tree_K_V = Any.any_l ()
    | & _3: t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: t_Map_K_V) -> {[@expl:new result type invariant] inv_Map_K_V result}
      {[@expl:new ensures] view_Map_K_V result = Const.const (None'0)}
      (! return {result}) ]
end
module M_impl_Map_K_V__insert (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec insert_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (val''0: t_V) (return (x: ())) =
    {[@expl:insert_rec 'self' type invariant] inv_ref_Tree_K_V self}
    {[@expl:insert_rec 'key' type invariant] inv_K key'0}
    {[@expl:insert_rec 'val' type invariant] inv_V val''0}
    {[@expl:insert_rec requires #0] internal_invariant_K self.current}
    {[@expl:insert_rec requires #1] color_invariant_K self.current}
    any
    [ return (result: ()) -> {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {match_t_K (cpn (Red) (CPL (Red)) (CPL (Black))) self.final /\ color_K self.current = Red
      \/ color_invariant_K self.final}
      {has_mapping_K self.final (deep_model_K key'0) val''0}
      {forall k: t_DeepModelTy, v: t_V. k = deep_model_K key'0
        \/ has_mapping_K self.current k v = has_mapping_K self.final k v}
      (! return {result}) ]
  
  type t_Option_ref_Box_Node_K_V_Global = None'1 | Some'1 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_K (self: MutBorrow.t t_Map_K_V) (key'0: t_K) (val''0: t_V) (return (x: ())) =
    {[@expl:insert 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:insert 'key' type invariant] inv_K key'0}
    {[@expl:insert 'val' type invariant] inv_V val''0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_8 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_11 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = insert_rec_K {_11} {key'0} {val''0} (fun (_x: ()) -> [ &_10 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_14 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_17 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { f0 = { node = _bor.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_17} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_16 <- _x ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_16} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_15 <- _x ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_15 <- { _15 with current = { _15.current with color = _14 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _15} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _15}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb6 ]
    | bb6 = return {_ret} ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & key'0: t_K = key'0
    | & val''0: t_V = val''0
    | & _8: () = Any.any_l ()
    | & _10: () = Any.any_l ()
    | & _11: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _14: t_Color = Any.any_l ()
    | & _15: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _16: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _17: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: ()) -> {[@expl:insert ensures] view_Map_K_V self.final
      = Map.set (view_Map_K_V self.current) (deep_model_K key'0) (Some'0 val''0)}
      (! return {result}) ]
end
module M_impl_Map_K_V__delete_max (* Map<K, V> *)
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'0 | Some'0 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  type t_Option_Infallible = None'1 | Some'1 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global =
    | Continue (MutBorrow.t t_Node_K_V)
    | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_Infallible f0'0
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        | Break f0'0 -> inv_Option_Infallible f0'0
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'0 v -> result = Continue v
        | None'0 -> result = Break (None'1)
        end}
      (! return {result}) ]
  
  let rec elim_Break (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (return (f0'0: t_Option_Infallible)) = any
    [ _k (f0'0: t_Option_Infallible) -> {Break f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Break _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  type t_Option_tup2_K_V = None'2 | Some'2 tup2_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'2 -> true
        | Some'2 f0'1 -> inv_tup2_K_V f0'1
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'2} (! return {result}) ]
  
  let rec elim_Continue (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (return (f0'1: MutBorrow.t t_Node_K_V)) = any
    [ _k (f0'1: MutBorrow.t t_Node_K_V) -> {Continue f0'1 = _x} (! return {f0'1})
    | _chk -> (! {match _x with
        | Continue _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec delete_max_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_max_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_max_rec requires #0] internal_invariant_K self.current}
    {[@expl:delete_max_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: tup2_K_V) -> {inv_tup2_K_V result}
      {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {has_mapping_K self.current (deep_model_K result.f0'0) result.f1'0}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy k (deep_model_K result.f0'0)}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'0 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'0}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'0 result = self_}
      (! return {result}) ]
  
  type t_Option_V = None'3 | Some'3 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'3 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'3))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'3 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'3 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'3 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'3 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'3)) k in has_mapping_model_acc_K self (Const.const (None'3)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'3 v))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max_K (self: MutBorrow.t t_Map_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_max 'self' type invariant] inv_ref_Map_K_V self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_7 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { f0 = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_7} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_6 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_6}
          (fun (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_5 <- _x ] s1)
      | s1 = bb2 ]
    | bb2 = any
      [ br0 (x0: MutBorrow.t t_Node_K_V) -> {_5 = Continue x0} (! bb5)
      | br1 (x0: t_Option_Infallible) -> {_5 = Break x0} (! bb6) ]
    | bb6 = s0
      [ s0 = elim_Break {_5} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Map_K_V self} s2
      | s2 = -{resolve_ref_Map_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_x: t_Option_tup2_K_V) -> [ &_ret <- _x ] s4)
      | s4 = bb22 ]
    | bb5 = s0
      [ s0 = elim_Continue {_5} (fun (r0: MutBorrow.t t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &node'0 <- val''0 ] s2
      | s2 = is_red_K {node'0.current.left} (fun (_x: bool) -> [ &_14 <- _x ] s3)
      | s3 = bb8 ]
    | bb8 = any [ br0 -> {_14 = false} (! bb10) | br1 -> {_14} (! bb9) ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = bb11 ]
    | bb10 = s0
      [ s0 = [ &_16 <- Red ] s1
      | s1 = [ &node'0 <- { node'0 with current = { node'0.current with color = _16 } } ] s2
      | s2 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s3
      | s3 = -{resolve_ref_Box_Node_K_V_Global node'0}- s4
      | s4 = bb11 ]
    | bb11 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_18 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = delete_max_rec_K {_18} (fun (_x: tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb12 ]
    | bb12 = s0 [ s0 = is_red_K {self.current.f0} (fun (_x: bool) -> [ &_20 <- _x ] s1) | s1 = bb13 ]
    | bb13 = any [ br0 -> {_20 = false} (! bb17) | br1 -> {_20} (! bb14) ]
    | bb14 = s0
      [ s0 = [ &_22 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_25 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { f0 = { node = _bor.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_25} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_24 <- _x ] s3)
      | s3 = bb15 ]
    | bb15 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_24} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_23 <- _x ] s1) | s1 = bb16 ]
    | bb16 = s0
      [ s0 = [ &_23 <- { _23 with current = { _23.current with color = _22 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _23} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _23}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb18 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Map_K_V self} s1 | s1 = -{resolve_ref_Map_K_V self}- s2 | s2 = bb18 ]
    | bb18 = s0 [ s0 = [ &_26 <- () ] s1 | s1 = bb19 ]
    | bb19 = s0 [ s0 = [ &_ret <- Some'2 r ] s1 | s1 = bb22 ]
    | bb22 = return {_ret} ]
    [ & _ret: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _5: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _6: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _7: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _16: t_Color = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _18: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _22: t_Color = Any.any_l ()
    | & _23: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _24: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _25: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & _26: () = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete_max result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete_max ensures] match result with
        | Some'2 {f0'0 = k; f1'0 = v} -> Map.get (view_Map_K_V self.current) (deep_model_K k) = Some'3 v
        /\ (forall k2: t_DeepModelTy. Map.get (view_Map_K_V self.current) k2 = None'3
            \/ le_log_DeepModelTy k2 (deep_model_K k))
        /\ view_Map_K_V self.final = Map.set (view_Map_K_V self.current) (deep_model_K k) (None'3)
        | None'2 -> view_Map_K_V self.final = view_Map_K_V self.current
        /\ view_Map_K_V self.current = Const.const (None'3)
        end}
      (! return {result}) ]
end
module M_impl_Map_K_V__delete_min (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'1 | Some'1 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  type t_Option_Infallible = None'2 | Some'2 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global =
    | Continue (MutBorrow.t t_Node_K_V)
    | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'2 -> true
        | Some'2 f0'0 -> inv_Infallible f0'0
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        | Break f0'0 -> inv_Option_Infallible f0'0
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'1 v -> result = Continue v
        | None'1 -> result = Break (None'2)
        end}
      (! return {result}) ]
  
  let rec elim_Break (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (return (f0'0: t_Option_Infallible)) = any
    [ _k (f0'0: t_Option_Infallible) -> {Break f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Break _ -> true
        | _ -> false
        end}
      any) ]
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  type t_Option_tup2_K_V = None'3 | Some'3 tup2_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'3 -> true
        | Some'3 f0'1 -> inv_tup2_K_V f0'1
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'3} (! return {result}) ]
  
  let rec elim_Continue (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (return (f0'1: MutBorrow.t t_Node_K_V)) = any
    [ _k (f0'1: MutBorrow.t t_Node_K_V) -> {Continue f0'1 = _x} (! return {f0'1})
    | _chk -> (! {match _x with
        | Continue _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  let rec delete_min_rec_K (self: MutBorrow.t t_Tree_K_V) (return (x: tup2_K_V)) =
    {[@expl:delete_min_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_min_rec requires #0] internal_invariant_K self.current}
    {[@expl:delete_min_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: tup2_K_V) -> {inv_tup2_K_V result}
      {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {has_mapping_K self.current (deep_model_K result.f0'0) result.f1'0}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.current k v
        -> le_log_DeepModelTy (deep_model_K result.f0'0) k}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_K result.f0'0 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min_K (self: MutBorrow.t t_Map_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_min 'self' type invariant] inv_ref_Map_K_V self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_9 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { f0 = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_9} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_8 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_8}
          (fun (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_7 <- _x ] s1)
      | s1 = bb3 ]
    | bb3 = any
      [ br0 (x0: MutBorrow.t t_Node_K_V) -> {_7 = Continue x0} (! bb6)
      | br1 (x0: t_Option_Infallible) -> {_7 = Break x0} (! bb7) ]
    | bb7 = s0
      [ s0 = elim_Break {_7} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Map_K_V self} s2
      | s2 = -{resolve_ref_Map_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_x: t_Option_tup2_K_V) -> [ &_ret <- _x ] s4)
      | s4 = bb22 ]
    | bb6 = s0
      [ s0 = elim_Continue {_7} (fun (r0: MutBorrow.t t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &node'0 <- val''0 ] s2
      | s2 = is_red_K {node'0.current.left} (fun (_x: bool) -> [ &_16 <- _x ] s3)
      | s3 = bb9 ]
    | bb9 = any [ br0 -> {_16 = false} (! bb11) | br1 -> {_16} (! bb10) ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = bb12 ]
    | bb11 = s0
      [ s0 = [ &_18 <- Red ] s1
      | s1 = [ &node'0 <- { node'0 with current = { node'0.current with color = _18 } } ] s2
      | s2 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s3
      | s3 = -{resolve_ref_Box_Node_K_V_Global node'0}- s4
      | s4 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_20 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = delete_min_rec_K {_20} (fun (_x: tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb13 ]
    | bb13 = s0 [ s0 = is_red_K {self.current.f0} (fun (_x: bool) -> [ &_22 <- _x ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_22 = false} (! bb18) | br1 -> {_22} (! bb15) ]
    | bb15 = s0
      [ s0 = [ &_24 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_27 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { f0 = { node = _bor.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_27} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_26 <- _x ] s3)
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_26} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_25 <- _x ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_25 <- { _25 with current = { _25.current with color = _24 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _25} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _25}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb19 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Map_K_V self} s1 | s1 = -{resolve_ref_Map_K_V self}- s2 | s2 = bb19 ]
    | bb19 = s0 [ s0 = [ &_ret <- Some'3 r ] s1 | s1 = bb22 ]
    | bb22 = return {_ret} ]
    [ & _ret: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & _4: () = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _7: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _8: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _9: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: t_Color = Any.any_l ()
    | & r: tup2_K_V = Any.any_l ()
    | & _20: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Color = Any.any_l ()
    | & _25: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _26: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _27: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete_min result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete_min ensures] match result with
        | Some'3 {f0'0 = k; f1'0 = v} -> Map.get (view_Map_K_V self.current) (deep_model_K k) = Some'0 v
        /\ (forall k2: t_DeepModelTy. Map.get (view_Map_K_V self.current) k2 = None'0
            \/ le_log_DeepModelTy (deep_model_K k) k2)
        /\ view_Map_K_V self.final = Map.set (view_Map_K_V self.current) (deep_model_K k) (None'0)
        | None'3 -> view_Map_K_V self.final = view_Map_K_V self.current
        /\ view_Map_K_V self.current = Const.const (None'0)
        end}
      (! return {result}) ]
end
module M_impl_Map_K_V__delete (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  type t_Option_ref_Box_Node_K_V_Global = None'1 | Some'1 (MutBorrow.t t_Node_K_V)
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate inv_Option_ref_Box_Node_K_V_Global (_1: t_Option_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'2 [@rewrite]:
    forall x: t_Option_ref_Box_Node_K_V_Global [inv_Option_ref_Box_Node_K_V_Global x]. inv_Option_ref_Box_Node_K_V_Global x
      = match x with
        | None'1 -> true
        | Some'1 f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        end
  
  let rec as_mut_Box_Node_K_V_Global (self_: MutBorrow.t t_Option_Box_Node_K_V_Global)
    (return (x: t_Option_ref_Box_Node_K_V_Global)) =
    {[@expl:as_mut 'self_' type invariant] inv_ref_Option_Box_Node_K_V_Global self_}
    any
    [ return (result: t_Option_ref_Box_Node_K_V_Global) -> {inv_Option_ref_Box_Node_K_V_Global result}
      {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_Node_K_V. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  type t_Option_Infallible = None'2 | Some'2 ()
  
  type t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global =
    | Continue (MutBorrow.t t_Node_K_V)
    | Break t_Option_Infallible
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'2 -> true
        | Some'2 f0'0 -> inv_Infallible f0'0
        end
  
  predicate inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global (_1: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
  
  axiom inv_axiom'4 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global [inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x]. inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global x
      = match x with
        | Continue f0'0 -> inv_ref_Box_Node_K_V_Global f0'0
        | Break f0'0 -> inv_Option_Infallible f0'0
        end
  
  let rec branch_Option_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)) =
    {[@expl:branch 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    any
    [ return (result: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) ->
    {inv_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global result}
      {match self_ with
        | Some'1 v -> result = Continue v
        | None'1 -> result = Break (None'2)
        end}
      (! return {result}) ]
  
  let rec elim_Break (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (return (f0'0: t_Option_Infallible)) = any
    [ _k (f0'0: t_Option_Infallible) -> {Break f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Break _ -> true
        | _ -> false
        end}
      any) ]
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  type tup2_K_V = { f0'0: t_K; f1'0: t_V }
  
  type t_Option_tup2_K_V = None'3 | Some'3 tup2_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'0 /\ inv_V _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'3 -> true
        | Some'3 f0'1 -> inv_tup2_K_V f0'1
        end
  
  let rec from_residual_Option_tup2_K_V (residual: t_Option_Infallible) (return (x: t_Option_tup2_K_V)) =
    {[@expl:from_residual 'residual' type invariant] inv_Option_Infallible residual}
    any [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result} {result = None'3} (! return {result}) ]
  
  let rec elim_Continue (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global)
    (return (f0'1: MutBorrow.t t_Node_K_V)) = any
    [ _k (f0'1: MutBorrow.t t_Node_K_V) -> {Continue f0'1 = _x} (! return {f0'1})
    | _chk -> (! {match _x with
        | Continue _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec is_red_K (self: t_Tree_K_V) (return (x: bool)) = {[@expl:is_red 'self' type invariant] inv_ref_Tree_K_V self}
    any [ return (result: bool) -> {result = (color_K self = Red)} (! return {result}) ]
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Tree_K_V'0 [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V'0
  
  predicate inv_ref_Tree_K_V'0 [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V'0 _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V'0
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function cpn [@inline:trivial] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP = CPN c l r
  
  meta "rewrite_def" function cpn
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  let rec delete_rec_K (self: MutBorrow.t t_Tree_K_V) (key'0: t_K) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete_rec 'self' type invariant] inv_ref_Tree_K_V'0 self}
    {[@expl:delete_rec 'key' type invariant] inv_ref_K key'0}
    {[@expl:delete_rec requires #0] internal_invariant_K self.current}
    {[@expl:delete_rec requires #1] match_t_K (CPL (Red)) self.current
    \/ match_t_K (cpn (Black) (CPL (Red)) (CPL (Black))) self.current}
    any
    [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result}
      {internal_invariant_K self.final}
      {height_K self.current = height_K self.final}
      {match result with
        | None'3 -> forall v: t_V. not has_mapping_K self.current (deep_model_ref_K key'0) v
        | Some'3 {f0'0 = k; f1'0 = v} -> deep_model_ref_K key'0 = deep_model_K k
        /\ has_mapping_K self.current (deep_model_K k) v
        end}
      {forall k: t_DeepModelTy, v: t_V. has_mapping_K self.final k v
        = (deep_model_ref_K key'0 <> k /\ has_mapping_K self.current k v)}
      {color_invariant_K self.final}
      {color_K self.current = Black -> color_K self.final = Black}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_Node_K_V_Global (self_: t_Option_ref_Box_Node_K_V_Global)
    (return (x: MutBorrow.t t_Node_K_V)) =
    {[@expl:unwrap 'self_' type invariant] inv_Option_ref_Box_Node_K_V_Global self_}
    {[@expl:unwrap requires] self_ <> None'1}
    any
    [ return (result: MutBorrow.t t_Node_K_V) -> {inv_ref_Box_Node_K_V_Global result}
      {Some'1 result = self_}
      (! return {result}) ]
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_K (self: MutBorrow.t t_Map_K_V) (key'0: t_K) (return (x: t_Option_tup2_K_V)) =
    {[@expl:delete 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:delete 'key' type invariant] inv_ref_K key'0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_9 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_mut <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_14 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { f0 = { node = _bor.final } } } ] s1)
      | s1 = as_mut_Box_Node_K_V_Global {_14} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_13 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = branch_Option_ref_Box_Node_K_V_Global {_13}
          (fun (_x: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global) -> [ &_12 <- _x ] s1)
      | s1 = bb3 ]
    | bb3 = any
      [ br0 (x0: MutBorrow.t t_Node_K_V) -> {_12 = Continue x0} (! bb6)
      | br1 (x0: t_Option_Infallible) -> {_12 = Break x0} (! bb7) ]
    | bb7 = s0
      [ s0 = elim_Break {_12} (fun (r0: t_Option_Infallible) -> [ &residual <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv_ref_Map_K_V self} s2
      | s2 = -{resolve_ref_Map_K_V self}- s3
      | s3 = from_residual_Option_tup2_K_V {residual} (fun (_x: t_Option_tup2_K_V) -> [ &_ret <- _x ] s4)
      | s4 = bb21 ]
    | bb6 = s0
      [ s0 = elim_Continue {_12} (fun (r0: MutBorrow.t t_Node_K_V) -> [ &val''0 <- r0 ] s1)
      | s1 = [ &node'0 <- val''0 ] s2
      | s2 = is_red_K {node'0.current.left} (fun (_x: bool) -> [ &_21 <- _x ] s3)
      | s3 = bb9 ]
    | bb9 = any [ br0 -> {_21 = false} (! bb11) | br1 -> {_21} (! bb10) ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
      | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
      | s2 = bb12 ]
    | bb11 = s0
      [ s0 = [ &_23 <- Red ] s1
      | s1 = [ &node'0 <- { node'0 with current = { node'0.current with color = _23 } } ] s2
      | s2 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s3
      | s3 = -{resolve_ref_Box_Node_K_V_Global node'0}- s4
      | s4 = bb12 ]
    | bb12 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_mut <t_Tree_K_V> {self.current.f0}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &_25 <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = delete_rec_K {_25} {key'0} (fun (_x: t_Option_tup2_K_V) -> [ &r <- _x ] s2)
      | s2 = bb13 ]
    | bb13 = s0 [ s0 = is_red_K {self.current.f0} (fun (_x: bool) -> [ &_28 <- _x ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb15) ]
    | bb15 = s0
      [ s0 = [ &_30 <- Black ] s1
      | s1 = {inv_Option_Box_Node_K_V_Global self.current.f0.node}
        MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {self.current.f0.node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self) 1) 1}
          (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
            [ &_33 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
            [ &self <- { self with current = { f0 = { node = _bor.final } } } ] s2)
      | s2 = as_mut_Box_Node_K_V_Global {_33} (fun (_x: t_Option_ref_Box_Node_K_V_Global) -> [ &_32 <- _x ] s3)
      | s3 = bb16 ]
    | bb16 = s0
      [ s0 = unwrap_ref_Box_Node_K_V_Global {_32} (fun (_x: MutBorrow.t t_Node_K_V) -> [ &_31 <- _x ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = [ &_31 <- { _31 with current = { _31.current with color = _30 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global _31} s2
      | s2 = -{resolve_ref_Box_Node_K_V_Global _31}- s3
      | s3 = {[@expl:type invariant] inv_ref_Map_K_V self} s4
      | s4 = -{resolve_ref_Map_K_V self}- s5
      | s5 = bb19 ]
    | bb18 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Map_K_V self} s1 | s1 = -{resolve_ref_Map_K_V self}- s2 | s2 = bb19 ]
    | bb19 = s0 [ s0 = [ &_ret <- r ] s1 | s1 = bb21 ]
    | bb21 = return {_ret} ]
    [ & _ret: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & key'0: t_K = key'0
    | & _9: () = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _12: t_ControlFlow_Option_Infallible_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _13: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _14: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & residual: t_Option_Infallible = Any.any_l ()
    | & val''0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _23: t_Color = Any.any_l ()
    | & r: t_Option_tup2_K_V = Any.any_l ()
    | & _25: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: t_Color = Any.any_l ()
    | & _31: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _32: t_Option_ref_Box_Node_K_V_Global = Any.any_l ()
    | & _33: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) -> {[@expl:delete result type invariant] inv_Option_tup2_K_V result}
      {[@expl:delete ensures #0] match result with
        | Some'3 {f0'0 = k; f1'0 = v} -> deep_model_K k = deep_model_ref_K key'0
        /\ Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = Some'0 v
        | None'3 -> Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = None'0
        end}
      {[@expl:delete ensures #1] view_Map_K_V self.final
      = Map.set (view_Map_K_V self.current) (deep_model_ref_K key'0) (None'0)}
      (! return {result}) ]
end
module M_impl_Map_K_V__get (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: t_Tree_K_V) = inv_Tree_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec elim_Some (_x: t_Option_Box_Node_K_V_Global) (return (f0'0: t_Node_K_V)) = any
    [ _k (f0'0: t_Node_K_V) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type tup2_ref_K_ref_K = { f0'0: t_K; f1'0: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0'0 = self_; f1'0 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0'0 = self_; f1'0 = rhs } result}
      (! return {result}) ]
  
  type t_Option_ref_V = None'1 | Some'1 t_V
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: t_Map_K_V) = inv_Map_K_V self
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_ref_V f0'1
        end
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_K (self: t_Map_K_V) (key'0: t_K) (return (x: t_Option_ref_V)) =
    {[@expl:get 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:get 'key' type invariant] inv_ref_K key'0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_7 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &tree <- self.f0 ] s1 | s1 = bb2 ]
    | bb2 = bb2
      [ bb2 = {[@expl:loop invariant #0] inv_ref_Tree_K_V tree}
        {[@expl:loop invariant #1] bst_invariant_K tree}
        {[@expl:loop invariant #2] forall v: t_V. has_mapping_K self.f0 (deep_model_ref_K key'0) v
          = has_mapping_K tree (deep_model_ref_K key'0) v}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_21 <- tree.node ] s1
          | s1 = any [ br0 -> {_21 = None} (! bb14) | br1 (x0: t_Node_K_V) -> {_21 = Some x0} (! bb5) ] ]
        | bb5 = s0
          [ s0 = elim_Some {_21} (fun (r0: t_Node_K_V) -> [ &node'0 <- r0 ] s1)
          | s1 = [ &_27 <- node'0.key ] s2
          | s2 = cmp_K {key'0} {_27} (fun (_x: t_Ordering) -> [ &_24 <- _x ] s3)
          | s3 = bb6 ]
        | bb6 = any [ br0 -> {_24 = Less} (! bb12) | br1 -> {_24 = Equal} (! bb11) | br2 -> {_24 = Greater} (! bb10) ]
        | bb10 = s0 [ s0 = [ &_35 <- node'0.right ] s1 | s1 = [ &tree <- _35 ] s2 | s2 = bb2 ]
        | bb12 = s0 [ s0 = [ &_30 <- node'0.left ] s1 | s1 = [ &tree <- _30 ] s2 | s2 = bb2 ] ] ]
    | bb14 = s0 [ s0 = [ &_ret <- None'1 ] s1 | s1 = bb15 ]
    | bb11 = s0 [ s0 = [ &_33 <- node'0.val' ] s1 | s1 = [ &_ret <- Some'1 _33 ] s2 | s2 = bb15 ]
    | bb15 = return {_ret} ]
    [ & _ret: t_Option_ref_V = Any.any_l ()
    | & self: t_Map_K_V = self
    | & key'0: t_K = key'0
    | & _7: () = Any.any_l ()
    | & tree: t_Tree_K_V = Any.any_l ()
    | & _21: t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & node'0: t_Node_K_V = Any.any_l ()
    | & _24: t_Ordering = Any.any_l ()
    | & _27: t_K = Any.any_l ()
    | & _30: t_Tree_K_V = Any.any_l ()
    | & _33: t_V = Any.any_l ()
    | & _35: t_Tree_K_V = Any.any_l () ])
    [ return (result: t_Option_ref_V) -> {[@expl:get result type invariant] inv_Option_ref_V result}
      {[@expl:get ensures] match result with
        | Some'1 v -> Map.get (view_Map_K_V self) (deep_model_ref_K key'0) = Some'0 v
        | None'1 -> Map.get (view_Map_K_V self) (deep_model_ref_K key'0) = None'0
        end}
      (! return {result}) ]
end
module M_impl_Map_K_V__get_mut (* Map<K, V> *)
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function model_acc_has_mapping_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = model_acc_has_mapping_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom model_acc_has_mapping_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. Map.get (model_acc_K self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc_K self accu) k = Some'0 v /\ has_mapping_K self k v)
  
  function has_mapping_model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) (k: t_DeepModelTy) : () =
    match self with
      | {node = None} -> ()
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let _ = has_mapping_model_acc_K left'0 accu k in let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in let _ = has_mapping_model_acc_K right'0 accu2 k in model_acc_has_mapping_K right'0 accu2 k
      end
  
  axiom has_mapping_model_acc_K_spec:
    forall self: t_Tree_K_V, accu: Map.map t_DeepModelTy t_Option_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v -> Map.get (model_acc_K self accu) k = Some'0 v)
  
  function has_mapping_model_K (self: t_Tree_K_V) (k: t_DeepModelTy) : () =
    let _ = model_acc_has_mapping_K self (Const.const (None'0)) k in has_mapping_model_acc_K self (Const.const (None'0)) k
  
  axiom has_mapping_model_K_spec: forall self: t_Tree_K_V, k: t_DeepModelTy. bst_invariant_K self
      -> (forall v: t_V. has_mapping_K self k v = (Map.get (view_Tree_K_V self) k = Some'0 v))
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  type t_CP = CPL t_Color | CPN t_Color t_CP t_CP
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate match_t_K (self: t_CP) (tree: t_Tree_K_V) =
    match self with
      | CPL color'0 -> color_K tree = color'0 /\ color_invariant_K tree
      | CPN color'0 l r -> match tree.node with
        | Some node'0 -> node'0.color = color'0 /\ match_t_K l node'0.left /\ match_t_K r node'0.right
        | None -> false
        end
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate invariant_ref_Tree_K_V [@inline:trivial] (self: MutBorrow.t t_Tree_K_V) =
    inv_Tree_K_V self.current /\ inv_Tree_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Tree_K_V
  
  predicate inv_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = invariant_ref_Tree_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Tree_K_V
  
  let rec elim_Some (_x: t_Option_Box_Node_K_V_Global) (return (f0'0: t_Node_K_V)) = any
    [ _k (f0'0: t_Node_K_V) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type tup2_ref_K_ref_K = { f0'0: t_K; f1'0: t_K }
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate precondition_cmp (self: ()) (args: tup2_ref_K_ref_K)
  
  axiom precondition_fndef:
    forall args: tup2_ref_K_ref_K [precondition_cmp () args]. (let {f0'0 = self_; f1'0 = rhs} = args in inv_ref_K self_
        /\ inv_ref_K rhs) -> precondition_cmp () args
  
  predicate postcondition_once_cmp (self: ()) (args: tup2_ref_K_ref_K) (result: t_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_K_ref_K, res: t_Ordering [postcondition_once_cmp () args res]. postcondition_once_cmp () args res
      -> (let {f0'0 = self_; f1'0 = rhs} = args in res = cmp_log_DeepModelTy (deep_model_K self_) (deep_model_K rhs))
  
  let rec cmp_K (self_: t_K) (rhs: t_K) (return (x: t_Ordering)) =
    {[@expl:cmp requires] precondition_cmp () { f0'0 = self_; f1'0 = rhs }}
    any
    [ return (result: t_Ordering) -> {postcondition_once_cmp () { f0'0 = self_; f1'0 = rhs } result}
      (! return {result}) ]
  
  predicate resolve_ref_Tree_K_V [@inline:trivial] (_1: MutBorrow.t t_Tree_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Tree_K_V
  
  predicate invariant_ref_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Node_K_V) =
    inv_Box_Node_K_V_Global self.current /\ inv_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Box_Node_K_V_Global
  
  predicate inv_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) =
    invariant_ref_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Box_Node_K_V_Global
  
  predicate resolve_ref_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Node_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_Node_K_V_Global
  
  predicate invariant_ref_Option_Box_Node_K_V_Global [@inline:trivial] (self: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    inv_Option_Box_Node_K_V_Global self.current /\ inv_Option_Box_Node_K_V_Global self.final
  
  meta "rewrite_def" predicate invariant_ref_Option_Box_Node_K_V_Global
  
  predicate inv_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    invariant_ref_Option_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_ref_Option_Box_Node_K_V_Global
  
  predicate resolve_ref_Option_Box_Node_K_V_Global [@inline:trivial] (_1: MutBorrow.t t_Option_Box_Node_K_V_Global) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Option_Box_Node_K_V_Global
  
  type t_Option_ref_V = None'1 | Some'1 (MutBorrow.t t_V)
  
  predicate invariant_ref_V [@inline:trivial] (self: MutBorrow.t t_V) = inv_V self.current /\ inv_V self.final
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate resolve_ref_V [@inline:trivial] (_1: MutBorrow.t t_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_V
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate invariant_ref_Map_K_V [@inline:trivial] (self: MutBorrow.t t_Map_K_V) =
    inv_Map_K_V self.current /\ inv_Map_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_Map_K_V
  
  predicate inv_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = invariant_ref_Map_K_V _1
  
  meta "rewrite_def" predicate inv_ref_Map_K_V
  
  predicate resolve_ref_Map_K_V [@inline:trivial] (_1: MutBorrow.t t_Map_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Map_K_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_ref_V f0'1
        end
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_mut_K (self: MutBorrow.t t_Map_K_V) (key'0: t_K) (return (x: t_Option_ref_V)) =
    {[@expl:get_mut 'self' type invariant] inv_ref_Map_K_V self}
    {[@expl:get_mut 'key' type invariant] inv_ref_K key'0}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_7 <- () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Tree_K_V self.current.f0}
        MutBorrow.borrow_final <t_Tree_K_V> {self.current.f0} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_bor: MutBorrow.t t_Tree_K_V) ->
            [ &tree <- _bor ] -{inv_Tree_K_V _bor.final}-
            [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = [ &old_tree <- tree ] s2
      | s2 = bb3 ]
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant #0] inv_ref_Tree_K_V tree}
        {[@expl:loop invariant #1] bst_invariant_K tree.current}
        {[@expl:loop invariant #2] height_invariant_K tree.current}
        {[@expl:loop invariant #3] color_invariant_K tree.current}
        {[@expl:loop invariant #4] forall v: t_V. has_mapping_K tree.final (deep_model_ref_K key'0) v
          = has_mapping_K old_tree.final (deep_model_ref_K key'0) v}
        {[@expl:loop invariant #5] forall v: t_V. has_mapping_K tree.current (deep_model_ref_K key'0) v
          = has_mapping_K old_tree.current (deep_model_ref_K key'0) v}
        {[@expl:loop invariant #6] (forall k: t_DeepModelTy, v: t_V. k = deep_model_ref_K key'0
            \/ has_mapping_K tree.current k v = has_mapping_K tree.final k v)
        -> bst_invariant_K tree.final -> bst_invariant_K old_tree.final}
        {[@expl:loop invariant #7] height_K tree.current = height_K tree.final /\ height_invariant_K tree.final
        -> height_invariant_K old_tree.final}
        {[@expl:loop invariant #8] match_t_K (CPL (color_K tree.current)) tree.final
        -> match_t_K (CPL (Black)) old_tree.final}
        {[@expl:loop invariant #9] forall k: t_DeepModelTy, v: t_V. has_mapping_K tree.current k v
            = has_mapping_K tree.final k v -> has_mapping_K old_tree.current k v = has_mapping_K old_tree.final k v}
        (! s0)
        [ s0 = bb4 ]
        [ bb4 = s0
          [ s0 = {inv_Option_Box_Node_K_V_Global tree.current.node}
            MutBorrow.borrow_final <t_Option_Box_Node_K_V_Global> {tree.current.node}
              {MutBorrow.inherit_id (MutBorrow.get_id tree) 1}
              (fun (_bor: MutBorrow.t t_Option_Box_Node_K_V_Global) ->
                [ &_45 <- _bor ] -{inv_Option_Box_Node_K_V_Global _bor.final}-
                [ &tree <- { tree with current = { node = _bor.final } } ] s1)
          | s1 = any
            [ br0 -> {_45.current = None} (! bb15) | br1 (x0: t_Node_K_V) -> {_45.current = Some x0} (! bb6) ] ]
        | bb6 = s0
          [ s0 = elim_Some {_45.current}
              (fun (r0: t_Node_K_V) ->
                {inv_Box_Node_K_V_Global r0}
                MutBorrow.borrow_final <t_Node_K_V> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _45) 1}
                  (fun (_bor: MutBorrow.t t_Node_K_V) ->
                    [ &node'0 <- _bor ] -{inv_Box_Node_K_V_Global _bor.final}-
                    [ &_45 <- { _45 with current = Some _bor.final } ] s1))
          | s1 = [ &_51 <- node'0.current.key ] s2
          | s2 = cmp_K {key'0} {_51} (fun (_x: t_Ordering) -> [ &_48 <- _x ] s3)
          | s3 = bb7 ]
        | bb7 = any [ br0 -> {_48 = Less} (! bb13) | br1 -> {_48 = Equal} (! bb12) | br2 -> {_48 = Greater} (! bb11) ]
        | bb11 = s0
          [ s0 = {inv_Tree_K_V node'0.current.right}
            MutBorrow.borrow_final <t_Tree_K_V> {node'0.current.right}
              {MutBorrow.inherit_id (MutBorrow.get_id node'0) 5}
              (fun (_bor: MutBorrow.t t_Tree_K_V) ->
                [ &_59 <- _bor ] -{inv_Tree_K_V _bor.final}-
                [ &node'0 <- { node'0 with current = { node'0.current with right = _bor.final } } ] s1)
          | s1 = {inv_Tree_K_V _59.current}
            MutBorrow.borrow_final <t_Tree_K_V> {_59.current} {MutBorrow.get_id _59}
              (fun (_bor: MutBorrow.t t_Tree_K_V) ->
                [ &_58 <- _bor ] -{inv_Tree_K_V _bor.final}-
                [ &_59 <- { _59 with current = _bor.final } ] s2)
          | s2 = {[@expl:type invariant] inv_ref_Tree_K_V tree} s3
          | s3 = -{resolve_ref_Tree_K_V tree}- s4
          | s4 = [ &tree <- _58 ] s5
          | s5 = {[@expl:type invariant] inv_ref_Tree_K_V _59} s6
          | s6 = -{resolve_ref_Tree_K_V _59}- s7
          | s7 = bb14 ]
        | bb13 = s0
          [ s0 = {inv_Tree_K_V node'0.current.left}
            MutBorrow.borrow_final <t_Tree_K_V> {node'0.current.left} {MutBorrow.inherit_id (MutBorrow.get_id node'0) 1}
              (fun (_bor: MutBorrow.t t_Tree_K_V) ->
                [ &_54 <- _bor ] -{inv_Tree_K_V _bor.final}-
                [ &node'0 <- { node'0 with current = { node'0.current with left = _bor.final } } ] s1)
          | s1 = {inv_Tree_K_V _54.current}
            MutBorrow.borrow_final <t_Tree_K_V> {_54.current} {MutBorrow.get_id _54}
              (fun (_bor: MutBorrow.t t_Tree_K_V) ->
                [ &_53 <- _bor ] -{inv_Tree_K_V _bor.final}-
                [ &_54 <- { _54 with current = _bor.final } ] s2)
          | s2 = {[@expl:type invariant] inv_ref_Tree_K_V tree} s3
          | s3 = -{resolve_ref_Tree_K_V tree}- s4
          | s4 = [ &tree <- _53 ] s5
          | s5 = {[@expl:type invariant] inv_ref_Tree_K_V _54} s6
          | s6 = -{resolve_ref_Tree_K_V _54}- s7
          | s7 = bb14 ]
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s1
          | s1 = -{resolve_ref_Box_Node_K_V_Global node'0}- s2
          | s2 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _45} s3
          | s3 = -{resolve_ref_Option_Box_Node_K_V_Global _45}- s4
          | s4 = bb3 ] ] ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _45} s1
      | s1 = -{resolve_ref_Option_Box_Node_K_V_Global _45}- s2
      | s2 = [ &_ret <- None'1 ] s3
      | s3 = bb16 ]
    | bb12 = s0
      [ s0 = {inv_V node'0.current.val'}
        MutBorrow.borrow_final <t_V> {node'0.current.val'} {MutBorrow.inherit_id (MutBorrow.get_id node'0) 4}
          (fun (_bor: MutBorrow.t t_V) ->
            [ &_57 <- _bor ] -{inv_V _bor.final}-
            [ &node'0 <- { node'0 with current = { node'0.current with val' = _bor.final } } ] s1)
      | s1 = {inv_V _57.current}
        MutBorrow.borrow_final <t_V> {_57.current} {MutBorrow.get_id _57}
          (fun (_bor: MutBorrow.t t_V) ->
            [ &_56 <- _bor ] -{inv_V _bor.final}-
            [ &_57 <- { _57 with current = _bor.final } ] s2)
      | s2 = [ &_ret <- Some'1 _56 ] s3
      | s3 = {[@expl:type invariant] inv_ref_V _57} s4
      | s4 = -{resolve_ref_V _57}- s5
      | s5 = {[@expl:type invariant] inv_ref_Box_Node_K_V_Global node'0} s6
      | s6 = -{resolve_ref_Box_Node_K_V_Global node'0}- s7
      | s7 = {[@expl:type invariant] inv_ref_Option_Box_Node_K_V_Global _45} s8
      | s8 = -{resolve_ref_Option_Box_Node_K_V_Global _45}- s9
      | s9 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Tree_K_V tree} s1
      | s1 = -{resolve_ref_Tree_K_V tree}- s2
      | s2 = {[@expl:type invariant] inv_ref_Map_K_V self} s3
      | s3 = -{resolve_ref_Map_K_V self}- s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_Option_ref_V = Any.any_l ()
    | & self: MutBorrow.t t_Map_K_V = self
    | & key'0: t_K = key'0
    | & _7: () = Any.any_l ()
    | & tree: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & old_tree: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _45: MutBorrow.t t_Option_Box_Node_K_V_Global = Any.any_l ()
    | & node'0: MutBorrow.t t_Node_K_V = Any.any_l ()
    | & _48: t_Ordering = Any.any_l ()
    | & _51: t_K = Any.any_l ()
    | & _53: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _54: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _56: MutBorrow.t t_V = Any.any_l ()
    | & _57: MutBorrow.t t_V = Any.any_l ()
    | & _58: MutBorrow.t t_Tree_K_V = Any.any_l ()
    | & _59: MutBorrow.t t_Tree_K_V = Any.any_l () ])
    [ return (result: t_Option_ref_V) -> {[@expl:get_mut result type invariant] inv_Option_ref_V result}
      {[@expl:get_mut ensures] match result with
        | Some'1 v -> Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = Some'0 (v.current)
        /\ view_Map_K_V self.final = Map.set (view_Map_K_V self.current) (deep_model_ref_K key'0) (Some'0 (v.final))
        | None'1 -> Map.get (view_Map_K_V self.current) (deep_model_ref_K key'0) = None'0
        /\ view_Map_K_V self.final = view_Map_K_V self.current
        end}
      (! return {result}) ]
end
module M_impl_Resolve_for_Tree_K_V__resolve_coherence__refines (* <Tree<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  axiom resolve_axiom'1 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  predicate structural_resolve_Tree_K_V (_1: t_Tree_K_V) = resolve_Option_Box_Node_K_V_Global _1.node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Tree_K_V. inv_Tree_K_V self /\ structural_resolve_Tree_K_V self
      -> structural_resolve_Tree_K_V self /\ (forall result: (). resolve_Tree_K_V self -> resolve_Tree_K_V self)
end
module M_impl_Resolve_for_Node_K_V__resolve_coherence__refines (* <Node<K, V> as creusot_contracts::resolve::Resolve> *)
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  with t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0 -> inv_Box_Node_K_V_Global f0
        end
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Node_K_V (_1: t_Node_K_V) =
    resolve_Tree_K_V'0 _1.left /\ resolve_K _1.key /\ resolve_V _1.val' /\ resolve_Tree_K_V'0 _1.right
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Node_K_V. inv_Node_K_V self /\ structural_resolve_Node_K_V self
      -> structural_resolve_Node_K_V self /\ (forall result: (). resolve_Node_K_V self -> resolve_Node_K_V self)
end
module M_impl_Resolve_for_Map_K_V__resolve_coherence__refines (* <Map<K, V> as creusot_contracts::resolve::Resolve> *)
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = Red | Black
  
  type t_K
  
  type t_V
  
  type t_Node_K_V = { left: t_Tree_K_V; color: t_Color; key: t_K; val': t_V; right: t_Tree_K_V }
  with t_Option_Box_Node_K_V_Global = None | Some t_Node_K_V
  with t_Tree_K_V = { node: t_Option_Box_Node_K_V_Global }
  
  type t_Map_K_V = { f0: t_Tree_K_V }
  
  type t_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate has_mapping_K (self: t_Tree_K_V) (k: t_DeepModelTy) (v: t_V) =
    match self with
      | {node = None} -> false
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> has_mapping_K left'0 k v
      \/ has_mapping_K right'0 k v \/ k = deep_model_K key'0 /\ v = val''0
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  predicate bst_invariant_here_K (self: t_Node_K_V) =
    (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.left k v -> lt_log_DeepModelTy k (deep_model_K self.key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping_K self.right k v -> lt_log_DeepModelTy (deep_model_K self.key) k)
  
  predicate bst_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> bst_invariant_here_K node'0
      /\ bst_invariant_K left'0 /\ bst_invariant_K right'0
      end
  
  function height_K (self: t_Tree_K_V) : int = match self with
      | {node = None} -> 0
      | {node = Some {left = left'0; color = Red}} -> height_K left'0
      | {node = Some {left = left'0; color = Black}} -> height_K left'0 + 1
      end
  
  axiom height_K_spec: forall self: t_Tree_K_V. height_K self >= 0
  
  predicate height_invariant_here_K (self: t_Node_K_V) = height_K self.left = height_K self.right
  
  predicate height_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> height_invariant_here_K node'0
      /\ height_invariant_K left'0 /\ height_invariant_K right'0
      end
  
  predicate internal_invariant_K (self: t_Tree_K_V) = bst_invariant_K self /\ height_invariant_K self
  
  function color_K (self: t_Tree_K_V) : t_Color = match self.node with
      | Some {color = color'0} -> color'0
      | _ -> Black
      end
  
  predicate color_invariant_here_K (self: t_Node_K_V) =
    color_K self.right = Black /\ (self.color = Black \/ color_K self.left = Black)
  
  predicate color_invariant_K (self: t_Tree_K_V) =
    match self with
      | {node = None} -> true
      | {node = Some ({left = left'0; right = right'0} as node'0)} -> color_invariant_here_K node'0
      /\ color_invariant_K left'0 /\ color_invariant_K right'0
      end
  
  predicate invariant_Map_K_V (self: t_Map_K_V) =
    internal_invariant_K self.f0 /\ color_invariant_K self.f0 /\ color_K self.f0 = Black
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_Node_K_V (_1: t_Node_K_V)
  
  predicate inv_Tree_K_V (_1: t_Tree_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node_K_V [inv_Node_K_V x]. inv_Node_K_V x
      = (inv_Tree_K_V x.left /\ inv_K x.key /\ inv_V x.val' /\ inv_Tree_K_V x.right)
  
  predicate invariant_Box_Node_K_V_Global (self: t_Node_K_V) = inv_Node_K_V self
  
  predicate inv_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = invariant_Box_Node_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_Node_K_V_Global
  
  predicate inv_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [inv_Option_Box_Node_K_V_Global x]. inv_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some f0'0 -> inv_Box_Node_K_V_Global f0'0
        end
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree_K_V [inv_Tree_K_V x]. inv_Tree_K_V x
      = inv_Option_Box_Node_K_V_Global x.node
  
  predicate inv_Map_K_V (_1: t_Map_K_V)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Map_K_V [inv_Map_K_V x]. inv_Map_K_V x
      = (invariant_Map_K_V x /\ inv_Tree_K_V x.f0)
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Tree_K_V (self: t_Tree_K_V) = forall k: t_DeepModelTy, v: t_V. has_mapping_K self k v -> resolve_V v
  
  predicate has_mapping_K'0 (self: t_Node_K_V) (k: t_DeepModelTy) (v: t_V) =
    has_mapping_K self.left k v \/ has_mapping_K self.right k v \/ k = deep_model_K self.key /\ v = self.val'
  
  axiom has_mapping_K_spec: forall self: t_Node_K_V, k: t_DeepModelTy, v: t_V. forall node'0: t_Node_K_V. self = node'0
        -> has_mapping_K'0 self k v = has_mapping_K { node = Some node'0 } k v
  
  predicate resolve_Node_K_V (self: t_Node_K_V) =
    forall k: t_DeepModelTy, v: t_V. has_mapping_K'0 self k v -> resolve_V v
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_Node_K_V'0 (_1: t_Node_K_V)
  
  predicate resolve_Tree_K_V'0 (_1: t_Tree_K_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Node_K_V [resolve_Node_K_V'0 x]. resolve_Node_K_V'0 x
      = (resolve_Node_K_V x
      /\ resolve_Tree_K_V'0 x.left /\ resolve_K x.key /\ resolve_V x.val' /\ resolve_Tree_K_V'0 x.right)
  
  predicate resolve_Box_Node_K_V_Global [@inline:trivial] (_1: t_Node_K_V) = resolve_Node_K_V'0 _1
  
  meta "rewrite_def" predicate resolve_Box_Node_K_V_Global
  
  predicate resolve_Option_Box_Node_K_V_Global (_1: t_Option_Box_Node_K_V_Global)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_Box_Node_K_V_Global [resolve_Option_Box_Node_K_V_Global x]. resolve_Option_Box_Node_K_V_Global x
      = match x with
        | None -> true
        | Some x0 -> resolve_Box_Node_K_V_Global x0
        end
  
  axiom resolve_axiom'1 [@rewrite]: forall x: t_Tree_K_V [resolve_Tree_K_V'0 x]. resolve_Tree_K_V'0 x
      = (resolve_Tree_K_V x /\ resolve_Option_Box_Node_K_V_Global x.node)
  
  predicate structural_resolve_Map_K_V (_1: t_Map_K_V) = resolve_Tree_K_V'0 _1.f0
  
  type t_Option_V = None'0 | Some'0 t_V
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom'2 [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_V x0
        end
  
  function model_acc_K (self: t_Tree_K_V) (accu: Map.map t_DeepModelTy t_Option_V) : Map.map t_DeepModelTy t_Option_V =
    match self with
      | {node = None} -> accu
      | {node = Some {left = left'0; key = key'0; val' = val''0; right = right'0}} -> let accu1 = model_acc_K left'0 accu in let accu2 = Map.set accu1 (deep_model_K key'0) (Some'0 val''0) in model_acc_K right'0 accu2
      end
  
  function view_Tree_K_V (self: t_Tree_K_V) : Map.map t_DeepModelTy t_Option_V = model_acc_K self (Const.const (None'0))
  
  function view_Map_K_V (self: t_Map_K_V) : Map.map t_DeepModelTy t_Option_V = view_Tree_K_V self.f0
  
  predicate resolve_Map_K_V (self: t_Map_K_V) =
    forall k: t_DeepModelTy. resolve_Option_V (Map.get (view_Map_K_V self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map_K_V. inv_Map_K_V self /\ structural_resolve_Map_K_V self
      -> structural_resolve_Map_K_V self /\ (forall result: (). resolve_Map_K_V self -> resolve_Map_K_V self)
end
