module M_red_black_tree__qyi11959472507597060150__clone [#"red_black_tree.rs" 10 9 10 14] (* <Color as creusot_contracts::Clone> *)
  let%span sred_black_tree = "red_black_tree.rs" 10 9 10 14
  
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type tuple = { _p0: t_Color; _p1: t_Color }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone' [#"red_black_tree.rs" 10 9 10 14] (self: t_Color) (return' (x: t_Color)) = (! bb0
    [ bb0 = any [ br0 -> {self'0 = C_Red} (! bb4) | br1 -> {self'0 = C_Black} (! bb3) ]
    | bb3 = s0 [ s0 = [ &_0 <- C_Black ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- C_Red ] s1 | s1 = bb5 ]
    | bb5 = return''0 {_0} ] [ & _0: t_Color = Any.any_l () | & self'0: t_Color = self ])
    [ return''0 (result: t_Color) -> {[@expl:clone ensures] [%#sred_black_tree] match { _p0 = self; _p1 = result } with
        | {_p0 = C_Red; _p1 = C_Red} -> true
        | {_p0 = C_Black; _p1 = C_Black} -> true
        | _ -> false
        end}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'0 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'1 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'2 = "red_black_tree.rs" 35 12 39 13
  
  use map.Map
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'1] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'2] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant accu : Map.map t_DeepModelTy t_Option'0
  
  constant k : t_DeepModelTy
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self'0: t_Tree) (accu'0: Map.map t_DeepModelTy t_Option'0) (k'0: t_DeepModelTy) : ()
  
  goal vc_model_acc_has_mapping: match self with
      | {t_Tree__node = C_None} -> [@expl:model_acc_has_mapping ensures] [%#sred_black_tree] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> ([%#sred_black_tree] Map.get (model_acc left accu) k
          = Map.get accu k
        \/ (exists v: t_V. Map.get (model_acc left accu) k = C_Some'0 v /\ has_mapping left k v))
      -> (let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in ([%#sred_black_tree] Map.get (model_acc right accu2) k
          = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc right accu2) k = C_Some'0 v /\ has_mapping right k v))
      -> ([@expl:model_acc_has_mapping ensures] [%#sred_black_tree] Map.get (model_acc self accu) k = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)))
      end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'0 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'1 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'2 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'3 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'4 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'5 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'6 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 207 12 208 104
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  
  use map.Map
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'7] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'3] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'5] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'1] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant accu : Map.map t_DeepModelTy t_Option'0
  
  constant k : t_DeepModelTy
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self'0: t_Tree) (accu'0: Map.map t_DeepModelTy t_Option'0) (k'0: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model_acc: ([%#sred_black_tree] bst_invariant self)
    -> match self with
      | {t_Tree__node = C_None} -> [@expl:has_mapping_model_acc ensures] [%#sred_black_tree'0] forall v: t_V. has_mapping self k v
        -> Map.get (model_acc self accu) k = C_Some'0 v
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> ([@expl:has_mapping_model_acc requires] [%#sred_black_tree] bst_invariant left)
      /\ (([%#sred_black_tree'0] forall v: t_V. has_mapping left k v -> Map.get (model_acc left accu) k = C_Some'0 v)
      -> (let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in ([@expl:has_mapping_model_acc requires] [%#sred_black_tree] bst_invariant right)
      /\ (([%#sred_black_tree'0] forall v: t_V. has_mapping right k v -> Map.get (model_acc right accu2) k = C_Some'0 v)
      -> (let _ = has_mapping_model_acc right accu2 k in ([%#sred_black_tree'1] Map.get (model_acc right accu2) k
          = Map.get accu2 k
        \/ (exists v: t_V. Map.get (model_acc right accu2) k = C_Some'0 v /\ has_mapping right k v))
      -> ([@expl:has_mapping_model_acc ensures] [%#sred_black_tree'0] forall v: t_V. has_mapping self k v
        -> Map.get (model_acc self accu) k = C_Some'0 v)))))
      end
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'0 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'1 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'2 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'3 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'4 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'5 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'6 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'8 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'10 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'11 = "red_black_tree.rs" 207 12 208 104
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'11] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'5] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'9] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'7] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'8] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'1] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'10] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'2] bst_invariant self)
      -> ([%#sred_black_tree'3] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant k : t_DeepModelTy
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self'0: t_Tree) (k'0: t_DeepModelTy) : ()
  
  goal vc_has_mapping_model: ([%#sred_black_tree] bst_invariant self)
    -> ([%#sred_black_tree'1] Map.get (model_acc self (Const.const (C_None'0))) k = Map.get (Const.const (C_None'0)) k
      \/ (exists v: t_V. Map.get (model_acc self (Const.const (C_None'0))) k = C_Some'0 v /\ has_mapping self k v))
    -> (let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in ([@expl:has_mapping_model_acc requires] [%#sred_black_tree'2] bst_invariant self)
    /\ (([%#sred_black_tree'3] forall v: t_V. has_mapping self k v
        -> Map.get (model_acc self (Const.const (C_None'0))) k = C_Some'0 v)
    -> ([@expl:has_mapping_model ensures] [%#sred_black_tree'0] forall v: t_V. has_mapping self k v
      = (Map.get (view self) k = C_Some'0 v))))
end
module M_red_black_tree__qyi3529752165842986389__has_mapping_inj [#"red_black_tree.rs" 120 4 122 33] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 116 4 116 37
  let%span sred_black_tree'0 = "red_black_tree.rs" 117 4 117 40
  let%span sred_black_tree'1 = "red_black_tree.rs" 118 4 118 40
  let%span sred_black_tree'2 = "red_black_tree.rs" 119 14 119 22
  let%span sred_black_tree'3 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'4 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'5 = "red_black_tree.rs" 124 8 127 11
  let%span sred_black_tree'6 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'8 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'9 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'10 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'11 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'12 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'13 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'14 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'15 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'16 = "red_black_tree.rs" 53 12 60 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'7] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'10] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'16] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'9] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'12] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'11] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'15] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'13] bst_invariant self)
      -> ([%#sred_black_tree'14] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'8] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'3] bst_invariant self)
      -> ([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  constant k : t_DeepModelTy
  
  constant v1 : t_V
  
  constant v2 : t_V
  
  function has_mapping_inj [#"red_black_tree.rs" 120 4 122 33] (self'0: t_Tree) (k'0: t_DeepModelTy) (v1'0: t_V) (v2'0: t_V) : ()
  
  goal vc_has_mapping_inj: ([%#sred_black_tree] bst_invariant self)
    -> ([%#sred_black_tree'0] has_mapping self k v1)
    -> ([%#sred_black_tree'1] has_mapping self k v2)
    -> ([@expl:has_mapping_model requires] [%#sred_black_tree'3] bst_invariant self)
    /\ (([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
    -> (let _ = has_mapping_model self k in match Map.get (view self) k with
      | C_None'0 -> [@expl:has_mapping_inj ensures] [%#sred_black_tree'2] v1 = v2
      | C_Some'0 _v -> [@expl:has_mapping_inj ensures] [%#sred_black_tree'2] v1 = v2
      end))
end
module M_red_black_tree__qyi3665871523867809084__has_mapping [#"red_black_tree.rs" 135 4 135 57] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'0 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'1 = "red_black_tree.rs" 35 12 39 13
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'1] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node
  
  constant k : t_DeepModelTy
  
  constant v : t_V
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self'0: t_Node) (k'0: t_DeepModelTy) (v'0: t_V)
  
  goal vc_has_mapping: if has_mapping self.t_Node__left k v then
      [@expl:has_mapping ensures] [%#sred_black_tree] forall node: t_Node. self = node
        -> true = has_mapping { t_Tree__node = C_Some node } k v
    else
      if has_mapping self.t_Node__right k v then
        [@expl:has_mapping ensures] [%#sred_black_tree] forall node: t_Node. self = node
          -> true = has_mapping { t_Tree__node = C_Some node } k v
      else
        if k = deep_model self.t_Node__key then
          [@expl:has_mapping ensures] [%#sred_black_tree] forall node: t_Node. self = node
            -> (v = self.t_Node__val) = has_mapping { t_Tree__node = C_Some node } k v
        else
          [@expl:has_mapping ensures] [%#sred_black_tree] forall node: t_Node. self = node
            -> false = has_mapping { t_Tree__node = C_Some node } k v
      
    

end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence [#"red_black_tree.rs" 181 4 181 30] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 179 15 179 39
  let%span sred_black_tree'0 = "red_black_tree.rs" 180 4 180 30
  let%span sred_black_tree'1 = "red_black_tree.rs" 181 31 181 33
  let%span sred_black_tree'2 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'3 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'4 = "red_black_tree.rs" 188 12 188 62
  let%span sred_black_tree'5 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'6 = "red_black_tree.rs" 136 8 139 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 56 8 56 22
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'3] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'6] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'5] forall node: t_Node. self
          = node -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 186 4 186 28] (self: t_Node) =
    [%#sred_black_tree'4] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_0: t_Node) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_Node) = [%#sresolve] resolve'1 self
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: t_Node) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_Option) =
    [%#soption] match self with
      | C_Some x -> resolve'3 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_0: t_Option) = resolve'4 _0
  
  meta "rewrite_def" predicate resolve'5
  
  predicate structural_resolve (_0: t_Tree) =
    match _0 with
      | {t_Tree__node = x0} -> resolve'5 x0
      end
  
  predicate resolve'6 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  function resolve_coherence [#"red_black_tree.rs" 181 4 181 30] (self'0: t_Tree) : ()
  
  goal vc_resolve_coherence: ([%#sred_black_tree] structural_resolve self)
    -> ([@expl:resolve_coherence ensures] [%#sred_black_tree'0] resolve'6 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence [#"red_black_tree.rs" 195 4 195 30] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 193 15 193 39
  let%span sred_black_tree'0 = "red_black_tree.rs" 194 4 194 30
  let%span sred_black_tree'1 = "red_black_tree.rs" 195 31 195 33
  let%span sred_black_tree'2 = "red_black_tree.rs" 188 12 188 62
  let%span sred_black_tree'3 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'4 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'5 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'6 = "red_black_tree.rs" 35 12 39 13
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'5] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_0: t_Tree) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_0: t_K)
  
  predicate structural_resolve (_0: t_Node) =
    match _0 with
      | {t_Node__left = x0; t_Node__color = x1; t_Node__key = x2; t_Node__val = x3; t_Node__right = x4} -> resolve'1 x4
      /\ resolve x3 /\ resolve'2 x2 /\ resolve'1 x0
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'3] forall node: t_Node. self
          = node -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'3 [#"red_black_tree.rs" 186 4 186 28] (self: t_Node) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node
  
  function resolve_coherence [#"red_black_tree.rs" 195 4 195 30] (self'0: t_Node) : ()
  
  goal vc_resolve_coherence: ([%#sred_black_tree] structural_resolve self)
    -> ([@expl:resolve_coherence ensures] [%#sred_black_tree'0] resolve'3 self)
end
module M_red_black_tree__qyi3529752165842986389__height [#"red_black_tree.rs" 317 4 317 26] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'0 = "red_black_tree.rs" 319 12 327 13
  
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Tree
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self'0: t_Tree) : int
  
  goal vc_height: match self with
      | {t_Tree__node = C_None} -> [@expl:height ensures] [%#sred_black_tree] 0 >= 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> ([%#sred_black_tree] height left >= 0)
        -> ([@expl:height ensures] [%#sred_black_tree] height left >= 0)
        | C_Black -> ([%#sred_black_tree] height left >= 0)
        -> ([@expl:height ensures] [%#sred_black_tree] height left + 1 >= 0)
        end
      end
end
module M_red_black_tree__qyi3665871523867809084__height [#"red_black_tree.rs" 349 4 349 26] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'0 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'1 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'2 = "red_black_tree.rs" 319 12 327 13
  
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'2] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'0] height self >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Node
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self'0: t_Node) : int
  
  goal vc_height: match self.t_Node__color with
      | C_Red -> ([%#sred_black_tree'0] height self.t_Node__left >= 0)
      -> ([@expl:height ensures] [%#sred_black_tree] forall node: t_Node. self = node
        -> height self.t_Node__left = height { t_Tree__node = C_Some node })
      | C_Black -> ([%#sred_black_tree'0] height self.t_Node__left >= 0)
      -> ([@expl:height ensures] [%#sred_black_tree] forall node: t_Node. self = node
        -> height self.t_Node__left + 1 = height { t_Tree__node = C_Some node })
      end
end
module M_red_black_tree__qyi3529752165842986389__is_red [#"red_black_tree.rs" 402 4 402 28] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 405 17 405 22
  let%span sred_black_tree'0 = "red_black_tree.rs" 404 49 404 53
  let%span sred_black_tree'1 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'2 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'3 = "red_black_tree.rs" 279 12 282 13
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: t_Tree) = [%#sinvariant] inv'2 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'3] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_red [#"red_black_tree.rs" 402 4 402 28] (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'1] inv'5 self}
    (! bb0
    [ bb0 = any
      [ br0 -> {self'0.t_Tree__node = C_None} (! bb1) | br1 (x0: t_Node) -> {self'0.t_Tree__node = C_Some x0} (! bb2) ]
    | bb2 = v_Some {self'0.t_Tree__node}
        (fun (r0: t_Node) ->
          any [ br0 -> {r0.t_Node__color = C_Red} (! bb4) | br1 -> {r0.t_Node__color = C_Black} (! bb1) ])
    | bb1 = s0 [ s0 = [ &_0 <- [%#sred_black_tree] false ] s1 | s1 = bb5 ]
    | bb4 = s0 [ s0 = [ &_0 <- [%#sred_black_tree'0] true ] s1 | s1 = bb5 ]
    | bb5 = return''0 {_0} ] [ & _0: bool = Any.any_l () | & self'0: t_Tree = self ])
    [ return''0 (result: bool) -> {[@expl:is_red ensures] [%#sred_black_tree'2] result = (color self = C_Red)}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__rotate_right [#"red_black_tree.rs" 426 4 426 30] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 427 23 427 41
  let%span sred_black_tree'0 = "red_black_tree.rs" 455 8 455 90
  let%span sred_black_tree'1 = "red_black_tree.rs" 426 25 426 29
  let%span sred_black_tree'2 = "red_black_tree.rs" 414 15 414 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 415 15 415 42
  let%span sred_black_tree'4 = "red_black_tree.rs" 416 14 416 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 417 14 417 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 418 14 418 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 419 14 419 65
  let%span sred_black_tree'8 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'9 = "red_black_tree.rs" 421 14 421 44
  let%span sred_black_tree'10 = "red_black_tree.rs" 422 14 425 34
  let%span sred_black_tree'11 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'13 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'15 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'16 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'17 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'18 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'19 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'20 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'21 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'22 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'23 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'25 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'27 = "red_black_tree.rs" 334 12 340 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 606 18 606 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 159 14 159 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 164 14 164 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 169 14 169 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 125 4 125 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 126 4 126 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 4 131 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 4 136 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 137 4 137 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 138 4 138 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 143 14 144 104
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_0: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {inv'2 result} {[%#soption'2] result = C_None} (! return' {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return' (x: t_Option)) =
    {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result: t_Option) -> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  let rec unwrap (self_: t_Option) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any [ return''0 (result: t_Node) -> {inv'4 result} {[%#soption'1] C_Some result = self_} (! return' {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  let rec swap (x: MutBorrow.t t_Tree) (y: MutBorrow.t t_Tree) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'2] inv'6 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'6 y}
    any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Tree) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: MutBorrow.t t_Tree) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  let rec swap'0 (x: MutBorrow.t t_Node) (y: MutBorrow.t t_Node) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'2] inv'7 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'7 y}
    any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'4 _0
  
  meta "rewrite_def" predicate resolve'5
  
  let rec swap'1 (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Color) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_0: MutBorrow.t t_Color) = resolve'6 _0
  
  meta "rewrite_def" predicate resolve'7
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'17] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_0: t_Tree) = resolve'9 _0
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'11 _0
  
  meta "rewrite_def" predicate resolve'12
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'24] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'18] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'22] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'26] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'27] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'19] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'12] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'13] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'21] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'20] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'14] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'16] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'15] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_right [#"red_black_tree.rs" 426 4 426 30] (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'1] inv'7 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'2] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'3] color (self.current).t_Node__left = C_Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- [%#sred_black_tree] self'0 ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__left).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_16 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = {inv'2 _16.current}
        MutBorrow.borrow_final <t_Option> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &_16 <- { _16 with current = _ret.final } ] s2)
      | s2 = take {_15} (fun (_ret: t_Option) -> [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap {_14} (fun (_ret: t_Node) -> [ &x <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'1 (self'0.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_19 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = _ret.final } } ] s1)
      | s1 = {inv'1 x.t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {x.t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_21 <- _ret ] -{inv'1 _ret.final}-
            [ &x <- { x with t_Node__right = _ret.final } ] s2)
      | s2 = {inv'1 _19.current}
        MutBorrow.borrow_final <t_Tree> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_18 <- _ret ] -{inv'1 _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s3)
      | s3 = {inv'1 _21.current}
        MutBorrow.borrow_final <t_Tree> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &_21 <- { _21 with current = _ret.final } ] s4)
      | s4 = swap {_18} {_20} (fun (_ret: ()) -> [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'3 _21}- s2
      | s2 = {[@expl:type invariant] inv'6 _19} s3
      | s3 = -{resolve'3 _19}- s4
      | s4 = {inv'4 x}
        MutBorrow.borrow_mut <t_Node> {x}
          (fun (_ret: MutBorrow.t t_Node) -> [ &_25 <- _ret ] -{inv'4 _ret.final}- [ &x <- _ret.final ] s5)
      | s5 = {inv'3 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_23 <- _ret ] -{inv'3 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s6)
      | s6 = {inv'3 _25.current}
        MutBorrow.borrow_final <t_Node> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_24 <- _ret ] -{inv'3 _ret.final}-
            [ &_25 <- { _25 with current = _ret.final } ] s7)
      | s7 = swap'0 {_23} {_24} (fun (_ret: ()) -> [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'8 _25} s1
      | s1 = -{resolve'5 _25}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {(self'0.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_28 <- _ret ] [ &self'0 <- { self'0 with current = { self'0.current with t_Node__color = _ret.final } } ]
            s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.t_Node__color}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_30 <- _ret ] [ &x <- { x with t_Node__color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_27 <- _ret ] [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_29 <- _ret ] [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap'1 {_27} {_29} (fun (_ret: ()) -> [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve'7 _30}- s1
      | s1 = -{resolve'7 _28}- s2
      | s2 =
        {[@expl:assertion] [%#sred_black_tree'0] has_mapping (old_self.current).t_Node__left (deep_model (self'0.current).t_Node__key) (self'0.current).t_Node__val}
        s3
      | s3 = [ &_34 <- C_Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_33 <- { t_Tree__node = _34 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'1 (self'0.current).t_Node__right} s1
      | s1 = -{resolve'10 (self'0.current).t_Node__right}- s2
      | s2 = [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'12 self'0}- s5
      | s5 = bb12 ]
    | bb12 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & old_self: MutBorrow.t t_Node = Any.any_l ()
    | & x: t_Node = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: MutBorrow.t t_Tree = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _21: MutBorrow.t t_Tree = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node = Any.any_l ()
    | & _24: MutBorrow.t t_Node = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree = Any.any_l ()
    | & _34: t_Option = Any.any_l () ])
    [ return''0 (result: ()) ->
    {[@expl:rotate_right ensures #0] [%#sred_black_tree'4] same_mappings self.current self.final}
      {[@expl:rotate_right ensures #1] [%#sred_black_tree'5] internal_invariant self.final}
      {[@expl:rotate_right ensures #2] [%#sred_black_tree'6] height'0 self.current = height'0 self.final}
      {[@expl:rotate_right ensures #3] [%#sred_black_tree'7] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[@expl:rotate_right ensures #4] [%#sred_black_tree'8] color (self.final).t_Node__right = C_Red}
      {[@expl:rotate_right ensures #5] [%#sred_black_tree'9] (self.final).t_Node__color = (self.current).t_Node__color}
      {[@expl:rotate_right ensures #6] [%#sred_black_tree'10] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node
          = C_Some l
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
        /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
          = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
        /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__rotate_left [#"red_black_tree.rs" 476 4 476 29] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 477 23 477 41
  let%span sred_black_tree'0 = "red_black_tree.rs" 482 8 482 91
  let%span sred_black_tree'1 = "red_black_tree.rs" 476 24 476 28
  let%span sred_black_tree'2 = "red_black_tree.rs" 464 15 464 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 465 15 465 43
  let%span sred_black_tree'4 = "red_black_tree.rs" 466 14 466 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 467 14 467 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 468 14 468 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 469 14 469 65
  let%span sred_black_tree'8 = "red_black_tree.rs" 470 14 470 41
  let%span sred_black_tree'9 = "red_black_tree.rs" 471 14 471 44
  let%span sred_black_tree'10 = "red_black_tree.rs" 472 14 475 34
  let%span sred_black_tree'11 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'13 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'15 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'16 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'17 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'18 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'19 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'20 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'21 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'22 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'23 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'25 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'27 = "red_black_tree.rs" 334 12 340 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 606 18 606 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 159 14 159 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 164 14 164 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 169 14 169 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 125 4 125 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 126 4 126 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 4 131 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 4 136 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 137 4 137 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 138 4 138 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 143 14 144 104
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve [@inline:trivial] (_0: ()) = true
  
  meta "rewrite_def" predicate resolve
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {inv'2 result} {[%#soption'2] result = C_None} (! return' {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return' (x: t_Option)) =
    {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result: t_Option) -> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  predicate resolve'0 [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  let rec unwrap (self_: t_Option) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'0] self_ <> C_None}
    any [ return''0 (result: t_Node) -> {inv'4 result} {[%#soption'1] C_Some result = self_} (! return' {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  let rec swap (x: MutBorrow.t t_Tree) (y: MutBorrow.t t_Tree) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'2] inv'6 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'6 y}
    any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'2 [@inline:trivial] (self: MutBorrow.t t_Tree) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: MutBorrow.t t_Tree) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  let rec swap'0 (x: MutBorrow.t t_Node) (y: MutBorrow.t t_Node) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'2] inv'7 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'7 y}
    any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'4 _0
  
  meta "rewrite_def" predicate resolve'5
  
  let rec swap'1 (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Color) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_0: MutBorrow.t t_Color) = resolve'6 _0
  
  meta "rewrite_def" predicate resolve'7
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'17] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_0: t_Tree) = resolve'9 _0
  
  meta "rewrite_def" predicate resolve'10
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'11 _0
  
  meta "rewrite_def" predicate resolve'12
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'24] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'18] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'22] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'26] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'27] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'19] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'12] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'13] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'21] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'20] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'14] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'16] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'15] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec rotate_left [#"red_black_tree.rs" 476 4 476 29] (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree'1] inv'7 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree'2] internal_invariant self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree'3] color (self.current).t_Node__right = C_Red}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- [%#sred_black_tree] self'0 ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_16 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = {inv'2 _16.current}
        MutBorrow.borrow_final <t_Option> {_16.current} {MutBorrow.get_id _16}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &_16 <- { _16 with current = _ret.final } ] s2)
      | s2 = take {_15} (fun (_ret: t_Option) -> [ &_14 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'5 _16} s1
      | s1 = -{resolve'1 _16}- s2
      | s2 = unwrap {_14} (fun (_ret: t_Node) -> [ &x <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {inv'1 (self'0.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_19 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = _ret.final } } ] s1)
      | s1 = {inv'1 x.t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {x.t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_21 <- _ret ] -{inv'1 _ret.final}-
            [ &x <- { x with t_Node__left = _ret.final } ] s2)
      | s2 = {inv'1 _19.current}
        MutBorrow.borrow_final <t_Tree> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_18 <- _ret ] -{inv'1 _ret.final}-
            [ &_19 <- { _19 with current = _ret.final } ] s3)
      | s3 = {inv'1 _21.current}
        MutBorrow.borrow_final <t_Tree> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &_21 <- { _21 with current = _ret.final } ] s4)
      | s4 = swap {_18} {_20} (fun (_ret: ()) -> [ &_17 <- _ret ] s5)
      | s5 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'3 _21}- s2
      | s2 = {[@expl:type invariant] inv'6 _19} s3
      | s3 = -{resolve'3 _19}- s4
      | s4 = {inv'4 x}
        MutBorrow.borrow_mut <t_Node> {x}
          (fun (_ret: MutBorrow.t t_Node) -> [ &_25 <- _ret ] -{inv'4 _ret.final}- [ &x <- _ret.final ] s5)
      | s5 = {inv'3 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_23 <- _ret ] -{inv'3 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s6)
      | s6 = {inv'3 _25.current}
        MutBorrow.borrow_final <t_Node> {_25.current} {MutBorrow.get_id _25}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_24 <- _ret ] -{inv'3 _ret.final}-
            [ &_25 <- { _25 with current = _ret.final } ] s7)
      | s7 = swap'0 {_23} {_24} (fun (_ret: ()) -> [ &_22 <- _ret ] s8)
      | s8 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'8 _25} s1
      | s1 = -{resolve'5 _25}- s2
      | s2 = MutBorrow.borrow_final <t_Color> {(self'0.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_28 <- _ret ] [ &self'0 <- { self'0 with current = { self'0.current with t_Node__color = _ret.final } } ]
            s3)
      | s3 = MutBorrow.borrow_mut <t_Color> {x.t_Node__color}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_30 <- _ret ] [ &x <- { x with t_Node__color = _ret.final } ] s4)
      | s4 = MutBorrow.borrow_final <t_Color> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_27 <- _ret ] [ &_28 <- { _28 with current = _ret.final } ] s5)
      | s5 = MutBorrow.borrow_final <t_Color> {_30.current} {MutBorrow.get_id _30}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_29 <- _ret ] [ &_30 <- { _30 with current = _ret.final } ] s6)
      | s6 = swap'1 {_27} {_29} (fun (_ret: ()) -> [ &_26 <- _ret ] s7)
      | s7 = bb6 ]
    | bb6 = s0
      [ s0 = -{resolve'7 _30}- s1
      | s1 = -{resolve'7 _28}- s2
      | s2 =
        {[@expl:assertion] [%#sred_black_tree'0] has_mapping (old_self.current).t_Node__right (deep_model (self'0.current).t_Node__key) (self'0.current).t_Node__val}
        s3
      | s3 = [ &_34 <- C_Some x ] s4
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = [ &_33 <- { t_Tree__node = _34 } ] s1 | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'1 (self'0.current).t_Node__left} s1
      | s1 = -{resolve'10 (self'0.current).t_Node__left}- s2
      | s2 = [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = _33 } } ] s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'12 self'0}- s5
      | s5 = bb12 ]
    | bb12 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & old_self: MutBorrow.t t_Node = Any.any_l ()
    | & x: t_Node = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _18: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: MutBorrow.t t_Tree = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _21: MutBorrow.t t_Tree = Any.any_l ()
    | & _22: () = Any.any_l ()
    | & _23: MutBorrow.t t_Node = Any.any_l ()
    | & _24: MutBorrow.t t_Node = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Color = Any.any_l ()
    | & _28: MutBorrow.t t_Color = Any.any_l ()
    | & _29: MutBorrow.t t_Color = Any.any_l ()
    | & _30: MutBorrow.t t_Color = Any.any_l ()
    | & _33: t_Tree = Any.any_l ()
    | & _34: t_Option = Any.any_l () ])
    [ return''0 (result: ()) ->
    {[@expl:rotate_left ensures #0] [%#sred_black_tree'4] same_mappings self.current self.final}
      {[@expl:rotate_left ensures #1] [%#sred_black_tree'5] internal_invariant self.final}
      {[@expl:rotate_left ensures #2] [%#sred_black_tree'6] height'0 self.current = height'0 self.final}
      {[@expl:rotate_left ensures #3] [%#sred_black_tree'7] lt_log (deep_model (self.current).t_Node__key) (deep_model (self.final).t_Node__key)}
      {[@expl:rotate_left ensures #4] [%#sred_black_tree'8] color (self.final).t_Node__left = C_Red}
      {[@expl:rotate_left ensures #5] [%#sred_black_tree'9] (self.final).t_Node__color = (self.current).t_Node__color}
      {[@expl:rotate_left ensures #6] [%#sred_black_tree'10] exists l: t_Node, r: t_Node. ((self.current).t_Node__right).t_Tree__node
          = C_Some r
        /\ ((self.final).t_Node__left).t_Tree__node = C_Some l
        /\ { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.final).t_Node__right }
          = { _p0 = (self.current).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
        /\ l.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__flip_colors [#"red_black_tree.rs" 500 4 500 29] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 500 24 500 28
  let%span sred_black_tree'0 = "red_black_tree.rs" 486 15 486 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 487 15 487 40
  let%span sred_black_tree'2 = "red_black_tree.rs" 488 15 488 41
  let%span sred_black_tree'3 = "red_black_tree.rs" 489 15 489 60
  let%span sred_black_tree'4 = "red_black_tree.rs" 490 14 490 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 491 14 491 50
  let%span sred_black_tree'6 = "red_black_tree.rs" 492 14 492 42
  let%span sred_black_tree'7 = "red_black_tree.rs" 493 14 493 40
  let%span sred_black_tree'8 = "red_black_tree.rs" 494 14 496 68
  let%span sred_black_tree'9 = "red_black_tree.rs" 497 14 499 88
  let%span sred_black_tree'10 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'11 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'13 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'15 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'16 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'17 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'18 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'19 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'20 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'21 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'22 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'24 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 35 12 39 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'7 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  let rec swap (x: MutBorrow.t t_Color) (y: MutBorrow.t t_Color) (return' (x'0: ())) = any
    [ return''0 (result: ()) -> {[%#smem] x.final = y.current} {[%#smem'0] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Color) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Color) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'21] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'22] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'15] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'18] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'17] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'23] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'16] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'10] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'11] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'13] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'12] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'20] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'19] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'14] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec flip_colors [#"red_black_tree.rs" 500 4 500 29] (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree] inv'8 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'0] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'1] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'2] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'3] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Node__left).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = as_mut {_15} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret: MutBorrow.t t_Node) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &_13 <- { _13 with current = { _13.current with t_Node__color = (self'0.current).t_Node__color } } ] s1
      | s1 = {[@expl:type invariant] inv'6 _13} s2
      | s2 = -{resolve'0 _13}- s3
      | s3 = MutBorrow.borrow_final <t_Color> {(self'0.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_18 <- _ret ] [ &self'0 <- { self'0 with current = { self'0.current with t_Node__color = _ret.final } } ]
            s4)
      | s4 = {inv'2 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 5) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_23 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            s5)
      | s5 = as_mut {_23} (fun (_ret: t_Option'0) -> [ &_22 <- _ret ] s6)
      | s6 = bb3 ]
    | bb3 = s0 [ s0 = unwrap {_22} (fun (_ret: MutBorrow.t t_Node) -> [ &_21 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_final <t_Color> {(_21.current).t_Node__color}
          {MutBorrow.inherit_id (MutBorrow.get_id _21) 2}
          (fun (_ret: MutBorrow.t t_Color) ->
            [ &_20 <- _ret ] [ &_21 <- { _21 with current = { _21.current with t_Node__color = _ret.final } } ] s1)
      | s1 = MutBorrow.borrow_final <t_Color> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_17 <- _ret ] [ &_18 <- { _18 with current = _ret.final } ] s2)
      | s2 = MutBorrow.borrow_final <t_Color> {_20.current} {MutBorrow.get_id _20}
          (fun (_ret: MutBorrow.t t_Color) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s3)
      | s3 = swap {_17} {_19} (fun (_ret: ()) -> [ &_16 <- _ret ] s4)
      | s4 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'6 _21} s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = -{resolve'2 _20}- s3
      | s3 = -{resolve'2 _18}- s4
      | s4 = {[@expl:type invariant] inv'8 self'0} s5
      | s5 = -{resolve'4 self'0}- s6
      | s6 = return''0 {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: MutBorrow.t t_Color = Any.any_l ()
    | & _18: MutBorrow.t t_Color = Any.any_l ()
    | & _19: MutBorrow.t t_Color = Any.any_l ()
    | & _20: MutBorrow.t t_Color = Any.any_l ()
    | & _21: MutBorrow.t t_Node = Any.any_l ()
    | & _22: t_Option'0 = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:flip_colors ensures #0] [%#sred_black_tree'4] internal_invariant self.final}
      {[@expl:flip_colors ensures #1] [%#sred_black_tree'5] height'0 self.current = height'0 self.final}
      {[@expl:flip_colors ensures #2] [%#sred_black_tree'6] same_mappings self.current self.final}
      {[@expl:flip_colors ensures #3] [%#sred_black_tree'7] (self.current).t_Node__key = (self.final).t_Node__key}
      {[@expl:flip_colors ensures #4] [%#sred_black_tree'8] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node
          = C_Some l1
        /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[@expl:flip_colors ensures #5] [%#sred_black_tree'9] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node
          = C_Some r1
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ (self.current).t_Node__color = r2.t_Node__color
        /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__balance [#"red_black_tree.rs" 524 4 524 25] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 524 20 524 24
  let%span sred_black_tree'0 = "red_black_tree.rs" 505 15 505 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 506 15 507 45
  let%span sred_black_tree'2 = "red_black_tree.rs" 508 15 509 46
  let%span sred_black_tree'3 = "red_black_tree.rs" 510 15 510 108
  let%span sred_black_tree'4 = "red_black_tree.rs" 511 14 511 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 512 14 512 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 513 14 513 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 514 14 515 32
  let%span sred_black_tree'8 = "red_black_tree.rs" 516 14 517 37
  let%span sred_black_tree'9 = "red_black_tree.rs" 518 14 519 61
  let%span sred_black_tree'10 = "red_black_tree.rs" 520 14 521 59
  let%span sred_black_tree'11 = "red_black_tree.rs" 522 14 523 37
  let%span sred_black_tree'12 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'13 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'14 = "red_black_tree.rs" 476 24 476 28
  let%span sred_black_tree'15 = "red_black_tree.rs" 464 15 464 43
  let%span sred_black_tree'16 = "red_black_tree.rs" 465 15 465 43
  let%span sred_black_tree'17 = "red_black_tree.rs" 466 14 466 42
  let%span sred_black_tree'18 = "red_black_tree.rs" 467 14 467 42
  let%span sred_black_tree'19 = "red_black_tree.rs" 468 14 468 50
  let%span sred_black_tree'20 = "red_black_tree.rs" 469 14 469 65
  let%span sred_black_tree'21 = "red_black_tree.rs" 470 14 470 41
  let%span sred_black_tree'22 = "red_black_tree.rs" 471 14 471 44
  let%span sred_black_tree'23 = "red_black_tree.rs" 472 14 475 34
  let%span sred_black_tree'24 = "red_black_tree.rs" 426 25 426 29
  let%span sred_black_tree'25 = "red_black_tree.rs" 414 15 414 43
  let%span sred_black_tree'26 = "red_black_tree.rs" 415 15 415 42
  let%span sred_black_tree'27 = "red_black_tree.rs" 416 14 416 42
  let%span sred_black_tree'28 = "red_black_tree.rs" 417 14 417 42
  let%span sred_black_tree'29 = "red_black_tree.rs" 418 14 418 50
  let%span sred_black_tree'30 = "red_black_tree.rs" 419 14 419 65
  let%span sred_black_tree'31 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'32 = "red_black_tree.rs" 421 14 421 44
  let%span sred_black_tree'33 = "red_black_tree.rs" 422 14 425 34
  let%span sred_black_tree'34 = "red_black_tree.rs" 500 24 500 28
  let%span sred_black_tree'35 = "red_black_tree.rs" 486 15 486 43
  let%span sred_black_tree'36 = "red_black_tree.rs" 487 15 487 40
  let%span sred_black_tree'37 = "red_black_tree.rs" 488 15 488 41
  let%span sred_black_tree'38 = "red_black_tree.rs" 489 15 489 60
  let%span sred_black_tree'39 = "red_black_tree.rs" 490 14 490 42
  let%span sred_black_tree'40 = "red_black_tree.rs" 491 14 491 50
  let%span sred_black_tree'41 = "red_black_tree.rs" 492 14 492 42
  let%span sred_black_tree'42 = "red_black_tree.rs" 493 14 493 40
  let%span sred_black_tree'43 = "red_black_tree.rs" 494 14 496 68
  let%span sred_black_tree'44 = "red_black_tree.rs" 497 14 499 88
  let%span sred_black_tree'45 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'46 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'47 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'48 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'49 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'50 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 267 12 270 13
  let%span sred_black_tree'52 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'53 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'54 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'55 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'56 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'57 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'58 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'59 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'60 = "red_black_tree.rs" 308 8 308 112
  let%span sred_black_tree'61 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'62 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'63 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'64 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'65 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'66 = "red_black_tree.rs" 35 12 39 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 84 16 84 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 86 26 86 58
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 88 20 88 89
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'2 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'46] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'12] inv'5 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'13] result = (color self = C_Red)} (! return' {result}) ]
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'66] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'62] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'63] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'53] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'59] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'58] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'64] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'65] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'54] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'45] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'57] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'56] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'48] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'50] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'49] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_left (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree'14] inv'6 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree'15] internal_invariant self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree'16] color (self.current).t_Node__right = C_Red}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'17] same_mappings self.current self.final}
      {[%#sred_black_tree'18] internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] lt_log (deep_model (self.current).t_Node__key) (deep_model (self.final).t_Node__key)}
      {[%#sred_black_tree'21] color (self.final).t_Node__left = C_Red}
      {[%#sred_black_tree'22] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'23] exists l: t_Node, r: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r
        /\ ((self.final).t_Node__left).t_Tree__node = C_Some l
        /\ { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.final).t_Node__right }
          = { _p0 = (self.current).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
        /\ l.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 t_Node
  
  predicate invariant''2 [@inline:trivial] (self: t_Option) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: t_Option)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate invariant''3 [@inline:trivial] (self: t_Node) = [%#sinvariant'0] inv'3 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate inv'9 (_0: t_Option'0)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Option'0 [inv'9 x]. inv'9 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'8 a_0
        end
  
  let rec as_ref (self_: t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_ref 'self_' type invariant] [%#soption] inv'7 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'9 result}
      {[%#soption'0] self_ = C_None -> result = C_None'0}
      {[%#soption'1] self_ = C_None \/ (exists r: t_Node. result = C_Some'0 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'9 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any [ return''0 (result: t_Node) -> {inv'8 result} {[%#soption'4] C_Some'0 result = self_} (! return' {result}) ]
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'24] inv'6 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'25] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'26] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'27] same_mappings self.current self.final}
      {[%#sred_black_tree'28] internal_invariant self.final}
      {[%#sred_black_tree'29] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'30] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'31] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'32] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'33] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
        /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
          = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
        /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  let rec flip_colors (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree'34] inv'6 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'35] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'36] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'37] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'38] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'39] internal_invariant self.final}
      {[%#sred_black_tree'40] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'41] same_mappings self.current self.final}
      {[%#sred_black_tree'42] (self.current).t_Node__key = (self.final).t_Node__key}
      {[%#sred_black_tree'43] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l1
        /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[%#sred_black_tree'44] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r1
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ (self.current).t_Node__color = r2.t_Node__color
        /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'55] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'47] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant'0 [#"red_black_tree.rs" 307 4 307 36] (self: t_Node) =
    [%#sred_black_tree'60] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'61] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 265 4 265 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'51] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'52] C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec balance [#"red_black_tree.rs" 524 4 524 25] (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:balance 'self' type invariant] [%#sred_black_tree] inv'6 self}
    {[@expl:balance requires #0] [%#sred_black_tree'0] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'1] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__left = C_Red -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'2] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'3] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red -> false}
    (! bb0
    [ bb0 = s0 [ s0 = is_red {(self'0.current).t_Node__right} (fun (_ret: bool) -> [ &_15 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb2) ]
    | bb2 = s0 [ s0 = is_red {(self'0.current).t_Node__left} (fun (_ret: bool) -> [ &_17 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb9) ]
    | bb5 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = rotate_left {_20} (fun (_ret: ()) -> [ &_19 <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Node__left} (fun (_ret: bool) -> [ &_22 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb20) | br1 -> {_22} (! bb11) ]
    | bb11 = s0
      [ s0 = as_ref {((self'0.current).t_Node__left).t_Tree__node} (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s1)
      | s1 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_27} (fun (_ret: t_Node) -> [ &_26 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0 [ s0 = is_red {_26.t_Node__left} (fun (_ret: bool) -> [ &_24 <- _ret ] s1) | s1 = bb14 ]
    | bb14 = any [ br0 -> {_24 = false} (! bb20) | br1 -> {_24} (! bb15) ]
    | bb15 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_30 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = rotate_right {_30} (fun (_ret: ()) -> [ &_29 <- _ret ] s2)
      | s2 = bb20 ]
    | bb20 = s0 [ s0 = is_red {(self'0.current).t_Node__left} (fun (_ret: bool) -> [ &_31 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = any [ br0 -> {_31 = false} (! bb27) | br1 -> {_31} (! bb22) ]
    | bb22 = s0 [ s0 = is_red {(self'0.current).t_Node__right} (fun (_ret: bool) -> [ &_33 <- _ret ] s1) | s1 = bb23 ]
    | bb23 = any [ br0 -> {_33 = false} (! bb26) | br1 -> {_33} (! bb24) ]
    | bb24 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_final <t_Node> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_36 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = flip_colors {_36} (fun (_ret: ()) -> [ &_35 <- _ret ] s2)
      | s2 = bb25 ]
    | bb25 = s0 [ s0 = {[@expl:type invariant] inv'6 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb29 ]
    | bb26 = s0 [ s0 = {[@expl:type invariant] inv'6 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb29 ]
    | bb27 = s0 [ s0 = {[@expl:type invariant] inv'6 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb29 ]
    | bb29 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _15: bool = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Node = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: () = Any.any_l ()
    | & _36: MutBorrow.t t_Node = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:balance ensures #0] [%#sred_black_tree'4] same_mappings self.current self.final}
      {[@expl:balance ensures #1] [%#sred_black_tree'5] internal_invariant self.final}
      {[@expl:balance ensures #2] [%#sred_black_tree'6] height'0 self.current = height'0 self.final}
      {[@expl:balance ensures #3] [%#sred_black_tree'7] color_invariant (self.current).t_Node__left
        /\ color (self.current).t_Node__right = C_Black -> self.current = self.final}
      {[@expl:balance ensures #4] [%#sred_black_tree'8] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {[@expl:balance ensures #5] [%#sred_black_tree'9] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[@expl:balance ensures #6] [%#sred_black_tree'10] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[@expl:balance ensures #7] [%#sred_black_tree'11] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__move_red_left [#"red_black_tree.rs" 556 4 556 44] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 556 26 556 30
  let%span sred_black_tree'0 = "red_black_tree.rs" 538 15 538 41
  let%span sred_black_tree'1 = "red_black_tree.rs" 539 15 539 43
  let%span sred_black_tree'2 = "red_black_tree.rs" 540 15 540 86
  let%span sred_black_tree'3 = "red_black_tree.rs" 556 35 556 44
  let%span sred_black_tree'4 = "red_black_tree.rs" 541 14 541 44
  let%span sred_black_tree'5 = "red_black_tree.rs" 542 14 544 46
  let%span sred_black_tree'6 = "red_black_tree.rs" 545 14 545 95
  let%span sred_black_tree'7 = "red_black_tree.rs" 546 14 546 42
  let%span sred_black_tree'8 = "red_black_tree.rs" 547 14 547 103
  let%span sred_black_tree'9 = "red_black_tree.rs" 548 14 549 45
  let%span sred_black_tree'10 = "red_black_tree.rs" 550 14 551 106
  let%span sred_black_tree'11 = "red_black_tree.rs" 552 14 553 61
  let%span sred_black_tree'12 = "red_black_tree.rs" 554 14 555 43
  let%span sred_black_tree'13 = "red_black_tree.rs" 500 24 500 28
  let%span sred_black_tree'14 = "red_black_tree.rs" 486 15 486 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 487 15 487 40
  let%span sred_black_tree'16 = "red_black_tree.rs" 488 15 488 41
  let%span sred_black_tree'17 = "red_black_tree.rs" 489 15 489 60
  let%span sred_black_tree'18 = "red_black_tree.rs" 490 14 490 42
  let%span sred_black_tree'19 = "red_black_tree.rs" 491 14 491 50
  let%span sred_black_tree'20 = "red_black_tree.rs" 492 14 492 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 493 14 493 40
  let%span sred_black_tree'22 = "red_black_tree.rs" 494 14 496 68
  let%span sred_black_tree'23 = "red_black_tree.rs" 497 14 499 88
  let%span sred_black_tree'24 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'25 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'26 = "red_black_tree.rs" 426 25 426 29
  let%span sred_black_tree'27 = "red_black_tree.rs" 414 15 414 43
  let%span sred_black_tree'28 = "red_black_tree.rs" 415 15 415 42
  let%span sred_black_tree'29 = "red_black_tree.rs" 416 14 416 42
  let%span sred_black_tree'30 = "red_black_tree.rs" 417 14 417 42
  let%span sred_black_tree'31 = "red_black_tree.rs" 418 14 418 50
  let%span sred_black_tree'32 = "red_black_tree.rs" 419 14 419 65
  let%span sred_black_tree'33 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'34 = "red_black_tree.rs" 421 14 421 44
  let%span sred_black_tree'35 = "red_black_tree.rs" 422 14 425 34
  let%span sred_black_tree'36 = "red_black_tree.rs" 476 24 476 28
  let%span sred_black_tree'37 = "red_black_tree.rs" 464 15 464 43
  let%span sred_black_tree'38 = "red_black_tree.rs" 465 15 465 43
  let%span sred_black_tree'39 = "red_black_tree.rs" 466 14 466 42
  let%span sred_black_tree'40 = "red_black_tree.rs" 467 14 467 42
  let%span sred_black_tree'41 = "red_black_tree.rs" 468 14 468 50
  let%span sred_black_tree'42 = "red_black_tree.rs" 469 14 469 65
  let%span sred_black_tree'43 = "red_black_tree.rs" 470 14 470 41
  let%span sred_black_tree'44 = "red_black_tree.rs" 471 14 471 44
  let%span sred_black_tree'45 = "red_black_tree.rs" 472 14 475 34
  let%span sred_black_tree'46 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'47 = "red_black_tree.rs" 267 12 270 13
  let%span sred_black_tree'48 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'49 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'50 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'52 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'53 = "red_black_tree.rs" 308 8 308 112
  let%span sred_black_tree'54 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'55 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'56 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'57 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'58 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'59 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'60 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'61 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'62 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'63 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'64 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'65 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'66 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'67 = "red_black_tree.rs" 334 12 340 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  predicate inv'4 (_0: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
      = match x with
        | {t_Tree__node = node} -> inv'3 node
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'4 left
        /\ inv key /\ inv'0 val' /\ inv'4 right
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Node [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'61] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'64] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'65] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'56] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'60] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'59] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'66] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'67] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'57] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'46] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'54] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'50] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'49] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'52] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'51] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'55] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree'13] inv'5 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'15] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'16] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'17] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'18] internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] same_mappings self.current self.final}
      {[%#sred_black_tree'21] (self.current).t_Node__key = (self.final).t_Node__key}
      {[%#sred_black_tree'22] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l1
        /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[%#sred_black_tree'23] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r1
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ (self.current).t_Node__color = r2.t_Node__color
        /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'7 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'6 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'8 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'8 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'7 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'24] inv'9 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'25] result = (color self = C_Red)} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  type tuple = { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'26] inv'5 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'27] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'28] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'29] same_mappings self.current self.final}
      {[%#sred_black_tree'30] internal_invariant self.final}
      {[%#sred_black_tree'31] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'32] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'33] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'34] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'35] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
        /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
          = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
        /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  let rec rotate_left (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_left 'self' type invariant] [%#sred_black_tree'36] inv'5 self}
    {[@expl:rotate_left requires #0] [%#sred_black_tree'37] internal_invariant self.current}
    {[@expl:rotate_left requires #1] [%#sred_black_tree'38] color (self.current).t_Node__right = C_Red}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'39] same_mappings self.current self.final}
      {[%#sred_black_tree'40] internal_invariant self.final}
      {[%#sred_black_tree'41] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'42] lt_log (deep_model (self.current).t_Node__key) (deep_model (self.final).t_Node__key)}
      {[%#sred_black_tree'43] color (self.final).t_Node__left = C_Red}
      {[%#sred_black_tree'44] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'45] exists l: t_Node, r: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r
        /\ ((self.final).t_Node__left).t_Tree__node = C_Some l
        /\ { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.final).t_Node__right }
          = { _p0 = (self.current).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
        /\ l.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'62] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'63] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 307 4 307 36] (self: t_Node) =
    [%#sred_black_tree'53] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'58] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 265 4 265 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'47] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'48] C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_left [#"red_black_tree.rs" 556 4 556 44] (self: MutBorrow.t t_Node)
    (return' (x: MutBorrow.t t_Node)) = {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree] inv'5 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree'0] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] [%#sred_black_tree'1] internal_invariant self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree'2] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = flip_colors {_16} (fun (_ret: ()) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_22 <- _ret ] -{inv'3 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = as_mut {_22} (fun (_ret: t_Option'0) -> [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_21} (fun (_ret: MutBorrow.t t_Node) -> [ &_20 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = is_red {(_20.current).t_Node__left} (fun (_ret: bool) -> [ &_18 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'7 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb13) | br1 -> {_18} (! bb5) ] ]
    | bb5 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_28 <- _ret ] -{inv'3 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = as_mut {_28} (fun (_ret: t_Option'0) -> [ &_27 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0 [ s0 = unwrap {_27} (fun (_ret: MutBorrow.t t_Node) -> [ &_26 <- _ret ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'1 _26.current}
        MutBorrow.borrow_final <t_Node> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_25 <- _ret ] -{inv'1 _ret.final}-
            [ &_26 <- { _26 with current = _ret.final } ] s1)
      | s1 = rotate_right {_25} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'7 _26} s1
      | s1 = -{resolve'0 _26}- s2
      | s2 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_30 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s3)
      | s3 = rotate_left {_30} (fun (_ret: ()) -> [ &_29 <- _ret ] s4)
      | s4 = bb9 ]
    | bb9 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_32 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = flip_colors {_32} (fun (_ret: ()) -> [ &_31 <- _ret ] s2)
      | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Node__left).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_35 <- _ret ] -{inv'3 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = as_mut {_35} (fun (_ret: t_Option'0) -> [ &_34 <- _ret ] s2)
      | s2 = bb11 ]
    | bb11 = s0 [ s0 = unwrap {_34} (fun (_ret: MutBorrow.t t_Node) -> [ &_33 <- _ret ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = {inv'1 _33.current}
        MutBorrow.borrow_final <t_Node> {_33.current} {MutBorrow.get_id _33}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_0 <- _ret ] -{inv'1 _ret.final}-
            [ &_33 <- { _33 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'7 _33} s2
      | s2 = -{resolve'0 _33}- s3
      | s3 = bb16 ]
    | bb16 = s0 [ s0 = {[@expl:type invariant] inv'5 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb14 ]
    | bb13 = s0 [ s0 = [ &_0 <- self'0 ] s1 | s1 = bb14 ]
    | bb14 = return''0 {_0} ]
    [ & _0: MutBorrow.t t_Node = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _21: t_Option'0 = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: MutBorrow.t t_Node = Any.any_l ()
    | & _27: t_Option'0 = Any.any_l ()
    | & _28: MutBorrow.t t_Option = Any.any_l ()
    | & _29: () = Any.any_l ()
    | & _30: MutBorrow.t t_Node = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _32: MutBorrow.t t_Node = Any.any_l ()
    | & _33: MutBorrow.t t_Node = Any.any_l ()
    | & _34: t_Option'0 = Any.any_l ()
    | & _35: MutBorrow.t t_Option = Any.any_l () ])
    [ return''0 (result: MutBorrow.t t_Node) ->
    {[@expl:move_red_left result type invariant] [%#sred_black_tree'3] inv'5 result}
      {[@expl:move_red_left ensures #0] [%#sred_black_tree'4] internal_invariant result.current}
      {[@expl:move_red_left ensures #1] [%#sred_black_tree'5] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[@expl:move_red_left ensures #2] [%#sred_black_tree'6] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_left ensures #3] [%#sred_black_tree'7] (self.current).t_Node__key = (result.current).t_Node__key}
      {[@expl:move_red_left ensures #4] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[@expl:move_red_left ensures #5] [%#sred_black_tree'9] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log k (deep_model (self.current).t_Node__key) -> has_mapping'0 result.current k v}
      {[@expl:move_red_left ensures #6] [%#sred_black_tree'10] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_left ensures #7] [%#sred_black_tree'11] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[@expl:move_red_left ensures #8] [%#sred_black_tree'12] color_invariant'0 result.final
        /\ (color (result.current).t_Node__right = C_Black -> (result.final).t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3665871523867809084__move_red_right [#"red_black_tree.rs" 585 4 585 45] (* Node<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 585 27 585 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 567 15 567 40
  let%span sred_black_tree'1 = "red_black_tree.rs" 568 15 568 43
  let%span sred_black_tree'2 = "red_black_tree.rs" 569 15 569 86
  let%span sred_black_tree'3 = "red_black_tree.rs" 585 36 585 45
  let%span sred_black_tree'4 = "red_black_tree.rs" 570 14 570 44
  let%span sred_black_tree'5 = "red_black_tree.rs" 571 14 573 46
  let%span sred_black_tree'6 = "red_black_tree.rs" 574 14 574 95
  let%span sred_black_tree'7 = "red_black_tree.rs" 575 14 575 42
  let%span sred_black_tree'8 = "red_black_tree.rs" 576 14 576 103
  let%span sred_black_tree'9 = "red_black_tree.rs" 577 14 578 45
  let%span sred_black_tree'10 = "red_black_tree.rs" 579 14 580 106
  let%span sred_black_tree'11 = "red_black_tree.rs" 581 14 582 61
  let%span sred_black_tree'12 = "red_black_tree.rs" 583 14 584 43
  let%span sred_black_tree'13 = "red_black_tree.rs" 500 24 500 28
  let%span sred_black_tree'14 = "red_black_tree.rs" 486 15 486 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 487 15 487 40
  let%span sred_black_tree'16 = "red_black_tree.rs" 488 15 488 41
  let%span sred_black_tree'17 = "red_black_tree.rs" 489 15 489 60
  let%span sred_black_tree'18 = "red_black_tree.rs" 490 14 490 42
  let%span sred_black_tree'19 = "red_black_tree.rs" 491 14 491 50
  let%span sred_black_tree'20 = "red_black_tree.rs" 492 14 492 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 493 14 493 40
  let%span sred_black_tree'22 = "red_black_tree.rs" 494 14 496 68
  let%span sred_black_tree'23 = "red_black_tree.rs" 497 14 499 88
  let%span sred_black_tree'24 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'25 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'26 = "red_black_tree.rs" 426 25 426 29
  let%span sred_black_tree'27 = "red_black_tree.rs" 414 15 414 43
  let%span sred_black_tree'28 = "red_black_tree.rs" 415 15 415 42
  let%span sred_black_tree'29 = "red_black_tree.rs" 416 14 416 42
  let%span sred_black_tree'30 = "red_black_tree.rs" 417 14 417 42
  let%span sred_black_tree'31 = "red_black_tree.rs" 418 14 418 50
  let%span sred_black_tree'32 = "red_black_tree.rs" 419 14 419 65
  let%span sred_black_tree'33 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'34 = "red_black_tree.rs" 421 14 421 44
  let%span sred_black_tree'35 = "red_black_tree.rs" 422 14 425 34
  let%span sred_black_tree'36 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'37 = "red_black_tree.rs" 267 12 270 13
  let%span sred_black_tree'38 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'39 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'40 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'41 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'42 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'43 = "red_black_tree.rs" 308 8 308 112
  let%span sred_black_tree'44 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'45 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'46 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'47 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'48 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'49 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'50 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'52 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'53 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'54 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'55 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'56 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'57 = "red_black_tree.rs" 334 12 340 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  predicate inv'4 (_0: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
      = match x with
        | {t_Tree__node = node} -> inv'3 node
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'4 left
        /\ inv key /\ inv'0 val' /\ inv'4 right
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Node [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'51] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'54] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'55] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'46] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'50] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'49] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'56] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'57] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'47] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'36] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'44] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'40] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'39] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'42] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'41] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'45] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec flip_colors (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:flip_colors 'self' type invariant] [%#sred_black_tree'13] inv'5 self}
    {[@expl:flip_colors requires #0] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:flip_colors requires #1] [%#sred_black_tree'15] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #2] [%#sred_black_tree'16] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:flip_colors requires #3] [%#sred_black_tree'17] color (self.current).t_Node__left
    = color (self.current).t_Node__right}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'18] internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] same_mappings self.current self.final}
      {[%#sred_black_tree'21] (self.current).t_Node__key = (self.final).t_Node__key}
      {[%#sred_black_tree'22] exists l1: t_Node, l2: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l1
        /\ ((self.final).t_Node__left).t_Tree__node = C_Some l2
        /\ l1.t_Node__left = l2.t_Node__left
        /\ l1.t_Node__right = l2.t_Node__right
        /\ l1.t_Node__key = l2.t_Node__key
        /\ (self.current).t_Node__color = l2.t_Node__color /\ (self.final).t_Node__color = l1.t_Node__color}
      {[%#sred_black_tree'23] exists r1: t_Node, r2: t_Node. ((self.current).t_Node__right).t_Tree__node = C_Some r1
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r2
        /\ r1.t_Node__left = r2.t_Node__left
        /\ r1.t_Node__right = r2.t_Node__right
        /\ r1.t_Node__key = r2.t_Node__key
        /\ (self.current).t_Node__color = r2.t_Node__color
        /\ (self.final).t_Node__color = r1.t_Node__color /\ r1.t_Node__key = r2.t_Node__key}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'7 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'6 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'8 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'8 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'7 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'24] inv'9 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'25] result = (color self = C_Red)} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  type tuple = { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'26] inv'5 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'27] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'28] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'29] same_mappings self.current self.final}
      {[%#sred_black_tree'30] internal_invariant self.final}
      {[%#sred_black_tree'31] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'32] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'33] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'34] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'35] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
        /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
          = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
        /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'52] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'53] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 307 4 307 36] (self: t_Node) =
    [%#sred_black_tree'43] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'48] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 265 4 265 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'37] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'38] C_CPN c l r
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec move_red_right [#"red_black_tree.rs" 585 4 585 45] (self: MutBorrow.t t_Node)
    (return' (x: MutBorrow.t t_Node)) = {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree] inv'5 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree'0] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] [%#sred_black_tree'1] internal_invariant self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree'2] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = flip_colors {_16} (fun (_ret: ()) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__left).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Node__left).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_22 <- _ret ] -{inv'3 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__left = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = as_mut {_22} (fun (_ret: t_Option'0) -> [ &_21 <- _ret ] s2)
      | s2 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_21} (fun (_ret: MutBorrow.t t_Node) -> [ &_20 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = is_red {(_20.current).t_Node__left} (fun (_ret: bool) -> [ &_18 <- _ret ] s1) | s1 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv'7 _20} s1
      | s1 = -{resolve'0 _20}- s2
      | s2 = any [ br0 -> {_18 = false} (! bb10) | br1 -> {_18} (! bb5) ] ]
    | bb5 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_25 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = rotate_right {_25} (fun (_ret: ()) -> [ &_24 <- _ret ] s2)
      | s2 = bb6 ]
    | bb6 = s0
      [ s0 = {inv'1 self'0.current}
        MutBorrow.borrow_mut <t_Node> {self'0.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_27 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = _ret.final } ] s1)
      | s1 = flip_colors {_27} (fun (_ret: ()) -> [ &_26 <- _ret ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'3 ((self'0.current).t_Node__right).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Node__right).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 5) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_30 <- _ret ] -{inv'3 _ret.final}-
            [ &self'0 <- { self'0 with current = { self'0.current with t_Node__right = { t_Tree__node = _ret.final } } } ]
            s1)
      | s1 = as_mut {_30} (fun (_ret: t_Option'0) -> [ &_29 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = s0 [ s0 = unwrap {_29} (fun (_ret: MutBorrow.t t_Node) -> [ &_28 <- _ret ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = {inv'1 _28.current}
        MutBorrow.borrow_final <t_Node> {_28.current} {MutBorrow.get_id _28}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_0 <- _ret ] -{inv'1 _ret.final}-
            [ &_28 <- { _28 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'7 _28} s2
      | s2 = -{resolve'0 _28}- s3
      | s3 = bb13 ]
    | bb13 = s0 [ s0 = {[@expl:type invariant] inv'5 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb11 ]
    | bb10 = s0 [ s0 = [ &_0 <- self'0 ] s1 | s1 = bb11 ]
    | bb11 = return''0 {_0} ]
    [ & _0: MutBorrow.t t_Node = Any.any_l ()
    | & self'0: MutBorrow.t t_Node = self
    | & _15: () = Any.any_l ()
    | & _16: MutBorrow.t t_Node = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: MutBorrow.t t_Node = Any.any_l ()
    | & _21: t_Option'0 = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l ()
    | & _25: MutBorrow.t t_Node = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Node = Any.any_l ()
    | & _28: MutBorrow.t t_Node = Any.any_l ()
    | & _29: t_Option'0 = Any.any_l ()
    | & _30: MutBorrow.t t_Option = Any.any_l () ])
    [ return''0 (result: MutBorrow.t t_Node) ->
    {[@expl:move_red_right result type invariant] [%#sred_black_tree'3] inv'5 result}
      {[@expl:move_red_right ensures #0] [%#sred_black_tree'4] internal_invariant result.current}
      {[@expl:move_red_right ensures #1] [%#sred_black_tree'5] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[@expl:move_red_right ensures #2] [%#sred_black_tree'6] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[@expl:move_red_right ensures #3] [%#sred_black_tree'7] (result.current).t_Node__key
      = (self.current).t_Node__key}
      {[@expl:move_red_right ensures #4] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[@expl:move_red_right ensures #5] [%#sred_black_tree'9] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log (deep_model (self.current).t_Node__key) k -> has_mapping'0 result.current k v}
      {[@expl:move_red_right ensures #6] [%#sred_black_tree'10] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[@expl:move_red_right ensures #7] [%#sred_black_tree'11] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[@expl:move_red_right ensures #8] [%#sred_black_tree'12] color_invariant'0 result.final
        /\ (color (result.current).t_Node__left = C_Black -> (result.final).t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__insert_rec [#"red_black_tree.rs" 608 4 608 44] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 608 23 608 27
  let%span sred_black_tree'0 = "red_black_tree.rs" 608 29 608 32
  let%span sred_black_tree'1 = "red_black_tree.rs" 608 37 608 40
  let%span sred_black_tree'2 = "red_black_tree.rs" 600 15 600 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 601 15 601 40
  let%span sred_black_tree'4 = "red_black_tree.rs" 602 14 602 42
  let%span sred_black_tree'5 = "red_black_tree.rs" 603 14 603 50
  let%span sred_black_tree'6 = "red_black_tree.rs" 604 14 605 39
  let%span sred_black_tree'7 = "red_black_tree.rs" 606 14 606 56
  let%span sred_black_tree'8 = "red_black_tree.rs" 607 14 607 125
  let%span sred_black_tree'9 = "red_black_tree.rs" 524 20 524 24
  let%span sred_black_tree'10 = "red_black_tree.rs" 505 15 505 43
  let%span sred_black_tree'11 = "red_black_tree.rs" 506 15 507 45
  let%span sred_black_tree'12 = "red_black_tree.rs" 508 15 509 46
  let%span sred_black_tree'13 = "red_black_tree.rs" 510 15 510 108
  let%span sred_black_tree'14 = "red_black_tree.rs" 511 14 511 42
  let%span sred_black_tree'15 = "red_black_tree.rs" 512 14 512 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 513 14 513 50
  let%span sred_black_tree'17 = "red_black_tree.rs" 514 14 515 32
  let%span sred_black_tree'18 = "red_black_tree.rs" 516 14 517 37
  let%span sred_black_tree'19 = "red_black_tree.rs" 518 14 519 61
  let%span sred_black_tree'20 = "red_black_tree.rs" 520 14 521 59
  let%span sred_black_tree'21 = "red_black_tree.rs" 522 14 523 37
  let%span sred_black_tree'22 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'23 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'25 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'28 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'29 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 1 0 979 4
  let%span sred_black_tree'31 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'32 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'33 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'34 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'35 = "red_black_tree.rs" 267 12 270 13
  let%span sred_black_tree'36 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'38 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'39 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'40 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'41 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'42 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'43 = "red_black_tree.rs" 308 8 308 112
  let%span sred_black_tree'44 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'45 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'46 = "red_black_tree.rs" 188 12 188 62
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sresolve'0 = "../../creusot-contracts/src/resolve.rs" 56 8 56 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'42] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'41] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'1 (_0: t_V)
  
  predicate resolve'2 [#"red_black_tree.rs" 186 4 186 28] (self: t_Node) =
    [%#sred_black_tree'46] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve'1 v
  
  predicate resolve'3 [@inline:trivial] (_0: t_Node) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_Node) = [%#sresolve'0] resolve'3 self
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_0: t_Node) = resolve'4 _0
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (self: t_Option) =
    [%#soption] match self with
      | C_Some x -> resolve'5 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_0: t_Option) = resolve'6 _0
  
  meta "rewrite_def" predicate resolve'7
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate resolve'8 [@inline:trivial] (self: MutBorrow.t t_Tree) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'8
  
  predicate resolve'9 [@inline:trivial] (_0: MutBorrow.t t_Tree) = resolve'8 _0
  
  meta "rewrite_def" predicate resolve'9
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { _p0: t_K; _p1: t_K }
  
  predicate invariant''2 [@inline:trivial] (self: t_K) = [%#sinvariant'0] inv self
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: t_K)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_K [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    [%#sred_black_tree'30] forall args: tuple [precondition () args]. (let {_p0 = self_; _p1 = rhs} = args in inv'7 rhs
        /\ inv'7 self_) -> precondition () args
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    [%#sred_black_tree'30] forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {_p0 = self_; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return' (x: t_Ordering)) = {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                          _p1 = rhs }}
    any
    [ return''0 (result: t_Ordering) -> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  predicate resolve'10 (_0: t_K)
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'11 _0
  
  meta "rewrite_def" predicate resolve'12
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'44] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'39] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'24] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'45] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'37] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'40] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'31] bst_invariant'0 self /\ height_invariant'0 self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'28] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'38] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'32] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'34] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'33] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant'0 [#"red_black_tree.rs" 307 4 307 36] (self: t_Node) =
    [%#sred_black_tree'43] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'26] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 265 4 265 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'35] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'27] C_CPN c l r
  
  let rec balance (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:balance 'self' type invariant] [%#sred_black_tree'9] inv'9 self}
    {[@expl:balance requires #0] [%#sred_black_tree'10] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'11] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__left = C_Red -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'12] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'13] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red -> false}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'14] same_mappings self.current self.final}
      {[%#sred_black_tree'15] internal_invariant self.final}
      {[%#sred_black_tree'16] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'17] color_invariant (self.current).t_Node__left
        /\ color (self.current).t_Node__right = C_Black -> self.current = self.final}
      {[%#sred_black_tree'18] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'19] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'20] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'21] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'22] bst_invariant self /\ height_invariant self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert_rec [#"red_black_tree.rs" 608 4 608 44] (self: MutBorrow.t t_Tree) (key: t_K) (val': t_V)
    (return' (x: ())) = {[@expl:insert_rec 'self' type invariant] [%#sred_black_tree] inv'6 self}
    {[@expl:insert_rec 'key' type invariant] [%#sred_black_tree'0] inv key}
    {[@expl:insert_rec 'val' type invariant] [%#sred_black_tree'1] inv'0 val'}
    {[@expl:insert_rec requires #0] [%#sred_black_tree'2] internal_invariant'0 self.current}
    {[@expl:insert_rec requires #1] [%#sred_black_tree'3] color_invariant self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_11 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = any [ br0 -> {_11.current = C_None} (! bb17) | br1 (x0: t_Node) -> {_11.current = C_Some x0} (! bb2) ] ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'5 _11} s1
      | s1 = -{resolve'0 _11}- s2
      | s2 = [ &_35 <- C_None ] s3
      | s3 = [ &_34 <- { t_Tree__node = _35 } ] s4
      | s4 = bb18 ]
    | bb18 = s0
      [ s0 = [ &_36 <- C_Red ] s1
      | s1 = [ &_40 <- C_None ] s2
      | s2 = [ &_39 <- { t_Tree__node = _40 } ] s3
      | s3 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_33 <- { t_Node__left = _34;
                         t_Node__color = _36;
                         t_Node__key = key'0;
                         t_Node__val = val''0;
                         t_Node__right = _39 } ] s1
      | s1 = bb24 ]
    | bb24 = s0 [ s0 = [ &_31 <- C_Some _33 ] s1 | s1 = bb26 ]
    | bb26 = s0
      [ s0 = {[@expl:type invariant] inv'2 (self'0.current).t_Tree__node} s1
      | s1 = -{resolve'7 (self'0.current).t_Tree__node}- s2
      | s2 = [ &self'0 <- { self'0 with current = { t_Tree__node = _31 } } ] s3
      | s3 = {[@expl:type invariant] inv'6 self'0} s4
      | s4 = -{resolve'9 self'0}- s5
      | s5 = bb32 ]
    | bb2 = s0
      [ s0 = v_Some {_11.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _11) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_11 <- { _11 with current = C_Some _ret.final } ] s1))
      | s1 = [ &_18 <- (node.current).t_Node__key ] s2
      | s2 = cmp {key'0} {_18} (fun (_ret: t_Ordering) -> [ &_15 <- _ret ] s3)
      | s3 = bb3 ]
    | bb3 = any [ br0 -> {_15 = C_Less} (! bb9) | br1 -> {_15 = C_Equal} (! bb6) | br2 -> {_15 = C_Greater} (! bb7) ]
    | bb7 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_25 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = insert_rec {_25} {key'0} {val''0} (fun (_ret: ()) -> [ &_14 <- _ret ] s2)
      | s2 = bb15 ]
    | bb6 = s0 [ s0 = {[@expl:type invariant] inv key'0} s1 | s1 = -{resolve'10 key'0}- s2 | s2 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'0 (node.current).t_Node__val} s1
      | s1 = -{resolve'1 (node.current).t_Node__val}- s2
      | s2 = [ &node <- { node with current = { node.current with t_Node__val = val''0 } } ] s3
      | s3 = {[@expl:type invariant] inv'8 node} s4
      | s4 = -{resolve'12 node}- s5
      | s5 = {[@expl:type invariant] inv'5 _11} s6
      | s6 = -{resolve'0 _11}- s7
      | s7 = {[@expl:type invariant] inv'6 self'0} s8
      | s8 = -{resolve'9 self'0}- s9
      | s9 = bb32 ]
    | bb9 = s0
      [ s0 = {inv'1 (node.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_20 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
      | s1 = insert_rec {_20} {key'0} {val''0} (fun (_ret: ()) -> [ &_14 <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_29 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_29} (fun (_ret: ()) -> [ &_28 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'12 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _11} s3
      | s3 = -{resolve'0 _11}- s4
      | s4 = {[@expl:type invariant] inv'6 self'0} s5
      | s5 = -{resolve'9 self'0}- s6
      | s6 = bb32 ]
    | bb32 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & key'0: t_K = key
    | & val''0: t_V = val'
    | & _11: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _14: () = Any.any_l ()
    | & _15: t_Ordering = Any.any_l ()
    | & _18: t_K = Any.any_l ()
    | & _20: MutBorrow.t t_Tree = Any.any_l ()
    | & _25: MutBorrow.t t_Tree = Any.any_l ()
    | & _28: () = Any.any_l ()
    | & _29: MutBorrow.t t_Node = Any.any_l ()
    | & _31: t_Option = Any.any_l ()
    | & _33: t_Node = Any.any_l ()
    | & _34: t_Tree = Any.any_l ()
    | & _35: t_Option = Any.any_l ()
    | & _36: t_Color = Any.any_l ()
    | & _39: t_Tree = Any.any_l ()
    | & _40: t_Option = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:insert_rec ensures #0] [%#sred_black_tree'4] internal_invariant'0 self.final}
      {[@expl:insert_rec ensures #1] [%#sred_black_tree'5] height self.current = height self.final}
      {[@expl:insert_rec ensures #2] [%#sred_black_tree'6] match_t (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final
        /\ color self.current = C_Red
      \/ color_invariant self.final}
      {[@expl:insert_rec ensures #3] [%#sred_black_tree'7] has_mapping self.final (deep_model key) val'}
      {[@expl:insert_rec ensures #4] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. k = deep_model key
        \/ has_mapping self.current k v = has_mapping self.final k v}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__delete_max_rec [#"red_black_tree.rs" 642 4 642 42] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 642 27 642 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 631 15 631 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 632 15 633 62
  let%span sred_black_tree'2 = "red_black_tree.rs" 642 36 642 42
  let%span sred_black_tree'3 = "red_black_tree.rs" 634 14 634 42
  let%span sred_black_tree'4 = "red_black_tree.rs" 635 14 635 50
  let%span sred_black_tree'5 = "red_black_tree.rs" 636 14 636 66
  let%span sred_black_tree'6 = "red_black_tree.rs" 637 14 637 102
  let%span sred_black_tree'7 = "red_black_tree.rs" 638 14 639 71
  let%span sred_black_tree'8 = "red_black_tree.rs" 640 14 640 39
  let%span sred_black_tree'9 = "red_black_tree.rs" 641 14 641 67
  let%span sred_black_tree'10 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'11 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'12 = "red_black_tree.rs" 426 25 426 29
  let%span sred_black_tree'13 = "red_black_tree.rs" 414 15 414 43
  let%span sred_black_tree'14 = "red_black_tree.rs" 415 15 415 42
  let%span sred_black_tree'15 = "red_black_tree.rs" 416 14 416 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 417 14 417 42
  let%span sred_black_tree'17 = "red_black_tree.rs" 418 14 418 50
  let%span sred_black_tree'18 = "red_black_tree.rs" 419 14 419 65
  let%span sred_black_tree'19 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'20 = "red_black_tree.rs" 421 14 421 44
  let%span sred_black_tree'21 = "red_black_tree.rs" 422 14 425 34
  let%span sred_black_tree'22 = "red_black_tree.rs" 585 27 585 31
  let%span sred_black_tree'23 = "red_black_tree.rs" 567 15 567 40
  let%span sred_black_tree'24 = "red_black_tree.rs" 568 15 568 43
  let%span sred_black_tree'25 = "red_black_tree.rs" 569 15 569 86
  let%span sred_black_tree'26 = "red_black_tree.rs" 585 36 585 45
  let%span sred_black_tree'27 = "red_black_tree.rs" 570 14 570 44
  let%span sred_black_tree'28 = "red_black_tree.rs" 571 14 573 46
  let%span sred_black_tree'29 = "red_black_tree.rs" 574 14 574 95
  let%span sred_black_tree'30 = "red_black_tree.rs" 575 14 575 42
  let%span sred_black_tree'31 = "red_black_tree.rs" 576 14 576 103
  let%span sred_black_tree'32 = "red_black_tree.rs" 577 14 578 45
  let%span sred_black_tree'33 = "red_black_tree.rs" 579 14 580 106
  let%span sred_black_tree'34 = "red_black_tree.rs" 581 14 582 61
  let%span sred_black_tree'35 = "red_black_tree.rs" 583 14 584 43
  let%span sred_black_tree'36 = "red_black_tree.rs" 524 20 524 24
  let%span sred_black_tree'37 = "red_black_tree.rs" 505 15 505 43
  let%span sred_black_tree'38 = "red_black_tree.rs" 506 15 507 45
  let%span sred_black_tree'39 = "red_black_tree.rs" 508 15 509 46
  let%span sred_black_tree'40 = "red_black_tree.rs" 510 15 510 108
  let%span sred_black_tree'41 = "red_black_tree.rs" 511 14 511 42
  let%span sred_black_tree'42 = "red_black_tree.rs" 512 14 512 42
  let%span sred_black_tree'43 = "red_black_tree.rs" 513 14 513 50
  let%span sred_black_tree'44 = "red_black_tree.rs" 514 14 515 32
  let%span sred_black_tree'45 = "red_black_tree.rs" 516 14 517 37
  let%span sred_black_tree'46 = "red_black_tree.rs" 518 14 519 61
  let%span sred_black_tree'47 = "red_black_tree.rs" 520 14 521 59
  let%span sred_black_tree'48 = "red_black_tree.rs" 522 14 523 37
  let%span sred_black_tree'49 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'50 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'52 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'53 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'54 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'55 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'56 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'57 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'58 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'59 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'60 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'61 = "red_black_tree.rs" 267 12 270 13
  let%span sred_black_tree'62 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'63 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'64 = "red_black_tree.rs" 308 8 308 112
  let%span sred_black_tree'65 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'66 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'67 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'68 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'69 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'70 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'71 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'72 = "red_black_tree.rs" 360 20 360 61
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 84 16 84 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 86 26 86 58
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 88 20 88 89
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 606 18 606 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 44 16 44 17
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 45 26 45 43
  let%span sboxed'1 = "../../creusot-contracts/src/std/boxed.rs" 46 26 46 43
  let%span sboxed'2 = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 159 14 159 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 164 14 164 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 169 14 169 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 125 4 125 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 126 4 126 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 4 131 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 4 136 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 137 4 137 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 138 4 138 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 143 14 144 104
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed'2] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'7 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_: MutBorrow.t t_Node) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'self_' type invariant] [%#sboxed] inv'6 self_}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'8 result}
      {[%#sboxed'0] self_.current = result.current}
      {[%#sboxed'1] self_.final = result.final}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'56] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'10] inv'9 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'11] result = (color self = C_Red)} (! return' {result}) ]
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'54] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'71] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'66] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'69] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'53] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'52] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'72] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'67] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'70] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'57] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'63] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'62] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'58] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'60] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'59] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple = { _p0: t_Tree; _p1: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'12] inv'8 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'13] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'14] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'15] same_mappings self.current self.final}
      {[%#sred_black_tree'16] internal_invariant self.final}
      {[%#sred_black_tree'17] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'18] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'19] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'20] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'21] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
        /\ { _p0 = (self.final).t_Node__left; _p1 = r.t_Node__left; _p2 = r.t_Node__right }
          = { _p0 = l.t_Node__left; _p1 = l.t_Node__right; _p2 = (self.current).t_Node__right }
        /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Node
  
  predicate invariant''4 [@inline:trivial] (self: t_Option) = [%#sinvariant'0] inv'2 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_0: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: t_Node) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'11 (_0: t_Node)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Node [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'11 a_0
        end
  
  let rec as_ref (self_: t_Option) (return' (x: t_Option'1)) =
    {[@expl:as_ref 'self_' type invariant] [%#soption'5] inv'10 self_}
    any
    [ return''0 (result: t_Option'1) -> {inv'12 result}
      {[%#soption'6] self_ = C_None -> result = C_None'1}
      {[%#soption'7] self_ = C_None \/ (exists r: t_Node. result = C_Some'1 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'1}
    any [ return''0 (result: t_Node) -> {inv'11 result} {[%#soption'4] C_Some'1 result = self_} (! return' {result}) ]
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'68] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'55] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 307 4 307 36] (self: t_Node) =
    [%#sred_black_tree'64] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'50] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 265 4 265 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'61] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'51] C_CPN c l r
  
  let rec move_red_right (self: MutBorrow.t t_Node) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree'22] inv'8 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree'23] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] [%#sred_black_tree'24] internal_invariant self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree'25] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {[%#sred_black_tree'26] inv'8 result}
      {[%#sred_black_tree'27] internal_invariant result.current}
      {[%#sred_black_tree'28] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[%#sred_black_tree'29] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'30] (result.current).t_Node__key = (self.current).t_Node__key}
      {[%#sred_black_tree'31] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'32] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log (deep_model (self.current).t_Node__key) k -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'33] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'34] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'35] color_invariant'0 result.final
        /\ (color (result.current).t_Node__left = C_Black -> (result.final).t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple'0 = { _p0'0: t_K; _p1'0: t_V }
  
  let rec balance (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:balance 'self' type invariant] [%#sred_black_tree'36] inv'8 self}
    {[@expl:balance requires #0] [%#sred_black_tree'37] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'38] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__left = C_Red -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'39] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'40] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red -> false}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'41] same_mappings self.current self.final}
      {[%#sred_black_tree'42] internal_invariant self.final}
      {[%#sred_black_tree'43] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'44] color_invariant (self.current).t_Node__left
        /\ color (self.current).t_Node__right = C_Black -> self.current = self.final}
      {[%#sred_black_tree'45] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'46] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'47] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'48] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'13 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'13 x]. inv'13 x = invariant''6 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Tree) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_Tree) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve'5 [@inline:trivial] (_0: ()) = true
  
  meta "rewrite_def" predicate resolve'5
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'5 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {inv'2 result} {[%#soption'8] result = C_None} (! return' {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return' (x: t_Option)) =
    {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result: t_Option) -> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve'6 _0
  
  meta "rewrite_def" predicate resolve'7
  
  let rec unwrap'1 (self_: t_Option) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None}
    any [ return''0 (result: t_Node) -> {inv'4 result} {[%#soption'4] C_Some result = self_} (! return' {result}) ]
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'65] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_0: t_Tree) = resolve'9 _0
  
  meta "rewrite_def" predicate resolve'10
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'49] bst_invariant self /\ height_invariant self
  
  predicate inv'14 (_0: tuple'0)
  
  axiom inv_axiom'12 [@rewrite]: forall x: tuple'0 [inv'14 x]. inv'14 x
      = (let {_p0'0 = x0; _p1'0 = x1} = x in inv x0 /\ inv'0 x1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max_rec [#"red_black_tree.rs" 642 4 642 42] (self: MutBorrow.t t_Tree) (return' (x: tuple'0)) =
    {[@expl:delete_max_rec 'self' type invariant] [%#sred_black_tree] inv'13 self}
    {[@expl:delete_max_rec requires #0] [%#sred_black_tree'0] internal_invariant'0 self.current}
    {[@expl:delete_max_rec requires #1] [%#sred_black_tree'1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = as_mut {_15} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret: MutBorrow.t t_Node) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv'4 _13.current}
        MutBorrow.borrow_final <t_Node> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = as_mut'0 {_12} (fun (_ret: MutBorrow.t t_Node) -> [ &node <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = is_red {(node.current).t_Node__left} (fun (_ret: bool) -> [ &_17 <- _ret ] s3)
      | s3 = bb4 ]
    | bb4 = any [ br0 -> {_17 = false} (! bb8) | br1 -> {_17} (! bb5) ]
    | bb5 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node> {node.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_19 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = rotate_right {_19} (fun (_ret: ()) -> [ &_16 <- _ret ] s2)
      | s2 = bb8 ]
    | bb8 = any
      [ br0 -> {((node.current).t_Node__right).t_Tree__node = C_None} (! bb9)
      | br1 (x0: t_Node) -> {((node.current).t_Node__right).t_Tree__node = C_Some x0} (! bb15) ]
    | bb15 = s0 [ s0 = is_red {(node.current).t_Node__right} (fun (_ret: bool) -> [ &_30 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb26) ]
    | bb18 = s0
      [ s0 = as_ref {((node.current).t_Node__right).t_Tree__node} (fun (_ret: t_Option'1) -> [ &_35 <- _ret ] s1)
      | s1 = bb19 ]
    | bb19 = s0 [ s0 = unwrap'0 {_35} (fun (_ret: t_Node) -> [ &_34 <- _ret ] s1) | s1 = bb20 ]
    | bb20 = s0 [ s0 = is_red {_34.t_Node__left} (fun (_ret: bool) -> [ &_32 <- _ret ] s1) | s1 = bb21 ]
    | bb21 = any [ br0 -> {_32 = false} (! bb23) | br1 -> {_32} (! bb26) ]
    | bb23 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_39 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_right {_39} (fun (_ret: MutBorrow.t t_Node) -> [ &_38 <- _ret ] s2)
      | s2 = bb24 ]
    | bb24 = s0
      [ s0 = {inv'3 _38.current}
        MutBorrow.borrow_final <t_Node> {_38.current} {MutBorrow.get_id _38}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_37 <- _ret ] -{inv'3 _ret.final}-
            [ &_38 <- { _38 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _37 ] s4
      | s4 = {[@expl:type invariant] inv'8 _38} s5
      | s5 = -{resolve'2 _38}- s6
      | s6 = bb26 ]
    | bb26 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_41 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_max_rec {_41} (fun (_ret: tuple'0) -> [ &r <- _ret ] s2)
      | s2 = bb27 ]
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_43 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_43} (fun (_ret: ()) -> [ &_42 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb31 ]
    | bb9 = s0 [ s0 = {[@expl:type invariant] inv'8 node} s1 | s1 = -{resolve'2 node}- s2 | s2 = bb10 ]
    | bb10 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {(self'0.current).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_26 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = {inv'2 _26.current}
        MutBorrow.borrow_final <t_Option> {_26.current} {MutBorrow.get_id _26}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_25 <- _ret ] -{inv'2 _ret.final}-
            [ &_26 <- { _26 with current = _ret.final } ] s2)
      | s2 = take {_25} (fun (_ret: t_Option) -> [ &_24 <- _ret ] s3)
      | s3 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'5 _26} s1
      | s1 = -{resolve'7 _26}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 = unwrap'1 {_24} (fun (_ret: t_Node) -> [ &node'0 <- _ret ] s5)
      | s5 = bb12 ]
    | bb12 = s0
      [ s0 = {[@expl:type invariant] inv'1 node'0.t_Node__right} s1
      | s1 = -{resolve'10 node'0.t_Node__right}- s2
      | s2 = {[@expl:type invariant] inv'1 node'0.t_Node__left} s3
      | s3 = -{resolve'10 node'0.t_Node__left}- s4
      | s4 = [ &_0 <- { _p0'0 = node'0.t_Node__key; _p1'0 = node'0.t_Node__val } ] s5
      | s5 = bb31 ]
    | bb31 = return''0 {_0} ]
    [ & _0: tuple'0 = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _12: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _24: t_Option = Any.any_l ()
    | & _25: MutBorrow.t t_Option = Any.any_l ()
    | & _26: MutBorrow.t t_Option = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _34: t_Node = Any.any_l ()
    | & _35: t_Option'1 = Any.any_l ()
    | & _37: MutBorrow.t t_Node = Any.any_l ()
    | & _38: MutBorrow.t t_Node = Any.any_l ()
    | & _39: MutBorrow.t t_Node = Any.any_l ()
    | & r: tuple'0 = Any.any_l ()
    | & _41: MutBorrow.t t_Tree = Any.any_l ()
    | & _42: () = Any.any_l ()
    | & _43: MutBorrow.t t_Node = Any.any_l () ])
    [ return''0 (result: tuple'0) -> {[@expl:delete_max_rec result type invariant] [%#sred_black_tree'2] inv'14 result}
      {[@expl:delete_max_rec ensures #0] [%#sred_black_tree'3] internal_invariant'0 self.final}
      {[@expl:delete_max_rec ensures #1] [%#sred_black_tree'4] height self.current = height self.final}
      {[@expl:delete_max_rec ensures #2] [%#sred_black_tree'5] has_mapping self.current (deep_model result._p0'0) result._p1'0}
      {[@expl:delete_max_rec ensures #3] [%#sred_black_tree'6] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
        -> le_log k (deep_model result._p0'0)}
      {[@expl:delete_max_rec ensures #4] [%#sred_black_tree'7] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result._p0'0 <> k /\ has_mapping self.current k v)}
      {[@expl:delete_max_rec ensures #5] [%#sred_black_tree'8] color_invariant self.final}
      {[@expl:delete_max_rec ensures #6] [%#sred_black_tree'9] color self.current = C_Black
      -> color self.final = C_Black}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__delete_min_rec [#"red_black_tree.rs" 670 4 670 42] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 670 27 670 31
  let%span sred_black_tree'0 = "red_black_tree.rs" 659 15 659 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 660 15 661 62
  let%span sred_black_tree'2 = "red_black_tree.rs" 670 36 670 42
  let%span sred_black_tree'3 = "red_black_tree.rs" 662 14 662 42
  let%span sred_black_tree'4 = "red_black_tree.rs" 663 14 663 50
  let%span sred_black_tree'5 = "red_black_tree.rs" 664 14 664 66
  let%span sred_black_tree'6 = "red_black_tree.rs" 665 14 665 102
  let%span sred_black_tree'7 = "red_black_tree.rs" 666 14 667 71
  let%span sred_black_tree'8 = "red_black_tree.rs" 668 14 668 39
  let%span sred_black_tree'9 = "red_black_tree.rs" 669 14 669 67
  let%span sred_black_tree'10 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'11 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'12 = "red_black_tree.rs" 556 26 556 30
  let%span sred_black_tree'13 = "red_black_tree.rs" 538 15 538 41
  let%span sred_black_tree'14 = "red_black_tree.rs" 539 15 539 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 540 15 540 86
  let%span sred_black_tree'16 = "red_black_tree.rs" 556 35 556 44
  let%span sred_black_tree'17 = "red_black_tree.rs" 541 14 541 44
  let%span sred_black_tree'18 = "red_black_tree.rs" 542 14 544 46
  let%span sred_black_tree'19 = "red_black_tree.rs" 545 14 545 95
  let%span sred_black_tree'20 = "red_black_tree.rs" 546 14 546 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 547 14 547 103
  let%span sred_black_tree'22 = "red_black_tree.rs" 548 14 549 45
  let%span sred_black_tree'23 = "red_black_tree.rs" 550 14 551 106
  let%span sred_black_tree'24 = "red_black_tree.rs" 552 14 553 61
  let%span sred_black_tree'25 = "red_black_tree.rs" 554 14 555 43
  let%span sred_black_tree'26 = "red_black_tree.rs" 524 20 524 24
  let%span sred_black_tree'27 = "red_black_tree.rs" 505 15 505 43
  let%span sred_black_tree'28 = "red_black_tree.rs" 506 15 507 45
  let%span sred_black_tree'29 = "red_black_tree.rs" 508 15 509 46
  let%span sred_black_tree'30 = "red_black_tree.rs" 510 15 510 108
  let%span sred_black_tree'31 = "red_black_tree.rs" 511 14 511 42
  let%span sred_black_tree'32 = "red_black_tree.rs" 512 14 512 42
  let%span sred_black_tree'33 = "red_black_tree.rs" 513 14 513 50
  let%span sred_black_tree'34 = "red_black_tree.rs" 514 14 515 32
  let%span sred_black_tree'35 = "red_black_tree.rs" 516 14 517 37
  let%span sred_black_tree'36 = "red_black_tree.rs" 518 14 519 61
  let%span sred_black_tree'37 = "red_black_tree.rs" 520 14 521 59
  let%span sred_black_tree'38 = "red_black_tree.rs" 522 14 523 37
  let%span sred_black_tree'39 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'40 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'41 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'42 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'43 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'44 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'45 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'46 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'47 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'48 = "red_black_tree.rs" 267 12 270 13
  let%span sred_black_tree'49 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'50 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'51 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'52 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'53 = "red_black_tree.rs" 308 8 308 112
  let%span sred_black_tree'54 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'55 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'56 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'57 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'58 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'59 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'60 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'61 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'62 = "red_black_tree.rs" 360 20 360 61
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 84 16 84 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 86 26 86 58
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 88 20 88 89
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 606 18 606 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 44 16 44 17
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 45 26 45 43
  let%span sboxed'1 = "../../creusot-contracts/src/std/boxed.rs" 46 26 46 43
  let%span sboxed'2 = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 159 14 159 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 164 14 164 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 169 14 169 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 125 4 125 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 126 4 126 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 4 131 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 4 136 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 137 4 137 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 138 4 138 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 143 14 144 104
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed'2] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'7 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_: MutBorrow.t t_Node) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'self_' type invariant] [%#sboxed] inv'6 self_}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'8 result}
      {[%#sboxed'0] self_.current = result.current}
      {[%#sboxed'1] self_.final = result.final}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_0: t_Tree)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Tree [inv'9 x]. inv'9 x = invariant''3 x
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'46] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'10] inv'9 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'11] result = (color self = C_Red)} (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_Node
  
  predicate invariant''4 [@inline:trivial] (self: t_Option) = [%#sinvariant'0] inv'2 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_0: t_Option)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate invariant''5 [@inline:trivial] (self: t_Node) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'11 (_0: t_Node)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Node [inv'11 x]. inv'11 x = invariant''5 x
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'11 a_0
        end
  
  let rec as_ref (self_: t_Option) (return' (x: t_Option'1)) =
    {[@expl:as_ref 'self_' type invariant] [%#soption'5] inv'10 self_}
    any
    [ return''0 (result: t_Option'1) -> {inv'12 result}
      {[%#soption'6] self_ = C_None -> result = C_None'1}
      {[%#soption'7] self_ = C_None \/ (exists r: t_Node. result = C_Some'1 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  let rec unwrap'0 (self_: t_Option'1) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'1}
    any [ return''0 (result: t_Node) -> {inv'11 result} {[%#soption'4] C_Some'1 result = self_} (! return' {result}) ]
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'44] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'61] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'56] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'59] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'43] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'42] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'62] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'57] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'60] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'47] bst_invariant'0 self /\ height_invariant'0 self
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'58] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'45] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 307 4 307 36] (self: t_Node) =
    [%#sred_black_tree'53] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'40] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 265 4 265 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'48] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'41] C_CPN c l r
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'50] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'49] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'52] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'51] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  let rec move_red_left (self: MutBorrow.t t_Node) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree'12] inv'8 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree'13] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree'15] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {[%#sred_black_tree'16] inv'8 result}
      {[%#sred_black_tree'17] internal_invariant result.current}
      {[%#sred_black_tree'18] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[%#sred_black_tree'19] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'20] (self.current).t_Node__key = (result.current).t_Node__key}
      {[%#sred_black_tree'21] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'22] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log k (deep_model (self.current).t_Node__key) -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'23] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'24] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'25] color_invariant'0 result.final
        /\ (color (result.current).t_Node__right = C_Black -> (result.final).t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { _p0: t_K; _p1: t_V }
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'54] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  let rec balance (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:balance 'self' type invariant] [%#sred_black_tree'26] inv'8 self}
    {[@expl:balance requires #0] [%#sred_black_tree'27] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'28] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__left = C_Red -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'29] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'30] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red -> false}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'31] same_mappings self.current self.final}
      {[%#sred_black_tree'32] internal_invariant self.final}
      {[%#sred_black_tree'33] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'34] color_invariant (self.current).t_Node__left
        /\ color (self.current).t_Node__right = C_Black -> self.current = self.final}
      {[%#sred_black_tree'35] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'36] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'37] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'38] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'13 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'11 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'13 x]. inv'13 x = invariant''6 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Tree) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_Tree) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate postcondition_once [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once
  
  predicate resolve'5 [@inline:trivial] (_0: ()) = true
  
  meta "rewrite_def" predicate resolve'5
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'5 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once self args res
      = (postcondition self args res /\ resolve'5 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {inv'2 result} {[%#soption'8] result = C_None} (! return' {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return' (x: t_Option)) =
    {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result: t_Option) -> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve'6 _0
  
  meta "rewrite_def" predicate resolve'7
  
  let rec unwrap'1 (self_: t_Option) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None}
    any [ return''0 (result: t_Node) -> {inv'4 result} {[%#soption'4] C_Some result = self_} (! return' {result}) ]
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'55] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_0: t_Tree) = resolve'9 _0
  
  meta "rewrite_def" predicate resolve'10
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'39] bst_invariant self /\ height_invariant self
  
  predicate inv'14 (_0: tuple)
  
  axiom inv_axiom'12 [@rewrite]: forall x: tuple [inv'14 x]. inv'14 x
      = (let {_p0 = x0; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min_rec [#"red_black_tree.rs" 670 4 670 42] (self: MutBorrow.t t_Tree) (return' (x: tuple)) =
    {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree] inv'13 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree'0] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree'1] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_15 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = as_mut {_15} (fun (_ret: t_Option'0) -> [ &_14 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_14} (fun (_ret: MutBorrow.t t_Node) -> [ &_13 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv'4 _13.current}
        MutBorrow.borrow_final <t_Node> {_13.current} {MutBorrow.get_id _13}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &_13 <- { _13 with current = _ret.final } ] s1)
      | s1 = as_mut'0 {_12} (fun (_ret: MutBorrow.t t_Node) -> [ &node <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _13} s1
      | s1 = -{resolve'0 _13}- s2
      | s2 = any
        [ br0 -> {((node.current).t_Node__left).t_Tree__node = C_None} (! bb4)
        | br1 (x0: t_Node) -> {((node.current).t_Node__left).t_Tree__node = C_Some x0} (! bb10) ] ]
    | bb10 = s0 [ s0 = is_red {(node.current).t_Node__left} (fun (_ret: bool) -> [ &_26 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = any [ br0 -> {_26 = false} (! bb13) | br1 -> {_26} (! bb21) ]
    | bb13 = s0
      [ s0 = as_ref {((node.current).t_Node__left).t_Tree__node} (fun (_ret: t_Option'1) -> [ &_31 <- _ret ] s1)
      | s1 = bb14 ]
    | bb14 = s0 [ s0 = unwrap'0 {_31} (fun (_ret: t_Node) -> [ &_30 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = is_red {_30.t_Node__left} (fun (_ret: bool) -> [ &_28 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any [ br0 -> {_28 = false} (! bb18) | br1 -> {_28} (! bb21) ]
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_35 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_left {_35} (fun (_ret: MutBorrow.t t_Node) -> [ &_34 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = {inv'3 _34.current}
        MutBorrow.borrow_final <t_Node> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_33 <- _ret ] -{inv'3 _ret.final}-
            [ &_34 <- { _34 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _33 ] s4
      | s4 = {[@expl:type invariant] inv'8 _34} s5
      | s5 = -{resolve'2 _34}- s6
      | s6 = bb21 ]
    | bb21 = s0
      [ s0 = {inv'1 (node.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_37 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
      | s1 = delete_min_rec {_37} (fun (_ret: tuple) -> [ &r <- _ret ] s2)
      | s2 = bb22 ]
    | bb22 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_39 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_39} (fun (_ret: ()) -> [ &_38 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb26 ]
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'8 node} s1 | s1 = -{resolve'2 node}- s2 | s2 = bb5 ]
    | bb5 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {(self'0.current).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_22 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = {inv'2 _22.current}
        MutBorrow.borrow_final <t_Option> {_22.current} {MutBorrow.get_id _22}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_21 <- _ret ] -{inv'2 _ret.final}-
            [ &_22 <- { _22 with current = _ret.final } ] s2)
      | s2 = take {_21} (fun (_ret: t_Option) -> [ &_20 <- _ret ] s3)
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv'5 _22} s1
      | s1 = -{resolve'7 _22}- s2
      | s2 = {[@expl:type invariant] inv'13 self'0} s3
      | s3 = -{resolve'4 self'0}- s4
      | s4 = unwrap'1 {_20} (fun (_ret: t_Node) -> [ &node'0 <- _ret ] s5)
      | s5 = bb7 ]
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'1 node'0.t_Node__right} s1
      | s1 = -{resolve'10 node'0.t_Node__right}- s2
      | s2 = {[@expl:type invariant] inv'1 node'0.t_Node__left} s3
      | s3 = -{resolve'10 node'0.t_Node__left}- s4
      | s4 = [ &_0 <- { _p0 = node'0.t_Node__key; _p1 = node'0.t_Node__val } ] s5
      | s5 = bb26 ]
    | bb26 = return''0 {_0} ]
    [ & _0: tuple = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _12: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: t_Option'0 = Any.any_l ()
    | & _15: MutBorrow.t t_Option = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _20: t_Option = Any.any_l ()
    | & _21: MutBorrow.t t_Option = Any.any_l ()
    | & _22: MutBorrow.t t_Option = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: t_Node = Any.any_l ()
    | & _31: t_Option'1 = Any.any_l ()
    | & _33: MutBorrow.t t_Node = Any.any_l ()
    | & _34: MutBorrow.t t_Node = Any.any_l ()
    | & _35: MutBorrow.t t_Node = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _37: MutBorrow.t t_Tree = Any.any_l ()
    | & _38: () = Any.any_l ()
    | & _39: MutBorrow.t t_Node = Any.any_l () ])
    [ return''0 (result: tuple) -> {[@expl:delete_min_rec result type invariant] [%#sred_black_tree'2] inv'14 result}
      {[@expl:delete_min_rec ensures #0] [%#sred_black_tree'3] internal_invariant'0 self.final}
      {[@expl:delete_min_rec ensures #1] [%#sred_black_tree'4] height self.current = height self.final}
      {[@expl:delete_min_rec ensures #2] [%#sred_black_tree'5] has_mapping self.current (deep_model result._p0) result._p1}
      {[@expl:delete_min_rec ensures #3] [%#sred_black_tree'6] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
        -> le_log (deep_model result._p0) k}
      {[@expl:delete_min_rec ensures #4] [%#sred_black_tree'7] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result._p0 <> k /\ has_mapping self.current k v)}
      {[@expl:delete_min_rec ensures #5] [%#sred_black_tree'8] color_invariant self.final}
      {[@expl:delete_min_rec ensures #6] [%#sred_black_tree'9] color self.current = C_Black
      -> color self.final = C_Black}
      (! return' {result}) ]
end
module M_red_black_tree__qyi3529752165842986389__delete_rec [#"red_black_tree.rs" 696 4 696 55] (* Tree<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 726 24 726 59
  let%span sred_black_tree'0 = "red_black_tree.rs" 696 23 696 27
  let%span sred_black_tree'1 = "red_black_tree.rs" 696 29 696 32
  let%span sred_black_tree'2 = "red_black_tree.rs" 684 15 684 43
  let%span sred_black_tree'3 = "red_black_tree.rs" 685 15 686 62
  let%span sred_black_tree'4 = "red_black_tree.rs" 696 41 696 55
  let%span sred_black_tree'5 = "red_black_tree.rs" 687 14 687 42
  let%span sred_black_tree'6 = "red_black_tree.rs" 688 14 688 50
  let%span sred_black_tree'7 = "red_black_tree.rs" 689 14 692 5
  let%span sred_black_tree'8 = "red_black_tree.rs" 693 14 693 127
  let%span sred_black_tree'9 = "red_black_tree.rs" 694 14 694 39
  let%span sred_black_tree'10 = "red_black_tree.rs" 695 14 695 67
  let%span sred_black_tree'11 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'12 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'13 = "red_black_tree.rs" 426 25 426 29
  let%span sred_black_tree'14 = "red_black_tree.rs" 414 15 414 43
  let%span sred_black_tree'15 = "red_black_tree.rs" 415 15 415 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 416 14 416 42
  let%span sred_black_tree'17 = "red_black_tree.rs" 417 14 417 42
  let%span sred_black_tree'18 = "red_black_tree.rs" 418 14 418 50
  let%span sred_black_tree'19 = "red_black_tree.rs" 419 14 419 65
  let%span sred_black_tree'20 = "red_black_tree.rs" 420 14 420 42
  let%span sred_black_tree'21 = "red_black_tree.rs" 421 14 421 44
  let%span sred_black_tree'22 = "red_black_tree.rs" 422 14 425 34
  let%span sred_black_tree'23 = "red_black_tree.rs" 585 27 585 31
  let%span sred_black_tree'24 = "red_black_tree.rs" 567 15 567 40
  let%span sred_black_tree'25 = "red_black_tree.rs" 568 15 568 43
  let%span sred_black_tree'26 = "red_black_tree.rs" 569 15 569 86
  let%span sred_black_tree'27 = "red_black_tree.rs" 585 36 585 45
  let%span sred_black_tree'28 = "red_black_tree.rs" 570 14 570 44
  let%span sred_black_tree'29 = "red_black_tree.rs" 571 14 573 46
  let%span sred_black_tree'30 = "red_black_tree.rs" 574 14 574 95
  let%span sred_black_tree'31 = "red_black_tree.rs" 575 14 575 42
  let%span sred_black_tree'32 = "red_black_tree.rs" 576 14 576 103
  let%span sred_black_tree'33 = "red_black_tree.rs" 577 14 578 45
  let%span sred_black_tree'34 = "red_black_tree.rs" 579 14 580 106
  let%span sred_black_tree'35 = "red_black_tree.rs" 581 14 582 61
  let%span sred_black_tree'36 = "red_black_tree.rs" 583 14 584 43
  let%span sred_black_tree'37 = "red_black_tree.rs" 670 27 670 31
  let%span sred_black_tree'38 = "red_black_tree.rs" 659 15 659 43
  let%span sred_black_tree'39 = "red_black_tree.rs" 660 15 661 62
  let%span sred_black_tree'40 = "red_black_tree.rs" 670 36 670 42
  let%span sred_black_tree'41 = "red_black_tree.rs" 662 14 662 42
  let%span sred_black_tree'42 = "red_black_tree.rs" 663 14 663 50
  let%span sred_black_tree'43 = "red_black_tree.rs" 664 14 664 66
  let%span sred_black_tree'44 = "red_black_tree.rs" 665 14 665 102
  let%span sred_black_tree'45 = "red_black_tree.rs" 666 14 667 71
  let%span sred_black_tree'46 = "red_black_tree.rs" 668 14 668 39
  let%span sred_black_tree'47 = "red_black_tree.rs" 669 14 669 67
  let%span sred_black_tree'48 = "red_black_tree.rs" 116 4 116 37
  let%span sred_black_tree'49 = "red_black_tree.rs" 117 4 117 40
  let%span sred_black_tree'50 = "red_black_tree.rs" 118 4 118 40
  let%span sred_black_tree'51 = "red_black_tree.rs" 119 14 119 22
  let%span sred_black_tree'52 = "red_black_tree.rs" 124 8 127 11
  let%span sred_black_tree'53 = "red_black_tree.rs" 556 26 556 30
  let%span sred_black_tree'54 = "red_black_tree.rs" 538 15 538 41
  let%span sred_black_tree'55 = "red_black_tree.rs" 539 15 539 43
  let%span sred_black_tree'56 = "red_black_tree.rs" 540 15 540 86
  let%span sred_black_tree'57 = "red_black_tree.rs" 556 35 556 44
  let%span sred_black_tree'58 = "red_black_tree.rs" 541 14 541 44
  let%span sred_black_tree'59 = "red_black_tree.rs" 542 14 544 46
  let%span sred_black_tree'60 = "red_black_tree.rs" 545 14 545 95
  let%span sred_black_tree'61 = "red_black_tree.rs" 546 14 546 42
  let%span sred_black_tree'62 = "red_black_tree.rs" 547 14 547 103
  let%span sred_black_tree'63 = "red_black_tree.rs" 548 14 549 45
  let%span sred_black_tree'64 = "red_black_tree.rs" 550 14 551 106
  let%span sred_black_tree'65 = "red_black_tree.rs" 552 14 553 61
  let%span sred_black_tree'66 = "red_black_tree.rs" 554 14 555 43
  let%span sred_black_tree'67 = "red_black_tree.rs" 524 20 524 24
  let%span sred_black_tree'68 = "red_black_tree.rs" 505 15 505 43
  let%span sred_black_tree'69 = "red_black_tree.rs" 506 15 507 45
  let%span sred_black_tree'70 = "red_black_tree.rs" 508 15 509 46
  let%span sred_black_tree'71 = "red_black_tree.rs" 510 15 510 108
  let%span sred_black_tree'72 = "red_black_tree.rs" 511 14 511 42
  let%span sred_black_tree'73 = "red_black_tree.rs" 512 14 512 42
  let%span sred_black_tree'74 = "red_black_tree.rs" 513 14 513 50
  let%span sred_black_tree'75 = "red_black_tree.rs" 514 14 515 32
  let%span sred_black_tree'76 = "red_black_tree.rs" 516 14 517 37
  let%span sred_black_tree'77 = "red_black_tree.rs" 518 14 519 61
  let%span sred_black_tree'78 = "red_black_tree.rs" 520 14 521 59
  let%span sred_black_tree'79 = "red_black_tree.rs" 522 14 523 37
  let%span sred_black_tree'80 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'81 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'82 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'83 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'84 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'85 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'86 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'87 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'88 = "red_black_tree.rs" 1 0 979 4
  let%span sred_black_tree'89 = "red_black_tree.rs" 392 8 394 9
  let%span sred_black_tree'90 = "red_black_tree.rs" 145 12 145 89
  let%span sred_black_tree'91 = "red_black_tree.rs" 347 14 348 75
  let%span sred_black_tree'92 = "red_black_tree.rs" 351 12 354 13
  let%span sred_black_tree'93 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'94 = "red_black_tree.rs" 267 12 270 13
  let%span sred_black_tree'95 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'96 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'97 = "red_black_tree.rs" 308 8 308 112
  let%span sred_black_tree'98 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'99 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'100 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'101 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'102 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'103 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'104 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'105 = "red_black_tree.rs" 214 8 216 9
  let%span sred_black_tree'106 = "red_black_tree.rs" 365 8 365 115
  let%span sred_black_tree'107 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'108 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'109 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'110 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'111 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'112 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'113 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'114 = "red_black_tree.rs" 360 20 360 61
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span soption'5 = "../../creusot-contracts/src/std/option.rs" 77 16 77 17
  let%span soption'6 = "../../creusot-contracts/src/std/option.rs" 79 26 79 51
  let%span soption'7 = "../../creusot-contracts/src/std/option.rs" 84 16 84 17
  let%span soption'8 = "../../creusot-contracts/src/std/option.rs" 86 26 86 58
  let%span soption'9 = "../../creusot-contracts/src/std/option.rs" 88 20 88 89
  let%span soption'10 = "../../creusot-contracts/src/std/option.rs" 606 18 606 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 44 16 44 17
  let%span sboxed'0 = "../../creusot-contracts/src/std/boxed.rs" 45 26 45 43
  let%span sboxed'1 = "../../creusot-contracts/src/std/boxed.rs" 46 26 46 43
  let%span sboxed'2 = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 23 32 23 36
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 21 22 21 37
  let%span smem'1 = "../../creusot-contracts/src/std/mem.rs" 22 22 22 57
  let%span smem'2 = "../../creusot-contracts/src/std/mem.rs" 19 23 19 24
  let%span smem'3 = "../../creusot-contracts/src/std/mem.rs" 19 34 19 35
  let%span smem'4 = "../../creusot-contracts/src/std/mem.rs" 17 22 17 30
  let%span smem'5 = "../../creusot-contracts/src/std/mem.rs" 18 22 18 30
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 159 14 159 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 164 14 164 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 169 14 169 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 125 4 125 61
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 126 4 126 40
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 131 4 131 35
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 136 4 136 33
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 137 4 137 30
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 138 4 138 32
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 143 14 144 104
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed'2] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Node [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate inv'7 (_0: t_Option'0)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Option'0 [inv'7 x]. inv'7 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'6 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'7 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'7 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'6 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'8 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Node [inv'8 x]. inv'8 x = invariant''2 x
  
  let rec as_mut'0 (self_: MutBorrow.t t_Node) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:as_mut 'self_' type invariant] [%#sboxed] inv'6 self_}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'8 result}
      {[%#sboxed'0] self_.current = result.current}
      {[%#sboxed'1] self_.final = result.final}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  type tuple = { _p0: t_K; _p1: t_K }
  
  predicate invariant''3 [@inline:trivial] (self: t_K) = [%#sinvariant'0] inv self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'9 (_0: t_K)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_K [inv'9 x]. inv'9 x = invariant''3 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    [%#sred_black_tree'88] forall args: tuple [precondition () args]. (let {_p0 = self_; _p1 = rhs} = args in inv'9 rhs
        /\ inv'9 self_) -> precondition () args
  
  type t_DeepModelTy
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    [%#sred_black_tree'88] forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {_p0 = self_; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return' (x: t_Ordering)) = {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                          _p1 = rhs }}
    any
    [ return''0 (result: t_Ordering) -> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'1 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_0: t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Tree [inv'10 x]. inv'10 x = invariant''4 x
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'87] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'11] inv'10 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'12] result = (color self = C_Red)} (! return' {result}) ]
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'85] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'107] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'98] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  predicate bst_invariant'0 [#"red_black_tree.rs" 213 4 213 34] (self: t_Node) =
    [%#sred_black_tree'105] bst_invariant_here self
    /\ bst_invariant self.t_Node__left /\ bst_invariant self.t_Node__right
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'84] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'83] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'114] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'103] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate height_invariant'0 [#"red_black_tree.rs" 364 4 364 37] (self: t_Node) =
    [%#sred_black_tree'106] height_invariant_here self
    /\ height_invariant self.t_Node__left /\ height_invariant self.t_Node__right
  
  predicate internal_invariant [#"red_black_tree.rs" 391 4 391 39] (self: t_Node) =
    [%#sred_black_tree'89] bst_invariant'0 self /\ height_invariant'0 self
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'96] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec:
    forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'95] forall node: t_Node. self = node
        -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate same_mappings [#"red_black_tree.rs" 143 4 143 43] (self: t_Node) (o: t_Node) =
    [%#sred_black_tree'90] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v = has_mapping'0 o k v
  
  function height'0 [#"red_black_tree.rs" 349 4 349 26] (self: t_Node) : int =
    [%#sred_black_tree'92] match self.t_Node__color with
      | C_Red -> height self.t_Node__left
      | C_Black -> height self.t_Node__left + 1
      end
  
  axiom height_spec'0: forall self: t_Node. [%#sred_black_tree'91] forall node: t_Node. self = node
        -> height'0 self = height { t_Tree__node = C_Some node }
  
  type tuple'0 = { _p0'0: t_Tree; _p1'0: t_Tree; _p2: t_Tree }
  
  let rec rotate_right (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:rotate_right 'self' type invariant] [%#sred_black_tree'13] inv'8 self}
    {[@expl:rotate_right requires #0] [%#sred_black_tree'14] internal_invariant self.current}
    {[@expl:rotate_right requires #1] [%#sred_black_tree'15] color (self.current).t_Node__left = C_Red}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'16] same_mappings self.current self.final}
      {[%#sred_black_tree'17] internal_invariant self.final}
      {[%#sred_black_tree'18] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'19] lt_log (deep_model (self.final).t_Node__key) (deep_model (self.current).t_Node__key)}
      {[%#sred_black_tree'20] color (self.final).t_Node__right = C_Red}
      {[%#sred_black_tree'21] (self.final).t_Node__color = (self.current).t_Node__color}
      {[%#sred_black_tree'22] exists l: t_Node, r: t_Node. ((self.current).t_Node__left).t_Tree__node = C_Some l
        /\ ((self.final).t_Node__right).t_Tree__node = C_Some r
        /\ { _p0'0 = (self.final).t_Node__left; _p1'0 = r.t_Node__left; _p2 = r.t_Node__right }
          = { _p0'0 = l.t_Node__left; _p1'0 = l.t_Node__right; _p2 = (self.current).t_Node__right }
        /\ r.t_Node__key = (self.current).t_Node__key}
      (! return' {result}) ]
  
  type tuple'1 = { _p0'1: t_K; _p1'1: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple'1
  
  predicate invariant''5 [@inline:trivial] (self: t_Option) = [%#sinvariant'0] inv'2 self
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'11 (_0: t_Option)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_Option [inv'11 x]. inv'11 x = invariant''5 x
  
  let rec is_none (self_: t_Option) (return' (x: bool)) =
    {[@expl:is_none 'self_' type invariant] [%#soption'5] inv'11 self_}
    any [ return''0 (result: bool) -> {[%#soption'6] result = (self_ = C_None)} (! return' {result}) ]
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate postcondition_once'0 [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_once'0
  
  predicate resolve'3 [@inline:trivial] (_0: ()) = true
  
  meta "rewrite_def" predicate resolve'3
  
  predicate postcondition_mut [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition_mut
  
  function fn_mut_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: (), res: t_Option. [%#sops'8] postcondition_once'0 self args res
      = (exists res_state: (). postcondition_mut self args res_state res /\ resolve'3 res_state)
  
  predicate hist_inv [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
      -> ([%#sops'6] hist_inv b c) -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom postcondition_mut_hist_inv_spec:
    forall self: (), args: (), res_state: (), res: t_Option. ([%#sops'2] postcondition_mut self args res_state res)
      -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition [@inline:trivial] (self: ()) (args: ()) (result: t_Option) =
    let () = args in result = C_None /\ inv'2 result
  
  meta "rewrite_def" predicate postcondition
  
  function fn_once (self: ()) (args: ()) (res: t_Option) : ()
  
  axiom fn_once_spec: forall self: (), args: (), res: t_Option. [%#sops'0] postcondition_once'0 self args res
      = (postcondition self args res /\ resolve'3 self)
  
  function fn_mut (self: ()) (args: ()) (res_state: ()) (res: t_Option) : ()
  
  axiom fn_mut_spec:
    forall self: (), args: (), res_state: (), res: t_Option. [%#sops] postcondition_mut self args res_state res
      = (postcondition self args res /\ self = res_state)
  
  let rec default (return' (x: t_Option)) = any
    [ return''0 (result: t_Option) -> {inv'2 result} {[%#soption'10] result = C_None} (! return' {result}) ]
  
  let rec take (dest: MutBorrow.t t_Option) (return' (x: t_Option)) =
    {[@expl:take 'dest' type invariant] [%#smem] inv'5 dest}
    any
    [ return''0 (result: t_Option) -> {inv'2 result}
      {[%#smem'0] result = dest.current}
      {[%#smem'1] postcondition () () dest.final}
      (! return' {result}) ]
  
  predicate resolve'4 [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve'4 _0
  
  meta "rewrite_def" predicate resolve'5
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'12 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'10 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'12 x]. inv'12 x = invariant''6 x
  
  predicate resolve'6 [@inline:trivial] (self: MutBorrow.t t_Tree) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'6
  
  predicate resolve'7 [@inline:trivial] (_0: MutBorrow.t t_Tree) = resolve'6 _0
  
  meta "rewrite_def" predicate resolve'7
  
  let rec unwrap'0 (self_: t_Option) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'2 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None}
    any [ return''0 (result: t_Node) -> {inv'4 result} {[%#soption'4] C_Some result = self_} (! return' {result}) ]
  
  predicate resolve'8 (_0: t_V)
  
  predicate resolve'9 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'93] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve'8 v
  
  predicate resolve'10 [@inline:trivial] (_0: t_Tree) = resolve'9 _0
  
  meta "rewrite_def" predicate resolve'10
  
  type t_Option'2 = C_None'2 | C_Some'2 t_Node
  
  predicate invariant''7 [@inline:trivial] (self: t_Node) = [%#sinvariant'0] inv'4 self
  
  meta "rewrite_def" predicate invariant''7
  
  predicate inv'13 (_0: t_Node)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Node [inv'13 x]. inv'13 x = invariant''7 x
  
  predicate inv'14 (_0: t_Option'2)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'2 [inv'14 x]. inv'14 x
      = match x with
        | C_None'2 -> true
        | C_Some'2 a_0 -> inv'13 a_0
        end
  
  let rec as_ref (self_: t_Option) (return' (x: t_Option'2)) =
    {[@expl:as_ref 'self_' type invariant] [%#soption'7] inv'11 self_}
    any
    [ return''0 (result: t_Option'2) -> {inv'14 result}
      {[%#soption'8] self_ = C_None -> result = C_None'2}
      {[%#soption'9] self_ = C_None \/ (exists r: t_Node. result = C_Some'2 r /\ self_ = C_Some r)}
      (! return' {result}) ]
  
  let rec unwrap'1 (self_: t_Option'2) (return' (x: t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'14 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'2}
    any [ return''0 (result: t_Node) -> {inv'13 result} {[%#soption'4] C_Some'2 result = self_} (! return' {result}) ]
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'104] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'86] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate color_invariant'0 [#"red_black_tree.rs" 307 4 307 36] (self: t_Node) =
    [%#sred_black_tree'97] color_invariant_here self
    /\ color_invariant self.t_Node__left /\ color_invariant self.t_Node__right
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'81] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  predicate match_n [#"red_black_tree.rs" 265 4 265 52] (self: t_CP) (node: t_Node) =
    [%#sred_black_tree'94] match self with
      | C_CPL color'0 -> node.t_Node__color = color'0 /\ color_invariant'0 node
      | C_CPN color'0 l r -> node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'82] C_CPN c l r
  
  let rec move_red_right (self: MutBorrow.t t_Node) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_right 'self' type invariant] [%#sred_black_tree'23] inv'8 self}
    {[@expl:move_red_right requires #0] [%#sred_black_tree'24] ((self.current).t_Node__left).t_Tree__node <> C_None}
    {[@expl:move_red_right requires #1] [%#sred_black_tree'25] internal_invariant self.current}
    {[@expl:move_red_right requires #2] [%#sred_black_tree'26] match_n (cpn (C_Red) (C_CPL (C_Black)) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black)))) self.current}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {[%#sred_black_tree'27] inv'8 result}
      {[%#sred_black_tree'28] internal_invariant result.current}
      {[%#sred_black_tree'29] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[%#sred_black_tree'30] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'31] (result.current).t_Node__key = (self.current).t_Node__key}
      {[%#sred_black_tree'32] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'33] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log (deep_model (self.current).t_Node__key) k -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'34] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'35] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'36] color_invariant'0 result.final
        /\ (color (result.current).t_Node__left = C_Black -> (result.final).t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  predicate internal_invariant'0 [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'80] bst_invariant self /\ height_invariant self
  
  predicate inv'15 (_0: tuple'1)
  
  axiom inv_axiom'13 [@rewrite]: forall x: tuple'1 [inv'15 x]. inv'15 x
      = (let {_p0'1 = x0; _p1'1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_min_rec (self: MutBorrow.t t_Tree) (return' (x: tuple'1)) =
    {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree'37] inv'12 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree'38] internal_invariant'0 self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree'39] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result: tuple'1) -> {[%#sred_black_tree'40] inv'15 result}
      {[%#sred_black_tree'41] internal_invariant'0 self.final}
      {[%#sred_black_tree'42] height self.current = height self.final}
      {[%#sred_black_tree'43] has_mapping self.current (deep_model result._p0'1) result._p1'1}
      {[%#sred_black_tree'44] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
        -> le_log (deep_model result._p0'1) k}
      {[%#sred_black_tree'45] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result._p0'1 <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'46] color_invariant self.final}
      {[%#sred_black_tree'47] color self.current = C_Black -> color self.final = C_Black}
      (! return' {result}) ]
  
  type t_Option'3 = C_None'3 | C_Some'3 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) : Map.map t_DeepModelTy t_Option'3
   = [%#sred_black_tree'113] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'3 =
    [%#sred_black_tree'102] model_acc self (Const.const (C_None'3))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'109] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'3, k: t_DeepModelTy. [%#sred_black_tree'108] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'3 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'3) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'112] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'3 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'3, k: t_DeepModelTy. ([%#sred_black_tree'110] bst_invariant self)
      -> ([%#sred_black_tree'111] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'3 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'101] let _ = model_acc_has_mapping self (Const.const (C_None'3)) k in has_mapping_model_acc self (Const.const (C_None'3)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'99] bst_invariant self)
      -> ([%#sred_black_tree'100] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'3 v))
  
  function has_mapping_inj [#"red_black_tree.rs" 120 4 122 33] (self: t_Tree) (k: t_DeepModelTy) (v1: t_V) (v2: t_V) : ()
   = [%#sred_black_tree'52] let _ = has_mapping_model self k in match Map.get (view self) k with
      | C_None'3 -> ()
      | C_Some'3 _v -> ()
      end
  
  axiom has_mapping_inj_spec:
    forall self: t_Tree, k: t_DeepModelTy, v1: t_V, v2: t_V. ([%#sred_black_tree'48] bst_invariant self)
      -> ([%#sred_black_tree'49] has_mapping self k v1)
      -> ([%#sred_black_tree'50] has_mapping self k v2) -> ([%#sred_black_tree'51] v1 = v2)
  
  predicate invariant''8 [@inline:trivial] (self: MutBorrow.t t_K) = [%#sinvariant] inv self.current /\ inv self.final
  
  meta "rewrite_def" predicate invariant''8
  
  predicate inv'16 (_0: MutBorrow.t t_K)
  
  axiom inv_axiom'14 [@rewrite]: forall x: MutBorrow.t t_K [inv'16 x]. inv'16 x = invariant''8 x
  
  let rec swap (x: MutBorrow.t t_K) (y: MutBorrow.t t_K) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'2] inv'16 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'16 y}
    any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'11 [@inline:trivial] (self: MutBorrow.t t_K) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'11
  
  predicate resolve'12 [@inline:trivial] (_0: MutBorrow.t t_K) = resolve'11 _0
  
  meta "rewrite_def" predicate resolve'12
  
  predicate invariant''9 [@inline:trivial] (self: MutBorrow.t t_V) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''9
  
  predicate inv'17 (_0: MutBorrow.t t_V)
  
  axiom inv_axiom'15 [@rewrite]: forall x: MutBorrow.t t_V [inv'17 x]. inv'17 x = invariant''9 x
  
  let rec swap'0 (x: MutBorrow.t t_V) (y: MutBorrow.t t_V) (return' (x'0: ())) =
    {[@expl:swap 'x' type invariant] [%#smem'2] inv'17 x}
    {[@expl:swap 'y' type invariant] [%#smem'3] inv'17 y}
    any
    [ return''0 (result: ()) -> {[%#smem'4] x.final = y.current} {[%#smem'5] y.final = x.current} (! return' {result}) ]
  
  predicate resolve'13 [@inline:trivial] (self: MutBorrow.t t_V) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'13
  
  predicate resolve'14 [@inline:trivial] (_0: MutBorrow.t t_V) = resolve'13 _0
  
  meta "rewrite_def" predicate resolve'14
  
  let rec move_red_left (self: MutBorrow.t t_Node) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:move_red_left 'self' type invariant] [%#sred_black_tree'53] inv'8 self}
    {[@expl:move_red_left requires #0] [%#sred_black_tree'54] ((self.current).t_Node__right).t_Tree__node <> C_None}
    {[@expl:move_red_left requires #1] [%#sred_black_tree'55] internal_invariant self.current}
    {[@expl:move_red_left requires #2] [%#sred_black_tree'56] match_n (cpn (C_Red) (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {[%#sred_black_tree'57] inv'8 result}
      {[%#sred_black_tree'58] internal_invariant result.current}
      {[%#sred_black_tree'59] internal_invariant result.final
        /\ height'0 result.current = height'0 result.final
        /\ (forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.final k v -> has_mapping'0 result.current k v)
      -> internal_invariant self.final}
      {[%#sred_black_tree'60] height'0 result.current = height'0 result.final
      -> height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'61] (self.current).t_Node__key = (result.current).t_Node__key}
      {[%#sred_black_tree'62] forall k: t_DeepModelTy, v: t_V. has_mapping'0 result.current k v
        -> has_mapping'0 self.current k v}
      {[%#sred_black_tree'63] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.current k v
          /\ le_log k (deep_model (self.current).t_Node__key) -> has_mapping'0 result.current k v}
      {[%#sred_black_tree'64] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self.final k v
        = (has_mapping'0 result.final k v \/ has_mapping'0 self.current k v /\ not has_mapping'0 result.current k v)}
      {[%#sred_black_tree'65] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) result.current
      \/ match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) result.current}
      {[%#sred_black_tree'66] color_invariant'0 result.final
        /\ (color (result.current).t_Node__right = C_Black -> (result.final).t_Node__color = C_Black)
      -> color_invariant'0 self.final}
      (! return' {result}) ]
  
  let rec balance (self: MutBorrow.t t_Node) (return' (x: ())) =
    {[@expl:balance 'self' type invariant] [%#sred_black_tree'67] inv'8 self}
    {[@expl:balance requires #0] [%#sred_black_tree'68] internal_invariant self.current}
    {[@expl:balance requires #1] [%#sred_black_tree'69] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__left = C_Red -> color_invariant (self.current).t_Node__left}
    {[@expl:balance requires #2] [%#sred_black_tree'70] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red -> color_invariant (self.current).t_Node__right}
    {[@expl:balance requires #3] [%#sred_black_tree'71] (self.current).t_Node__color = C_Red
      /\ color (self.current).t_Node__right = C_Red /\ color (self.current).t_Node__left = C_Red -> false}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'72] same_mappings self.current self.final}
      {[%#sred_black_tree'73] internal_invariant self.final}
      {[%#sred_black_tree'74] height'0 self.current = height'0 self.final}
      {[%#sred_black_tree'75] color_invariant (self.current).t_Node__left
        /\ color (self.current).t_Node__right = C_Black -> self.current = self.final}
      {[%#sred_black_tree'76] match_n (cpn (C_Black) (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) (C_CPL (C_Black))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      {[%#sred_black_tree'77] match_n (cpn (C_Black) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'78] match_n (cpn (C_Red) (C_CPL (C_Black)) (C_CPL (C_Red))) self.current
      -> match_n (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final}
      {[%#sred_black_tree'79] match_n (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Red))) self.current
      -> match_n (C_CPL (C_Red)) self.final}
      (! return' {result}) ]
  
  predicate inv'18 (_0: t_Option'1)
  
  axiom inv_axiom'16 [@rewrite]: forall x: t_Option'1 [inv'18 x]. inv'18 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'15 a_0
        end
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_rec [#"red_black_tree.rs" 696 4 696 55] (self: MutBorrow.t t_Tree) (key: t_K)
    (return' (x: t_Option'1)) = {[@expl:delete_rec 'self' type invariant] [%#sred_black_tree'0] inv'12 self}
    {[@expl:delete_rec 'key' type invariant] [%#sred_black_tree'1] inv'9 key}
    {[@expl:delete_rec requires #0] [%#sred_black_tree'2] internal_invariant'0 self.current}
    {[@expl:delete_rec requires #1] [%#sred_black_tree'3] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {(self'0.current).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_16 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = as_mut {_16} (fun (_ret: t_Option'0) -> [ &_15 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = unwrap {_15} (fun (_ret: MutBorrow.t t_Node) -> [ &_14 <- _ret ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = {inv'4 _14.current}
        MutBorrow.borrow_final <t_Node> {_14.current} {MutBorrow.get_id _14}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_13 <- _ret ] -{inv'4 _ret.final}-
            [ &_14 <- { _14 with current = _ret.final } ] s1)
      | s1 = as_mut'0 {_13} (fun (_ret: MutBorrow.t t_Node) -> [ &node <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'6 _14} s1
      | s1 = -{resolve'0 _14}- s2
      | s2 = [ &_21 <- (node.current).t_Node__key ] s3
      | s3 = cmp {key'0} {_21} (fun (_ret: t_Ordering) -> [ &_18 <- _ret ] s4)
      | s4 = bb4 ]
    | bb4 = any [ br0 -> {_18 = C_Less} (! bb7) | br1 -> {_18 = C_Equal} (! bb5) | br2 -> {_18 = C_Greater} (! bb5) ]
    | bb5 = s0
      [ s0 = [ &ord <- _18 ] s1
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret: bool) -> [ &_42 <- _ret ] s2)
      | s2 = bb26 ]
    | bb26 = any [ br0 -> {_42 = false} (! bb33) | br1 -> {_42} (! bb27) ]
    | bb27 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_mut <t_Node> {node.current}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_45 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = rotate_right {_45} (fun (_ret: ()) -> [ &_44 <- _ret ] s2)
      | s2 = bb28 ]
    | bb28 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_47 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_rec {_47} {key'0} (fun (_ret: t_Option'1) -> [ &_46 <- _ret ] s2)
      | s2 = bb30 ]
    | bb30 = s0 [ s0 = [ &r <- _46 ] s1 | s1 = bb69 ]
    | bb33 = s0
      [ s0 = is_none {((node.current).t_Node__right).t_Tree__node} (fun (_ret: bool) -> [ &_50 <- _ret ] s1)
      | s1 = bb34 ]
    | bb34 = any [ br0 -> {_50 = false} (! bb44) | br1 -> {_50} (! bb35) ]
    | bb35 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = any
        [ br0 -> {ord = C_Less} (! bb38) | br1 -> {ord = C_Equal} (! bb38) | br2 -> {ord = C_Greater} (! bb36) ] ]
    | bb38 = s0
      [ s0 = {inv'2 (self'0.current).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {(self'0.current).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_59 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Tree__node = _ret.final } } ] s1)
      | s1 = {inv'2 _59.current}
        MutBorrow.borrow_final <t_Option> {_59.current} {MutBorrow.get_id _59}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_58 <- _ret ] -{inv'2 _ret.final}-
            [ &_59 <- { _59 with current = _ret.final } ] s2)
      | s2 = take {_58} (fun (_ret: t_Option) -> [ &_57 <- _ret ] s3)
      | s3 = bb39 ]
    | bb39 = s0
      [ s0 = {[@expl:type invariant] inv'5 _59} s1
      | s1 = -{resolve'5 _59}- s2
      | s2 = {[@expl:type invariant] inv'12 self'0} s3
      | s3 = -{resolve'7 self'0}- s4
      | s4 = unwrap'0 {_57} (fun (_ret: t_Node) -> [ &node'0 <- _ret ] s5)
      | s5 = bb40 ]
    | bb40 = s0
      [ s0 = {[@expl:type invariant] inv'1 node'0.t_Node__right} s1
      | s1 = -{resolve'10 node'0.t_Node__right}- s2
      | s2 = {[@expl:type invariant] inv'1 node'0.t_Node__left} s3
      | s3 = -{resolve'10 node'0.t_Node__left}- s4
      | s4 = [ &_60 <- { _p0'1 = node'0.t_Node__key; _p1'1 = node'0.t_Node__val } ] s5
      | s5 = bb42 ]
    | bb42 = s0 [ s0 = [ &_0 <- C_Some'1 _60 ] s1 | s1 = bb76 ]
    | bb36 = s0 [ s0 = {[@expl:type invariant] inv'12 self'0} s1 | s1 = -{resolve'7 self'0}- s2 | s2 = bb37 ]
    | bb37 = s0 [ s0 = [ &_0 <- C_None'1 ] s1 | s1 = bb76 ]
    | bb44 = s0
      [ s0 = as_ref {((node.current).t_Node__right).t_Tree__node} (fun (_ret: t_Option'2) -> [ &_67 <- _ret ] s1)
      | s1 = bb45 ]
    | bb45 = s0 [ s0 = unwrap'1 {_67} (fun (_ret: t_Node) -> [ &_66 <- _ret ] s1) | s1 = bb46 ]
    | bb46 = s0 [ s0 = is_red {_66.t_Node__left} (fun (_ret: bool) -> [ &_64 <- _ret ] s1) | s1 = bb47 ]
    | bb47 = any [ br0 -> {_64 = false} (! bb49) | br1 -> {_64} (! bb51) ]
    | bb49 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_71 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_right {_71} (fun (_ret: MutBorrow.t t_Node) -> [ &_70 <- _ret ] s2)
      | s2 = bb50 ]
    | bb50 = s0
      [ s0 = {inv'3 _70.current}
        MutBorrow.borrow_final <t_Node> {_70.current} {MutBorrow.get_id _70}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_69 <- _ret ] -{inv'3 _ret.final}-
            [ &_70 <- { _70 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _69 ] s4
      | s4 = {[@expl:type invariant] inv'8 _70} s5
      | s5 = -{resolve'2 _70}- s6
      | s6 = bb51 ]
    | bb51 = any
      [ br0 -> {ord = C_Less} (! bb63) | br1 -> {ord = C_Equal} (! bb53) | br2 -> {ord = C_Greater} (! bb63) ]
    | bb63 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_90 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_rec {_90} {key'0} (fun (_ret: t_Option'1) -> [ &_89 <- _ret ] s2)
      | s2 = bb65 ]
    | bb65 = s0 [ s0 = [ &r <- _89 ] s1 | s1 = bb69 ]
    | bb53 = s0
      [ s0 = {inv'1 (node.current).t_Node__right}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__right}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_74 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
      | s1 = delete_min_rec {_74} (fun (_ret: tuple'1) -> [ &kv <- _ret ] s2)
      | s2 = bb54 ]
    | bb54 = s0 [ s0 = [ &_75 <- [%#sred_black_tree] () ] s1 | s1 = bb55 ]
    | bb55 = s0
      [ s0 = {inv (node.current).t_Node__key}
        MutBorrow.borrow_mut <t_K> {(node.current).t_Node__key}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_79 <- _ret ] -{inv _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__key = _ret.final } } ] s1)
      | s1 = {inv kv._p0'1}
        MutBorrow.borrow_mut <t_K> {kv._p0'1}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_81 <- _ret ] -{inv _ret.final}-
            [ &kv <- { kv with _p0'1 = _ret.final } ] s2)
      | s2 = {inv _79.current}
        MutBorrow.borrow_final <t_K> {_79.current} {MutBorrow.get_id _79}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_78 <- _ret ] -{inv _ret.final}-
            [ &_79 <- { _79 with current = _ret.final } ] s3)
      | s3 = {inv _81.current}
        MutBorrow.borrow_final <t_K> {_81.current} {MutBorrow.get_id _81}
          (fun (_ret: MutBorrow.t t_K) ->
            [ &_80 <- _ret ] -{inv _ret.final}-
            [ &_81 <- { _81 with current = _ret.final } ] s4)
      | s4 = swap {_78} {_80} (fun (_ret: ()) -> [ &_77 <- _ret ] s5)
      | s5 = bb56 ]
    | bb56 = s0
      [ s0 = {[@expl:type invariant] inv'16 _81} s1
      | s1 = -{resolve'12 _81}- s2
      | s2 = {[@expl:type invariant] inv'16 _79} s3
      | s3 = -{resolve'12 _79}- s4
      | s4 = {inv'0 (node.current).t_Node__val}
        MutBorrow.borrow_mut <t_V> {(node.current).t_Node__val}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_84 <- _ret ] -{inv'0 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__val = _ret.final } } ] s5)
      | s5 = {inv'0 kv._p1'1}
        MutBorrow.borrow_mut <t_V> {kv._p1'1}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_86 <- _ret ] -{inv'0 _ret.final}-
            [ &kv <- { kv with _p1'1 = _ret.final } ] s6)
      | s6 = {inv'0 _84.current}
        MutBorrow.borrow_final <t_V> {_84.current} {MutBorrow.get_id _84}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_83 <- _ret ] -{inv'0 _ret.final}-
            [ &_84 <- { _84 with current = _ret.final } ] s7)
      | s7 = {inv'0 _86.current}
        MutBorrow.borrow_final <t_V> {_86.current} {MutBorrow.get_id _86}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_85 <- _ret ] -{inv'0 _ret.final}-
            [ &_86 <- { _86 with current = _ret.final } ] s8)
      | s8 = swap'0 {_83} {_85} (fun (_ret: ()) -> [ &_82 <- _ret ] s9)
      | s9 = bb57 ]
    | bb57 = s0
      [ s0 = {[@expl:type invariant] inv'17 _86} s1
      | s1 = -{resolve'14 _86}- s2
      | s2 = {[@expl:type invariant] inv'17 _84} s3
      | s3 = -{resolve'14 _84}- s4
      | s4 = [ &_87 <- C_Some'1 kv ] s5
      | s5 = bb59 ]
    | bb59 = s0 [ s0 = [ &r <- _87 ] s1 | s1 = bb69 ]
    | bb7 = s0
      [ s0 = is_none {((node.current).t_Node__left).t_Tree__node} (fun (_ret: bool) -> [ &_24 <- _ret ] s1) | s1 = bb8 ]
    | bb8 = any [ br0 -> {_24 = false} (! bb10) | br1 -> {_24} (! bb9) ]
    | bb9 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'12 self'0} s3
      | s3 = -{resolve'7 self'0}- s4
      | s4 = [ &_0 <- C_None'1 ] s5
      | s5 = bb76 ]
    | bb10 = s0 [ s0 = is_red {(node.current).t_Node__left} (fun (_ret: bool) -> [ &_28 <- _ret ] s1) | s1 = bb11 ]
    | bb11 = any [ br0 -> {_28 = false} (! bb13) | br1 -> {_28} (! bb21) ]
    | bb13 = s0
      [ s0 = as_ref {((node.current).t_Node__left).t_Tree__node} (fun (_ret: t_Option'2) -> [ &_33 <- _ret ] s1)
      | s1 = bb14 ]
    | bb14 = s0 [ s0 = unwrap'1 {_33} (fun (_ret: t_Node) -> [ &_32 <- _ret ] s1) | s1 = bb15 ]
    | bb15 = s0 [ s0 = is_red {_32.t_Node__left} (fun (_ret: bool) -> [ &_30 <- _ret ] s1) | s1 = bb16 ]
    | bb16 = any [ br0 -> {_30 = false} (! bb18) | br1 -> {_30} (! bb21) ]
    | bb18 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_37 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = move_red_left {_37} (fun (_ret: MutBorrow.t t_Node) -> [ &_36 <- _ret ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = {inv'3 _36.current}
        MutBorrow.borrow_final <t_Node> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_35 <- _ret ] -{inv'3 _ret.final}-
            [ &_36 <- { _36 with current = _ret.final } ] s1)
      | s1 = {[@expl:type invariant] inv'8 node} s2
      | s2 = -{resolve'2 node}- s3
      | s3 = [ &node <- _35 ] s4
      | s4 = {[@expl:type invariant] inv'8 _36} s5
      | s5 = -{resolve'2 _36}- s6
      | s6 = bb21 ]
    | bb21 = s0
      [ s0 = {inv'1 (node.current).t_Node__left}
        MutBorrow.borrow_mut <t_Tree> {(node.current).t_Node__left}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_39 <- _ret ] -{inv'1 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
      | s1 = delete_rec {_39} {key'0} (fun (_ret: t_Option'1) -> [ &_38 <- _ret ] s2)
      | s2 = bb23 ]
    | bb23 = s0 [ s0 = [ &r <- _38 ] s1 | s1 = bb69 ]
    | bb69 = s0
      [ s0 = {inv'3 node.current}
        MutBorrow.borrow_final <t_Node> {node.current} {MutBorrow.get_id node}
          (fun (_ret: MutBorrow.t t_Node) ->
            [ &_93 <- _ret ] -{inv'3 _ret.final}-
            [ &node <- { node with current = _ret.final } ] s1)
      | s1 = balance {_93} (fun (_ret: ()) -> [ &_92 <- _ret ] s2)
      | s2 = bb70 ]
    | bb70 = s0
      [ s0 = {[@expl:type invariant] inv'8 node} s1
      | s1 = -{resolve'2 node}- s2
      | s2 = {[@expl:type invariant] inv'12 self'0} s3
      | s3 = -{resolve'7 self'0}- s4
      | s4 = [ &_0 <- r ] s5
      | s5 = bb76 ]
    | bb76 = return''0 {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Tree = self
    | & key'0: t_K = key
    | & r: t_Option'1 = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _13: MutBorrow.t t_Node = Any.any_l ()
    | & _14: MutBorrow.t t_Node = Any.any_l ()
    | & _15: t_Option'0 = Any.any_l ()
    | & _16: MutBorrow.t t_Option = Any.any_l ()
    | & _18: t_Ordering = Any.any_l ()
    | & _21: t_K = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: bool = Any.any_l ()
    | & _32: t_Node = Any.any_l ()
    | & _33: t_Option'2 = Any.any_l ()
    | & _35: MutBorrow.t t_Node = Any.any_l ()
    | & _36: MutBorrow.t t_Node = Any.any_l ()
    | & _37: MutBorrow.t t_Node = Any.any_l ()
    | & _38: t_Option'1 = Any.any_l ()
    | & _39: MutBorrow.t t_Tree = Any.any_l ()
    | & ord: t_Ordering = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _44: () = Any.any_l ()
    | & _45: MutBorrow.t t_Node = Any.any_l ()
    | & _46: t_Option'1 = Any.any_l ()
    | & _47: MutBorrow.t t_Tree = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & node'0: t_Node = Any.any_l ()
    | & _57: t_Option = Any.any_l ()
    | & _58: MutBorrow.t t_Option = Any.any_l ()
    | & _59: MutBorrow.t t_Option = Any.any_l ()
    | & _60: tuple'1 = Any.any_l ()
    | & _64: bool = Any.any_l ()
    | & _66: t_Node = Any.any_l ()
    | & _67: t_Option'2 = Any.any_l ()
    | & _69: MutBorrow.t t_Node = Any.any_l ()
    | & _70: MutBorrow.t t_Node = Any.any_l ()
    | & _71: MutBorrow.t t_Node = Any.any_l ()
    | & kv: tuple'1 = Any.any_l ()
    | & _74: MutBorrow.t t_Tree = Any.any_l ()
    | & _75: () = Any.any_l ()
    | & _77: () = Any.any_l ()
    | & _78: MutBorrow.t t_K = Any.any_l ()
    | & _79: MutBorrow.t t_K = Any.any_l ()
    | & _80: MutBorrow.t t_K = Any.any_l ()
    | & _81: MutBorrow.t t_K = Any.any_l ()
    | & _82: () = Any.any_l ()
    | & _83: MutBorrow.t t_V = Any.any_l ()
    | & _84: MutBorrow.t t_V = Any.any_l ()
    | & _85: MutBorrow.t t_V = Any.any_l ()
    | & _86: MutBorrow.t t_V = Any.any_l ()
    | & _87: t_Option'1 = Any.any_l ()
    | & _89: t_Option'1 = Any.any_l ()
    | & _90: MutBorrow.t t_Tree = Any.any_l ()
    | & _92: () = Any.any_l ()
    | & _93: MutBorrow.t t_Node = Any.any_l () ])
    [ return''0 (result: t_Option'1) -> {[@expl:delete_rec result type invariant] [%#sred_black_tree'4] inv'18 result}
      {[@expl:delete_rec ensures #0] [%#sred_black_tree'5] internal_invariant'0 self.final}
      {[@expl:delete_rec ensures #1] [%#sred_black_tree'6] height self.current = height self.final}
      {[@expl:delete_rec ensures #2] [%#sred_black_tree'7] match result with
        | C_None'1 -> forall v: t_V. not has_mapping self.current (deep_model'0 key) v
        | C_Some'1 {_p0'1 = k; _p1'1 = v} -> deep_model'0 key = deep_model k
        /\ has_mapping self.current (deep_model k) v
        end}
      {[@expl:delete_rec ensures #3] [%#sred_black_tree'8] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model'0 key <> k /\ has_mapping self.current k v)}
      {[@expl:delete_rec ensures #4] [%#sred_black_tree'9] color_invariant self.final}
      {[@expl:delete_rec ensures #5] [%#sred_black_tree'10] color self.current = C_Black -> color self.final = C_Black}
      (! return' {result}) ]
end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence [#"red_black_tree.rs" 778 4 778 30] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 776 15 776 39
  let%span sred_black_tree'0 = "red_black_tree.rs" 777 4 777 30
  let%span sred_black_tree'1 = "red_black_tree.rs" 779 8 779 48
  let%span sred_black_tree'2 = "red_black_tree.rs" 772 20 772 67
  let%span sred_black_tree'3 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'4 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'5 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'6 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'7 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'8 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'10 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'11 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'13 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'14 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'15 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'16 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'17 = "red_black_tree.rs" 53 12 60 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 772 8 775 9
  
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'8] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'15] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_0: t_Tree) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  predicate structural_resolve (_0: t_Map) =
    match _0 with
      | {t_Map__0 = x0} -> resolve'1 x0
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  predicate resolve'2 [@inline:trivial] (self: t_Option'0) =
    [%#soption] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: t_Option'0) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'17] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'9] model_acc self (Const.const (C_None'0))
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'6] view self.t_Map__0
  
  predicate resolve'4 [#"red_black_tree.rs" 771 4 771 28] (self: t_Map) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy. resolve'3 (Map.get (view'0 self) k)
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'16] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'7] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'10] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'14] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'12] bst_invariant self)
      -> ([%#sred_black_tree'13] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'5] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'3] bst_invariant self)
      -> ([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map
  
  function resolve_coherence [#"red_black_tree.rs" 778 4 778 30] (self'0: t_Map) : ()
  
  goal vc_resolve_coherence: ([%#sred_black_tree] structural_resolve self)
    -> ([@expl:resolve_coherence ensures] [%#sred_black_tree'0] resolve'4 self)
end
module M_red_black_tree__qyi1722927563742988856__new [#"red_black_tree.rs" 788 4 788 24] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 788 20 788 24
  let%span sred_black_tree'0 = "red_black_tree.rs" 787 14 787 43
  let%span sred_black_tree'1 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'2 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'3 = "red_black_tree.rs" 760 8 762 9
  let%span sred_black_tree'4 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'5 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'6 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'7 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'8 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'10 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'11 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'12 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'13 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'14 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'15 = "red_black_tree.rs" 319 12 327 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use creusot.prelude.Any
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  
  type t_Map = { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'13] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'11] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'8] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'15] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'14] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'12] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'9] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'5] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'7] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'10] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'6] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant' [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'3] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color'0; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant''0 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate inv'5 (_0: t_Map)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map [inv'5 x]. inv'5 x
      = (invariant' x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'4] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'2] model_acc self (Const.const (C_None'0))
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'1] view self.t_Map__0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new [#"red_black_tree.rs" 788 4 788 24] (return' (x: t_Map)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- C_None ] s1 | s1 = [ &_2 <- { t_Tree__node = _3 } ] s2 | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &_0 <- { t_Map__0 = _2 } ] s1 | s1 = bb2 ]
    | bb2 = return''0 {_0} ]
    [ & _0: t_Map = Any.any_l () | & _2: t_Tree = Any.any_l () | & _3: t_Option = Any.any_l () ])
    [ return''0 (result: t_Map) -> {[@expl:new result type invariant] [%#sred_black_tree] inv'5 result}
      {[@expl:new ensures] [%#sred_black_tree'0] view'0 result = Const.const (C_None'0)}
      (! return' {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__insert [#"red_black_tree.rs" 793 4 793 44] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 796 8 796 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 793 23 793 27
  let%span sred_black_tree'1 = "red_black_tree.rs" 793 29 793 32
  let%span sred_black_tree'2 = "red_black_tree.rs" 793 37 793 40
  let%span sred_black_tree'3 = "red_black_tree.rs" 792 14 792 64
  let%span sred_black_tree'4 = "red_black_tree.rs" 608 23 608 27
  let%span sred_black_tree'5 = "red_black_tree.rs" 608 29 608 32
  let%span sred_black_tree'6 = "red_black_tree.rs" 608 37 608 40
  let%span sred_black_tree'7 = "red_black_tree.rs" 600 15 600 43
  let%span sred_black_tree'8 = "red_black_tree.rs" 601 15 601 40
  let%span sred_black_tree'9 = "red_black_tree.rs" 602 14 602 42
  let%span sred_black_tree'10 = "red_black_tree.rs" 603 14 603 50
  let%span sred_black_tree'11 = "red_black_tree.rs" 604 14 605 39
  let%span sred_black_tree'12 = "red_black_tree.rs" 606 14 606 56
  let%span sred_black_tree'13 = "red_black_tree.rs" 607 14 607 125
  let%span sred_black_tree'14 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'15 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'16 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'17 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'18 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'19 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'20 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'21 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'22 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'24 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'28 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'29 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'31 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'32 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'33 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'34 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'35 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'36 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'38 = "red_black_tree.rs" 760 8 762 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 59 8 59 22
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'25] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'35] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'26] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'21] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'20] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'37] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'33] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'18] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'24] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'34] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'19] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'22] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'23] C_CPN c l r
  
  let rec insert_rec (self: MutBorrow.t t_Tree) (key: t_K) (val': t_V) (return' (x: ())) =
    {[@expl:insert_rec 'self' type invariant] [%#sred_black_tree'4] inv'5 self}
    {[@expl:insert_rec 'key' type invariant] [%#sred_black_tree'5] inv key}
    {[@expl:insert_rec 'val' type invariant] [%#sred_black_tree'6] inv'0 val'}
    {[@expl:insert_rec requires #0] [%#sred_black_tree'7] internal_invariant self.current}
    {[@expl:insert_rec requires #1] [%#sred_black_tree'8] color_invariant self.current}
    any
    [ return''0 (result: ()) -> {[%#sred_black_tree'9] internal_invariant self.final}
      {[%#sred_black_tree'10] height self.current = height self.final}
      {[%#sred_black_tree'11] match_t (cpn (C_Red) (C_CPL (C_Red)) (C_CPL (C_Black))) self.final
        /\ color self.current = C_Red
      \/ color_invariant self.final}
      {[%#sred_black_tree'12] has_mapping self.final (deep_model key) val'}
      {[%#sred_black_tree'13] forall k: t_DeepModelTy, v: t_V. k = deep_model key
        \/ has_mapping self.current k v = has_mapping self.final k v}
      (! return' {result}) ]
  
  type t_Option'0 = C_None'0 | C_Some'0 (MutBorrow.t t_Node)
  
  predicate invariant''1 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'4 [@rewrite]: forall x: MutBorrow.t t_Option [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate inv'8 (_0: t_Option'0)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Option'0 [inv'8 x]. inv'8 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'7 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'0)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'6 self_}
    any
    [ return''0 (result: t_Option'0) -> {inv'8 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'0 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'0 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'0) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'8 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'0}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'7 result}
      {[%#soption'4] C_Some'0 result = self_}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''3 [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'38] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'9 (_0: t_Map)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_Map [inv'9 x]. inv'9 x
      = (invariant''3 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'9 self.current /\ inv'9 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'10 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Map [inv'10 x]. inv'10 x = invariant''4 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Map) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) : Map.map t_DeepModelTy t_Option'1
   = [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'1 =
    [%#sred_black_tree'27] model_acc self (Const.const (C_None'1))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'1, k: t_DeepModelTy. [%#sred_black_tree'28] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'1 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'1) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'32] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'1 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'1, k: t_DeepModelTy. ([%#sred_black_tree'30] bst_invariant self)
      -> ([%#sred_black_tree'31] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'1 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'16] let _ = model_acc_has_mapping self (Const.const (C_None'1)) k in has_mapping_model_acc self (Const.const (C_None'1)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'14] bst_invariant self)
      -> ([%#sred_black_tree'15] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'1 v))
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'1 =
    [%#sred_black_tree'17] view self.t_Map__0
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'1 =
    [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert [#"red_black_tree.rs" 793 4 793 44] (self: MutBorrow.t t_Map) (key: t_K) (val': t_V)
    (return' (x: ())) = {[@expl:insert 'self' type invariant] [%#sred_black_tree'0] inv'10 self}
    {[@expl:insert 'key' type invariant] [%#sred_black_tree'1] inv key}
    {[@expl:insert 'val' type invariant] [%#sred_black_tree'2] inv'0 val'}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv'2 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_6 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = insert_rec {_6} {key'0} {val''0} (fun (_ret: ()) -> [ &_5 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_9 <- C_Black ] s1
      | s1 = {inv'4 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_12 <- _ret ] -{inv'4 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_12} (fun (_ret: t_Option'0) -> [ &_11 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0 [ s0 = unwrap {_11} (fun (_ret: MutBorrow.t t_Node) -> [ &_10 <- _ret ] s1) | s1 = bb3 ]
    | bb3 = s0
      [ s0 = [ &_10 <- { _10 with current = { _10.current with t_Node__color = _9 } } ] s1
      | s1 = {[@expl:type invariant] inv'7 _10} s2
      | s2 = -{resolve'0 _10}- s3
      | s3 = {[@expl:type invariant] inv'10 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 = [ &_13 <- [%#sred_black_tree] () ] s6
      | s6 = bb6 ]
    | bb6 = return''0 {_0} ]
    [ & _0: () = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & key'0: t_K = key
    | & val''0: t_V = val'
    | & _5: () = Any.any_l ()
    | & _6: MutBorrow.t t_Tree = Any.any_l ()
    | & _9: t_Color = Any.any_l ()
    | & _10: MutBorrow.t t_Node = Any.any_l ()
    | & _11: t_Option'0 = Any.any_l ()
    | & _12: MutBorrow.t t_Option = Any.any_l ()
    | & _13: () = Any.any_l () ])
    [ return''0 (result: ()) -> {[@expl:insert ensures] [%#sred_black_tree'3] view'0 self.final
      = Map.set (view'1 self) (deep_model key) (C_Some'1 val')}
      (! return' {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__delete_max [#"red_black_tree.rs" 805 4 805 50] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 806 23 806 41
  let%span sred_black_tree'0 = "red_black_tree.rs" 814 8 814 58
  let%span sred_black_tree'1 = "red_black_tree.rs" 819 8 819 53
  let%span sred_black_tree'2 = "red_black_tree.rs" 805 27 805 31
  let%span sred_black_tree'3 = "red_black_tree.rs" 805 36 805 50
  let%span sred_black_tree'4 = "red_black_tree.rs" 799 14 804 5
  let%span sred_black_tree'5 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'6 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'7 = "red_black_tree.rs" 46 12 46 89
  let%span sred_black_tree'8 = "red_black_tree.rs" 642 27 642 31
  let%span sred_black_tree'9 = "red_black_tree.rs" 631 15 631 43
  let%span sred_black_tree'10 = "red_black_tree.rs" 632 15 633 62
  let%span sred_black_tree'11 = "red_black_tree.rs" 642 36 642 42
  let%span sred_black_tree'12 = "red_black_tree.rs" 634 14 634 42
  let%span sred_black_tree'13 = "red_black_tree.rs" 635 14 635 50
  let%span sred_black_tree'14 = "red_black_tree.rs" 636 14 636 66
  let%span sred_black_tree'15 = "red_black_tree.rs" 637 14 637 102
  let%span sred_black_tree'16 = "red_black_tree.rs" 638 14 639 71
  let%span sred_black_tree'17 = "red_black_tree.rs" 640 14 640 39
  let%span sred_black_tree'18 = "red_black_tree.rs" 641 14 641 67
  let%span sred_black_tree'19 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'20 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'21 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'22 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'23 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'26 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'28 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'29 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'31 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'32 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'33 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'34 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'35 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'36 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'37 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'38 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'39 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'40 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'41 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'42 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'43 = "red_black_tree.rs" 760 8 762 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 59 8 59 22
  
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'40] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'31] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'28] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'42] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'38] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'25] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'23] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'39] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'30] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'43] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_0: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
      = (invariant''1 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'1 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Map) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { _p0: t_K; _p1: t_V }
  
  type t_Option'0 = C_None'0 | C_Some'0 tuple
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'5] inv'8 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'6] result = (color self = C_Red)} (! return' {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate same_mappings [#"red_black_tree.rs" 44 4 44 43] (self: t_Tree) (o: t_Tree) =
    [%#sred_black_tree'7] forall k: t_DeepModelTy, v: t_V. has_mapping self k v = has_mapping o k v
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'26] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'27] C_CPN c l r
  
  predicate inv'11 (_0: tuple)
  
  axiom inv_axiom'9 [@rewrite]: forall x: tuple [inv'11 x]. inv'11 x
      = (let {_p0 = x0; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_max_rec (self: MutBorrow.t t_Tree) (return' (x: tuple)) =
    {[@expl:delete_max_rec 'self' type invariant] [%#sred_black_tree'8] inv'10 self}
    {[@expl:delete_max_rec requires #0] [%#sred_black_tree'9] internal_invariant self.current}
    {[@expl:delete_max_rec requires #1] [%#sred_black_tree'10] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result: tuple) -> {[%#sred_black_tree'11] inv'11 result}
      {[%#sred_black_tree'12] internal_invariant self.final}
      {[%#sred_black_tree'13] height self.current = height self.final}
      {[%#sred_black_tree'14] has_mapping self.current (deep_model result._p0) result._p1}
      {[%#sred_black_tree'15] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
        -> le_log k (deep_model result._p0)}
      {[%#sred_black_tree'16] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result._p0 <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'17] color_invariant self.final}
      {[%#sred_black_tree'18] color self.current = C_Black -> color self.final = C_Black}
      (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_Node)
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'9 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'1)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result: t_Option'1) -> {inv'12 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'1 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'1 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'1) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'1}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'9 result}
      {[%#soption'4] C_Some'1 result = self_}
      (! return' {result}) ]
  
  type t_Option'2 = C_None'2 | C_Some'2 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) : Map.map t_DeepModelTy t_Option'2
   = [%#sred_black_tree'41] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'2 =
    [%#sred_black_tree'32] model_acc self (Const.const (C_None'2))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'34] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'2, k: t_DeepModelTy. [%#sred_black_tree'33] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'2 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'2) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'37] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'2 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'2, k: t_DeepModelTy. ([%#sred_black_tree'35] bst_invariant self)
      -> ([%#sred_black_tree'36] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'2 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'21] let _ = model_acc_has_mapping self (Const.const (C_None'2)) k in has_mapping_model_acc self (Const.const (C_None'2)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'19] bst_invariant self)
      -> ([%#sred_black_tree'20] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'2 v))
  
  predicate inv'13 (_0: t_Option'0)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'0 [inv'13 x]. inv'13 x
      = match x with
        | C_None'0 -> true
        | C_Some'0 a_0 -> inv'11 a_0
        end
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'2 =
    [%#sred_black_tree'22] view self.t_Map__0
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'2 =
    [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_max [#"red_black_tree.rs" 805 4 805 50] (self: MutBorrow.t t_Map) (return' (x: t_Option'0)) =
    {[@expl:delete_max 'self' type invariant] [%#sred_black_tree'2] inv'7 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_self <- [%#sred_black_tree] self'0 ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_6 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = any [ br0 -> {_6.current = C_None} (! bb8) | br1 (x0: t_Node) -> {_6.current = C_Some x0} (! bb3) ] ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'7 self'0} s3
      | s3 = -{resolve'2 self'0}- s4
      | s4 = [ &_0 <- C_None'0 ] s5
      | s5 = bb19 ]
    | bb3 = s0
      [ s0 = v_Some {_6.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_6 <- { _6 with current = C_Some _ret.final } ] s1))
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret: bool) -> [ &_9 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    | bb6 = s0
      [ s0 = [ &_11 <- C_Red ] s1
      | s1 = [ &node <- { node with current = { node.current with t_Node__color = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    | bb7 = s0
      [ s0 =
        {[@expl:assertion] [%#sred_black_tree'0] same_mappings (old_self.current).t_Map__0 (self'0.current).t_Map__0}
        s1
      | s1 = {inv'1 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] s2)
      | s2 = delete_max_rec {_16} (fun (_ret: tuple) -> [ &r <- _ret ] s3)
      | s3 = bb9 ]
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Map__0} (fun (_ret: bool) -> [ &_18 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_18 = false} (! bb14) | br1 -> {_18} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_20 <- C_Black ] s1
      | s1 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_23 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_23} (fun (_ret: t_Option'1) -> [ &_22 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_22} (fun (_ret: MutBorrow.t t_Node) -> [ &_21 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_21 <- { _21 with current = { _21.current with t_Node__color = _20 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _21} s2
      | s2 = -{resolve'4 _21}- s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 = bb15 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb15 ]
    | bb15 = s0 [ s0 = [ &_24 <- [%#sred_black_tree'1] () ] s1 | s1 = bb16 ]
    | bb16 = s0 [ s0 = [ &_0 <- C_Some'0 r ] s1 | s1 = bb19 ]
    | bb19 = return''0 {_0} ]
    [ & _0: t_Option'0 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & old_self: MutBorrow.t t_Map = Any.any_l ()
    | & _6: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _11: t_Color = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _16: MutBorrow.t t_Tree = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: t_Color = Any.any_l ()
    | & _21: MutBorrow.t t_Node = Any.any_l ()
    | & _22: t_Option'1 = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l ()
    | & _24: () = Any.any_l () ])
    [ return''0 (result: t_Option'0) -> {[@expl:delete_max result type invariant] [%#sred_black_tree'3] inv'13 result}
      {[@expl:delete_max ensures] [%#sred_black_tree'4] match result with
        | C_Some'0 {_p0 = k; _p1 = v} -> Map.get (view'1 self) (deep_model k) = C_Some'2 v
        /\ (forall k2: t_DeepModelTy. Map.get (view'1 self) k2 = C_None'2 \/ le_log k2 (deep_model k))
        /\ view'0 self.final = Map.set (view'1 self) (deep_model k) (C_None'2)
        | C_None'0 -> view'0 self.final = view'1 self /\ view'1 self = Const.const (C_None'2)
        end}
      (! return' {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__delete_min [#"red_black_tree.rs" 830 4 830 50] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 831 8 831 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 830 27 830 31
  let%span sred_black_tree'1 = "red_black_tree.rs" 830 36 830 50
  let%span sred_black_tree'2 = "red_black_tree.rs" 823 14 829 5
  let%span sred_black_tree'3 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'4 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'5 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'6 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'7 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'8 = "red_black_tree.rs" 670 27 670 31
  let%span sred_black_tree'9 = "red_black_tree.rs" 659 15 659 43
  let%span sred_black_tree'10 = "red_black_tree.rs" 660 15 661 62
  let%span sred_black_tree'11 = "red_black_tree.rs" 670 36 670 42
  let%span sred_black_tree'12 = "red_black_tree.rs" 662 14 662 42
  let%span sred_black_tree'13 = "red_black_tree.rs" 663 14 663 50
  let%span sred_black_tree'14 = "red_black_tree.rs" 664 14 664 66
  let%span sred_black_tree'15 = "red_black_tree.rs" 665 14 665 102
  let%span sred_black_tree'16 = "red_black_tree.rs" 666 14 667 71
  let%span sred_black_tree'17 = "red_black_tree.rs" 668 14 668 39
  let%span sred_black_tree'18 = "red_black_tree.rs" 669 14 669 67
  let%span sred_black_tree'19 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'20 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'21 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'22 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'23 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'24 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'26 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'27 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'28 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'29 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'30 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'31 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'32 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'33 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'34 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'35 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'36 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'38 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'39 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'40 = "red_black_tree.rs" 760 8 762 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 59 8 59 22
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'21] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'35] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'20] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'22] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'23] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'27] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'25] bst_invariant self)
      -> ([%#sred_black_tree'26] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'5] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'3] bst_invariant self)
      -> ([%#sred_black_tree'4] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'33] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'32] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'39] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'37] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'29] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'28] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'38] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'34] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'40] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_0: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
      = (invariant''1 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'1 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Map) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { _p0: t_K; _p1: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'6] inv'8 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'7] result = (color self = C_Red)} (! return' {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'30] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'31] C_CPN c l r
  
  predicate inv'11 (_0: tuple)
  
  axiom inv_axiom'9 [@rewrite]: forall x: tuple [inv'11 x]. inv'11 x
      = (let {_p0 = x0; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  let rec delete_min_rec (self: MutBorrow.t t_Tree) (return' (x: tuple)) =
    {[@expl:delete_min_rec 'self' type invariant] [%#sred_black_tree'8] inv'10 self}
    {[@expl:delete_min_rec requires #0] [%#sred_black_tree'9] internal_invariant self.current}
    {[@expl:delete_min_rec requires #1] [%#sred_black_tree'10] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result: tuple) -> {[%#sred_black_tree'11] inv'11 result}
      {[%#sred_black_tree'12] internal_invariant self.final}
      {[%#sred_black_tree'13] height self.current = height self.final}
      {[%#sred_black_tree'14] has_mapping self.current (deep_model result._p0) result._p1}
      {[%#sred_black_tree'15] forall k: t_DeepModelTy, v: t_V. has_mapping self.current k v
        -> le_log (deep_model result._p0) k}
      {[%#sred_black_tree'16] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model result._p0 <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'17] color_invariant self.final}
      {[%#sred_black_tree'18] color self.current = C_Black -> color self.final = C_Black}
      (! return' {result}) ]
  
  type t_Option'2 = C_None'2 | C_Some'2 (MutBorrow.t t_Node)
  
  predicate inv'12 (_0: t_Option'2)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'2 [inv'12 x]. inv'12 x
      = match x with
        | C_None'2 -> true
        | C_Some'2 a_0 -> inv'9 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'2)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result: t_Option'2) -> {inv'12 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'2 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'2 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'2) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'12 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'2}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'9 result}
      {[%#soption'4] C_Some'2 result = self_}
      (! return' {result}) ]
  
  predicate inv'13 (_0: t_Option'1)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'1 [inv'13 x]. inv'13 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'11 a_0
        end
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'19] view self.t_Map__0
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#smodel] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete_min [#"red_black_tree.rs" 830 4 830 50] (self: MutBorrow.t t_Map) (return' (x: t_Option'1)) =
    {[@expl:delete_min 'self' type invariant] [%#sred_black_tree'0] inv'7 self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_3 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_6 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = any [ br0 -> {_6.current = C_None} (! bb8) | br1 (x0: t_Node) -> {_6.current = C_Some x0} (! bb3) ] ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _6} s1
      | s1 = -{resolve'0 _6}- s2
      | s2 = {[@expl:type invariant] inv'7 self'0} s3
      | s3 = -{resolve'2 self'0}- s4
      | s4 = [ &_0 <- C_None'1 ] s5
      | s5 = bb18 ]
    | bb3 = s0
      [ s0 = v_Some {_6.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _6) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_6 <- { _6 with current = C_Some _ret.final } ] s1))
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret: bool) -> [ &_9 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _6} s3
      | s3 = -{resolve'0 _6}- s4
      | s4 = bb7 ]
    | bb6 = s0
      [ s0 = [ &_11 <- C_Red ] s1
      | s1 = [ &node <- { node with current = { node.current with t_Node__color = _11 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _6} s5
      | s5 = -{resolve'0 _6}- s6
      | s6 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'1 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_14 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = delete_min_rec {_14} (fun (_ret: tuple) -> [ &r <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Map__0} (fun (_ret: bool) -> [ &_16 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_16 = false} (! bb14) | br1 -> {_16} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_18 <- C_Black ] s1
      | s1 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_21 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_21} (fun (_ret: t_Option'2) -> [ &_20 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_20} (fun (_ret: MutBorrow.t t_Node) -> [ &_19 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_19 <- { _19 with current = { _19.current with t_Node__color = _18 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _19} s2
      | s2 = -{resolve'4 _19}- s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 = bb15 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb15 ]
    | bb15 = s0 [ s0 = [ &_0 <- C_Some'1 r ] s1 | s1 = bb18 ]
    | bb18 = return''0 {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & _3: () = Any.any_l ()
    | & _6: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _11: t_Color = Any.any_l ()
    | & r: tuple = Any.any_l ()
    | & _14: MutBorrow.t t_Tree = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: t_Color = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & _20: t_Option'2 = Any.any_l ()
    | & _21: MutBorrow.t t_Option = Any.any_l () ])
    [ return''0 (result: t_Option'1) -> {[@expl:delete_min result type invariant] [%#sred_black_tree'1] inv'13 result}
      {[@expl:delete_min ensures] [%#sred_black_tree'2] match result with
        | C_Some'1 {_p0 = k; _p1 = v} -> Map.get (view'1 self) (deep_model k) = C_Some'0 v
        /\ (forall k2: t_DeepModelTy. Map.get (view'1 self) k2 = C_None'0 \/ le_log (deep_model k) k2)
        /\ view'0 self.final = Map.set (view'1 self) (deep_model k) (C_None'0)
        | C_None'1 -> view'0 self.final = view'1 self /\ view'1 self = Const.const (C_None'0)
        end}
      (! return' {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__delete [#"red_black_tree.rs" 853 4 853 55] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 854 8 854 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 853 23 853 27
  let%span sred_black_tree'1 = "red_black_tree.rs" 853 29 853 32
  let%span sred_black_tree'2 = "red_black_tree.rs" 853 41 853 55
  let%span sred_black_tree'3 = "red_black_tree.rs" 847 14 851 5
  let%span sred_black_tree'4 = "red_black_tree.rs" 852 14 852 59
  let%span sred_black_tree'5 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'6 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'7 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'8 = "red_black_tree.rs" 402 15 402 19
  let%span sred_black_tree'9 = "red_black_tree.rs" 401 14 401 45
  let%span sred_black_tree'10 = "red_black_tree.rs" 696 23 696 27
  let%span sred_black_tree'11 = "red_black_tree.rs" 696 29 696 32
  let%span sred_black_tree'12 = "red_black_tree.rs" 684 15 684 43
  let%span sred_black_tree'13 = "red_black_tree.rs" 685 15 686 62
  let%span sred_black_tree'14 = "red_black_tree.rs" 696 41 696 55
  let%span sred_black_tree'15 = "red_black_tree.rs" 687 14 687 42
  let%span sred_black_tree'16 = "red_black_tree.rs" 688 14 688 50
  let%span sred_black_tree'17 = "red_black_tree.rs" 689 14 692 5
  let%span sred_black_tree'18 = "red_black_tree.rs" 693 14 693 127
  let%span sred_black_tree'19 = "red_black_tree.rs" 694 14 694 39
  let%span sred_black_tree'20 = "red_black_tree.rs" 695 14 695 67
  let%span sred_black_tree'21 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'22 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'25 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'26 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'28 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'29 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'30 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'31 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'32 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'33 = "red_black_tree.rs" 248 16 248 48
  let%span sred_black_tree'34 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'35 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'36 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'37 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'38 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'39 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'40 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'41 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'42 = "red_black_tree.rs" 760 8 762 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 97 16 97 17
  let%span soption'0 = "../../creusot-contracts/src/std/option.rs" 99 26 99 75
  let%span soption'1 = "../../creusot-contracts/src/std/option.rs" 101 20 102 100
  let%span soption'2 = "../../creusot-contracts/src/std/option.rs" 148 16 148 17
  let%span soption'3 = "../../creusot-contracts/src/std/option.rs" 149 27 149 39
  let%span soption'4 = "../../creusot-contracts/src/std/option.rs" 150 26 150 46
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 59 8 59 22
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'37] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'22] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'38] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'24] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'26] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'25] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'29] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'27] bst_invariant self)
      -> ([%#sred_black_tree'28] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'7] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'5] bst_invariant self)
      -> ([%#sred_black_tree'6] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Tree)
  
  predicate inv'2 (_0: t_Option)
  
  axiom inv_axiom [@rewrite]: forall x: t_Tree [inv'1 x]. inv'1 x
      = match x with
        | {t_Tree__node = node} -> inv'2 node
        end
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'1 left
        /\ inv key /\ inv'0 val' /\ inv'1 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'3 self
  
  predicate inv'4 (_0: t_Node)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Node [inv'4 x]. inv'4 x = invariant' x
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Option [inv'2 x]. inv'2 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'4 a_0
        end
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Option [inv'5 x]. inv'5 x = invariant''0 x
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'35] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'34] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'41] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'39] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'31] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'30] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'40] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'36] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''1 [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'42] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'6 (_0: t_Map)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_Map [inv'6 x]. inv'6 x
      = (invariant''1 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'1 a_0
        end)
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'6 self.current /\ inv'6 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Map [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Map) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Map) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  type tuple = { _p0: t_K; _p1: t_V }
  
  type t_Option'1 = C_None'1 | C_Some'1 tuple
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  predicate invariant''3 [@inline:trivial] (self: t_Tree) = [%#sinvariant'0] inv'1 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: t_Tree)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Tree [inv'8 x]. inv'8 x = invariant''3 x
  
  let rec is_red (self: t_Tree) (return' (x: bool)) =
    {[@expl:is_red 'self' type invariant] [%#sred_black_tree'8] inv'8 self}
    any [ return''0 (result: bool) -> {[%#sred_black_tree'9] result = (color self = C_Red)} (! return' {result}) ]
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_Node [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  predicate invariant''5 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'1 self.current /\ inv'1 self.final
  
  meta "rewrite_def" predicate invariant''5
  
  predicate inv'10 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'8 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'10 x]. inv'10 x = invariant''5 x
  
  predicate invariant''6 [@inline:trivial] (self: t_K) = [%#sinvariant'0] inv self
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'11 (_0: t_K)
  
  axiom inv_axiom'9 [@rewrite]: forall x: t_K [inv'11 x]. inv'11 x = invariant''6 x
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'32] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function cpn [#"red_black_tree.rs" 247 0 247 36] (c: t_Color) (l: t_CP) (r: t_CP) : t_CP =
    [%#sred_black_tree'33] C_CPN c l r
  
  predicate inv'12 (_0: tuple)
  
  axiom inv_axiom'10 [@rewrite]: forall x: tuple [inv'12 x]. inv'12 x
      = (let {_p0 = x0; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate inv'13 (_0: t_Option'1)
  
  axiom inv_axiom'11 [@rewrite]: forall x: t_Option'1 [inv'13 x]. inv'13 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'12 a_0
        end
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  let rec delete_rec (self: MutBorrow.t t_Tree) (key: t_K) (return' (x: t_Option'1)) =
    {[@expl:delete_rec 'self' type invariant] [%#sred_black_tree'10] inv'10 self}
    {[@expl:delete_rec 'key' type invariant] [%#sred_black_tree'11] inv'11 key}
    {[@expl:delete_rec requires #0] [%#sred_black_tree'12] internal_invariant self.current}
    {[@expl:delete_rec requires #1] [%#sred_black_tree'13] match_t (C_CPL (C_Red)) self.current
    \/ match_t (cpn (C_Black) (C_CPL (C_Red)) (C_CPL (C_Black))) self.current}
    any
    [ return''0 (result: t_Option'1) -> {[%#sred_black_tree'14] inv'13 result}
      {[%#sred_black_tree'15] internal_invariant self.final}
      {[%#sred_black_tree'16] height self.current = height self.final}
      {[%#sred_black_tree'17] match result with
        | C_None'1 -> forall v: t_V. not has_mapping self.current (deep_model'0 key) v
        | C_Some'1 {_p0 = k; _p1 = v} -> deep_model'0 key = deep_model k /\ has_mapping self.current (deep_model k) v
        end}
      {[%#sred_black_tree'18] forall k: t_DeepModelTy, v: t_V. has_mapping self.final k v
        = (deep_model'0 key <> k /\ has_mapping self.current k v)}
      {[%#sred_black_tree'19] color_invariant self.final}
      {[%#sred_black_tree'20] color self.current = C_Black -> color self.final = C_Black}
      (! return' {result}) ]
  
  type t_Option'2 = C_None'2 | C_Some'2 (MutBorrow.t t_Node)
  
  predicate inv'14 (_0: t_Option'2)
  
  axiom inv_axiom'12 [@rewrite]: forall x: t_Option'2 [inv'14 x]. inv'14 x
      = match x with
        | C_None'2 -> true
        | C_Some'2 a_0 -> inv'9 a_0
        end
  
  let rec as_mut (self_: MutBorrow.t t_Option) (return' (x: t_Option'2)) =
    {[@expl:as_mut 'self_' type invariant] [%#soption] inv'5 self_}
    any
    [ return''0 (result: t_Option'2) -> {inv'14 result}
      {[%#soption'0] self_.current = C_None -> result = C_None'2 /\ self_.final = C_None}
      {[%#soption'1] self_.current = C_None
      \/ (exists r: MutBorrow.t t_Node. result = C_Some'2 r
        /\ self_.current = C_Some (r.current) /\ self_.final = C_Some (r.final))}
      (! return' {result}) ]
  
  let rec unwrap (self_: t_Option'2) (return' (x: MutBorrow.t t_Node)) =
    {[@expl:unwrap 'self_' type invariant] [%#soption'2] inv'14 self_}
    {[@expl:unwrap requires] [%#soption'3] self_ <> C_None'2}
    any
    [ return''0 (result: MutBorrow.t t_Node) -> {inv'9 result}
      {[%#soption'4] C_Some'2 result = self_}
      (! return' {result}) ]
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'21] view self.t_Map__0
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#smodel'0] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec delete [#"red_black_tree.rs" 853 4 853 55] (self: MutBorrow.t t_Map) (key: t_K) (return' (x: t_Option'1)) =
    {[@expl:delete 'self' type invariant] [%#sred_black_tree'0] inv'7 self}
    {[@expl:delete 'key' type invariant] [%#sred_black_tree'1] inv'11 key}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_mut <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_8 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s1)
      | s1 = any [ br0 -> {_8.current = C_None} (! bb8) | br1 (x0: t_Node) -> {_8.current = C_Some x0} (! bb3) ] ]
    | bb8 = s0
      [ s0 = {[@expl:type invariant] inv'5 _8} s1
      | s1 = -{resolve'0 _8}- s2
      | s2 = {[@expl:type invariant] inv'7 self'0} s3
      | s3 = -{resolve'2 self'0}- s4
      | s4 = [ &_0 <- C_None'1 ] s5
      | s5 = bb17 ]
    | bb3 = s0
      [ s0 = v_Some {_8.current}
          (fun (r0: t_Node) ->
            {inv'4 r0}
            MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _8) 1}
              (fun (_ret: MutBorrow.t t_Node) ->
                [ &node <- _ret ] -{inv'4 _ret.final}-
                [ &_8 <- { _8 with current = C_Some _ret.final } ] s1))
      | s1 = is_red {(node.current).t_Node__left} (fun (_ret: bool) -> [ &_11 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = any [ br0 -> {_11 = false} (! bb6) | br1 -> {_11} (! bb5) ]
    | bb5 = s0
      [ s0 = {[@expl:type invariant] inv'9 node} s1
      | s1 = -{resolve'4 node}- s2
      | s2 = {[@expl:type invariant] inv'5 _8} s3
      | s3 = -{resolve'0 _8}- s4
      | s4 = bb7 ]
    | bb6 = s0
      [ s0 = [ &_13 <- C_Red ] s1
      | s1 = [ &node <- { node with current = { node.current with t_Node__color = _13 } } ] s2
      | s2 = {[@expl:type invariant] inv'9 node} s3
      | s3 = -{resolve'4 node}- s4
      | s4 = {[@expl:type invariant] inv'5 _8} s5
      | s5 = -{resolve'0 _8}- s6
      | s6 = bb7 ]
    | bb7 = s0
      [ s0 = {inv'1 (self'0.current).t_Map__0}
        MutBorrow.borrow_mut <t_Tree> {(self'0.current).t_Map__0}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &_16 <- _ret ] -{inv'1 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = delete_rec {_16} {key'0} (fun (_ret: t_Option'1) -> [ &r <- _ret ] s2)
      | s2 = bb9 ]
    | bb9 = s0 [ s0 = is_red {(self'0.current).t_Map__0} (fun (_ret: bool) -> [ &_19 <- _ret ] s1) | s1 = bb10 ]
    | bb10 = any [ br0 -> {_19 = false} (! bb14) | br1 -> {_19} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_21 <- C_Black ] s1
      | s1 = {inv'2 ((self'0.current).t_Map__0).t_Tree__node}
        MutBorrow.borrow_final <t_Option> {((self'0.current).t_Map__0).t_Tree__node}
          {MutBorrow.inherit_id (MutBorrow.inherit_id (MutBorrow.get_id self'0) 1) 1}
          (fun (_ret: MutBorrow.t t_Option) ->
            [ &_24 <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = { t_Tree__node = _ret.final } } } ] s2)
      | s2 = as_mut {_24} (fun (_ret: t_Option'2) -> [ &_23 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0 [ s0 = unwrap {_23} (fun (_ret: MutBorrow.t t_Node) -> [ &_22 <- _ret ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_22 <- { _22 with current = { _22.current with t_Node__color = _21 } } ] s1
      | s1 = {[@expl:type invariant] inv'9 _22} s2
      | s2 = -{resolve'4 _22}- s3
      | s3 = {[@expl:type invariant] inv'7 self'0} s4
      | s4 = -{resolve'2 self'0}- s5
      | s5 = bb15 ]
    | bb14 = s0 [ s0 = {[@expl:type invariant] inv'7 self'0} s1 | s1 = -{resolve'2 self'0}- s2 | s2 = bb15 ]
    | bb15 = s0 [ s0 = [ &_0 <- r ] s1 | s1 = bb17 ]
    | bb17 = return''0 {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & key'0: t_K = key
    | & _5: () = Any.any_l ()
    | & _8: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: t_Color = Any.any_l ()
    | & r: t_Option'1 = Any.any_l ()
    | & _16: MutBorrow.t t_Tree = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _21: t_Color = Any.any_l ()
    | & _22: MutBorrow.t t_Node = Any.any_l ()
    | & _23: t_Option'2 = Any.any_l ()
    | & _24: MutBorrow.t t_Option = Any.any_l () ])
    [ return''0 (result: t_Option'1) -> {[@expl:delete result type invariant] [%#sred_black_tree'2] inv'13 result}
      {[@expl:delete ensures #0] [%#sred_black_tree'3] match result with
        | C_Some'1 {_p0 = k; _p1 = v} -> deep_model k = deep_model'0 key
        /\ Map.get (view'1 self) (deep_model'0 key) = C_Some'0 v
        | C_None'1 -> Map.get (view'1 self) (deep_model'0 key) = C_None'0
        end}
      {[@expl:delete ensures #1] [%#sred_black_tree'4] view'0 self.final
      = Map.set (view'1 self) (deep_model'0 key) (C_None'0)}
      (! return' {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__get [#"red_black_tree.rs" 874 4 874 44] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 875 8 875 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 880 20 880 116
  let%span sred_black_tree'1 = "red_black_tree.rs" 878 8 878 31
  let%span sred_black_tree'2 = "red_black_tree.rs" 878 20 878 29
  let%span sred_black_tree'3 = "red_black_tree.rs" 874 16 874 20
  let%span sred_black_tree'4 = "red_black_tree.rs" 874 22 874 25
  let%span sred_black_tree'5 = "red_black_tree.rs" 874 34 874 44
  let%span sred_black_tree'6 = "red_black_tree.rs" 870 14 873 5
  let%span sred_black_tree'7 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'8 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'9 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'10 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'11 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'13 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'14 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'15 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'16 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'17 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'18 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'19 = "red_black_tree.rs" 1 0 979 4
  let%span sred_black_tree'20 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'21 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'22 = "red_black_tree.rs" 760 8 762 9
  let%span sred_black_tree'23 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'24 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'25 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'26 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'27 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'28 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'29 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'30 = "red_black_tree.rs" 319 12 327 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 43 8 43 22
  
  use map.Map
  use map.Const
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'10] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'18] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'21] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'12] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'14] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'13] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'17] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'15] bst_invariant self)
      -> ([%#sred_black_tree'16] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'9] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'7] bst_invariant self)
      -> ([%#sred_black_tree'8] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate invariant''0 [@inline:trivial] (self: t_Tree) = [%#sinvariant] inv'2 self
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type tuple = { _p0: t_K; _p1: t_K }
  
  predicate invariant''1 [@inline:trivial] (self: t_K) = [%#sinvariant] inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: t_K)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_K [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    [%#sred_black_tree'19] forall args: tuple [precondition () args]. (let {_p0 = self_; _p1 = rhs} = args in inv'6 rhs
        /\ inv'6 self_) -> precondition () args
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    [%#sred_black_tree'19] forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {_p0 = self_; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return' (x: t_Ordering)) = {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                          _p1 = rhs }}
    any
    [ return''0 (result: t_Ordering) -> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  type t_Option'1 = C_None'1 | C_Some'1 t_V
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'30] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'29] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'28] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'26] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'23] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'25] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'27] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'24] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant''2 [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'22] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'7 (_0: t_Map)
  
  axiom inv_axiom'5 [@rewrite]: forall x: t_Map [inv'7 x]. inv'7 x
      = (invariant''2 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''3 [@inline:trivial] (self: t_Map) = [%#sinvariant] inv'7 self
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: t_Map)
  
  axiom inv_axiom'6 [@rewrite]: forall x: t_Map [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate invariant''4 [@inline:trivial] (self: t_V) = [%#sinvariant] inv'0 self
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: t_V)
  
  axiom inv_axiom'7 [@rewrite]: forall x: t_V [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate inv'10 (_0: t_Option'1)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Option'1 [inv'10 x]. inv'10 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'9 a_0
        end
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'20] view self.t_Map__0
  
  function view'1 [@inline:trivial] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 = [%#smodel'0] view'0 self
  
  meta "rewrite_def" function view'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get [#"red_black_tree.rs" 874 4 874 44] (self: t_Map) (key: t_K) (return' (x: t_Option'1)) =
    {[@expl:get 'self' type invariant] [%#sred_black_tree'3] inv'8 self}
    {[@expl:get 'key' type invariant] [%#sred_black_tree'4] inv'6 key}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &tree <- self'0.t_Map__0 ] s1 | s1 = bb2 ]
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:loop invariant #0] [%#sred_black_tree'2] inv'5 tree}
        {[@expl:loop invariant #1] [%#sred_black_tree'1] bst_invariant tree}
        {[@expl:loop invariant #2] [%#sred_black_tree'0] forall v: t_V. has_mapping self'0.t_Map__0 (deep_model'0 key'0) v
          = has_mapping tree (deep_model'0 key'0) v}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_14 <- tree.t_Tree__node ] s1
          | s1 = any [ br0 -> {_14 = C_None} (! bb14) | br1 (x0: t_Node) -> {_14 = C_Some x0} (! bb5) ] ]
        | bb5 = s0
          [ s0 = v_Some {_14} (fun (r0: t_Node) -> [ &node <- r0 ] s1)
          | s1 = [ &_20 <- node.t_Node__key ] s2
          | s2 = cmp {key'0} {_20} (fun (_ret: t_Ordering) -> [ &_17 <- _ret ] s3)
          | s3 = bb6 ]
        | bb6 = any
          [ br0 -> {_17 = C_Less} (! bb12) | br1 -> {_17 = C_Equal} (! bb11) | br2 -> {_17 = C_Greater} (! bb10) ]
        | bb10 = s0 [ s0 = [ &_28 <- node.t_Node__right ] s1 | s1 = [ &tree <- _28 ] s2 | s2 = bb2'0 ]
        | bb12 = s0 [ s0 = [ &_23 <- node.t_Node__left ] s1 | s1 = [ &tree <- _23 ] s2 | s2 = bb2'0 ] ] ]
    | bb14 = s0 [ s0 = [ &_0 <- C_None'1 ] s1 | s1 = bb15 ]
    | bb11 = s0 [ s0 = [ &_26 <- node.t_Node__val ] s1 | s1 = [ &_0 <- C_Some'1 _26 ] s2 | s2 = bb15 ]
    | bb15 = return''0 {_0} ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: t_Map = self
    | & key'0: t_K = key
    | & _5: () = Any.any_l ()
    | & tree: t_Tree = Any.any_l ()
    | & _14: t_Option = Any.any_l ()
    | & node: t_Node = Any.any_l ()
    | & _17: t_Ordering = Any.any_l ()
    | & _20: t_K = Any.any_l ()
    | & _23: t_Tree = Any.any_l ()
    | & _26: t_V = Any.any_l ()
    | & _28: t_Tree = Any.any_l () ])
    [ return''0 (result: t_Option'1) -> {[@expl:get result type invariant] [%#sred_black_tree'5] inv'10 result}
      {[@expl:get ensures] [%#sred_black_tree'6] match result with
        | C_Some'1 v -> Map.get (view'1 self) (deep_model'0 key) = C_Some'0 v
        | C_None'1 -> Map.get (view'1 self) (deep_model'0 key) = C_None'0
        end}
      (! return' {result}) ]
end
module M_red_black_tree__qyi1722927563742988856__get_mut [#"red_black_tree.rs" 895 4 895 56] (* Map<K, V> *)
  let%span sred_black_tree = "red_black_tree.rs" 896 8 896 53
  let%span sred_black_tree'0 = "red_black_tree.rs" 899 23 899 41
  let%span sred_black_tree'1 = "red_black_tree.rs" 912 20 913 84
  let%span sred_black_tree'2 = "red_black_tree.rs" 911 20 911 90
  let%span sred_black_tree'3 = "red_black_tree.rs" 909 20 910 51
  let%span sred_black_tree'4 = "red_black_tree.rs" 907 20 908 80
  let%span sred_black_tree'5 = "red_black_tree.rs" 906 20 906 122
  let%span sred_black_tree'6 = "red_black_tree.rs" 905 20 905 122
  let%span sred_black_tree'7 = "red_black_tree.rs" 901 8 901 31
  let%span sred_black_tree'8 = "red_black_tree.rs" 901 20 901 29
  let%span sred_black_tree'9 = "red_black_tree.rs" 895 24 895 28
  let%span sred_black_tree'10 = "red_black_tree.rs" 895 30 895 33
  let%span sred_black_tree'11 = "red_black_tree.rs" 895 42 895 56
  let%span sred_black_tree'12 = "red_black_tree.rs" 891 14 894 5
  let%span sred_black_tree'13 = "red_black_tree.rs" 103 4 103 37
  let%span sred_black_tree'14 = "red_black_tree.rs" 104 14 104 78
  let%span sred_black_tree'15 = "red_black_tree.rs" 109 8 112 11
  let%span sred_black_tree'16 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'17 = "red_black_tree.rs" 255 12 260 13
  let%span sred_black_tree'18 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'19 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'20 = "red_black_tree.rs" 319 12 327 13
  let%span sred_black_tree'21 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'22 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'23 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'24 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'25 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'26 = "red_black_tree.rs" 65 14 66 91
  let%span sred_black_tree'27 = "red_black_tree.rs" 69 12 77 13
  let%span sred_black_tree'28 = "red_black_tree.rs" 82 4 82 37
  let%span sred_black_tree'29 = "red_black_tree.rs" 83 14 83 92
  let%span sred_black_tree'30 = "red_black_tree.rs" 89 12 98 13
  let%span sred_black_tree'31 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'32 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'33 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'34 = "red_black_tree.rs" 1 0 979 4
  let%span sred_black_tree'35 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'36 = "red_black_tree.rs" 760 8 762 9
  let%span sred_black_tree'37 = "red_black_tree.rs" 377 8 379 9
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 99 20 99 44
  let%span sinvariant'0 = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 59 8 59 22
  
  use map.Map
  use map.Const
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'16] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'32] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'22] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'35] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'25] model_acc self (Const.const (C_None'0))
  
  function model_acc_has_mapping [#"red_black_tree.rs" 67 4 67 83] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'27] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = model_acc_has_mapping left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc_has_mapping right accu2 k
      end
  
  axiom model_acc_has_mapping_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. [%#sred_black_tree'26] Map.get (model_acc self accu) k
        = Map.get accu k
      \/ (exists v: t_V. Map.get (model_acc self accu) k = C_Some'0 v /\ has_mapping self k v)
  
  function has_mapping_model_acc [#"red_black_tree.rs" 84 4 86 33] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) (k: t_DeepModelTy) : ()
   = [%#sred_black_tree'30] match self with
      | {t_Tree__node = C_None} -> ()
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let _ = has_mapping_model_acc left accu k in let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in let _ = has_mapping_model_acc right accu2 k in model_acc_has_mapping right accu2 k
      end
  
  axiom has_mapping_model_acc_spec:
    forall self: t_Tree, accu: Map.map t_DeepModelTy t_Option'0, k: t_DeepModelTy. ([%#sred_black_tree'28] bst_invariant self)
      -> ([%#sred_black_tree'29] forall v: t_V. has_mapping self k v -> Map.get (model_acc self accu) k = C_Some'0 v)
  
  function has_mapping_model [#"red_black_tree.rs" 105 4 107 33] (self: t_Tree) (k: t_DeepModelTy) : () =
    [%#sred_black_tree'15] let _ = model_acc_has_mapping self (Const.const (C_None'0)) k in has_mapping_model_acc self (Const.const (C_None'0)) k
  
  axiom has_mapping_model_spec: forall self: t_Tree, k: t_DeepModelTy. ([%#sred_black_tree'13] bst_invariant self)
      -> ([%#sred_black_tree'14] forall v: t_V. has_mapping self k v = (Map.get (view self) k = C_Some'0 v))
  
  type t_Map = { t_Map__0: t_Tree }
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  type t_CP = C_CPL t_Color | C_CPN t_Color t_CP t_CP
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'18] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'33] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'23] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate match_t [#"red_black_tree.rs" 253 4 253 52] (self: t_CP) (tree: t_Tree) =
    [%#sred_black_tree'17] match self with
      | C_CPL color'0 -> color tree = color'0 /\ color_invariant tree
      | C_CPN color'0 l r -> exists node: t_Node. tree.t_Tree__node = C_Some node
        /\ node.t_Node__color = color'0 /\ match_t l node.t_Node__left /\ match_t r node.t_Node__right
      end
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'20] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color'0}} -> match color'0 with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'19] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'31] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'21] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  function deep_model'0 [@inline:trivial] (self: t_K) : t_DeepModelTy = [%#smodel] deep_model self
  
  meta "rewrite_def" function deep_model'0
  
  predicate invariant''0 [@inline:trivial] (self: MutBorrow.t t_Tree) =
    [%#sinvariant] inv'2 self.current /\ inv'2 self.final
  
  meta "rewrite_def" predicate invariant''0
  
  predicate inv'5 (_0: MutBorrow.t t_Tree)
  
  axiom inv_axiom'3 [@rewrite]: forall x: MutBorrow.t t_Tree [inv'5 x]. inv'5 x = invariant''0 x
  
  let rec v_Some (input: t_Option) (ret (field_0: t_Node)) = any
    [ good (field_0: t_Node) -> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Node [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  type tuple = { _p0: t_K; _p1: t_K }
  
  predicate invariant''1 [@inline:trivial] (self: t_K) = [%#sinvariant'0] inv self
  
  meta "rewrite_def" predicate invariant''1
  
  predicate inv'6 (_0: t_K)
  
  axiom inv_axiom'4 [@rewrite]: forall x: t_K [inv'6 x]. inv'6 x = invariant''1 x
  
  predicate precondition (self: ()) (args: tuple)
  
  axiom precondition_fndef:
    [%#sred_black_tree'34] forall args: tuple [precondition () args]. (let {_p0 = self_; _p1 = rhs} = args in inv'6 rhs
        /\ inv'6 self_) -> precondition () args
  
  predicate postcondition_once (self: ()) (args: tuple) (result: t_Ordering)
  
  axiom postcondition_fndef:
    [%#sred_black_tree'34] forall args: tuple, res: t_Ordering [postcondition_once () args res]. postcondition_once () args res
      -> (let {_p0 = self_; _p1 = rhs} = args in res = cmp_log (deep_model self_) (deep_model rhs))
  
  let rec cmp (self_: t_K) (rhs: t_K) (return' (x: t_Ordering)) = {[@expl:cmp requires] precondition () { _p0 = self_;
                                                                                                          _p1 = rhs }}
    any
    [ return''0 (result: t_Ordering) -> {postcondition_once () { _p0 = self_; _p1 = rhs } result} (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t t_Tree) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t t_Tree) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate invariant''2 [@inline:trivial] (self: MutBorrow.t t_Node) =
    [%#sinvariant] inv'3 self.current /\ inv'3 self.final
  
  meta "rewrite_def" predicate invariant''2
  
  predicate inv'7 (_0: MutBorrow.t t_Node)
  
  axiom inv_axiom'5 [@rewrite]: forall x: MutBorrow.t t_Node [inv'7 x]. inv'7 x = invariant''2 x
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Node) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Node) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate invariant''3 [@inline:trivial] (self: MutBorrow.t t_Option) =
    [%#sinvariant] inv'4 self.current /\ inv'4 self.final
  
  meta "rewrite_def" predicate invariant''3
  
  predicate inv'8 (_0: MutBorrow.t t_Option)
  
  axiom inv_axiom'6 [@rewrite]: forall x: MutBorrow.t t_Option [inv'8 x]. inv'8 x = invariant''3 x
  
  predicate resolve'3 [@inline:trivial] (self: MutBorrow.t t_Option) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (_0: MutBorrow.t t_Option) = resolve'3 _0
  
  meta "rewrite_def" predicate resolve'4
  
  type t_Option'1 = C_None'1 | C_Some'1 (MutBorrow.t t_V)
  
  predicate invariant''4 [@inline:trivial] (self: MutBorrow.t t_V) =
    [%#sinvariant] inv'0 self.current /\ inv'0 self.final
  
  meta "rewrite_def" predicate invariant''4
  
  predicate inv'9 (_0: MutBorrow.t t_V)
  
  axiom inv_axiom'7 [@rewrite]: forall x: MutBorrow.t t_V [inv'9 x]. inv'9 x = invariant''4 x
  
  predicate resolve'5 [@inline:trivial] (self: MutBorrow.t t_V) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'5
  
  predicate resolve'6 [@inline:trivial] (_0: MutBorrow.t t_V) = resolve'5 _0
  
  meta "rewrite_def" predicate resolve'6
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'37] bst_invariant self /\ height_invariant self
  
  predicate invariant''5 [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'36] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv'10 (_0: t_Map)
  
  axiom inv_axiom'8 [@rewrite]: forall x: t_Map [inv'10 x]. inv'10 x
      = (invariant''5 x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  predicate invariant''6 [@inline:trivial] (self: MutBorrow.t t_Map) =
    [%#sinvariant] inv'10 self.current /\ inv'10 self.final
  
  meta "rewrite_def" predicate invariant''6
  
  predicate inv'11 (_0: MutBorrow.t t_Map)
  
  axiom inv_axiom'9 [@rewrite]: forall x: MutBorrow.t t_Map [inv'11 x]. inv'11 x = invariant''6 x
  
  predicate resolve'7 [@inline:trivial] (self: MutBorrow.t t_Map) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'7
  
  predicate resolve'8 [@inline:trivial] (_0: MutBorrow.t t_Map) = resolve'7 _0
  
  meta "rewrite_def" predicate resolve'8
  
  predicate inv'12 (_0: t_Option'1)
  
  axiom inv_axiom'10 [@rewrite]: forall x: t_Option'1 [inv'12 x]. inv'12 x
      = match x with
        | C_None'1 -> true
        | C_Some'1 a_0 -> inv'9 a_0
        end
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'24] view self.t_Map__0
  
  function view'1 [@inline:trivial] (self: MutBorrow.t t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#smodel'0] view'0 self.current
  
  meta "rewrite_def" function view'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_mut [#"red_black_tree.rs" 895 4 895 56] (self: MutBorrow.t t_Map) (key: t_K) (return' (x: t_Option'1)) =
    {[@expl:get_mut 'self' type invariant] [%#sred_black_tree'9] inv'11 self}
    {[@expl:get_mut 'key' type invariant] [%#sred_black_tree'10] inv'6 key}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- [%#sred_black_tree] () ] s1 | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {inv'2 (self'0.current).t_Map__0}
        MutBorrow.borrow_final <t_Tree> {(self'0.current).t_Map__0} {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret: MutBorrow.t t_Tree) ->
            [ &tree <- _ret ] -{inv'2 _ret.final}-
            [ &self'0 <- { self'0 with current = { t_Map__0 = _ret.final } } ] s1)
      | s1 = [ &old_tree <- [%#sred_black_tree'0] tree ] s2
      | s2 = bb3 ]
    | bb3 = bb3'0
      [ bb3'0 = {[@expl:loop invariant #0] [%#sred_black_tree'8] inv'5 tree}
        {[@expl:loop invariant #1] [%#sred_black_tree'7] bst_invariant tree.current}
        {[@expl:loop invariant #2] [%#sred_black_tree'7] height_invariant tree.current}
        {[@expl:loop invariant #3] [%#sred_black_tree'7] color_invariant tree.current}
        {[@expl:loop invariant #4] [%#sred_black_tree'6] forall v: t_V. has_mapping tree.final (deep_model'0 key'0) v
          = has_mapping old_tree.final (deep_model'0 key'0) v}
        {[@expl:loop invariant #5] [%#sred_black_tree'5] forall v: t_V. has_mapping tree.current (deep_model'0 key'0) v
          = has_mapping old_tree.current (deep_model'0 key'0) v}
        {[@expl:loop invariant #6] [%#sred_black_tree'4] (forall k: t_DeepModelTy, v: t_V. k = deep_model'0 key'0
            \/ has_mapping tree.current k v = has_mapping tree.final k v)
        -> bst_invariant tree.final -> bst_invariant old_tree.final}
        {[@expl:loop invariant #7] [%#sred_black_tree'3] height tree.current = height tree.final
          /\ height_invariant tree.final -> height_invariant old_tree.final}
        {[@expl:loop invariant #8] [%#sred_black_tree'2] match_t (C_CPL (color tree.current)) tree.final
        -> match_t (C_CPL (C_Black)) old_tree.final}
        {[@expl:loop invariant #9] [%#sred_black_tree'1] forall k: t_DeepModelTy, v: t_V. has_mapping tree.current k v
            = has_mapping tree.final k v -> has_mapping old_tree.current k v = has_mapping old_tree.final k v}
        (! s0)
        [ s0 = bb4 ]
        [ bb4 = s0
          [ s0 = {inv'4 (tree.current).t_Tree__node}
            MutBorrow.borrow_final <t_Option> {(tree.current).t_Tree__node}
              {MutBorrow.inherit_id (MutBorrow.get_id tree) 1}
              (fun (_ret: MutBorrow.t t_Option) ->
                [ &_23 <- _ret ] -{inv'4 _ret.final}-
                [ &tree <- { tree with current = { t_Tree__node = _ret.final } } ] s1)
          | s1 = any
            [ br0 -> {_23.current = C_None} (! bb15) | br1 (x0: t_Node) -> {_23.current = C_Some x0} (! bb6) ] ]
        | bb6 = s0
          [ s0 = v_Some {_23.current}
              (fun (r0: t_Node) ->
                {inv'3 r0}
                MutBorrow.borrow_final <t_Node> {r0} {MutBorrow.inherit_id (MutBorrow.get_id _23) 1}
                  (fun (_ret: MutBorrow.t t_Node) ->
                    [ &node <- _ret ] -{inv'3 _ret.final}-
                    [ &_23 <- { _23 with current = C_Some _ret.final } ] s1))
          | s1 = [ &_29 <- (node.current).t_Node__key ] s2
          | s2 = cmp {key'0} {_29} (fun (_ret: t_Ordering) -> [ &_26 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = any
          [ br0 -> {_26 = C_Less} (! bb13) | br1 -> {_26 = C_Equal} (! bb12) | br2 -> {_26 = C_Greater} (! bb11) ]
        | bb11 = s0
          [ s0 = {inv'2 (node.current).t_Node__right}
            MutBorrow.borrow_final <t_Tree> {(node.current).t_Node__right}
              {MutBorrow.inherit_id (MutBorrow.get_id node) 5}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_37 <- _ret ] -{inv'2 _ret.final}-
                [ &node <- { node with current = { node.current with t_Node__right = _ret.final } } ] s1)
          | s1 = {inv'2 _37.current}
            MutBorrow.borrow_final <t_Tree> {_37.current} {MutBorrow.get_id _37}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_36 <- _ret ] -{inv'2 _ret.final}-
                [ &_37 <- { _37 with current = _ret.final } ] s2)
          | s2 = {[@expl:type invariant] inv'5 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 = [ &tree <- _36 ] s5
          | s5 = {[@expl:type invariant] inv'5 _37} s6
          | s6 = -{resolve'0 _37}- s7
          | s7 = bb14 ]
        | bb13 = s0
          [ s0 = {inv'2 (node.current).t_Node__left}
            MutBorrow.borrow_final <t_Tree> {(node.current).t_Node__left}
              {MutBorrow.inherit_id (MutBorrow.get_id node) 1}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_32 <- _ret ] -{inv'2 _ret.final}-
                [ &node <- { node with current = { node.current with t_Node__left = _ret.final } } ] s1)
          | s1 = {inv'2 _32.current}
            MutBorrow.borrow_final <t_Tree> {_32.current} {MutBorrow.get_id _32}
              (fun (_ret: MutBorrow.t t_Tree) ->
                [ &_31 <- _ret ] -{inv'2 _ret.final}-
                [ &_32 <- { _32 with current = _ret.final } ] s2)
          | s2 = {[@expl:type invariant] inv'5 tree} s3
          | s3 = -{resolve'0 tree}- s4
          | s4 = [ &tree <- _31 ] s5
          | s5 = {[@expl:type invariant] inv'5 _32} s6
          | s6 = -{resolve'0 _32}- s7
          | s7 = bb14 ]
        | bb14 = s0
          [ s0 = {[@expl:type invariant] inv'7 node} s1
          | s1 = -{resolve'2 node}- s2
          | s2 = {[@expl:type invariant] inv'8 _23} s3
          | s3 = -{resolve'4 _23}- s4
          | s4 = bb3'0 ] ] ]
    | bb15 = s0
      [ s0 = {[@expl:type invariant] inv'8 _23} s1
      | s1 = -{resolve'4 _23}- s2
      | s2 = [ &_0 <- C_None'1 ] s3
      | s3 = bb16 ]
    | bb12 = s0
      [ s0 = {inv'0 (node.current).t_Node__val}
        MutBorrow.borrow_final <t_V> {(node.current).t_Node__val} {MutBorrow.inherit_id (MutBorrow.get_id node) 4}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_35 <- _ret ] -{inv'0 _ret.final}-
            [ &node <- { node with current = { node.current with t_Node__val = _ret.final } } ] s1)
      | s1 = {inv'0 _35.current}
        MutBorrow.borrow_final <t_V> {_35.current} {MutBorrow.get_id _35}
          (fun (_ret: MutBorrow.t t_V) ->
            [ &_34 <- _ret ] -{inv'0 _ret.final}-
            [ &_35 <- { _35 with current = _ret.final } ] s2)
      | s2 = [ &_0 <- C_Some'1 _34 ] s3
      | s3 = {[@expl:type invariant] inv'9 _35} s4
      | s4 = -{resolve'6 _35}- s5
      | s5 = {[@expl:type invariant] inv'7 node} s6
      | s6 = -{resolve'2 node}- s7
      | s7 = {[@expl:type invariant] inv'8 _23} s8
      | s8 = -{resolve'4 _23}- s9
      | s9 = bb16 ]
    | bb16 = s0
      [ s0 = {[@expl:type invariant] inv'5 tree} s1
      | s1 = -{resolve'0 tree}- s2
      | s2 = {[@expl:type invariant] inv'11 self'0} s3
      | s3 = -{resolve'8 self'0}- s4
      | s4 = return''0 {_0} ] ]
    [ & _0: t_Option'1 = Any.any_l ()
    | & self'0: MutBorrow.t t_Map = self
    | & key'0: t_K = key
    | & _5: () = Any.any_l ()
    | & tree: MutBorrow.t t_Tree = Any.any_l ()
    | & old_tree: MutBorrow.t t_Tree = Any.any_l ()
    | & _23: MutBorrow.t t_Option = Any.any_l ()
    | & node: MutBorrow.t t_Node = Any.any_l ()
    | & _26: t_Ordering = Any.any_l ()
    | & _29: t_K = Any.any_l ()
    | & _31: MutBorrow.t t_Tree = Any.any_l ()
    | & _32: MutBorrow.t t_Tree = Any.any_l ()
    | & _34: MutBorrow.t t_V = Any.any_l ()
    | & _35: MutBorrow.t t_V = Any.any_l ()
    | & _36: MutBorrow.t t_Tree = Any.any_l ()
    | & _37: MutBorrow.t t_Tree = Any.any_l () ])
    [ return''0 (result: t_Option'1) -> {[@expl:get_mut result type invariant] [%#sred_black_tree'11] inv'12 result}
      {[@expl:get_mut ensures] [%#sred_black_tree'12] match result with
        | C_Some'1 v -> Map.get (view'1 self) (deep_model'0 key) = C_Some'0 (v.current)
        /\ view'0 self.final = Map.set (view'1 self) (deep_model'0 key) (C_Some'0 (v.final))
        | C_None'1 -> Map.get (view'1 self) (deep_model'0 key) = C_None'0 /\ view'0 self.final = view'1 self
        end}
      (! return' {result}) ]
end
module M_red_black_tree__qyi8412372133095258695__resolve_coherence__refines [#"red_black_tree.rs" 181 4 181 30] (* <Tree<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 181 4 181 30
  let%span sred_black_tree'0 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'1 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'2 = "red_black_tree.rs" 188 12 188 62
  let%span sred_black_tree'3 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'4 = "red_black_tree.rs" 136 8 139 9
  let%span soption = "../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 56 8 56 22
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'1] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'3] forall node: t_Node. self
          = node -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 186 4 186 28] (self: t_Node) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_0: t_Node) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (self: t_Node) = [%#sresolve] resolve'1 self
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: t_Node) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  predicate resolve'4 [@inline:trivial] (self: t_Option) =
    [%#soption] match self with
      | C_Some x -> resolve'3 x
      | C_None -> true
      end
  
  meta "rewrite_def" predicate resolve'4
  
  predicate resolve'5 [@inline:trivial] (_0: t_Option) = resolve'4 _0
  
  meta "rewrite_def" predicate resolve'5
  
  predicate structural_resolve (_0: t_Tree) =
    match _0 with
      | {t_Tree__node = x0} -> resolve'5 x0
      end
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant' x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate resolve'6 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'0] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sred_black_tree] forall self: t_Tree. structural_resolve self /\ inv'2 self
      -> structural_resolve self /\ (forall result: (). resolve'6 self -> resolve'6 self)
end
module M_red_black_tree__qyi17767811206440054577__resolve_coherence__refines [#"red_black_tree.rs" 195 4 195 30] (* <Node<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 195 4 195 30
  let%span sred_black_tree'0 = "red_black_tree.rs" 188 12 188 62
  let%span sred_black_tree'1 = "red_black_tree.rs" 133 14 134 84
  let%span sred_black_tree'2 = "red_black_tree.rs" 136 8 139 9
  let%span sred_black_tree'3 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'4 = "red_black_tree.rs" 35 12 39 13
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  with t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'4] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'3] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_0: t_Tree) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 (_0: t_K)
  
  predicate structural_resolve (_0: t_Node) =
    match _0 with
      | {t_Node__left = x0; t_Node__color = x1; t_Node__key = x2; t_Node__val = x3; t_Node__right = x4} -> resolve'1 x4
      /\ resolve x3 /\ resolve'2 x2 /\ resolve'1 x0
      end
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate invariant' (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'2 (_0: t_Node)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'2 x]. inv'2 x = invariant' x
  
  predicate inv'3 (_0: t_Option)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option [inv'3 x]. inv'3 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'2 a_0
        end
  
  predicate inv'4 (_0: t_Tree)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Tree [inv'4 x]. inv'4 x
      = match x with
        | {t_Tree__node = node} -> inv'3 node
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'4 left
        /\ inv key /\ inv'0 val' /\ inv'4 right
        end
  
  predicate has_mapping'0 [#"red_black_tree.rs" 135 4 135 57] (self: t_Node) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'2] has_mapping self.t_Node__left k v
    \/ has_mapping self.t_Node__right k v \/ k = deep_model self.t_Node__key /\ v = self.t_Node__val
  
  axiom has_mapping_spec: forall self: t_Node, k: t_DeepModelTy, v: t_V. [%#sred_black_tree'1] forall node: t_Node. self
          = node -> has_mapping'0 self k v = has_mapping { t_Tree__node = C_Some node } k v
  
  predicate resolve'3 [#"red_black_tree.rs" 186 4 186 28] (self: t_Node) =
    [%#sred_black_tree'0] forall k: t_DeepModelTy, v: t_V. has_mapping'0 self k v -> resolve v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sred_black_tree] forall self: t_Node. structural_resolve self /\ inv'1 self
      -> structural_resolve self /\ (forall result: (). resolve'3 self -> resolve'3 self)
end
module M_red_black_tree__qyi7670249875066633436__resolve_coherence__refines [#"red_black_tree.rs" 778 4 778 30] (* <Map<K, V> as creusot_contracts::Resolve> *)
  let%span sred_black_tree = "red_black_tree.rs" 778 4 778 30
  let%span sred_black_tree'0 = "red_black_tree.rs" 772 20 772 67
  let%span sred_black_tree'1 = "red_black_tree.rs" 750 20 750 27
  let%span sred_black_tree'2 = "red_black_tree.rs" 174 12 174 62
  let%span sred_black_tree'3 = "red_black_tree.rs" 760 8 762 9
  let%span sred_black_tree'4 = "red_black_tree.rs" 166 8 166 56
  let%span sred_black_tree'5 = "red_black_tree.rs" 35 12 39 13
  let%span sred_black_tree'6 = "red_black_tree.rs" 377 8 379 9
  let%span sred_black_tree'7 = "red_black_tree.rs" 289 12 295 13
  let%span sred_black_tree'8 = "red_black_tree.rs" 279 12 282 13
  let%span sred_black_tree'9 = "red_black_tree.rs" 53 12 60 13
  let%span sred_black_tree'10 = "red_black_tree.rs" 227 12 233 13
  let%span sred_black_tree'11 = "red_black_tree.rs" 334 12 340 13
  let%span sred_black_tree'12 = "red_black_tree.rs" 303 20 303 102
  let%span sred_black_tree'13 = "red_black_tree.rs" 207 12 208 104
  let%span sred_black_tree'14 = "red_black_tree.rs" 360 20 360 61
  let%span sred_black_tree'15 = "red_black_tree.rs" 316 14 316 25
  let%span sred_black_tree'16 = "red_black_tree.rs" 319 12 327 13
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 28 14 28 64
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 38 14 38 61
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 48 14 48 61
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 58 14 58 64
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 63 14 63 45
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 68 15 68 32
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 69 15 69 32
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 70 14 70 31
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 77 15 77 45
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 78 14 78 47
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 85 15 85 48
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 86 14 86 44
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 91 14 91 59
  let%span soption = "../../creusot-contracts/src/std/option.rs" 772 8 775 9
  let%span sboxed = "../../creusot-contracts/src/std/boxed.rs" 30 8 30 18
  
  use mach.int.Int
  use map.Map
  use map.Const
  
  type t_Color = C_Red | C_Black
  
  type t_K
  
  type t_V
  
  type t_Node = {
    t_Node__left: t_Tree;
    t_Node__color: t_Color;
    t_Node__key: t_K;
    t_Node__val: t_V;
    t_Node__right: t_Tree }
  with t_Option = C_None | C_Some t_Node
  with t_Tree = { t_Tree__node: t_Option }
  
  type t_Map = { t_Map__0: t_Tree }
  
  type t_DeepModelTy
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate has_mapping [#"red_black_tree.rs" 33 4 33 57] (self: t_Tree) (k: t_DeepModelTy) (v: t_V) =
    [%#sred_black_tree'5] match self with
      | {t_Tree__node = C_None} -> false
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> has_mapping left k v
      \/ has_mapping right k v \/ k = deep_model key /\ v = val'
      end
  
  predicate resolve (_0: t_V)
  
  predicate resolve'0 [#"red_black_tree.rs" 172 4 172 28] (self: t_Tree) =
    [%#sred_black_tree'2] forall k: t_DeepModelTy, v: t_V. has_mapping self k v -> resolve v
  
  predicate resolve'1 [@inline:trivial] (_0: t_Tree) = resolve'0 _0
  
  meta "rewrite_def" predicate resolve'1
  
  predicate structural_resolve (_0: t_Map) =
    match _0 with
      | {t_Map__0 = x0} -> resolve'1 x0
      end
  
  type t_Ordering = C_Less | C_Equal | C_Greater
  
  function cmp_log (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'9] cmp_log x y = C_Greater)
      -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ([%#sord'7] cmp_log x y = C_Less)
      -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. ([%#sord'4] cmp_log x y
        = o) -> ([%#sord'5] cmp_log y z = o) -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: t_DeepModelTy) : ()
  
  axiom refl_spec: forall x: t_DeepModelTy. [%#sord'3] cmp_log x x = C_Equal
  
  predicate gt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'2] gt_log x y = (cmp_log x y = C_Greater)
  
  predicate ge_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'1] ge_log x y = (cmp_log x y <> C_Less)
  
  predicate lt_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord'0] lt_log x y = (cmp_log x y = C_Less)
  
  predicate le_log (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. [%#sord] le_log x y = (cmp_log x y <> C_Greater)
  
  predicate bst_invariant_here [#"red_black_tree.rs" 205 4 205 39] (self: t_Node) =
    [%#sred_black_tree'13] (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__left k v
        -> lt_log k (deep_model self.t_Node__key))
    /\ (forall k: t_DeepModelTy, v: t_V. has_mapping self.t_Node__right k v -> lt_log (deep_model self.t_Node__key) k)
  
  predicate bst_invariant [#"red_black_tree.rs" 225 4 225 34] (self: t_Tree) =
    [%#sred_black_tree'10] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in bst_invariant_here node
      /\ bst_invariant left /\ bst_invariant right
      end
  
  function height [#"red_black_tree.rs" 317 4 317 26] (self: t_Tree) : int = [%#sred_black_tree'16] match self with
      | {t_Tree__node = C_None} -> 0
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__color = color}} -> match color with
        | C_Red -> height left
        | C_Black -> height left + 1
        end
      end
  
  axiom height_spec: forall self: t_Tree. [%#sred_black_tree'15] height self >= 0
  
  predicate height_invariant_here [#"red_black_tree.rs" 359 4 359 42] (self: t_Node) =
    [%#sred_black_tree'14] height self.t_Node__left = height self.t_Node__right
  
  predicate height_invariant [#"red_black_tree.rs" 332 4 332 37] (self: t_Tree) =
    [%#sred_black_tree'11] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in height_invariant_here node
      /\ height_invariant left /\ height_invariant right
      end
  
  predicate internal_invariant [#"red_black_tree.rs" 376 4 376 39] (self: t_Tree) =
    [%#sred_black_tree'6] bst_invariant self /\ height_invariant self
  
  function color [#"red_black_tree.rs" 277 4 277 27] (self: t_Tree) : t_Color =
    [%#sred_black_tree'8] match self.t_Tree__node with
      | C_Some {t_Node__color = color'0} -> color'0
      | _ -> C_Black
      end
  
  predicate color_invariant_here [#"red_black_tree.rs" 302 4 302 41] (self: t_Node) =
    [%#sred_black_tree'12] color self.t_Node__right = C_Black
    /\ (self.t_Node__color = C_Black \/ color self.t_Node__left = C_Black)
  
  predicate color_invariant [#"red_black_tree.rs" 287 4 287 36] (self: t_Tree) =
    [%#sred_black_tree'7] match self with
      | {t_Tree__node = C_None} -> true
      | {t_Tree__node = C_Some node} -> let {t_Node__left = left; t_Node__right = right} = node in color_invariant_here node
      /\ color_invariant left /\ color_invariant right
      end
  
  predicate invariant' [#"red_black_tree.rs" 759 4 759 30] (self: t_Map) =
    [%#sred_black_tree'3] internal_invariant self.t_Map__0
    /\ color_invariant self.t_Map__0 /\ color self.t_Map__0 = C_Black
  
  predicate inv (_0: t_K)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: t_Node)
  
  predicate inv'2 (_0: t_Tree)
  
  axiom inv_axiom [@rewrite]: forall x: t_Node [inv'1 x]. inv'1 x
      = match x with
        | {t_Node__left = left; t_Node__color = color'0; t_Node__key = key; t_Node__val = val'; t_Node__right = right} -> inv'2 left
        /\ inv key /\ inv'0 val' /\ inv'2 right
        end
  
  predicate invariant''0 (self: t_Node) = [%#sboxed] inv'1 self
  
  predicate inv'3 (_0: t_Node)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Node [inv'3 x]. inv'3 x = invariant''0 x
  
  predicate inv'4 (_0: t_Option)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option [inv'4 x]. inv'4 x
      = match x with
        | C_None -> true
        | C_Some a_0 -> inv'3 a_0
        end
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Tree [inv'2 x]. inv'2 x
      = match x with
        | {t_Tree__node = node} -> inv'4 node
        end
  
  predicate inv'5 (_0: t_Map)
  
  axiom inv_axiom'3 [@rewrite]: forall x: t_Map [inv'5 x]. inv'5 x
      = (invariant' x
      /\ match x with
        | {t_Map__0 = a_0} -> inv'2 a_0
        end)
  
  type t_Option'0 = C_None'0 | C_Some'0 t_V
  
  predicate resolve'2 [@inline:trivial] (self: t_Option'0) =
    [%#soption] match self with
      | C_Some'0 x -> resolve x
      | C_None'0 -> true
      end
  
  meta "rewrite_def" predicate resolve'2
  
  predicate resolve'3 [@inline:trivial] (_0: t_Option'0) = resolve'2 _0
  
  meta "rewrite_def" predicate resolve'3
  
  function model_acc [#"red_black_tree.rs" 51 4 51 78] (self: t_Tree) (accu: Map.map t_DeepModelTy t_Option'0) : Map.map t_DeepModelTy t_Option'0
   = [%#sred_black_tree'9] match self with
      | {t_Tree__node = C_None} -> accu
      | {t_Tree__node = C_Some {t_Node__left = left; t_Node__key = key; t_Node__val = val'; t_Node__right = right}} -> let accu1 = model_acc left accu in let accu2 = Map.set accu1 (deep_model key) (C_Some'0 val') in model_acc right accu2
      end
  
  function view [#"red_black_tree.rs" 165 4 165 33] (self: t_Tree) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'4] model_acc self (Const.const (C_None'0))
  
  function view'0 [#"red_black_tree.rs" 749 4 749 33] (self: t_Map) : Map.map t_DeepModelTy t_Option'0 =
    [%#sred_black_tree'1] view self.t_Map__0
  
  predicate resolve'4 [#"red_black_tree.rs" 771 4 771 28] (self: t_Map) =
    [%#sred_black_tree'0] forall k: t_DeepModelTy. resolve'3 (Map.get (view'0 self) k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sred_black_tree] forall self: t_Map. structural_resolve self /\ inv'5 self
      -> structural_resolve self /\ (forall result: (). resolve'4 self -> resolve'4 self)
end
