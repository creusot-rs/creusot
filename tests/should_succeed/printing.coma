module M_f
  use creusot.prelude.Any
  use int.Int
  
  type t_Arguments
  
  predicate inv_Arguments (_1: t_Arguments)
  
  let rec from_str (s: string) (return (x: t_Arguments)) = any
    [ return (result: t_Arguments) -> {[@stop_split] [@expl:from_str result type invariant] inv_Arguments result}
      (! return {result}) ]
  
  let rec _print (args: t_Arguments) (return (x: ())) =
    {[@stop_split] [@expl:_print 'args' type invariant] inv_Arguments args}
    any [ return (result: ()) -> (! return {result}) ]
  
  let rec _eprint (args: t_Arguments) (return (x: ())) =
    {[@stop_split] [@expl:_eprint 'args' type invariant] inv_Arguments args}
    any [ return (result: ()) -> (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = from_str {"Hello "} (fun (_x: t_Arguments) -> [ &_3 <- _x ] s1)
      | s1 = _print {_3} (fun (_x: ()) -> [ &_2 <- _x ] s2)
      | s2 = from_str {"world!\n"} (fun (_x: t_Arguments) -> [ &_6 <- _x ] s3)
      | s3 = _print {_6} (fun (_x: ()) -> [ &_5 <- _x ] s4)
      | s4 = from_str {"Hello "} (fun (_x: t_Arguments) -> [ &_9 <- _x ] s5)
      | s5 = _eprint {_9} (fun (_x: ()) -> [ &_8 <- _x ] s6)
      | s6 = from_str {"stderr!\n"} (fun (_x: t_Arguments) -> [ &_12 <- _x ] s7)
      | s7 = _eprint {_12} (fun (_x: ()) -> [ &_11 <- _x ] s8)
      | s8 = {[@expl:assertion] 1 + 1 = 2} s9
      | s9 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & _2: () = Any.any_l ()
    | & _3: t_Arguments = Any.any_l ()
    | & _5: () = Any.any_l ()
    | & _6: t_Arguments = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _9: t_Arguments = Any.any_l ()
    | & _11: () = Any.any_l ()
    | & _12: t_Arguments = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
