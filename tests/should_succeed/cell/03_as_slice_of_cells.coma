module M_splits_up
  use creusot.int.UInt32
  use mach.int.Int
  use map.Map
  use seq.Seq
  use creusot.slice.Slice64
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PredCell_slice_u32
  
  type t_PredCell_u32
  
  predicate index_Mapping_slice_u32_bool [@inline:trivial] (self: Map.map (Slice64.slice UInt32.t) bool) (a: Slice64.slice UInt32.t) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_slice_u32_bool
  
  function view_PredCell_slice_u32 (self: t_PredCell_slice_u32) : Map.map (Slice64.slice UInt32.t) bool
  
  predicate index_Mapping_u32_bool [@inline:trivial] (self: Map.map UInt32.t bool) (a: UInt32.t) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_u32_bool
  
  function index_slice_u32 [@inline:trivial] (self: Slice64.slice UInt32.t) (ix: int) : UInt32.t =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_u32
  
  function view_PredCell_u32 (self: t_PredCell_u32) : Map.map UInt32.t bool
  
  function index_slice_PredCell_u32 [@inline:trivial] (self: Slice64.slice t_PredCell_u32) (ix: int) : t_PredCell_u32 =
    Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_PredCell_u32
  
  let rec as_slice_of_cells_u32 (self: t_PredCell_slice_u32) (_pred: Seq.seq (Map.map UInt32.t bool))
    (return (x: Slice64.slice t_PredCell_u32)) =
    {[@expl:as_slice_of_cells requires] forall s: Slice64.slice UInt32.t. index_Mapping_slice_u32_bool (view_PredCell_slice_u32 self) s
      = (Seq.length _pred = Seq.length (Slice64.view s)
      /\ (forall i: int. 0 <= i /\ i < Seq.length (Slice64.view s)
        -> index_Mapping_u32_bool (Seq.get _pred i) (index_slice_u32 s i)))}
    any
    [ return (result: Slice64.slice t_PredCell_u32) -> {forall i: int. 0 <= i /\ i < Seq.length _pred
        -> view_PredCell_u32 (index_slice_PredCell_u32 result i) = Seq.get _pred i}
      {Seq.length (Slice64.view result) = Seq.length _pred}
      (! return {result}) ]
  
  let rec get_u32 (self: t_PredCell_u32) (return (x: UInt32.t)) = any
    [ return (result: UInt32.t) -> {index_Mapping_u32_bool (view_PredCell_u32 self) result} (! return {result}) ]
  
  type tup2_u32_u32 = { f0: UInt32.t; f1: UInt32.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec splits_up (cell: t_PredCell_slice_u32) (return (x: tup2_u32_u32)) =
    {[@expl:splits_up requires] forall s: Slice64.slice UInt32.t. index_Mapping_slice_u32_bool (view_PredCell_slice_u32 cell) s
      = (Seq.length (Slice64.view s) = 2
      /\ Int.mod (UInt32.t'int (index_slice_u32 s 0)) 2 = 0 /\ Int.mod (UInt32.t'int (index_slice_u32 s 1)) 2 = 1)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &snapshot <- let pred0 = fun (z: UInt32.t) -> Int.mod (UInt32.t'int z) 2
        = 0 in let pred1 = fun (z: UInt32.t) -> Int.mod (UInt32.t'int z) 2 = 1 in Seq.create 2 [|pred0;pred1|] ] s1
      | s1 = as_slice_of_cells_u32 {cell} {snapshot} (fun (_x: Slice64.slice t_PredCell_u32) -> [ &slice <- _x ] s2)
      | s2 = [ &_12 <- (0: UInt64.t) ] s3
      | s3 = [ &_13 <- Slice64.length slice ] s4
      | s4 = [ &_14 <- UInt64.lt _12 _13 ] s5
      | s5 = {[@expl:index in bounds] _14} s6
      | s6 = Slice64.get <t_PredCell_u32> {slice} {_12} (fun (r: t_PredCell_u32) -> [ &_11 <- r ] s7)
      | s7 = get_u32 {_11} (fun (_x: UInt32.t) -> [ &_10 <- _x ] s8)
      | s8 = [ &_17 <- (1: UInt64.t) ] s9
      | s9 = [ &_18 <- Slice64.length slice ] s10
      | s10 = [ &_19 <- UInt64.lt _17 _18 ] s11
      | s11 = {[@expl:index in bounds] _19} s12
      | s12 = Slice64.get <t_PredCell_u32> {slice} {_17} (fun (r: t_PredCell_u32) -> [ &_16 <- r ] s13)
      | s13 = get_u32 {_16} (fun (_x: UInt32.t) -> [ &_15 <- _x ] s14)
      | s14 = [ &_ret <- { f0 = _10; f1 = _15 } ] s15
      | s15 = return {_ret} ] ]
    [ & _ret: tup2_u32_u32 = Any.any_l ()
    | & cell: t_PredCell_slice_u32 = cell
    | & snapshot: Seq.seq (Map.map UInt32.t bool) = Any.any_l ()
    | & slice: Slice64.slice t_PredCell_u32 = Any.any_l ()
    | & _10: UInt32.t = Any.any_l ()
    | & _11: t_PredCell_u32 = Any.any_l ()
    | & _12: UInt64.t = Any.any_l ()
    | & _13: UInt64.t = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: UInt32.t = Any.any_l ()
    | & _16: t_PredCell_u32 = Any.any_l ()
    | & _17: UInt64.t = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _19: bool = Any.any_l () ])
    [ return (result: tup2_u32_u32) -> {[@expl:splits_up ensures] Int.mod (UInt32.t'int result.f0) 2 = 0
      /\ Int.mod (UInt32.t'int result.f1) 2 = 1}
      (! return {result}) ]
end
