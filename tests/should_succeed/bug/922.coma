module M_g
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type tup2_i32_ref_i32 = { f0: Int32.t; f1: MutBorrow.t Int32.t }
  
  type tup2_tup2_i32_ref_i32_i32 = { f0'0: tup2_i32_ref_i32; f1'0: Int32.t }
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  predicate resolve_tup2_i32_ref_i32 [@inline:trivial] (_1: tup2_i32_ref_i32) = resolve_ref_i32 _1.f1
  
  meta "rewrite_def" predicate resolve_tup2_i32_ref_i32
  
  predicate resolve_tup2_tup2_i32_ref_i32_i32 [@inline:trivial] (_1: tup2_tup2_i32_ref_i32_i32) =
    resolve_tup2_i32_ref_i32 _1.f0'0
  
  meta "rewrite_def" predicate resolve_tup2_tup2_i32_ref_i32_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec g (x: tup2_tup2_i32_ref_i32_i32) (return (x'0: MutBorrow.t Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Int32.t> {x.f0'0.f1.current} {MutBorrow.get_id x.f0'0.f1}
          (fun (_ret: MutBorrow.t Int32.t) ->
            [ &_5 <- _ret ] [ &x <- { x with f0'0 = { x.f0'0 with f1 = { x.f0'0.f1 with current = _ret.final } } } ] s1)
      | s1 = MutBorrow.borrow_final <Int32.t> {_5.current} {MutBorrow.get_id _5}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_2 <- _ret ] [ &_5 <- { _5 with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_i32 _5}- s3
      | s3 = MutBorrow.borrow_final <Int32.t> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_0 <- _ret ] [ &_2 <- { _2 with current = _ret.final } ] s4)
      | s4 = -{resolve_ref_i32 _2}- s5
      | s5 = -{resolve_tup2_tup2_i32_ref_i32_i32 x}- s6
      | s6 = return {_0} ] ]
    [ & _0: MutBorrow.t Int32.t = Any.any_l ()
    | & x: tup2_tup2_i32_ref_i32_i32 = x
    | & _2: MutBorrow.t Int32.t = Any.any_l ()
    | & _5: MutBorrow.t Int32.t = Any.any_l () ])
    [ return (result: MutBorrow.t Int32.t) -> {[@expl:g ensures] result = x.f0'0.f1} (! return {result}) ]
end
module M_f1
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type tup2_i32_ref_i32 = { f0: Int32.t; f1: MutBorrow.t Int32.t }
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  predicate resolve_ref_tup2_i32_ref_i32 [@inline:trivial] (_1: MutBorrow.t tup2_i32_ref_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_tup2_i32_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f1'0 (b: MutBorrow.t tup2_i32_ref_i32) (return (x: MutBorrow.t Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {b.current.f1.current}
          (fun (_ret: MutBorrow.t Int32.t) ->
            [ &_9 <- _ret ]
            [ &b <- { b with current = { b.current with f1 = { b.current.f1 with current = _ret.final } } } ] s1)
      | s1 = MutBorrow.borrow_final <Int32.t> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_2 <- _ret ] [ &_9 <- { _9 with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_i32 _9}- s3
      | s3 = MutBorrow.borrow_final <Int32.t> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_0 <- _ret ] [ &_2 <- { _2 with current = _ret.final } ] s4)
      | s4 = -{resolve_ref_i32 _2}- s5
      | s5 = -{resolve_ref_tup2_i32_ref_i32 b}- s6
      | s6 = return {_0} ] ]
    [ & _0: MutBorrow.t Int32.t = Any.any_l ()
    | & b: MutBorrow.t tup2_i32_ref_i32 = b
    | & _2: MutBorrow.t Int32.t = Any.any_l ()
    | & _9: MutBorrow.t Int32.t = Any.any_l () ])
    [ return (result: MutBorrow.t Int32.t) -> {[@expl:f1 ensures #0] result.current = b.current.f1.current}
      {[@expl:f1 ensures #1] result.final = b.final.f1.current}
      {[@expl:f1 ensures #2] b.current.f1.final = b.final.f1.final}
      (! return {result}) ]
end
module M_f2
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type tup2_i32_ref_i32 = { f0: Int32.t; f1: MutBorrow.t Int32.t }
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  predicate resolve_ref_tup2_i32_ref_i32 [@inline:trivial] (_1: MutBorrow.t tup2_i32_ref_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_tup2_i32_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f2 (x0: MutBorrow.t tup2_i32_ref_i32) (return (x: MutBorrow.t Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x0.current.f1.current}
          (fun (_ret: MutBorrow.t Int32.t) ->
            [ &_9 <- _ret ]
            [ &x0 <- { x0 with current = { x0.current with f1 = { x0.current.f1 with current = _ret.final } } } ] s1)
      | s1 = MutBorrow.borrow_final <Int32.t> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_2 <- _ret ] [ &_9 <- { _9 with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_i32 _9}- s3
      | s3 = MutBorrow.borrow_final <Int32.t> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_0 <- _ret ] [ &_2 <- { _2 with current = _ret.final } ] s4)
      | s4 = -{resolve_ref_i32 _2}- s5
      | s5 = -{resolve_ref_tup2_i32_ref_i32 x0}- s6
      | s6 = return {_0} ] ]
    [ & _0: MutBorrow.t Int32.t = Any.any_l ()
    | & x0: MutBorrow.t tup2_i32_ref_i32 = x0
    | & _2: MutBorrow.t Int32.t = Any.any_l ()
    | & _9: MutBorrow.t Int32.t = Any.any_l () ])
    [ return (result: MutBorrow.t Int32.t) -> {[@expl:f2 ensures #0] result.current = x0.current.f1.current}
      {[@expl:f2 ensures #1] result.final = x0.final.f1.current}
      {[@expl:f2 ensures #2] x0.current.f1.final = x0.final.f1.final}
      (! return {result}) ]
end
module M_f3
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type tup2_i32_ref_i32 = { f0: Int32.t; f1: MutBorrow.t Int32.t }
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  predicate resolve_ref_tup2_i32_ref_i32 [@inline:trivial] (_1: MutBorrow.t tup2_i32_ref_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_tup2_i32_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f3 (x1: MutBorrow.t tup2_i32_ref_i32) (return (x: MutBorrow.t Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x1.current.f1.current}
          (fun (_ret: MutBorrow.t Int32.t) ->
            [ &_9 <- _ret ]
            [ &x1 <- { x1 with current = { x1.current with f1 = { x1.current.f1 with current = _ret.final } } } ] s1)
      | s1 = MutBorrow.borrow_final <Int32.t> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_2 <- _ret ] [ &_9 <- { _9 with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_i32 _9}- s3
      | s3 = MutBorrow.borrow_final <Int32.t> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_0 <- _ret ] [ &_2 <- { _2 with current = _ret.final } ] s4)
      | s4 = -{resolve_ref_i32 _2}- s5
      | s5 = -{resolve_ref_tup2_i32_ref_i32 x1}- s6
      | s6 = return {_0} ] ]
    [ & _0: MutBorrow.t Int32.t = Any.any_l ()
    | & x1: MutBorrow.t tup2_i32_ref_i32 = x1
    | & _2: MutBorrow.t Int32.t = Any.any_l ()
    | & _9: MutBorrow.t Int32.t = Any.any_l () ])
    [ return (result: MutBorrow.t Int32.t) -> {[@expl:f3 ensures #0] result.current = x1.current.f1.current}
      {[@expl:f3 ensures #1] result.final = x1.final.f1.current}
      {[@expl:f3 ensures #2] x1.current.f1.final = x1.final.f1.final}
      (! return {result}) ]
end
module M_f4
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type tup2_i32_ref_i32 = { f0: Int32.t; f1: MutBorrow.t Int32.t }
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  predicate resolve_ref_tup2_i32_ref_i32 [@inline:trivial] (_1: MutBorrow.t tup2_i32_ref_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_tup2_i32_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f4 (x2: MutBorrow.t tup2_i32_ref_i32) (return (x: MutBorrow.t Int32.t)) = (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x2.current.f1.current}
          (fun (_ret: MutBorrow.t Int32.t) ->
            [ &_9 <- _ret ]
            [ &x2 <- { x2 with current = { x2.current with f1 = { x2.current.f1 with current = _ret.final } } } ] s1)
      | s1 = MutBorrow.borrow_final <Int32.t> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_2 <- _ret ] [ &_9 <- { _9 with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_i32 _9}- s3
      | s3 = MutBorrow.borrow_final <Int32.t> {_2.current} {MutBorrow.get_id _2}
          (fun (_ret: MutBorrow.t Int32.t) -> [ &_0 <- _ret ] [ &_2 <- { _2 with current = _ret.final } ] s4)
      | s4 = -{resolve_ref_i32 _2}- s5
      | s5 = -{resolve_ref_tup2_i32_ref_i32 x2}- s6
      | s6 = return {_0} ] ]
    [ & _0: MutBorrow.t Int32.t = Any.any_l ()
    | & x2: MutBorrow.t tup2_i32_ref_i32 = x2
    | & _2: MutBorrow.t Int32.t = Any.any_l ()
    | & _9: MutBorrow.t Int32.t = Any.any_l () ])
    [ return (result: MutBorrow.t Int32.t) -> {[@expl:f4 ensures #0] result.current = x2.current.f1.current}
      {[@expl:f4 ensures #1] result.final = x2.final.f1.current}
      {[@expl:f4 ensures #2] x2.current.f1.final = x2.final.f1.final}
      (! return {result}) ]
end
