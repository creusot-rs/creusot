module M_bdd__hashmap__qyi1953663170559623169__hash [#"bdd.rs" 79 8 79 29] (* <(U, V) as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 80 66 80 68
  let%span sbdd'0 = "bdd.rs" 79 17 79 21
  let%span sbdd'1 = "bdd.rs" 78 18 78 62
  let%span sbdd'2 = "bdd.rs" 35 17 35 21
  let%span sbdd'3 = "bdd.rs" 34 18 34 62
  let%span sbdd'4 = "bdd.rs" 86 24 86 84
  let%span snum = "../../creusot-contracts/src/std/num.rs" 208 26 208 48
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 48
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_U
  
  type t_V
  
  type tuple  =
    { _0: t_U; _1: t_V }
  
  predicate inv (_0'0 : t_U)
  
  predicate invariant' (self : t_U) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0'0 : t_U)
  
  axiom inv_axiom [@rewrite] : forall x : t_U [inv'0 x] . inv'0 x = invariant' x
  
  type t_DeepModelTy
  
  function hash_log [#"bdd.rs" 38 8 38 49] (_0'0 : t_DeepModelTy) : int
  
  function deep_model (self : t_U) : t_DeepModelTy
  
  function deep_model'0 (self : t_U) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  let rec hash (self:t_U) (return'  (x:UInt64.t))= {[@expl:hash 'self' type invariant] [%#sbdd'2] inv'0 self}
    any
    [ return''0 (result:UInt64.t)-> {[%#sbdd'3] UInt64.t'int result = hash_log (deep_model'0 self)}
      (! return' {result}) ]
  
  
  predicate inv'1 (_0'0 : t_V)
  
  predicate invariant''0 (self : t_V) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0'0 : t_V)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_V [inv'2 x] . inv'2 x = invariant''0 x
  
  type t_DeepModelTy'0
  
  function hash_log'0 [#"bdd.rs" 38 8 38 49] (_0'0 : t_DeepModelTy'0) : int
  
  function deep_model'1 (self : t_V) : t_DeepModelTy'0
  
  function deep_model'2 (self : t_V) : t_DeepModelTy'0 =
    [%#smodel] deep_model'1 self
  
  let rec hash'0 (self:t_V) (return'  (x:UInt64.t))= {[@expl:hash 'self' type invariant] [%#sbdd'2] inv'2 self}
    any
    [ return''0 (result:UInt64.t)-> {[%#sbdd'3] UInt64.t'int result = hash_log'0 (deep_model'2 self)}
      (! return' {result}) ]
  
  
  let rec wrapping_mul (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = UInt64.mul self_ rhs} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum'0] result = UInt64.add self_ rhs} (! return' {result}) ]
  
  
  predicate inv'3 (_0'0 : tuple)
  
  axiom inv_axiom'1 [@rewrite] : forall x : tuple [inv'3 x] . inv'3 x
  = (let {_0 = x0 ; _1 = x1} = x in inv x0 /\ inv'1 x1)
  
  predicate invariant''1 (self : tuple) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 (_0'0 : tuple)
  
  axiom inv_axiom'2 [@rewrite] : forall x : tuple [inv'4 x] . inv'4 x = invariant''1 x
  
  type tuple'0  =
    { _0'0: t_DeepModelTy; _1'0: t_DeepModelTy'0 }
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function hash_log'1 [#"bdd.rs" 85 8 85 48] (x : tuple'0) : int =
    [%#sbdd'4] Int.mod (hash_log x._0'0 + hash_log'0 x._1'0 * 17) (UInt64.t'int (v_MAX : UInt64.t) + 1)
  
  function deep_model'3 (self : tuple) : tuple'0 =
    [%#stuples] { _0'0 = deep_model self._0; _1'0 = deep_model'1 self._1 }
  
  function deep_model'4 (self : tuple) : tuple'0 =
    [%#smodel] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  let rec hash'1[#"bdd.rs" 79 8 79 29] (self:tuple) (return'  (x:UInt64.t))= {[@expl:hash 'self' type invariant] [%#sbdd'0] inv'4 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash {self'0._0} (fun (_ret:UInt64.t) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = hash'0 {self'0._1} (fun (_ret:UInt64.t) ->  [ &_6 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = wrapping_mul {_6} {[%#sbdd] (17 : UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_5 <- _ret ] s1) | s1 = bb3 ]
    
    | bb3 = s0 [ s0 = wrapping_add {_3} {_5} (fun (_ret:UInt64.t) ->  [ &_0'1 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = return''0 {_0'1} ]
    )
    [ & _0'1 : UInt64.t = Any.any_l ()
    | & self'0 : tuple = self
    | & _3 : UInt64.t = Any.any_l ()
    | & _5 : UInt64.t = Any.any_l ()
    | & _6 : UInt64.t = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd'1] UInt64.t'int result
      = hash_log'1 (deep_model'4 self)}
      (! return' {result}) ]

end
module M_bdd__qyi2024536649982164874__assert_receiver_is_total_eq [#"bdd.rs" 93 9 93 11] (* <Node<'arena> as std::cmp::Eq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  meta "compute_max_steps" 1000000
  
  let rec assert_receiver_is_total_eq[#"bdd.rs" 93 9 93 11] (self:t_Node) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0 : () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi4854841669736991510__eq [#"bdd.rs" 93 13 93 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 93 13 93 22
  let%span sbdd'0 = "bdd.rs" 204 14 204 37
  let%span sbdd'1 = "bdd.rs" 163 12 167 13
  let%span sbdd'2 = "bdd.rs" 199 20 199 37
  let%span sbdd'3 = "bdd.rs" 189 20 189 26
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 11 26 11 75
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type tuple  =
    { _0: t_Node; _1: t_Node }
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd, childf : t_Bdd [C_If v childt childf : t_Node] . C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'3] self.t_Bdd__1
  
  function view [#"bdd.rs" 198 4 198 33] (self : t_Bdd) : UInt64.t =
    [%#sbdd'2] deep_model self
  
  function view'0 (self : t_Bdd) : UInt64.t =
    [%#smodel'0] view self
  
  let rec eq (self:t_Bdd) (o:t_Bdd) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sbdd'0] result = (view'0 self = view'0 o)} (! return' {result}) ]
  
  
  function deep_model'0 (self : UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  function deep_model'1 (self : UInt64.t) : int =
    [%#smodel] deep_model'0 self
  
  let rec eq'0 (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#scmp] result = (deep_model'1 self_ = deep_model'1 rhs)} (! return' {result}) ]
  
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model'2 [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'1] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'3 (self : t_Node) : t_NodeLog =
    [%#smodel] deep_model'2 self
  
  meta "compute_max_steps" 1000000
  
  let rec eq'1[#"bdd.rs" 93 13 93 22] (self:t_Node) (rhs:t_Node) (return'  (x:bool))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- { _0 = self'0; _1 = rhs'0 } ] s1
      | s1 = any
        [ br0 -> {_4._0 = C_False} (! bb2)
        | br1 -> {_4._0 = C_True} (! bb4)
        | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._0 = C_If x0 x1 x2} (! bb6) ]
       ]
    
    | bb6 = any
      [ br0 -> {_4._1 = C_False} (! bb25)
      | br1 -> {_4._1 = C_True} (! bb25)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._1 = C_If x0 x1 x2} (! bb7) ]
    
    | bb25 = bb1
    | bb7 = bb8
    | bb8 = s0
      [ s0 = v_If {_4._0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v_1 <- rv ] s1)
      | s1 = v_If {_4._0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt_1 <- rchildt ] s2)
      | s2 = v_If {_4._0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf_1 <- rchildf ] s3)
      | s3 = v_If {_4._1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v_2 <- rv ] s4)
      | s4 = v_If {_4._1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt_2 <- rchildt ] s5)
      | s5 = v_If {_4._1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf_2 <- rchildf ] s6)
      | s6 = eq {childf_1} {childf_2} (fun (_ret:bool) ->  [ &_17 <- _ret ] s7)
      | s7 = bb11 ]
    
    | bb11 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ] 
    | bb12 = s0 [ s0 = eq {childt_1} {childt_2} (fun (_ret:bool) ->  [ &_20 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_20 = false} (! bb18) | br1 -> {_20} (! bb14) ] 
    | bb14 = s0 [ s0 = eq'0 {v_1} {v_2} (fun (_ret:bool) ->  [ &_23 <- _ret ] s1) | s1 = bb15 ] 
    | bb15 = any [ br0 -> {_23 = false} (! bb17) | br1 -> {_23} (! bb16) ] 
    | bb16 = s0 [ s0 =  [ &_0'0 <- [%#sbdd] true ] s1 | s1 = bb21 ] 
    | bb17 = bb20
    | bb18 = bb20
    | bb19 = bb20
    | bb20 = s0 [ s0 =  [ &_0'0 <- [%#sbdd] false ] s1 | s1 = bb21 ] 
    | bb21 = bb22
    | bb4 = any
      [ br0 -> {_4._1 = C_False} (! bb1)
      | br1 -> {_4._1 = C_True} (! bb5)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._1 = C_If x0 x1 x2} (! bb1) ]
    
    | bb5 = bb9
    | bb9 = s0 [ s0 =  [ &_0'0 <- [%#sbdd] true ] s1 | s1 = bb22 ] 
    | bb2 = any
      [ br0 -> {_4._1 = C_False} (! bb3)
      | br1 -> {_4._1 = C_True} (! bb1)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._1 = C_If x0 x1 x2} (! bb1) ]
    
    | bb1 = s0 [ s0 =  [ &_0'0 <- [%#sbdd] false ] s1 | s1 = bb22 ] 
    | bb3 = bb10
    | bb10 = s0 [ s0 =  [ &_0'0 <- [%#sbdd] true ] s1 | s1 = bb22 ] 
    | bb22 = return''0 {_0'0} ]
    )
    [ & _0'0 : bool = Any.any_l ()
    | & self'0 : t_Node = self
    | & rhs'0 : t_Node = rhs
    | & _4 : tuple = Any.any_l ()
    | & v_1 : UInt64.t = Any.any_l ()
    | & childt_1 : t_Bdd = Any.any_l ()
    | & childf_1 : t_Bdd = Any.any_l ()
    | & v_2 : UInt64.t = Any.any_l ()
    | & childt_2 : t_Bdd = Any.any_l ()
    | & childf_2 : t_Bdd = Any.any_l ()
    | & _17 : bool = Any.any_l ()
    | & _20 : bool = Any.any_l ()
    | & _23 : bool = Any.any_l () ]
    
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#sbdd] result = (deep_model'3 self = deep_model'3 rhs)}
      (! return' {result}) ]

end
module M_bdd__qyi17981791245757283426__clone [#"bdd.rs" 93 24 93 29] (* <Node<'arena> as creusot_contracts::Clone> *)
  let%span sbdd = "bdd.rs" 93 24 93 29
  let%span sbdd'0 = "bdd.rs" 111 14 111 29
  let%span sclone = "../../creusot-contracts/src/std/clone.rs" 15 26 15 41
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd, childf : t_Bdd [C_If v childt childf : t_Node] . C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  let rec clone' (self_:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#sclone] result = self_} (! return' {result}) ]
  
  
  let rec clone''0 (self:t_Bdd) (return'  (x:t_Bdd))= any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'0] result = self} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec clone''1[#"bdd.rs" 93 24 93 29] (self:t_Node) (return'  (x:t_Node))= (! bb0
    [ bb0 = any
      [ br0 -> {self'0 = C_False} (! bb2)
      | br1 -> {self'0 = C_True} (! bb3)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {self'0 = C_If x0 x1 x2} (! bb4) ]
    
    | bb4 = s0
      [ s0 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v_1 <- rv ] s1)
      | s1 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt_1 <- rchildt ] s2)
      | s2 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf_1 <- rchildf ] s3)
      | s3 =  [ &_9 <- v_1 ] s4
      | s4 = clone' {_9} (fun (_ret:UInt64.t) ->  [ &_7 <- _ret ] s5)
      | s5 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_12 <- childt_1 ] s1 | s1 = clone''0 {_12} (fun (_ret:t_Bdd) ->  [ &_10 <- _ret ] s2) | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_15 <- childf_1 ] s1 | s1 = clone''0 {_15} (fun (_ret:t_Bdd) ->  [ &_13 <- _ret ] s2) | s2 = bb9 ]
    
    | bb9 = s0 [ s0 =  [ &_0 <- C_If _7 _10 _13 ] s1 | s1 = bb10 ] 
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- C_True ] s1 | s1 = bb10 ] 
    | bb2 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- C_False ] s1 | s1 = bb10 ] 
    | bb10 = return''0 {_0} ]
    )
    [ & _0 : t_Node = Any.any_l ()
    | & self'0 : t_Node = self
    | & v_1 : UInt64.t = Any.any_l ()
    | & childt_1 : t_Bdd = Any.any_l ()
    | & childf_1 : t_Bdd = Any.any_l ()
    | & _7 : UInt64.t = Any.any_l ()
    | & _9 : UInt64.t = Any.any_l ()
    | & _10 : t_Bdd = Any.any_l ()
    | & _12 : t_Bdd = Any.any_l ()
    | & _13 : t_Bdd = Any.any_l ()
    | & _15 : t_Bdd = Any.any_l () ]
     [ return''0 (result:t_Node)-> {[@expl:clone ensures] [%#sbdd] result = self} (! return' {result}) ] 
end
module M_bdd__qyi1284786238026687571__assert_receiver_is_total_eq [#"bdd.rs" 107 15 107 17] (* <Bdd<'arena> as std::cmp::Eq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  let rec assert_receiver_is_total_eq[#"bdd.rs" 107 15 107 17] (self:t_Bdd) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
    ) [ & _0 : () = Any.any_l () ]  [ return''0 (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi2820858787824331484__clone [#"bdd.rs" 112 4 112 27] (* <Bdd<'arena> as creusot_contracts::Clone> *)
  let%span sbdd = "bdd.rs" 111 14 111 29
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  let rec clone'[#"bdd.rs" 112 4 112 27] (self:t_Bdd) (return'  (x:t_Bdd))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : t_Bdd = Any.any_l () | & self'0 : t_Bdd = self ] 
    [ return''0 (result:t_Bdd)-> {[@expl:clone ensures] [%#sbdd] result = self} (! return' {result}) ]

end
module M_bdd__qyi699402059438633899__hash [#"bdd.rs" 119 4 119 25] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 124 53 124 54
  let%span sbdd'0 = "bdd.rs" 124 92 124 93
  let%span sbdd'1 = "bdd.rs" 122 20 122 21
  let%span sbdd'2 = "bdd.rs" 121 21 121 22
  let%span sbdd'3 = "bdd.rs" 118 14 118 46
  let%span sbdd'4 = "bdd.rs" 133 12 138 13
  let%span sbdd'5 = "bdd.rs" 179 20 179 37
  let%span sbdd'6 = "bdd.rs" 163 12 167 13
  let%span snum = "../../creusot-contracts/src/std/num.rs" 208 26 208 48
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 208 26 208 48
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd, childf : t_Bdd [C_If v childt childf : t_Node] . C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  let rec wrapping_mul (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = UInt64.mul self_ rhs} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum'0] result = UInt64.add self_ rhs} (! return' {result}) ]
  
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function hash_log [#"bdd.rs" 131 4 131 44] (x : t_NodeLog) : int =
    [%#sbdd'4] match x with
      | C_False'0 -> 1
      | C_True'0 -> 2
      | C_If'0 v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int (v_MAX : UInt64.t) + 1)
      end
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'6] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'5] deep_model self
  
  function view'0 (self : t_Node) : t_NodeLog =
    [%#smodel] view self
  
  meta "compute_max_steps" 1000000
  
  let rec hash[#"bdd.rs" 119 4 119 25] (self:t_Node) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = any
      [ br0 -> {self'0 = C_False} (! bb2)
      | br1 -> {self'0 = C_True} (! bb3)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {self'0 = C_If x0 x1 x2} (! bb4) ]
    
    | bb4 = s0
      [ s0 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v <- rv ] s1)
      | s1 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt <- rchildt ] s2)
      | s2 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf <- rchildf ] s3)
      | s3 = wrapping_mul {childt.t_Bdd__1} {[%#sbdd] (5 : UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_9 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = s0 [ s0 = wrapping_add {v} {_9} (fun (_ret:UInt64.t) ->  [ &_7 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = wrapping_mul {childf.t_Bdd__1} {[%#sbdd'0] (7 : UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = wrapping_add {_7} {_11} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb10 ] 
    | bb10 = bb11
    | bb3 = bb5
    | bb5 = s0 [ s0 =  [ &_0 <- [%#sbdd'1] (2 : UInt64.t) ] s1 | s1 = bb11 ] 
    | bb2 = bb6
    | bb6 = s0 [ s0 =  [ &_0 <- [%#sbdd'2] (1 : UInt64.t) ] s1 | s1 = bb11 ] 
    | bb11 = return''0 {_0} ]
    )
    [ & _0 : UInt64.t = Any.any_l ()
    | & self'0 : t_Node = self
    | & v : UInt64.t = Any.any_l ()
    | & childt : t_Bdd = Any.any_l ()
    | & childf : t_Bdd = Any.any_l ()
    | & _7 : UInt64.t = Any.any_l ()
    | & _9 : UInt64.t = Any.any_l ()
    | & _11 : UInt64.t = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd'3] UInt64.t'int result = hash_log (view'0 self)}
      (! return' {result}) ]

end
module M_bdd__qyi14323183011761258016__hash [#"bdd.rs" 145 4 145 25] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 144 14 144 46
  let%span sbdd'0 = "bdd.rs" 152 20 152 22
  let%span sbdd'1 = "bdd.rs" 199 20 199 37
  let%span sbdd'2 = "bdd.rs" 189 20 189 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function hash_log [#"bdd.rs" 151 4 151 44] (x : UInt64.t) : int =
    [%#sbdd'0] UInt64.t'int x
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'2] self.t_Bdd__1
  
  function view [#"bdd.rs" 198 4 198 33] (self : t_Bdd) : UInt64.t =
    [%#sbdd'1] deep_model self
  
  function view'0 (self : t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  meta "compute_max_steps" 1000000
  
  let rec hash[#"bdd.rs" 145 4 145 25] (self:t_Bdd) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_Bdd__1 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : UInt64.t = Any.any_l () | & self'0 : t_Bdd = self ] 
    [ return''0 (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd] UInt64.t'int result = hash_log (view'0 self)}
      (! return' {result}) ]

end
module M_bdd__qyi2581120635339165136__eq [#"bdd.rs" 205 4 205 34] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 204 14 204 37
  let%span sbdd'0 = "bdd.rs" 199 20 199 37
  let%span sbdd'1 = "bdd.rs" 189 20 189 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'1] self.t_Bdd__1
  
  function view [#"bdd.rs" 198 4 198 33] (self : t_Bdd) : UInt64.t =
    [%#sbdd'0] deep_model self
  
  function view'0 (self : t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  meta "compute_max_steps" 1000000
  
  let rec eq[#"bdd.rs" 205 4 205 34] (self:t_Bdd) (o:t_Bdd) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_Bdd__1 = o'0.t_Bdd__1 ] s1 | s1 = return''0 {_0} ]  ]
    ) [ & _0 : bool = Any.any_l () | & self'0 : t_Bdd = self | & o'0 : t_Bdd = o ] 
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#sbdd] result = (view'0 self = view'0 o)} (! return' {result}) ]

end
module M_bdd__qyi13535665294507397779__size [#"bdd.rs" 227 4 227 24] (* Bdd<'arena> *)
  let%span sbdd = "bdd.rs" 226 14 226 25
  let%span sbdd'0 = "bdd.rs" 229 12 237 13
  
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  constant self  : t_Bdd
  
  function size [#"bdd.rs" 227 4 227 24] (self'0 : t_Bdd) : int
  
  goal vc_size : match self with
    | {t_Bdd__0 = C_True} -> [%#sbdd] 0 >= 0
    | {t_Bdd__0 = C_False} -> [%#sbdd] 0 >= 0
    | {t_Bdd__0 = C_If _ childt childf} -> ([%#sbdd] size childt >= 0)
     -> (let ht = size childt in ([%#sbdd] size childf >= 0)  -> (let hf = size childf in [%#sbdd] 1 + ht + hf >= 0))
    end
end
module M_bdd__qyi11078426090797403070__grows_is_valid_bdd [#"bdd.rs" 339 4 339 56] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 336 15 336 27
  let%span sbdd'0 = "bdd.rs" 337 15 337 35
  let%span sbdd'1 = "bdd.rs" 338 14 338 37
  let%span sbdd'2 = "bdd.rs" 339 57 339 59
  let%span sbdd'3 = "bdd.rs" 301 12 306 17
  let%span sbdd'4 = "bdd.rs" 314 12 314 47
  let%span sbdd'5 = "bdd.rs" 179 20 179 37
  let%span sbdd'6 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'3] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'6] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'5] deep_model self
  
  function view'1 (self : t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'4] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant self  : MutBorrow.t t_Context
  
  constant b  : t_Bdd
  
  function grows_is_valid_bdd [#"bdd.rs" 339 4 339 56] (self'0 : MutBorrow.t t_Context) (b'0 : t_Bdd) : ()
  
  goal vc_grows_is_valid_bdd : ([%#sbdd] grows self)
   -> ([%#sbdd'0] is_valid_bdd self.current b)  -> ([%#sbdd'1] is_valid_bdd self.final b)
end
module M_bdd__qyi11078426090797403070__grows_trans [#"bdd.rs" 348 4 348 62] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 343 15 343 27
  let%span sbdd'0 = "bdd.rs" 344 15 344 24
  let%span sbdd'1 = "bdd.rs" 345 15 345 26
  let%span sbdd'2 = "bdd.rs" 346 15 346 43
  let%span sbdd'3 = "bdd.rs" 347 14 347 24
  let%span sbdd'4 = "bdd.rs" 348 63 348 65
  let%span sbdd'5 = "bdd.rs" 301 12 306 17
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'5] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  constant self  : MutBorrow.t t_Context
  
  constant o  : MutBorrow.t t_Context
  
  constant oo  : MutBorrow.t t_Context
  
  function grows_trans [#"bdd.rs" 348 4 348 62] (self'0 : MutBorrow.t t_Context) (o'0 : MutBorrow.t t_Context) (oo'0 : MutBorrow.t t_Context) : ()
  
  
  goal vc_grows_trans : ([%#sbdd] grows self)
   -> ([%#sbdd'0] grows o)
   -> ([%#sbdd'1] self.final = o.current)
   -> ([%#sbdd'2] self.current = oo.current /\ self.final = oo.final)  -> ([%#sbdd'3] grows oo)
end
module M_bdd__qyi11078426090797403070__set_irrelevent_var [#"bdd.rs" 355 4 355 87] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 351 15 351 24
  let%span sbdd'0 = "bdd.rs" 352 15 352 35
  let%span sbdd'1 = "bdd.rs" 353 15 353 32
  let%span sbdd'2 = "bdd.rs" 354 14 354 50
  let%span sbdd'3 = "bdd.rs" 357 12 363 13
  let%span sbdd'4 = "bdd.rs" 314 12 314 47
  let%span sbdd'5 = "bdd.rs" 244 12 248 13
  let%span sbdd'6 = "bdd.rs" 214 12 221 13
  let%span sbdd'7 = "bdd.rs" 267 12 291 19
  let%span sbdd'8 = "bdd.rs" 179 20 179 37
  let%span sbdd'9 = "bdd.rs" 321 12 330 13
  let%span sbdd'10 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'10] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'8] deep_model self
  
  function view'1 (self : t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'4] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'5] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'9] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'6] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'7] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'3 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'4 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  constant self  : t_Context
  
  constant a  : t_Bdd
  
  constant x  : UInt64.t
  
  constant v  : Map.map UInt64.t bool
  
  constant b  : bool
  
  function set_irrelevent_var [#"bdd.rs" 355 4 355 87] (self'0 : t_Context) (a'0 : t_Bdd) (x'0 : UInt64.t) (v'0 : Map.map UInt64.t bool) (b'0 : bool) : ()
  
  
  goal vc_set_irrelevent_var : ([%#sbdd] inv self)
   -> ([%#sbdd'0] is_valid_bdd self a)
   -> ([%#sbdd'1] UInt64.t'int x < leastvar a)
   -> match a with
    | {t_Bdd__0 = C_If _ childt childf} -> (([@expl:set_irrelevent_var requires #0] [%#sbdd] inv self)
    && ([@expl:set_irrelevent_var requires #1] [%#sbdd'0] is_valid_bdd self childt)
    && ([@expl:set_irrelevent_var requires #2] [%#sbdd'1] UInt64.t'int x < leastvar childt))
    /\ (([%#sbdd'2] interp childt v = interp childt (Map.set v x b))
     -> (let _ = set_irrelevent_var self childt x v b in (([@expl:set_irrelevent_var requires #0] [%#sbdd] inv self)
    && ([@expl:set_irrelevent_var requires #1] [%#sbdd'0] is_valid_bdd self childf)
    && ([@expl:set_irrelevent_var requires #2] [%#sbdd'1] UInt64.t'int x < leastvar childf))
    /\ (([%#sbdd'2] interp childf v = interp childf (Map.set v x b))
     -> (let _ = set_irrelevent_var self childf x v b in [%#sbdd'2] interp a v = interp a (Map.set v x b)))))
    | _ -> [%#sbdd'2] interp a v = interp a (Map.set v x b)
    end
end
module M_bdd__qyi11078426090797403070__discr_valuation [#"bdd.rs" 375 4 375 82] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 368 15 368 24
  let%span sbdd'0 = "bdd.rs" 369 15 369 35
  let%span sbdd'1 = "bdd.rs" 370 15 370 35
  let%span sbdd'2 = "bdd.rs" 371 15 371 21
  let%span sbdd'3 = "bdd.rs" 372 14 372 50
  let%span sbdd'4 = "bdd.rs" 373 14 373 33
  let%span sbdd'5 = "bdd.rs" 377 12 377 36
  let%span sbdd'6 = "bdd.rs" 314 12 314 47
  let%span sbdd'7 = "bdd.rs" 214 12 221 13
  let%span sbdd'8 = "bdd.rs" 226 14 226 25
  let%span sbdd'9 = "bdd.rs" 229 12 237 13
  let%span sbdd'10 = "bdd.rs" 351 15 351 24
  let%span sbdd'11 = "bdd.rs" 352 15 352 35
  let%span sbdd'12 = "bdd.rs" 353 15 353 32
  let%span sbdd'13 = "bdd.rs" 354 14 354 50
  let%span sbdd'14 = "bdd.rs" 357 12 363 13
  let%span sbdd'15 = "bdd.rs" 244 12 248 13
  let%span sbdd'16 = "bdd.rs" 267 12 291 19
  let%span sbdd'17 = "bdd.rs" 179 20 179 37
  let%span sbdd'18 = "bdd.rs" 321 12 330 13
  let%span sbdd'19 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'19] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'17] deep_model self
  
  function view'1 (self : t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'6] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'15] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'18] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'7] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'16] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'3 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'4 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  function size [#"bdd.rs" 227 4 227 24] (self : t_Bdd) : int =
    [%#sbdd'9] match self with
      | {t_Bdd__0 = C_True} -> 0
      | {t_Bdd__0 = C_False} -> 0
      | {t_Bdd__0 = C_If _ childt childf} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec : forall self : t_Bdd . [%#sbdd'8] size self >= 0
  
  function set_irrelevent_var [#"bdd.rs" 355 4 355 87] (self : t_Context) (a : t_Bdd) (x : UInt64.t) (v : Map.map UInt64.t bool) (b : bool) : ()
  
   =
    [%#sbdd'14] match a with
      | {t_Bdd__0 = C_If _ childt childf} -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var_spec : forall self : t_Context, a : t_Bdd, x : UInt64.t, v : Map.map UInt64.t bool, b : bool . ([%#sbdd'10] inv self)
   -> ([%#sbdd'11] is_valid_bdd self a)
   -> ([%#sbdd'12] UInt64.t'int x < leastvar a)  -> ([%#sbdd'13] interp a v = interp a (Map.set v x b))
  
  constant self  : t_Context
  
  constant a  : t_Bdd
  
  constant b  : t_Bdd
  
  function discr_valuation [#"bdd.rs" 375 4 375 82] (self'0 : t_Context) (a'0 : t_Bdd) (b'0 : t_Bdd) : Map.map UInt64.t bool
  
  
  goal vc_discr_valuation : ([%#sbdd] inv self)
   -> ([%#sbdd'0] is_valid_bdd self a)
   -> ([%#sbdd'1] is_valid_bdd self b)
   -> ([%#sbdd'2] a <> b)
   -> (let _ = set_irrelevent_var in if leastvar a < leastvar b then
    match a with
      | {t_Bdd__0 = C_If v childt childf} -> if childf <> b then
        ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
        && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childf)
        && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self b)
        && ([@expl:discr_valuation requires #3] [%#sbdd'2] childf <> b))
        /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size childf + size b) < ([%#sbdd'4] size a + size b))
        /\ (([%#sbdd'3] interp childf (discr_valuation self childf b) <> interp b (discr_valuation self childf b))
         -> (let result = Map.set (discr_valuation self childf b) v false in [%#sbdd'3] interp a result
        <> interp b result))
      else
        ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
        && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childt)
        && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self b)
        && ([@expl:discr_valuation requires #3] [%#sbdd'2] childt <> b))
        /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size childt + size b) < ([%#sbdd'4] size a + size b))
        /\ (([%#sbdd'3] interp childt (discr_valuation self childt b) <> interp b (discr_valuation self childt b))
         -> (let result = Map.set (discr_valuation self childt b) v true in [%#sbdd'3] interp a result
        <> interp b result))
      
      | _ -> let result = Const.const true in [%#sbdd'3] interp a result <> interp b result
      end
  else
    if leastvar a > leastvar b then
      match b with
        | {t_Bdd__0 = C_If v childt childf} -> if childf <> a then
          ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
          && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self a)
          && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childf)
          && ([@expl:discr_valuation requires #3] [%#sbdd'2] a <> childf))
          /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size a + size childf) < ([%#sbdd'4] size a + size b))
          /\ (([%#sbdd'3] interp a (discr_valuation self a childf) <> interp childf (discr_valuation self a childf))
           -> (let result = Map.set (discr_valuation self a childf) v false in [%#sbdd'3] interp a result
          <> interp b result))
        else
          ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
          && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self a)
          && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childt)
          && ([@expl:discr_valuation requires #3] [%#sbdd'2] a <> childt))
          /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size a + size childt) < ([%#sbdd'4] size a + size b))
          /\ (([%#sbdd'3] interp a (discr_valuation self a childt) <> interp childt (discr_valuation self a childt))
           -> (let result = Map.set (discr_valuation self a childt) v true in [%#sbdd'3] interp a result
          <> interp b result))
        
        | _ -> let result = Const.const true in [%#sbdd'3] interp a result <> interp b result
        end
    else
      match a with
        | {t_Bdd__0 = C_If v childta childfa} -> match b with
          | {t_Bdd__0 = C_If _ childtb childfb} -> if childfa <> childfb then
            ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
            && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childfa)
            && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childfb)
            && ([@expl:discr_valuation requires #3] [%#sbdd'2] childfa <> childfb))
            /\ 0 <= ([%#sbdd'4] size a + size b)
            /\ ([%#sbdd'4] size childfa + size childfb) < ([%#sbdd'4] size a + size b))
            /\ (([%#sbdd'3] interp childfa (discr_valuation self childfa childfb)
            <> interp childfb (discr_valuation self childfa childfb))
             -> (let result = Map.set (discr_valuation self childfa childfb) v false in [%#sbdd'3] interp a result
            <> interp b result))
          else
            ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
            && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childta)
            && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childtb)
            && ([@expl:discr_valuation requires #3] [%#sbdd'2] childta <> childtb))
            /\ 0 <= ([%#sbdd'4] size a + size b)
            /\ ([%#sbdd'4] size childta + size childtb) < ([%#sbdd'4] size a + size b))
            /\ (([%#sbdd'3] interp childta (discr_valuation self childta childtb)
            <> interp childtb (discr_valuation self childta childtb))
             -> (let result = Map.set (discr_valuation self childta childtb) v true in [%#sbdd'3] interp a result
            <> interp b result))
          
          | _ -> let result = Const.const true in [%#sbdd'3] interp a result <> interp b result
          end
        | _ -> let result = Const.const true in [%#sbdd'3] interp a result <> interp b result
        end
  
  )
end
module M_bdd__qyi11078426090797403070__bdd_canonical [#"bdd.rs" 424 4 424 62] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 418 15 418 24
  let%span sbdd'0 = "bdd.rs" 419 15 419 35
  let%span sbdd'1 = "bdd.rs" 420 15 420 35
  let%span sbdd'2 = "bdd.rs" 421 15 421 54
  let%span sbdd'3 = "bdd.rs" 422 14 422 20
  let%span sbdd'4 = "bdd.rs" 425 8 425 29
  let%span sbdd'5 = "bdd.rs" 314 12 314 47
  let%span sbdd'6 = "bdd.rs" 214 12 221 13
  let%span sbdd'7 = "bdd.rs" 368 15 368 24
  let%span sbdd'8 = "bdd.rs" 369 15 369 35
  let%span sbdd'9 = "bdd.rs" 370 15 370 35
  let%span sbdd'10 = "bdd.rs" 371 15 371 21
  let%span sbdd'11 = "bdd.rs" 372 14 372 50
  let%span sbdd'12 = "bdd.rs" 373 14 373 33
  let%span sbdd'13 = "bdd.rs" 377 12 377 36
  let%span sbdd'14 = "bdd.rs" 226 14 226 25
  let%span sbdd'15 = "bdd.rs" 229 12 237 13
  let%span sbdd'16 = "bdd.rs" 351 15 351 24
  let%span sbdd'17 = "bdd.rs" 352 15 352 35
  let%span sbdd'18 = "bdd.rs" 353 15 353 32
  let%span sbdd'19 = "bdd.rs" 354 14 354 50
  let%span sbdd'20 = "bdd.rs" 357 12 363 13
  let%span sbdd'21 = "bdd.rs" 244 12 248 13
  let%span sbdd'22 = "bdd.rs" 267 12 291 19
  let%span sbdd'23 = "bdd.rs" 179 20 179 37
  let%span sbdd'24 = "bdd.rs" 321 12 330 13
  let%span sbdd'25 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'25] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'23] deep_model self
  
  function view'1 (self : t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'5] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'21] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'24] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'6] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'22] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'3 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'4 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  function size [#"bdd.rs" 227 4 227 24] (self : t_Bdd) : int =
    [%#sbdd'15] match self with
      | {t_Bdd__0 = C_True} -> 0
      | {t_Bdd__0 = C_False} -> 0
      | {t_Bdd__0 = C_If _ childt childf} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec : forall self : t_Bdd . [%#sbdd'14] size self >= 0
  
  function set_irrelevent_var [#"bdd.rs" 355 4 355 87] (self : t_Context) (a : t_Bdd) (x : UInt64.t) (v : Map.map UInt64.t bool) (b : bool) : ()
  
   =
    [%#sbdd'20] match a with
      | {t_Bdd__0 = C_If _ childt childf} -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var_spec : forall self : t_Context, a : t_Bdd, x : UInt64.t, v : Map.map UInt64.t bool, b : bool . ([%#sbdd'16] inv self)
   -> ([%#sbdd'17] is_valid_bdd self a)
   -> ([%#sbdd'18] UInt64.t'int x < leastvar a)  -> ([%#sbdd'19] interp a v = interp a (Map.set v x b))
  
  function discr_valuation [#"bdd.rs" 375 4 375 82] (self : t_Context) (a : t_Bdd) (b : t_Bdd) : Map.map UInt64.t bool
  
  axiom discr_valuation_def : forall self : t_Context, a : t_Bdd, b : t_Bdd . ([%#sbdd'7] inv self)
   -> ([%#sbdd'8] is_valid_bdd self a)
   -> ([%#sbdd'9] is_valid_bdd self b)
   -> ([%#sbdd'10] a <> b)
   -> discr_valuation self a b
  = ([%#sbdd'13] let _ = () in if leastvar a < leastvar b then
    match a with
      | {t_Bdd__0 = C_If v childt childf} -> if childf <> b then
        Map.set (discr_valuation self childf b) v false
      else
        Map.set (discr_valuation self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar a > leastvar b then
      match b with
        | {t_Bdd__0 = C_If v childt childf} -> if childf <> a then
          Map.set (discr_valuation self a childf) v false
        else
          Map.set (discr_valuation self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | {t_Bdd__0 = C_If v childta childfa} -> match b with
          | {t_Bdd__0 = C_If _ childtb childfb} -> if childfa <> childfb then
            Map.set (discr_valuation self childfa childfb) v false
          else
            Map.set (discr_valuation self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
  
  )
  
  axiom discr_valuation_spec : forall self : t_Context, a : t_Bdd, b : t_Bdd . ([%#sbdd'7] inv self)
   -> ([%#sbdd'8] is_valid_bdd self a)
   -> ([%#sbdd'9] is_valid_bdd self b)
   -> ([%#sbdd'10] a <> b)  -> ([%#sbdd'11] interp a (discr_valuation self a b) <> interp b (discr_valuation self a b))
  
  constant self  : t_Context
  
  constant a  : t_Bdd
  
  constant b  : t_Bdd
  
  function bdd_canonical [#"bdd.rs" 424 4 424 62] (self'0 : t_Context) (a'0 : t_Bdd) (b'0 : t_Bdd) : ()
  
  goal vc_bdd_canonical : ([%#sbdd] inv self)
   -> ([%#sbdd'0] is_valid_bdd self a)
   -> ([%#sbdd'1] is_valid_bdd self b)
   -> ([%#sbdd'2] forall v : Map.map UInt64.t bool . interp a v = interp b v)
   -> (let _ = discr_valuation in [%#sbdd'3] a = b)
end
module M_bdd__qyi11078426090797403070__new [#"bdd.rs" 430 4 430 52] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 435 28 435 57
  let%span sbdd'0 = "bdd.rs" 438 17 438 18
  let%span sbdd'1 = "bdd.rs" 430 48 430 52
  let%span sbdd'2 = "bdd.rs" 70 18 70 47
  let%span sbdd'3 = "bdd.rs" 267 12 291 19
  let%span sbdd'4 = "bdd.rs" 321 12 330 13
  let%span sbdd'5 = "bdd.rs" 314 12 314 47
  let%span sbdd'6 = "bdd.rs" 214 12 221 13
  let%span sbdd'7 = "bdd.rs" 244 12 248 13
  let%span sbdd'8 = "bdd.rs" 179 20 179 37
  let%span sbdd'9 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use map.Map
  use map.Const
  use mach.int.Int
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  let rec promoted0__new (return'  (x:t_Node))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_True ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]  ]
     [ & _0 : t_Node = Any.any_l () | & _1 : t_Node = Any.any_l () ]  [ return''0 (result:t_Node)-> return' {result} ] 
  
  type t_MyHashMap
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  let rec new (return'  (x:t_MyHashMap))= any
    [ return''0 (result:t_MyHashMap)-> {[%#sbdd'2] view result = Const.const (C_None)} (! return' {result}) ]
  
  
  type t_MyHashMap'0
  
  function view'0 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  let rec new'0 (return'  (x:t_MyHashMap'0))= any
    [ return''0 (result:t_MyHashMap'0)-> {[%#sbdd'2] view'0 result = Const.const (C_None)} (! return' {result}) ]
  
  
  type t_MyHashMap'1
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  let rec new'1 (return'  (x:t_MyHashMap'1))= any
    [ return''0 (result:t_MyHashMap'1)-> {[%#sbdd'2] view'1 result = Const.const (C_None)} (! return' {result}) ]
  
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'9] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'8] deep_model self
  
  function view'3 (self : t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'5] Map.get (view self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'4 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'7] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'4] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'6] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'3] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'0 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'1 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  meta "compute_max_steps" 1000000
  
  let rec new'2[#"bdd.rs" 430 4 430 52] (alloc:()) (return'  (x:t_Context))= (! bb0
    [ bb0 = s0
      [ s0 = promoted0__new (fun (pr0:t_Node) ->  [ &_10 <- pr0 ] s1)
      | s1 =  [ &t <- _10 ] s2
      | s2 = new (fun (_ret:t_MyHashMap) ->  [ &_5 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_6 <- [%#sbdd] Const.const t ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = new'0 (fun (_ret:t_MyHashMap'0) ->  [ &_8 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new'1 (fun (_ret:t_MyHashMap'1) ->  [ &_9 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0
      [ s0 = 
        [ &_0'0 <- { t_Context__alloc = alloc'0;
                     t_Context__hashcons = _5;
                     t_Context__hashcons_ghost = _6;
                     t_Context__not_memo = _8;
                     t_Context__and_memo = _9;
                     t_Context__cnt = ([%#sbdd'0] (0 : UInt64.t)) } ]
        
        s1
      | s1 = return''0 {_0'0} ]
     ]
    )
    [ & _0'0 : t_Context = Any.any_l ()
    | & alloc'0 : () = alloc
    | & t : t_Node = Any.any_l ()
    | & _5 : t_MyHashMap = Any.any_l ()
    | & _6 : Map.map UInt64.t t_Node = Any.any_l ()
    | & _8 : t_MyHashMap'0 = Any.any_l ()
    | & _9 : t_MyHashMap'1 = Any.any_l ()
    | & _10 : t_Node = Any.any_l () ]
     [ return''0 (result:t_Context)-> {[@expl:new result type invariant] [%#sbdd'1] inv result} (! return' {result}) ] 
end
module M_bdd__qyi11078426090797403070__hashcons [#"bdd.rs" 446 4 446 58] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 453 30 453 77
  let%span sbdd'0 = "bdd.rs" 454 33 454 34
  let%span sbdd'1 = "bdd.rs" 454 22 454 30
  let%span sbdd'2 = "bdd.rs" 460 20 460 21
  let%span sbdd'3 = "bdd.rs" 448 28 448 38
  let%span sbdd'4 = "bdd.rs" 446 21 446 25
  let%span sbdd'5 = "bdd.rs" 442 15 442 36
  let%span sbdd'6 = "bdd.rs" 443 14 443 28
  let%span sbdd'7 = "bdd.rs" 444 14 444 26
  let%span sbdd'8 = "bdd.rs" 445 14 445 42
  let%span sbdd'9 = "bdd.rs" 61 18 64 9
  let%span sbdd'10 = "bdd.rs" 21 18 21 32
  let%span sbdd'11 = "bdd.rs" 55 18 55 126
  let%span sbdd'12 = "bdd.rs" 179 20 179 37
  let%span sbdd'13 = "bdd.rs" 321 12 330 13
  let%span sbdd'14 = "bdd.rs" 301 12 306 17
  let%span sbdd'15 = "bdd.rs" 314 12 314 47
  let%span sbdd'16 = "bdd.rs" 163 12 167 13
  let%span sbdd'17 = "bdd.rs" 244 12 248 13
  let%span sbdd'18 = "bdd.rs" 267 12 291 19
  let%span sbdd'19 = "bdd.rs" 214 12 221 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'1 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Bdd
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option'0
  
  function view'0 (self : t_MyHashMap) : Map.map t_NodeLog t_Option'0 =
    [%#smodel] view self
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'16] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'0 (self : t_Node) : t_NodeLog =
    [%#smodel'0] deep_model self
  
  let rec get (self:t_MyHashMap) (key:t_Node) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#sbdd'9] match result with
        | C_Some v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'0 v
        | C_None -> Map.get (view'0 self) (deep_model'0 key) = C_None'0
        end}
      (! return' {result}) ]
  
  
  let rec alloc (self:()) (val':t_Node) (return'  (x:MutBorrow.t t_Node))= any
    [ return''0 (result:MutBorrow.t t_Node)-> {[%#sbdd'10] result.current = val'} (! return' {result}) ]
  
  
  predicate resolve (self : MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0 : MutBorrow.t t_Node) =
    resolve _0
  
  function view'1 (self : MutBorrow.t t_MyHashMap) : Map.map t_NodeLog t_Option'0 =
    [%#smodel'1] view self.current
  
  let rec add (self:MutBorrow.t t_MyHashMap) (key:t_Node) (val':t_Bdd) (return'  (x:()))= any
    [ return''0 (result:())-> {[%#sbdd'11] forall i : t_NodeLog . Map.get (view self.final) i
      = (if i = deep_model key then C_Some'0 val' else Map.get (view'1 self) i)}
      (! return' {result}) ]
  
  
  function view'2 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'12] deep_model self
  
  function view'3 (self : t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'15] Map.get (view self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some'0 b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'4 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'17] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'13] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option'0
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'19] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'6 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option'0
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'18] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some'0 b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'5 self.t_Context__not_memo) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'6 self.t_Context__and_memo) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                                t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                                 t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc'0 ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self : MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0'0 : MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Context [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate resolve'1 (self : MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0'0 : MutBorrow.t t_Context) =
    resolve'1 _0'0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Bdd))= any
    [ good (field_0:t_Bdd)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Bdd [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'14] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some'0 b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  meta "compute_max_steps" 1000000
  
  let rec hashcons[#"bdd.rs" 446 4 446 58] (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'4] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'5] is_valid_node self.current n}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_11 <- n'0 ] s1
      | s1 = get {(self'0.current).t_Context__hashcons} {_11} (fun (_ret:t_Option) ->  [ &_8 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = any [ br0 -> {_8 = C_None} (! bb4) | br1 (x0:t_Bdd)-> {_8 = C_Some x0} (! bb2) ] 
    | bb4 = s0
      [ s0 = alloc {(self'0.current).t_Context__alloc} {n'0} (fun (_ret:MutBorrow.t t_Node) ->  [ &_19 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 =  [ &r'0 <- { t_Bdd__0 = _19.current; t_Bdd__1 = (self'0.current).t_Context__cnt } ] s1
      | s1 = -{resolve'0 _19}- s2
      | s2 = MutBorrow.borrow_final
          <t_MyHashMap>
          {(self'0.current).t_Context__hashcons}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_MyHashMap) ->
             [ &_24 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Context__hashcons = _ret.final } } ] 
            s3)
      | s3 = add {_24} {n'0} {r'0} (fun (_ret:()) ->  [ &_23 <- _ret ] s4)
      | s4 = bb6 ]
    
    | bb6 = s0
      [ s0 =  [ &_27 <- [%#sbdd] Map.set (self'0.current).t_Context__hashcons_ghost r'0.t_Bdd__1 r'0.t_Bdd__0 ] s1
      | s1 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_Context__hashcons_ghost = _27 } } ] s1
      | s1 = UInt64.sub {[%#sbdd'1] (18446744073709551615 : UInt64.t)} {[%#sbdd'0] (1 : UInt64.t)}
          (fun (_ret:UInt64.t) ->  [ &_32 <- _ret ] s2)
      | s2 =  [ &_30 <- UInt64.gt (self'0.current).t_Context__cnt _32 ] s3
      | s3 = any [ br0 -> {_30 = false} (! bb11) | br1 -> {_30} (! bb8) ]  ]
    
    | bb8 = s0 [ s0 =  [ &old_9_0 <- self'0 ] s1 | s1 = bb9 ] 
    | bb9 = bb9'0
      [ bb9'0 = {[@expl:mut invariant] old_9_0.final = self'0.final}
        (! s0) [ s0 = bb10 ] 
        [ bb10 = s0
          [ s0 = 
            [ &self'0 <- { self'0 with current = { self'0.current with t_Context__cnt = (self'0.current).t_Context__cnt } } ]
            
            s1
          | s1 = bb9'0 ]
         ]
       ]
    
    | bb11 = s0
      [ s0 = UInt64.add {(self'0.current).t_Context__cnt} {[%#sbdd'2] (1 : UInt64.t)}
          (fun (_ret:UInt64.t) ->
             [ &self'0 <- { self'0 with current = { self'0.current with t_Context__cnt = _ret } } ] 
            s1)
      | s1 = {[@expl:type invariant] inv'0 self'0} s2
      | s2 = -{resolve'2 self'0}- s3
      | s3 =  [ &_0'0 <- r'0 ] s4
      | s4 = bb12 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some {_8} (fun (r0:t_Bdd) ->  [ &r <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 self'0} s2
      | s2 = -{resolve'2 self'0}- s3
      | s3 = {[@expl:assertion] [%#sbdd'3] view'3 r.t_Bdd__0 = view'2 n'0} s4
      | s4 =  [ &_0'0 <- r ] s5
      | s5 = bb12 ]
    
    | bb12 = return''0 {_0'0} ]
    )
    [ & _0'0 : t_Bdd = Any.any_l ()
    | & self'0 : MutBorrow.t t_Context = self
    | & n'0 : t_Node = n
    | & _8 : t_Option = Any.any_l ()
    | & _11 : t_Node = Any.any_l ()
    | & r : t_Bdd = Any.any_l ()
    | & r'0 : t_Bdd = Any.any_l ()
    | & _19 : MutBorrow.t t_Node = Any.any_l ()
    | & _23 : () = Any.any_l ()
    | & _24 : MutBorrow.t t_MyHashMap = Any.any_l ()
    | & _27 : Map.map UInt64.t t_Node = Any.any_l ()
    | & _30 : bool = Any.any_l ()
    | & _32 : UInt64.t = Any.any_l ()
    | & old_9_0 : MutBorrow.t t_Context = Any.any_l () ]
    
    [ return''0 (result:t_Bdd)-> {[@expl:hashcons ensures #0] [%#sbdd'6] result.t_Bdd__0 = n}
      {[@expl:hashcons ensures #1] [%#sbdd'7] grows self}
      {[@expl:hashcons ensures #2] [%#sbdd'8] is_valid_bdd self.final result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__node [#"bdd.rs" 471 4 471 87] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 471 17 471 21
  let%span sbdd'0 = "bdd.rs" 464 15 464 40
  let%span sbdd'1 = "bdd.rs" 465 15 465 40
  let%span sbdd'2 = "bdd.rs" 466 15 466 63
  let%span sbdd'3 = "bdd.rs" 467 14 467 26
  let%span sbdd'4 = "bdd.rs" 468 14 468 42
  let%span sbdd'5 = "bdd.rs" 469 14 469 104
  let%span sbdd'6 = "bdd.rs" 470 14 470 37
  let%span sbdd'7 = "bdd.rs" 204 14 204 37
  let%span sbdd'8 = "bdd.rs" 446 21 446 25
  let%span sbdd'9 = "bdd.rs" 442 15 442 36
  let%span sbdd'10 = "bdd.rs" 443 14 443 28
  let%span sbdd'11 = "bdd.rs" 444 14 444 26
  let%span sbdd'12 = "bdd.rs" 445 14 445 42
  let%span sbdd'13 = "bdd.rs" 314 12 314 47
  let%span sbdd'14 = "bdd.rs" 244 12 248 13
  let%span sbdd'15 = "bdd.rs" 301 12 306 17
  let%span sbdd'16 = "bdd.rs" 214 12 221 13
  let%span sbdd'17 = "bdd.rs" 321 12 330 13
  let%span sbdd'18 = "bdd.rs" 199 20 199 37
  let%span sbdd'19 = "bdd.rs" 267 12 291 19
  let%span sbdd'20 = "bdd.rs" 179 20 179 37
  let%span sbdd'21 = "bdd.rs" 189 20 189 26
  let%span sbdd'22 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'21] self.t_Bdd__1
  
  function view [#"bdd.rs" 198 4 198 33] (self : t_Bdd) : UInt64.t =
    [%#sbdd'18] deep_model self
  
  function view'0 (self : t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  let rec eq (self:t_Bdd) (o:t_Bdd) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sbdd'7] result = (view'0 self = view'0 o)} (! return' {result}) ]
  
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model'0 [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'22] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'20] deep_model'0 self
  
  function view'3 (self : t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'13] Map.get (view'1 self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'4 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'14] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'17] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'16] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'6 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'19] (forall n : t_NodeLog . match Map.get (view'1 self.t_Context__hashcons) n with
      | C_Some b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'5 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'6 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self : MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0'0 : MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Context [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate resolve (self : MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0 : MutBorrow.t t_Context) =
    resolve _0'0
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'15] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view'1 (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view'1 (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec hashcons (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'8] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'9] is_valid_node self.current n}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'10] result.t_Bdd__0 = n}
      {[%#sbdd'11] grows self}
      {[%#sbdd'12] is_valid_bdd self.final result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec node[#"bdd.rs" 471 4 471 87] (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    (! bb0
    [ bb0 = s0 [ s0 = eq {childt'0} {childf'0} (fun (_ret:bool) ->  [ &_13 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0'0 <- childt'0 ] s3
      | s3 = bb5 ]
    
    | bb3 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_17 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 =  [ &_18 <- C_If x'0 childt'0 childf'0 ] s2
      | s2 = hashcons {_17} {_18} (fun (_ret:t_Bdd) ->  [ &_0'0 <- _ret ] s3)
      | s3 = bb4 ]
    
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb5 ] 
    | bb5 = return''0 {_0'0} ]
    )
    [ & _0'0 : t_Bdd = Any.any_l ()
    | & self'0 : MutBorrow.t t_Context = self
    | & x'0 : UInt64.t = x
    | & childt'0 : t_Bdd = childt
    | & childf'0 : t_Bdd = childf
    | & _13 : bool = Any.any_l ()
    | & _17 : MutBorrow.t t_Context = Any.any_l ()
    | & _18 : t_Node = Any.any_l () ]
    
    [ return''0 (result:t_Bdd)-> {[@expl:node ensures #0] [%#sbdd'3] grows self}
      {[@expl:node ensures #1] [%#sbdd'4] is_valid_bdd self.final result}
      {[@expl:node ensures #2] [%#sbdd'5] forall v : Map.map UInt64.t bool . interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[@expl:node ensures #3] [%#sbdd'6] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__trueqy95z [#"bdd.rs" 482 4 482 42] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 482 22 482 26
  let%span sbdd'0 = "bdd.rs" 478 14 478 26
  let%span sbdd'1 = "bdd.rs" 479 14 479 42
  let%span sbdd'2 = "bdd.rs" 480 14 480 42
  let%span sbdd'3 = "bdd.rs" 481 14 481 46
  let%span sbdd'4 = "bdd.rs" 446 21 446 25
  let%span sbdd'5 = "bdd.rs" 442 15 442 36
  let%span sbdd'6 = "bdd.rs" 443 14 443 28
  let%span sbdd'7 = "bdd.rs" 444 14 444 26
  let%span sbdd'8 = "bdd.rs" 445 14 445 42
  let%span sbdd'9 = "bdd.rs" 301 12 306 17
  let%span sbdd'10 = "bdd.rs" 314 12 314 47
  let%span sbdd'11 = "bdd.rs" 214 12 221 13
  let%span sbdd'12 = "bdd.rs" 244 12 248 13
  let%span sbdd'13 = "bdd.rs" 321 12 330 13
  let%span sbdd'14 = "bdd.rs" 267 12 291 19
  let%span sbdd'15 = "bdd.rs" 179 20 179 37
  let%span sbdd'16 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'16] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'15] deep_model self
  
  function view'1 (self : t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'10] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'12] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'13] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'11] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'14] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'3 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'4 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self : MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0'0 : MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Context [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'9] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec hashcons (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'4] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'5] is_valid_node self.current n}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'6] result.t_Bdd__0 = n}
      {[%#sbdd'7] grows self}
      {[%#sbdd'8] is_valid_bdd self.final result}
      (! return' {result}) ]
  
  
  predicate resolve (self : MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0 : MutBorrow.t t_Context) =
    resolve _0'0
  
  meta "compute_max_steps" 1000000
  
  let rec trueqy95z[#"bdd.rs" 482 4 482 42] (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:true_ 'self' type invariant] [%#sbdd] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 =  [ &_7 <- C_True ] s2
      | s2 = hashcons {_6} {_7} (fun (_ret:t_Bdd) ->  [ &_0'0 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0'0} ]
     ]
    )
    [ & _0'0 : t_Bdd = Any.any_l ()
    | & self'0 : MutBorrow.t t_Context = self
    | & _6 : MutBorrow.t t_Context = Any.any_l ()
    | & _7 : t_Node = Any.any_l () ]
    
    [ return''0 (result:t_Bdd)-> {[@expl:true_ ensures #0] [%#sbdd'0] grows self}
      {[@expl:true_ ensures #1] [%#sbdd'1] is_valid_bdd self.final result}
      {[@expl:true_ ensures #2] [%#sbdd'2] forall v : Map.map UInt64.t bool . interp result v}
      {[@expl:true_ ensures #3] [%#sbdd'3] UInt64.t'int (v_MAX : UInt64.t) + 1 = leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__falseqy95z [#"bdd.rs" 490 4 490 43] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 490 23 490 27
  let%span sbdd'0 = "bdd.rs" 486 14 486 26
  let%span sbdd'1 = "bdd.rs" 487 14 487 42
  let%span sbdd'2 = "bdd.rs" 488 14 488 43
  let%span sbdd'3 = "bdd.rs" 489 14 489 46
  let%span sbdd'4 = "bdd.rs" 446 21 446 25
  let%span sbdd'5 = "bdd.rs" 442 15 442 36
  let%span sbdd'6 = "bdd.rs" 443 14 443 28
  let%span sbdd'7 = "bdd.rs" 444 14 444 26
  let%span sbdd'8 = "bdd.rs" 445 14 445 42
  let%span sbdd'9 = "bdd.rs" 301 12 306 17
  let%span sbdd'10 = "bdd.rs" 314 12 314 47
  let%span sbdd'11 = "bdd.rs" 214 12 221 13
  let%span sbdd'12 = "bdd.rs" 244 12 248 13
  let%span sbdd'13 = "bdd.rs" 321 12 330 13
  let%span sbdd'14 = "bdd.rs" 267 12 291 19
  let%span sbdd'15 = "bdd.rs" 179 20 179 37
  let%span sbdd'16 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'16] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'15] deep_model self
  
  function view'1 (self : t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'10] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'12] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'13] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'11] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'14] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'3 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'4 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self : MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0'0 : MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Context [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'9] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec hashcons (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'4] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'5] is_valid_node self.current n}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'6] result.t_Bdd__0 = n}
      {[%#sbdd'7] grows self}
      {[%#sbdd'8] is_valid_bdd self.final result}
      (! return' {result}) ]
  
  
  predicate resolve (self : MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0 : MutBorrow.t t_Context) =
    resolve _0'0
  
  meta "compute_max_steps" 1000000
  
  let rec falseqy95z[#"bdd.rs" 490 4 490 43] (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 =  [ &_7 <- C_False ] s2
      | s2 = hashcons {_6} {_7} (fun (_ret:t_Bdd) ->  [ &_0'0 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0'0} ]
     ]
    )
    [ & _0'0 : t_Bdd = Any.any_l ()
    | & self'0 : MutBorrow.t t_Context = self
    | & _6 : MutBorrow.t t_Context = Any.any_l ()
    | & _7 : t_Node = Any.any_l () ]
    
    [ return''0 (result:t_Bdd)-> {[@expl:false_ ensures #0] [%#sbdd'0] grows self}
      {[@expl:false_ ensures #1] [%#sbdd'1] is_valid_bdd self.final result}
      {[@expl:false_ ensures #2] [%#sbdd'2] forall v : Map.map UInt64.t bool . not interp result v}
      {[@expl:false_ ensures #3] [%#sbdd'3] UInt64.t'int (v_MAX : UInt64.t) + 1 = leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__v [#"bdd.rs" 497 4 497 46] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 497 18 497 22
  let%span sbdd'0 = "bdd.rs" 494 14 494 26
  let%span sbdd'1 = "bdd.rs" 495 14 495 42
  let%span sbdd'2 = "bdd.rs" 496 14 496 54
  let%span sbdd'3 = "bdd.rs" 482 22 482 26
  let%span sbdd'4 = "bdd.rs" 478 14 478 26
  let%span sbdd'5 = "bdd.rs" 479 14 479 42
  let%span sbdd'6 = "bdd.rs" 480 14 480 42
  let%span sbdd'7 = "bdd.rs" 481 14 481 46
  let%span sbdd'8 = "bdd.rs" 490 23 490 27
  let%span sbdd'9 = "bdd.rs" 486 14 486 26
  let%span sbdd'10 = "bdd.rs" 487 14 487 42
  let%span sbdd'11 = "bdd.rs" 488 14 488 43
  let%span sbdd'12 = "bdd.rs" 489 14 489 46
  let%span sbdd'13 = "bdd.rs" 471 17 471 21
  let%span sbdd'14 = "bdd.rs" 464 15 464 40
  let%span sbdd'15 = "bdd.rs" 465 15 465 40
  let%span sbdd'16 = "bdd.rs" 466 15 466 63
  let%span sbdd'17 = "bdd.rs" 467 14 467 26
  let%span sbdd'18 = "bdd.rs" 468 14 468 42
  let%span sbdd'19 = "bdd.rs" 469 14 469 104
  let%span sbdd'20 = "bdd.rs" 470 14 470 37
  let%span sbdd'21 = "bdd.rs" 301 12 306 17
  let%span sbdd'22 = "bdd.rs" 314 12 314 47
  let%span sbdd'23 = "bdd.rs" 214 12 221 13
  let%span sbdd'24 = "bdd.rs" 244 12 248 13
  let%span sbdd'25 = "bdd.rs" 267 12 291 19
  let%span sbdd'26 = "bdd.rs" 179 20 179 37
  let%span sbdd'27 = "bdd.rs" 321 12 330 13
  let%span sbdd'28 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'28] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'26] deep_model self
  
  function view'1 (self : t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'22] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'2 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'24] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'27] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'23] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'4 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'25] (forall n : t_NodeLog . match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'3 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'4 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                              t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                               t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self : MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0'0 : MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Context [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'21] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec trueqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:true_ 'self' type invariant] [%#sbdd'3] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'4] grows self}
      {[%#sbdd'5] is_valid_bdd self.final result}
      {[%#sbdd'6] forall v : Map.map UInt64.t bool . interp result v}
      {[%#sbdd'7] UInt64.t'int (v_MAX : UInt64.t) + 1 = leastvar result}
      (! return' {result}) ]
  
  
  let rec falseqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd'8] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'9] grows self}
      {[%#sbdd'10] is_valid_bdd self.final result}
      {[%#sbdd'11] forall v : Map.map UInt64.t bool . not interp result v}
      {[%#sbdd'12] UInt64.t'int (v_MAX : UInt64.t) + 1 = leastvar result}
      (! return' {result}) ]
  
  
  let rec node (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd'13] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'14] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'15] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'16] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'17] grows self}
      {[%#sbdd'18] is_valid_bdd self.final result}
      {[%#sbdd'19] forall v : Map.map UInt64.t bool . interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[%#sbdd'20] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]
  
  
  predicate resolve (self : MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0 : MutBorrow.t t_Context) =
    resolve _0'0
  
  meta "compute_max_steps" 1000000
  
  let rec v[#"bdd.rs" 497 4 497 46] (self:MutBorrow.t t_Context) (x:UInt64.t) (return'  (x'0:t_Bdd))= {[@expl:v 'self' type invariant] [%#sbdd] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_7 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = trueqy95z {_7} (fun (_ret:t_Bdd) ->  [ &t <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_9 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = falseqy95z {_9} (fun (_ret:t_Bdd) ->  [ &f <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_10 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = node {_10} {x'0} {t} {f} (fun (_ret:t_Bdd) ->  [ &_0'0 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0'0} ]
     ]
    )
    [ & _0'0 : t_Bdd = Any.any_l ()
    | & self'0 : MutBorrow.t t_Context = self
    | & x'0 : UInt64.t = x
    | & t : t_Bdd = Any.any_l ()
    | & _7 : MutBorrow.t t_Context = Any.any_l ()
    | & f : t_Bdd = Any.any_l ()
    | & _9 : MutBorrow.t t_Context = Any.any_l ()
    | & _10 : MutBorrow.t t_Context = Any.any_l () ]
    
    [ return''0 (result:t_Bdd)-> {[@expl:v ensures #0] [%#sbdd'0] grows self}
      {[@expl:v ensures #1] [%#sbdd'1] is_valid_bdd self.final result}
      {[@expl:v ensures #2] [%#sbdd'2] forall v'0 : Map.map UInt64.t bool . interp result v'0 = Map.get v'0 x}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__not [#"bdd.rs" 509 4 509 56] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 509 20 509 24
  let%span sbdd'0 = "bdd.rs" 503 15 503 35
  let%span sbdd'1 = "bdd.rs" 504 14 504 26
  let%span sbdd'2 = "bdd.rs" 505 14 505 42
  let%span sbdd'3 = "bdd.rs" 506 14 506 58
  let%span sbdd'4 = "bdd.rs" 507 14 507 47
  let%span sbdd'5 = "bdd.rs" 508 14 508 22
  let%span sbdd'6 = "bdd.rs" 61 18 64 9
  let%span sbdd'7 = "bdd.rs" 471 17 471 21
  let%span sbdd'8 = "bdd.rs" 464 15 464 40
  let%span sbdd'9 = "bdd.rs" 465 15 465 40
  let%span sbdd'10 = "bdd.rs" 466 15 466 63
  let%span sbdd'11 = "bdd.rs" 467 14 467 26
  let%span sbdd'12 = "bdd.rs" 468 14 468 42
  let%span sbdd'13 = "bdd.rs" 469 14 469 104
  let%span sbdd'14 = "bdd.rs" 470 14 470 37
  let%span sbdd'15 = "bdd.rs" 490 23 490 27
  let%span sbdd'16 = "bdd.rs" 486 14 486 26
  let%span sbdd'17 = "bdd.rs" 487 14 487 42
  let%span sbdd'18 = "bdd.rs" 488 14 488 43
  let%span sbdd'19 = "bdd.rs" 489 14 489 46
  let%span sbdd'20 = "bdd.rs" 482 22 482 26
  let%span sbdd'21 = "bdd.rs" 478 14 478 26
  let%span sbdd'22 = "bdd.rs" 479 14 479 42
  let%span sbdd'23 = "bdd.rs" 480 14 480 42
  let%span sbdd'24 = "bdd.rs" 481 14 481 46
  let%span sbdd'25 = "bdd.rs" 55 18 55 126
  let%span sbdd'26 = "bdd.rs" 314 12 314 47
  let%span sbdd'27 = "bdd.rs" 301 12 306 17
  let%span sbdd'28 = "bdd.rs" 214 12 221 13
  let%span sbdd'29 = "bdd.rs" 244 12 248 13
  let%span sbdd'30 = "bdd.rs" 226 14 226 25
  let%span sbdd'31 = "bdd.rs" 229 12 237 13
  let%span sbdd'32 = "bdd.rs" 189 20 189 26
  let%span sbdd'33 = "bdd.rs" 267 12 291 19
  let%span sbdd'34 = "bdd.rs" 179 20 179 37
  let%span sbdd'35 = "bdd.rs" 321 12 330 13
  let%span sbdd'36 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'1 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Bdd
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option'0
  
  function view'0 (self : t_MyHashMap'0) : Map.map UInt64.t t_Option'0 =
    [%#smodel] view self
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'32] self.t_Bdd__1
  
  function deep_model'0 (self : t_Bdd) : UInt64.t =
    [%#smodel'0] deep_model self
  
  let rec get (self:t_MyHashMap'0) (key:t_Bdd) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#sbdd'6] match result with
        | C_Some v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'0 v
        | C_None -> Map.get (view'0 self) (deep_model'0 key) = C_None'0
        end}
      (! return' {result}) ]
  
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd, childf : t_Bdd [C_If v childt childf : t_Node] . C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option'0
  
  function deep_model'1 [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'36] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'34] deep_model'1 self
  
  function view'3 (self : t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'26] Map.get (view'1 self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some'0 b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'4 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'29] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'35] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'28] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tuple  =
    { _0: UInt64.t; _1: UInt64.t }
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple t_Option'0
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'33] (forall n : t_NodeLog . match Map.get (view'1 self.t_Context__hashcons) n with
      | C_Some'0 b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view self.t_Context__not_memo) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple . match Map.get (view'5 self.t_Context__and_memo) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0;
                                t_Bdd__1 = abm._0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1;
                                                                 t_Bdd__1 = abm._1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'0 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self : MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0'0 : MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Context [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'27] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view'1 (self.current).t_Context__hashcons) n with
      | C_Some'0 b -> Map.get (view'1 (self.final).t_Context__hashcons) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec node (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd'7] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'8] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'9] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'10] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'11] grows self}
      {[%#sbdd'12] is_valid_bdd self.final result}
      {[%#sbdd'13] forall v : Map.map UInt64.t bool . interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[%#sbdd'14] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]
  
  
  let rec falseqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd'15] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'16] grows self}
      {[%#sbdd'17] is_valid_bdd self.final result}
      {[%#sbdd'18] forall v : Map.map UInt64.t bool . not interp result v}
      {[%#sbdd'19] UInt64.t'int (v_MAX : UInt64.t) + 1 = leastvar result}
      (! return' {result}) ]
  
  
  let rec trueqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:true_ 'self' type invariant] [%#sbdd'20] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'21] grows self}
      {[%#sbdd'22] is_valid_bdd self.final result}
      {[%#sbdd'23] forall v : Map.map UInt64.t bool . interp result v}
      {[%#sbdd'24] UInt64.t'int (v_MAX : UInt64.t) + 1 = leastvar result}
      (! return' {result}) ]
  
  
  function view'6 (self : MutBorrow.t t_MyHashMap'0) : Map.map UInt64.t t_Option'0 =
    [%#smodel'1] view self.current
  
  let rec add (self:MutBorrow.t t_MyHashMap'0) (key:t_Bdd) (val':t_Bdd) (return'  (x:()))= any
    [ return''0 (result:())-> {[%#sbdd'25] forall i : UInt64.t . Map.get (view self.final) i
      = (if i = deep_model key then C_Some'0 val' else Map.get (view'6 self) i)}
      (! return' {result}) ]
  
  
  predicate resolve (self : MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'0 : MutBorrow.t t_Context) =
    resolve _0'0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Bdd))= any
    [ good (field_0:t_Bdd)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Bdd [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  function size [#"bdd.rs" 227 4 227 24] (self : t_Bdd) : int =
    [%#sbdd'31] match self with
      | {t_Bdd__0 = C_True} -> 0
      | {t_Bdd__0 = C_False} -> 0
      | {t_Bdd__0 = C_If _ childt childf} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec : forall self : t_Bdd . [%#sbdd'30] size self >= 0
  
  meta "compute_max_steps" 1000000
  
  let rec not'[#"bdd.rs" 509 4 509 56] (self:MutBorrow.t t_Context) (x:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:not 'self' type invariant] [%#sbdd] inv'0 self}
    {[@expl:not requires] [%#sbdd'0] is_valid_bdd self.current x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_13 <- x'0 ] s1
      | s1 = get {(self'0.current).t_Context__not_memo} {_13} (fun (_ret:t_Option) ->  [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = any [ br0 -> {_10 = C_None} (! bb4) | br1 (x0:t_Bdd)-> {_10 = C_Some x0} (! bb2) ] 
    | bb4 = any
      [ br0 -> {x'0.t_Bdd__0 = C_False} (! bb7)
      | br1 -> {x'0.t_Bdd__0 = C_True} (! bb6)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {x'0.t_Bdd__0 = C_If x0 x1 x2} (! bb8) ]
    
    | bb8 = s0
      [ s0 = v_If {x'0.t_Bdd__0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v <- rv ] s1)
      | s1 = v_If {x'0.t_Bdd__0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt <- rchildt ] s2)
      | s2 = v_If {x'0.t_Bdd__0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf <- rchildf ] s3)
      | s3 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_25 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s4)
      | s4 = not' {_25} {childt} (fun (_ret:t_Bdd) ->  [ &childt'0 <- _ret ] s5)
      | s5 = bb13 ]
    
    | bb13 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_28 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = not' {_28} {childf} (fun (_ret:t_Bdd) ->  [ &childf'0 <- _ret ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_30 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = node {_30} {v} {childt'0} {childf'0} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb15 ]
    
    | bb15 = bb16
    | bb6 = bb10
    | bb10 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_19 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = falseqy95z {_19} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb11 ]
    
    | bb11 = bb16
    | bb7 = bb9
    | bb9 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_20 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = trueqy95z {_20} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb12 ]
    
    | bb12 = bb16
    | bb16 = s0
      [ s0 = MutBorrow.borrow_final
          <t_MyHashMap'0>
          {(self'0.current).t_Context__not_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 4}
          (fun (_ret:MutBorrow.t t_MyHashMap'0) ->
             [ &_35 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Context__not_memo = _ret.final } } ] 
            s1)
      | s1 = add {_35} {x'0} {r'0} (fun (_ret:()) ->  [ &_34 <- _ret ] s2)
      | s2 = bb17 ]
    
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0'0 <- r'0 ] s3
      | s3 = bb18 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some {_10} (fun (r0:t_Bdd) ->  [ &r <- r0 ] s1)
      | s1 =  [ &_0'0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self'0} s3
      | s3 = -{resolve'0 self'0}- s4
      | s4 = bb18 ]
    
    | bb18 = return''0 {_0'0} ]
    )
    [ & _0'0 : t_Bdd = Any.any_l ()
    | & self'0 : MutBorrow.t t_Context = self
    | & x'0 : t_Bdd = x
    | & _10 : t_Option = Any.any_l ()
    | & _13 : t_Bdd = Any.any_l ()
    | & r : t_Bdd = Any.any_l ()
    | & r'0 : t_Bdd = Any.any_l ()
    | & _19 : MutBorrow.t t_Context = Any.any_l ()
    | & _20 : MutBorrow.t t_Context = Any.any_l ()
    | & v : UInt64.t = Any.any_l ()
    | & childt : t_Bdd = Any.any_l ()
    | & childf : t_Bdd = Any.any_l ()
    | & childt'0 : t_Bdd = Any.any_l ()
    | & _25 : MutBorrow.t t_Context = Any.any_l ()
    | & childf'0 : t_Bdd = Any.any_l ()
    | & _28 : MutBorrow.t t_Context = Any.any_l ()
    | & _30 : MutBorrow.t t_Context = Any.any_l ()
    | & _34 : () = Any.any_l ()
    | & _35 : MutBorrow.t t_MyHashMap'0 = Any.any_l () ]
    
    [ return''0 (result:t_Bdd)-> {[@expl:not ensures #0] [%#sbdd'1] grows self}
      {[@expl:not ensures #1] [%#sbdd'2] is_valid_bdd self.final result}
      {[@expl:not ensures #2] [%#sbdd'3] forall v : Map.map UInt64.t bool . interp result v = (not interp x v)}
      {[@expl:not ensures #3] [%#sbdd'4] leastvar x <= leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__and [#"bdd.rs" 533 4 533 72] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 537 22 537 34
  let%span sbdd'0 = "bdd.rs" 533 20 533 24
  let%span sbdd'1 = "bdd.rs" 526 15 526 35
  let%span sbdd'2 = "bdd.rs" 527 15 527 35
  let%span sbdd'3 = "bdd.rs" 528 14 528 26
  let%span sbdd'4 = "bdd.rs" 529 14 529 42
  let%span sbdd'5 = "bdd.rs" 530 14 530 74
  let%span sbdd'6 = "bdd.rs" 531 14 531 84
  let%span sbdd'7 = "bdd.rs" 532 14 532 33
  let%span sbdd'8 = "bdd.rs" 61 18 64 9
  let%span sbdd'9 = "bdd.rs" 471 17 471 21
  let%span sbdd'10 = "bdd.rs" 464 15 464 40
  let%span sbdd'11 = "bdd.rs" 465 15 465 40
  let%span sbdd'12 = "bdd.rs" 466 15 466 63
  let%span sbdd'13 = "bdd.rs" 467 14 467 26
  let%span sbdd'14 = "bdd.rs" 468 14 468 42
  let%span sbdd'15 = "bdd.rs" 469 14 469 104
  let%span sbdd'16 = "bdd.rs" 470 14 470 37
  let%span sbdd'17 = "bdd.rs" 490 23 490 27
  let%span sbdd'18 = "bdd.rs" 486 14 486 26
  let%span sbdd'19 = "bdd.rs" 487 14 487 42
  let%span sbdd'20 = "bdd.rs" 488 14 488 43
  let%span sbdd'21 = "bdd.rs" 489 14 489 46
  let%span sbdd'22 = "bdd.rs" 55 18 55 126
  let%span sbdd'23 = "bdd.rs" 314 12 314 47
  let%span sbdd'24 = "bdd.rs" 301 12 306 17
  let%span sbdd'25 = "bdd.rs" 214 12 221 13
  let%span sbdd'26 = "bdd.rs" 244 12 248 13
  let%span sbdd'27 = "bdd.rs" 226 14 226 25
  let%span sbdd'28 = "bdd.rs" 229 12 237 13
  let%span sbdd'29 = "bdd.rs" 267 12 291 19
  let%span sbdd'30 = "bdd.rs" 189 20 189 26
  let%span sbdd'31 = "bdd.rs" 179 20 179 37
  let%span sbdd'32 = "bdd.rs" 321 12 330 13
  let%span sbdd'33 = "bdd.rs" 163 12 167 13
  let%span snum = "../../creusot-contracts/src/std/num.rs" 25 28 25 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'1 = "../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 100 20 100 44
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 72 26 72 85
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'17 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'18 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'19 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'20 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'21 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'22 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'23 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'24 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'25 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'26 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 54 20 54 34
  
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  type tuple  =
    { _0: t_Bdd; _1: t_Bdd }
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: UInt64.t }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type tuple'0  =
    { _0'0: UInt64.t; _1'0: UInt64.t }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Bdd
  
  function view [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'1) : Map.map tuple'0 t_Option'0
  
  function view'0 (self : t_MyHashMap'1) : Map.map tuple'0 t_Option'0 =
    [%#smodel] view self
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'30] self.t_Bdd__1
  
  function deep_model'0 (self : tuple) : tuple'0 =
    [%#stuples] { _0'0 = deep_model self._0; _1'0 = deep_model self._1 }
  
  function deep_model'1 (self : tuple) : tuple'0 =
    [%#smodel'0] deep_model'0 self
  
  let rec get (self:t_MyHashMap'1) (key:tuple) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#sbdd'8] match result with
        | C_Some v -> Map.get (view'0 self) (deep_model'1 key) = C_Some'0 v
        | C_None -> Map.get (view'0 self) (deep_model'1 key) = C_None'0
        end}
      (! return' {result}) ]
  
  
  type tuple'1  =
    { _0'1: t_Node; _1'1: t_Node }
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'1 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap) : Map.map t_NodeLog t_Option'0
  
  function deep_model'2 [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'33] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'31] deep_model'2 self
  
  function view'3 (self : t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 312 4 312 53] (self : t_Context) (b : t_Bdd) =
    [%#sbdd'23] Map.get (view'1 self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some'0 b
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'4 (self : UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 242 4 242 28] (self : t_Bdd) : int =
    [%#sbdd'26] match self with
      | {t_Bdd__0 = C_True} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_False} -> UInt64.t'int (v_MAX : UInt64.t) + 1
      | {t_Bdd__0 = C_If v _ _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 319 4 319 51] (self : t_Context) (n : t_Node) =
    [%#sbdd'32] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self : UInt64.t) (o : UInt64.t) : t_Ordering =
    [%#sord'26] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom eq_cmp_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'25] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym2_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'23] cmp_log x y = C_Greater)
   -> ([%#sord'24] cmp_log y x = C_Less)
  
  function antisym1 (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom antisym1_spec : forall x : UInt64.t, y : UInt64.t . ([%#sord'21] cmp_log x y = C_Less)
   -> ([%#sord'22] cmp_log y x = C_Greater)
  
  function trans (x : UInt64.t) (y : UInt64.t) (z : UInt64.t) (o : t_Ordering) : ()
  
  axiom trans_spec : forall x : UInt64.t, y : UInt64.t, z : UInt64.t, o : t_Ordering . ([%#sord'18] cmp_log x y = o)
   -> ([%#sord'19] cmp_log y z = o)  -> ([%#sord'20] cmp_log x z = o)
  
  function refl (x : UInt64.t) : ()
  
  axiom refl_spec : forall x : UInt64.t . [%#sord'17] cmp_log x x = C_Equal
  
  function cmp_gt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_gt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'16] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_ge_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'15] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_lt_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'14] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x : UInt64.t) (y : UInt64.t) : ()
  
  axiom cmp_le_log_spec : forall x : UInt64.t, y : UInt64.t . [%#sord'13] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 [#"bdd.rs" 49 8 49 37] (self : t_MyHashMap'0) : Map.map UInt64.t t_Option'0
  
  function interp [#"bdd.rs" 212 4 212 53] (self : t_Bdd) (vars : Map.map UInt64.t bool) : bool =
    [%#sbdd'25] match self with
      | {t_Bdd__0 = C_True} -> true
      | {t_Bdd__0 = C_False} -> false
      | {t_Bdd__0 = C_If v childt childf} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  predicate invariant' [#"bdd.rs" 265 4 265 30] (self : t_Context) =
    [%#sbdd'29] (forall n : t_NodeLog . match Map.get (view'1 self.t_Context__hashcons) n with
      | C_Some'0 b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 self.t_Context__cnt /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None'0 -> true
      end)
    /\ (forall bm : UInt64.t . match Map.get (view'5 self.t_Context__not_memo) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm : tuple'0 . match Map.get (view self.t_Context__and_memo) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._0'0;
                                t_Bdd__1 = abm._0'0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._1'0;
                                                                   t_Bdd__1 = abm._1'0 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v : Map.map UInt64.t bool . interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0'2 : t_Context)
  
  axiom inv_axiom [@rewrite] : forall x : t_Context [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self : MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0'2 : MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite] : forall x : MutBorrow.t t_Context [inv'0 x] . inv'0 x = invariant''0 x
  
  predicate resolve (self : MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0'2 : MutBorrow.t t_Context) =
    resolve _0'2
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v : UInt64.t, childt : t_Bdd, childf : t_Bdd [C_If v childt childf : t_Node] . C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  function cmp_log'0 (self : int) (o : int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp'0 (x : int) (y : int) : ()
  
  axiom eq_cmp_spec'0 : forall x : int, y : int . [%#sord'12] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x : int) (y : int) : ()
  
  axiom antisym2_spec'0 : forall x : int, y : int . ([%#sord'10] cmp_log'0 x y = C_Greater)
   -> ([%#sord'11] cmp_log'0 y x = C_Less)
  
  function antisym1'0 (x : int) (y : int) : ()
  
  axiom antisym1_spec'0 : forall x : int, y : int . ([%#sord'8] cmp_log'0 x y = C_Less)
   -> ([%#sord'9] cmp_log'0 y x = C_Greater)
  
  function trans'0 (x : int) (y : int) (z : int) (o : t_Ordering) : ()
  
  axiom trans_spec'0 : forall x : int, y : int, z : int, o : t_Ordering . ([%#sord'5] cmp_log'0 x y = o)
   -> ([%#sord'6] cmp_log'0 y z = o)  -> ([%#sord'7] cmp_log'0 x z = o)
  
  function refl'0 (x : int) : ()
  
  axiom refl_spec'0 : forall x : int . [%#sord'4] cmp_log'0 x x = C_Equal
  
  function cmp_gt_log'0 (x : int) (y : int) : ()
  
  axiom cmp_gt_log_spec'0 : forall x : int, y : int . [%#sord'3] (x > y) = (cmp_log'0 x y = C_Greater)
  
  function cmp_ge_log'0 (x : int) (y : int) : ()
  
  axiom cmp_ge_log_spec'0 : forall x : int, y : int . [%#sord'2] (x >= y) = (cmp_log'0 x y <> C_Less)
  
  function cmp_lt_log'0 (x : int) (y : int) : ()
  
  axiom cmp_lt_log_spec'0 : forall x : int, y : int . [%#sord'1] (x < y) = (cmp_log'0 x y = C_Less)
  
  function cmp_le_log'0 (x : int) (y : int) : ()
  
  axiom cmp_le_log_spec'0 : forall x : int, y : int . [%#sord'0] (x <= y) = (cmp_log'0 x y <> C_Greater)
  
  function deep_model'3 (self : UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Ordering))= any
    [ return''0 (result:t_Ordering)-> {[%#scmp] result = cmp_log'0 (deep_model'3 self_) (deep_model'3 rhs)}
      (! return' {result}) ]
  
  
  predicate grows [#"bdd.rs" 299 4 299 35] (self : MutBorrow.t t_Context) =
    [%#sbdd'24] UInt64.t'int (self.current).t_Context__cnt <= UInt64.t'int (self.final).t_Context__cnt
    /\ (forall n : t_NodeLog . match Map.get (view'1 (self.current).t_Context__hashcons) n with
      | C_Some'0 b -> Map.get (view'1 (self.final).t_Context__hashcons) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec node (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd'9] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'10] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'11] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'12] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'13] grows self}
      {[%#sbdd'14] is_valid_bdd self.final result}
      {[%#sbdd'15] forall v : Map.map UInt64.t bool . interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[%#sbdd'16] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]
  
  
  let rec falseqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd'17] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'18] grows self}
      {[%#sbdd'19] is_valid_bdd self.final result}
      {[%#sbdd'20] forall v : Map.map UInt64.t bool . not interp result v}
      {[%#sbdd'21] UInt64.t'int (v_MAX : UInt64.t) + 1 = leastvar result}
      (! return' {result}) ]
  
  
  function view'6 (self : MutBorrow.t t_MyHashMap'1) : Map.map tuple'0 t_Option'0 =
    [%#smodel'1] view self.current
  
  let rec add (self:MutBorrow.t t_MyHashMap'1) (key:tuple) (val':t_Bdd) (return'  (x:()))= any
    [ return''0 (result:())-> {[%#sbdd'22] forall i : tuple'0 . Map.get (view self.final) i
      = (if i = deep_model'0 key then C_Some'0 val' else Map.get (view'6 self) i)}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Bdd))= any
    [ good (field_0:t_Bdd)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0 : t_Bdd [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]
  
  
  function size [#"bdd.rs" 227 4 227 24] (self : t_Bdd) : int =
    [%#sbdd'28] match self with
      | {t_Bdd__0 = C_True} -> 0
      | {t_Bdd__0 = C_False} -> 0
      | {t_Bdd__0 = C_If _ childt childf} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec : forall self : t_Bdd . [%#sbdd'27] size self >= 0
  
  meta "compute_max_steps" 1000000
  
  let rec and[#"bdd.rs" 533 4 533 72] (self:MutBorrow.t t_Context) (a:t_Bdd) (b:t_Bdd) (return'  (x:t_Bdd))= {[@expl:and 'self' type invariant] [%#sbdd'0] inv'0 self}
    {[@expl:and requires #0] [%#sbdd'1] is_valid_bdd self.current a}
    {[@expl:and requires #1] [%#sbdd'2] is_valid_bdd self.current b}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_16 <- { _0 = a'0; _1 = b'0 } ] s1
      | s1 =  [ &_15 <- _16 ] s2
      | s2 = get {(self'0.current).t_Context__and_memo} {_15} (fun (_ret:t_Option) ->  [ &_12 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = any [ br0 -> {_12 = C_None} (! bb4) | br1 (x0:t_Bdd)-> {_12 = C_Some x0} (! bb2) ] 
    | bb4 = s0
      [ s0 =  [ &_23 <- { _0'1 = a'0.t_Bdd__0; _1'1 = b'0.t_Bdd__0 } ] s1
      | s1 = any
        [ br0 -> {_23._0'1 = C_False} (! bb5)
        | br1 -> {_23._0'1 = C_True} (! bb6)
        | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._0'1 = C_If x0 x1 x2} (! bb5) ]
       ]
    
    | bb5 = any
      [ br0 -> {_23._1'1 = C_False} (! bb7)
      | br1 -> {_23._1'1 = C_True} (! bb8)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._1'1 = C_If x0 x1 x2} (! bb7) ]
    
    | bb7 = any
      [ br0 -> {_23._0'1 = C_False} (! bb13)
      | br1 -> {_23._0'1 = C_True} (! bb9)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._0'1 = C_If x0 x1 x2} (! bb9) ]
    
    | bb9 = any
      [ br0 -> {_23._1'1 = C_False} (! bb13)
      | br1 -> {_23._1'1 = C_True} (! bb10)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._1'1 = C_If x0 x1 x2} (! bb11) ]
    
    | bb11 = any
      [ br0 -> {_23._0'1 = C_False} (! bb10)
      | br1 -> {_23._0'1 = C_True} (! bb10)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._0'1 = C_If x0 x1 x2} (! bb12) ]
    
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = {[%#sbdd] false} any ]
    
    | bb12 = s0
      [ s0 = v_If {_23._0'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &va <- rv ] s1)
      | s1 = v_If {_23._0'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childta <- rchildt ] s2)
      | s2 = v_If {_23._0'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childfa <- rchildf ] s3)
      | s3 = v_If {_23._1'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &vb <- rv ] s4)
      | s4 = v_If {_23._1'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childtb <- rchildt ] s5)
      | s5 = v_If {_23._1'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childfb <- rchildf ] s6)
      | s6 =  [ &_45 <- vb ] s7
      | s7 = cmp {va} {_45} (fun (_ret:t_Ordering) ->  [ &_42 <- _ret ] s8)
      | s8 = bb18 ]
    
    | bb18 = any
      [ br0 -> {_42 = C_Less} (! bb21) | br1 -> {_42 = C_Equal} (! bb22) | br2 -> {_42 = C_Greater} (! bb20) ]
    
    | bb20 = bb24
    | bb24 = s0
      [ s0 =  [ &v <- vb ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_49 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_49} {a'0} {childtb} (fun (_ret:t_Bdd) ->  [ &_48 <- _ret ] s3)
      | s3 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &childt <- _48 ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_53 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_53} {a'0} {childfb} (fun (_ret:t_Bdd) ->  [ &_52 <- _ret ] s3)
      | s3 = bb26 ]
    
    | bb26 = s0 [ s0 =  [ &childf <- _52 ] s1 | s1 = bb31 ] 
    | bb22 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_67 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_67} {childta} {childtb} (fun (_ret:t_Bdd) ->  [ &_66 <- _ret ] s3)
      | s3 = bb29 ]
    
    | bb29 = s0
      [ s0 =  [ &childt <- _66 ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_71 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_71} {childfa} {childfb} (fun (_ret:t_Bdd) ->  [ &_70 <- _ret ] s3)
      | s3 = bb30 ]
    
    | bb30 = s0 [ s0 =  [ &childf <- _70 ] s1 | s1 = bb31 ] 
    | bb21 = bb23
    | bb23 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_58 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_58} {childta} {b'0} (fun (_ret:t_Bdd) ->  [ &_57 <- _ret ] s3)
      | s3 = bb27 ]
    
    | bb27 = s0
      [ s0 =  [ &childt <- _57 ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_62 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_62} {childfa} {b'0} (fun (_ret:t_Bdd) ->  [ &_61 <- _ret ] s3)
      | s3 = bb28 ]
    
    | bb28 = s0 [ s0 =  [ &childf <- _61 ] s1 | s1 = bb31 ] 
    | bb31 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_74 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = node {_74} {v} {childt} {childf} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb32 ]
    
    | bb32 = bb33
    | bb13 = bb14
    | bb14 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_31 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = falseqy95z {_31} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb17 ]
    
    | bb17 = bb33
    | bb8 = bb15
    | bb15 = s0 [ s0 =  [ &r'0 <- a'0 ] s1 | s1 = bb33 ] 
    | bb6 = bb16
    | bb16 = s0 [ s0 =  [ &r'0 <- b'0 ] s1 | s1 = bb33 ] 
    | bb33 = s0
      [ s0 = MutBorrow.borrow_final
          <t_MyHashMap'1>
          {(self'0.current).t_Context__and_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 5}
          (fun (_ret:MutBorrow.t t_MyHashMap'1) ->
             [ &_79 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Context__and_memo = _ret.final } } ] 
            s1)
      | s1 =  [ &_80 <- { _0 = a'0; _1 = b'0 } ] s2
      | s2 = add {_79} {_80} {r'0} (fun (_ret:()) ->  [ &_78 <- _ret ] s3)
      | s3 = bb34 ]
    
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0'2 <- r'0 ] s3
      | s3 = bb35 ]
    
    | bb2 = bb3
    | bb3 = s0
      [ s0 = v_Some {_12} (fun (r0:t_Bdd) ->  [ &r <- r0 ] s1)
      | s1 =  [ &_0'2 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self'0} s3
      | s3 = -{resolve'0 self'0}- s4
      | s4 = bb35 ]
    
    | bb35 = return''0 {_0'2} ]
    )
    [ & _0'2 : t_Bdd = Any.any_l ()
    | & self'0 : MutBorrow.t t_Context = self
    | & a'0 : t_Bdd = a
    | & b'0 : t_Bdd = b
    | & _12 : t_Option = Any.any_l ()
    | & _15 : tuple = Any.any_l ()
    | & _16 : tuple = Any.any_l ()
    | & r : t_Bdd = Any.any_l ()
    | & r'0 : t_Bdd = Any.any_l ()
    | & _23 : tuple'1 = Any.any_l ()
    | & _31 : MutBorrow.t t_Context = Any.any_l ()
    | & va : UInt64.t = Any.any_l ()
    | & childta : t_Bdd = Any.any_l ()
    | & childfa : t_Bdd = Any.any_l ()
    | & vb : UInt64.t = Any.any_l ()
    | & childtb : t_Bdd = Any.any_l ()
    | & childfb : t_Bdd = Any.any_l ()
    | & v : UInt64.t = Any.any_l ()
    | & childt : t_Bdd = Any.any_l ()
    | & childf : t_Bdd = Any.any_l ()
    | & _42 : t_Ordering = Any.any_l ()
    | & _45 : UInt64.t = Any.any_l ()
    | & _48 : t_Bdd = Any.any_l ()
    | & _49 : MutBorrow.t t_Context = Any.any_l ()
    | & _52 : t_Bdd = Any.any_l ()
    | & _53 : MutBorrow.t t_Context = Any.any_l ()
    | & _57 : t_Bdd = Any.any_l ()
    | & _58 : MutBorrow.t t_Context = Any.any_l ()
    | & _61 : t_Bdd = Any.any_l ()
    | & _62 : MutBorrow.t t_Context = Any.any_l ()
    | & _66 : t_Bdd = Any.any_l ()
    | & _67 : MutBorrow.t t_Context = Any.any_l ()
    | & _70 : t_Bdd = Any.any_l ()
    | & _71 : MutBorrow.t t_Context = Any.any_l ()
    | & _74 : MutBorrow.t t_Context = Any.any_l ()
    | & _78 : () = Any.any_l ()
    | & _79 : MutBorrow.t t_MyHashMap'1 = Any.any_l ()
    | & _80 : tuple = Any.any_l () ]
    
    [ return''0 (result:t_Bdd)-> {[@expl:and ensures #0] [%#sbdd'3] grows self}
      {[@expl:and ensures #1] [%#sbdd'4] is_valid_bdd self.final result}
      {[@expl:and ensures #2] [%#sbdd'5] forall v : Map.map UInt64.t bool . interp result v
      = (interp a v /\ interp b v)}
      {[@expl:and ensures #3] [%#sbdd'6] leastvar a <= leastvar result \/ leastvar b <= leastvar result}
      (! return' {result}) ]

end
module M_bdd__hashmap__qyi1953663170559623169__hash__refines [#"bdd.rs" 79 8 79 29] (* <(U, V) as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 79 8 79 29
  let%span sbdd'0 = "bdd.rs" 86 24 86 84
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 90 8 90 18
  
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_U
  
  type t_V
  
  type tuple  =
    { _0: t_U; _1: t_V }
  
  predicate inv (_0'0 : t_U)
  
  predicate inv'0 (_0'0 : t_V)
  
  predicate inv'1 (_0'0 : tuple)
  
  axiom inv_axiom [@rewrite] : forall x : tuple [inv'1 x] . inv'1 x
  = (let {_0 = x0 ; _1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate invariant' (self : tuple) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0'0 : tuple)
  
  axiom inv_axiom'0 [@rewrite] : forall x : tuple [inv'2 x] . inv'2 x = invariant' x
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type tuple'0  =
    { _0'0: t_DeepModelTy; _1'0: t_DeepModelTy'0 }
  
  function hash_log [#"bdd.rs" 38 8 38 49] (_0'1 : t_DeepModelTy) : int
  
  function hash_log'0 [#"bdd.rs" 38 8 38 49] (_0'1 : t_DeepModelTy'0) : int
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function hash_log'1 [#"bdd.rs" 85 8 85 48] (x : tuple'0) : int =
    [%#sbdd'0] Int.mod (hash_log x._0'0 + hash_log'0 x._1'0 * 17) (UInt64.t'int (v_MAX : UInt64.t) + 1)
  
  function deep_model (self : t_U) : t_DeepModelTy
  
  function deep_model'0 (self : t_V) : t_DeepModelTy'0
  
  function deep_model'1 (self : tuple) : tuple'0 =
    [%#stuples] { _0'0 = deep_model self._0; _1'0 = deep_model'0 self._1 }
  
  function deep_model'2 (self : tuple) : tuple'0 =
    [%#smodel] deep_model'1 self
  
  goal refines : [%#sbdd] forall self : tuple . inv'2 self
   -> inv'2 self
  /\ (forall result : UInt64.t . UInt64.t'int result = hash_log'1 (deep_model'2 self)
   -> UInt64.t'int result = hash_log'1 (deep_model'2 self))
end
module M_bdd__qyi699402059438633899__hash__refines [#"bdd.rs" 119 4 119 25] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 119 4 119 25
  let%span sbdd'0 = "bdd.rs" 133 12 138 13
  let%span sbdd'1 = "bdd.rs" 179 20 179 37
  let%span sbdd'2 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NodeLog  =
    | C_False
    | C_True
    | C_If UInt64.t UInt64.t UInt64.t
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function hash_log [#"bdd.rs" 131 4 131 44] (x : t_NodeLog) : int =
    [%#sbdd'0] match x with
      | C_False -> 1
      | C_True -> 2
      | C_If v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int (v_MAX : UInt64.t) + 1)
      end
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t t_Bdd t_Bdd
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'2] match self with
      | C_False'0 -> C_False
      | C_True'0 -> C_True
      | C_If'0 v childt childf -> C_If v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view [#"bdd.rs" 178 4 178 33] (self : t_Node) : t_NodeLog =
    [%#sbdd'1] deep_model self
  
  function view'0 (self : t_Node) : t_NodeLog =
    [%#smodel] view self
  
  function deep_model'0 (self : t_Node) : t_NodeLog =
    [%#smodel'0] deep_model self
  
  goal refines : [%#sbdd] forall self : t_Node . forall result : UInt64.t . UInt64.t'int result = hash_log (view'0 self)
   -> UInt64.t'int result = hash_log (deep_model'0 self)
end
module M_bdd__qyi14323183011761258016__hash__refines [#"bdd.rs" 145 4 145 25] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 145 4 145 25
  let%span sbdd'0 = "bdd.rs" 152 20 152 22
  let%span sbdd'1 = "bdd.rs" 199 20 199 37
  let%span sbdd'2 = "bdd.rs" 189 20 189 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt64
  
  function hash_log [#"bdd.rs" 151 4 151 44] (x : UInt64.t) : int =
    [%#sbdd'0] UInt64.t'int x
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'2] self.t_Bdd__1
  
  function view [#"bdd.rs" 198 4 198 33] (self : t_Bdd) : UInt64.t =
    [%#sbdd'1] deep_model self
  
  function view'0 (self : t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  function deep_model'0 (self : t_Bdd) : UInt64.t =
    [%#smodel'0] deep_model self
  
  goal refines : [%#sbdd] forall self : t_Bdd . forall result : UInt64.t . UInt64.t'int result = hash_log (view'0 self)
   -> UInt64.t'int result = hash_log (deep_model'0 self)
end
module M_bdd__qyi4854841669736991510__eq__refines [#"bdd.rs" 93 13 93 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 93 13 93 22
  let%span sbdd'0 = "bdd.rs" 163 12 167 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt64
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model [#"bdd.rs" 161 4 161 44] (self : t_Node) : t_NodeLog =
    [%#sbdd'0] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'0 (self : t_Node) : t_NodeLog =
    [%#smodel] deep_model self
  
  goal refines : [%#sbdd] forall self_ : t_Node . forall rhs : t_Node . forall result : bool . result
  = (deep_model'0 self_ = deep_model'0 rhs)  -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_bdd__qyi2581120635339165136__eq__refines [#"bdd.rs" 205 4 205 34] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 205 4 205 34
  let%span sbdd'0 = "bdd.rs" 199 20 199 37
  let%span sbdd'1 = "bdd.rs" 189 20 189 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 45 8 45 28
  
  use creusot.int.UInt64
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 188 4 188 44] (self : t_Bdd) : UInt64.t =
    [%#sbdd'1] self.t_Bdd__1
  
  function view [#"bdd.rs" 198 4 198 33] (self : t_Bdd) : UInt64.t =
    [%#sbdd'0] deep_model self
  
  function view'0 (self : t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  function deep_model'0 (self : t_Bdd) : UInt64.t =
    [%#smodel'0] deep_model self
  
  goal refines : [%#sbdd] forall self_ : t_Bdd . forall rhs : t_Bdd . forall result : bool . result
  = (view'0 self_ = view'0 rhs)  -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_bdd__qyi17981791245757283426__clone__refines [#"bdd.rs" 93 24 93 29] (* <Node<'arena> as creusot_contracts::Clone> *)
  let%span sbdd = "bdd.rs" 93 24 93 29
  
  use creusot.int.UInt64
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  goal refines : [%#sbdd] forall self_ : t_Node . forall result : t_Node . result = self_  -> result = self_
end
module M_bdd__qyi2820858787824331484__clone__refines [#"bdd.rs" 112 4 112 27] (* <Bdd<'arena> as creusot_contracts::Clone> *)
  let%span sbdd = "bdd.rs" 112 4 112 27
  
  use creusot.int.UInt64
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  goal refines : [%#sbdd] forall self_ : t_Bdd . forall result : t_Bdd . result = self_  -> result = self_
end
