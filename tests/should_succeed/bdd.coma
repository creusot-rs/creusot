module M_bdd__hashmap__qyi1953663170559623169__hash [#"bdd.rs" 80 8 80 29] (* <(U, V) as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 81 66 81 68
  let%span sbdd'0 = "bdd.rs" 80 17 80 21
  let%span sbdd'1 = "bdd.rs" 79 18 79 62
  let%span sbdd'2 = "bdd.rs" 86 24 86 84
  let%span sbdd'3 = "bdd.rs" 1 0 36 8
  let%span snum = "../../creusot-contracts/src/std/num.rs" 220 26 220 48
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 220 26 220 48
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 21 28 21 57
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_U
  
  type t_V
  
  type tuple  =
    { _p0: t_U; _p1: t_V }
  
  predicate inv (_0: t_U)
  
  predicate invariant' (self: t_U) =
    [%#sinvariant] inv self
  
  predicate inv'0 (_0: t_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_U [inv'0 x]. inv'0 x = invariant' x
  
  predicate precondition (self: ()) (args: t_U)
  
  axiom precondition_fndef: [%#sbdd'3] forall args: t_U [precondition () args]. (let self = args in inv'0 self)
   -> precondition () args
  
  type t_DeepModelTy
  
  function hash_log [#"bdd.rs" 39 8 39 49] (_0: t_DeepModelTy) : int
  
  function deep_model (self: t_U) : t_DeepModelTy
  
  function deep_model'0 (self: t_U) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate postcondition_once (self: ()) (args: t_U) (result: UInt64.t)
  
  axiom postcondition_fndef: [%#sbdd'3] forall args: t_U, res: UInt64.t [postcondition_once () args res]. postcondition_once () args res
   -> (let self = args in UInt64.t'int res = hash_log (deep_model'0 self))
  
  let rec hash (self:t_U) (return'  (x:UInt64.t))= {[@expl:hash requires] precondition () self}
    any [ return''0 (result:UInt64.t)-> {postcondition_once () self result} (! return' {result}) ] 
  
  predicate inv'1 (_0: t_V)
  
  predicate invariant''0 (self: t_V) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0: t_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_V [inv'2 x]. inv'2 x = invariant''0 x
  
  predicate precondition'0 (self: ()) (args: t_V)
  
  axiom precondition_fndef'0: [%#sbdd'3] forall args: t_V [precondition'0 () args]. (let self = args in inv'2 self)
   -> precondition'0 () args
  
  type t_DeepModelTy'0
  
  function hash_log'0 [#"bdd.rs" 39 8 39 49] (_0: t_DeepModelTy'0) : int
  
  function deep_model'1 (self: t_V) : t_DeepModelTy'0
  
  function deep_model'2 (self: t_V) : t_DeepModelTy'0 =
    [%#smodel] deep_model'1 self
  
  predicate postcondition_once'0 (self: ()) (args: t_V) (result: UInt64.t)
  
  axiom postcondition_fndef'0: [%#sbdd'3] forall args: t_V, res: UInt64.t [postcondition_once'0 () args res]. postcondition_once'0 () args res
   -> (let self = args in UInt64.t'int res = hash_log'0 (deep_model'2 self))
  
  let rec hash'0 (self:t_V) (return'  (x:UInt64.t))= {[@expl:hash requires] precondition'0 () self}
    any [ return''0 (result:UInt64.t)-> {postcondition_once'0 () self result} (! return' {result}) ] 
  
  let rec wrapping_mul (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = UInt64.mul self_ rhs} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum'0] result = UInt64.add self_ rhs} (! return' {result}) ]
  
  
  predicate inv'3 (_0: tuple)
  
  axiom inv_axiom'1 [@rewrite]: forall x: tuple [inv'3 x]. inv'3 x
  = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'1 x1)
  
  predicate invariant''1 (self: tuple) =
    [%#sinvariant] inv'3 self
  
  predicate inv'4 (_0: tuple)
  
  axiom inv_axiom'2 [@rewrite]: forall x: tuple [inv'4 x]. inv'4 x = invariant''1 x
  
  type tuple'0  =
    { _p0'0: t_DeepModelTy; _p1'0: t_DeepModelTy'0 }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log'1 [#"bdd.rs" 85 8 85 48] (x: tuple'0) : int =
    [%#sbdd'2] Int.mod (hash_log x._p0'0 + hash_log'0 x._p1'0 * 17) (UInt64.t'int v_MAX + 1)
  
  function deep_model'3 (self: tuple) : tuple'0 =
    [%#stuples] { _p0'0 = deep_model self._p0; _p1'0 = deep_model'1 self._p1 }
  
  function deep_model'4 (self: tuple) : tuple'0 =
    [%#smodel] deep_model'3 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash'1[#"bdd.rs" 80 8 80 29] (self:tuple) (return'  (x:UInt64.t))= {[@expl:hash 'self' type invariant] [%#sbdd'0] inv'4 self}
    (! bb0
    [ bb0 = s0 [ s0 = hash {self'0._p0} (fun (_ret:UInt64.t) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = hash'0 {self'0._p1} (fun (_ret:UInt64.t) ->  [ &_6 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0
      [ s0 = wrapping_mul {_6} {[%#sbdd] (17: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_5 <- _ret ] s1) | s1 = bb3 ]
    
    | bb3 = s0 [ s0 = wrapping_add {_3} {_5} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = return''0 {_0} ]
    
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: tuple = self
    | & _3: UInt64.t = Any.any_l ()
    | & _5: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l () ]
    )
    [ return''0 (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd'1] UInt64.t'int result
      = hash_log'1 (deep_model'4 self)}
      (! return' {result}) ]

end
module M_bdd__qyi2024536649982164874__assert_receiver_is_total_eq [#"bdd.rs" 93 9 93 11] (* <Node<'arena> as std::cmp::Eq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq[#"bdd.rs" 93 9 93 11] (self:t_Node) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
     [ & _0: () = Any.any_l () ] ) [ return''0 (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi4854841669736991510__eq [#"bdd.rs" 93 13 93 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 93 13 93 22
  let%span sbdd'0 = "bdd.rs" 198 14 198 37
  let%span sbdd'1 = "bdd.rs" 160 12 164 13
  let%span sbdd'2 = "bdd.rs" 193 20 193 37
  let%span sbdd'3 = "bdd.rs" 184 20 184 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 44 8 44 22
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type tuple  =
    { _p0: t_Node; _p1: t_Node }
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'3] self.t_Bdd__1
  
  function view [#"bdd.rs" 192 4 192 33] (self: t_Bdd) : UInt64.t =
    [%#sbdd'2] deep_model self
  
  function view'0 (self: t_Bdd) : UInt64.t =
    [%#smodel'0] view self
  
  let rec eq (self:t_Bdd) (o:t_Bdd) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sbdd'0] result = (view'0 self = view'0 o)} (! return' {result}) ]
  
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model'0 [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'1] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'1 (self: t_Node) : t_NodeLog =
    [%#smodel] deep_model'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq'0[#"bdd.rs" 93 13 93 22] (self:t_Node) (rhs:t_Node) (return'  (x:bool))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &_4 <- { _p0 = self'0; _p1 = rhs'0 } ] s1
      | s1 = any
        [ br0 -> {_4._p0 = C_False} (! bb2)
        | br1 -> {_4._p0 = C_True} (! bb4)
        | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._p0 = C_If x0 x1 x2} (! bb6) ]
       ]
    
    | bb6 = any
      [ br0 -> {_4._p1 = C_False} (! bb1)
      | br1 -> {_4._p1 = C_True} (! bb1)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._p1 = C_If x0 x1 x2} (! bb8) ]
    
    | bb8 = s0
      [ s0 = v_If {_4._p0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v_1 <- rv ] s1)
      | s1 = v_If {_4._p0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt_1 <- rchildt ] s2)
      | s2 = v_If {_4._p0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf_1 <- rchildf ] s3)
      | s3 = v_If {_4._p1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v_2 <- rv ] s4)
      | s4 = v_If {_4._p1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt_2 <- rchildt ] s5)
      | s5 = v_If {_4._p1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf_2 <- rchildf ] s6)
      | s6 = eq {childf_1} {childf_2} (fun (_ret:bool) ->  [ &_17 <- _ret ] s7)
      | s7 = bb11 ]
    
    | bb11 = any [ br0 -> {_17 = false} (! bb19) | br1 -> {_17} (! bb12) ] 
    | bb12 = s0 [ s0 = eq {childt_1} {childt_2} (fun (_ret:bool) ->  [ &_20 <- _ret ] s1) | s1 = bb13 ] 
    | bb13 = any [ br0 -> {_20 = false} (! bb19) | br1 -> {_20} (! bb14) ] 
    | bb14 = s0
      [ s0 =  [ &_23 <- v_1 = v_2 ] s1 | s1 = any [ br0 -> {_23 = false} (! bb19) | br1 -> {_23} (! bb15) ]  ]
    
    | bb15 = s0 [ s0 =  [ &_0 <- [%#sbdd] true ] s1 | s1 = bb21 ] 
    | bb19 = s0 [ s0 =  [ &_0 <- [%#sbdd] false ] s1 | s1 = bb21 ] 
    | bb4 = any
      [ br0 -> {_4._p1 = C_False} (! bb1)
      | br1 -> {_4._p1 = C_True} (! bb9)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._p1 = C_If x0 x1 x2} (! bb1) ]
    
    | bb9 = s0 [ s0 =  [ &_0 <- [%#sbdd] true ] s1 | s1 = bb21 ] 
    | bb2 = any
      [ br0 -> {_4._p1 = C_False} (! bb10)
      | br1 -> {_4._p1 = C_True} (! bb1)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_4._p1 = C_If x0 x1 x2} (! bb1) ]
    
    | bb1 = s0 [ s0 =  [ &_0 <- [%#sbdd] false ] s1 | s1 = bb21 ] 
    | bb10 = s0 [ s0 =  [ &_0 <- [%#sbdd] true ] s1 | s1 = bb21 ] 
    | bb21 = return''0 {_0} ]
    
    [ & _0: bool = Any.any_l ()
    | & self'0: t_Node = self
    | & rhs'0: t_Node = rhs
    | & _4: tuple = Any.any_l ()
    | & v_1: UInt64.t = Any.any_l ()
    | & childt_1: t_Bdd = Any.any_l ()
    | & childf_1: t_Bdd = Any.any_l ()
    | & v_2: UInt64.t = Any.any_l ()
    | & childt_2: t_Bdd = Any.any_l ()
    | & childf_2: t_Bdd = Any.any_l ()
    | & _17: bool = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & _23: bool = Any.any_l () ]
    )
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#sbdd] result = (deep_model'1 self = deep_model'1 rhs)}
      (! return' {result}) ]

end
module M_bdd__qyi17981791245757283426__clone [#"bdd.rs" 93 24 93 29] (* <Node<'arena> as creusot_contracts::Clone> *)
  let%span sbdd = "bdd.rs" 93 24 93 29
  let%span sbdd'0 = "bdd.rs" 111 14 111 29
  let%span sbdd'1 = "bdd.rs" 112 4 112 27
  let%span snum = "../../creusot-contracts/src/std/num.rs" 35 26 35 41
  let%span sops = "../../creusot-contracts/src/std/ops.rs" 169 14 169 114
  let%span sops'0 = "../../creusot-contracts/src/std/ops.rs" 174 14 174 100
  let%span sops'1 = "../../creusot-contracts/src/std/ops.rs" 179 14 179 61
  let%span sops'2 = "../../creusot-contracts/src/std/ops.rs" 133 15 133 59
  let%span sops'3 = "../../creusot-contracts/src/std/ops.rs" 134 14 134 38
  let%span sops'4 = "../../creusot-contracts/src/std/ops.rs" 139 14 139 33
  let%span sops'5 = "../../creusot-contracts/src/std/ops.rs" 144 15 144 31
  let%span sops'6 = "../../creusot-contracts/src/std/ops.rs" 145 15 145 28
  let%span sops'7 = "../../creusot-contracts/src/std/ops.rs" 146 14 146 30
  let%span sops'8 = "../../creusot-contracts/src/std/ops.rs" 151 14 152 104
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  let rec clone' (self_:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = self_} (! return' {result}) ]
  
  
  let rec clone''0 (self:t_Bdd) (return'  (x:t_Bdd))= any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'0] result = self} (! return' {result}) ]
  
  
  type tuple  =
    { _p0: t_Node; _p1: t_Node }
  
  predicate postcondition_once (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  predicate resolve (_0: ()) =
    true
  
  predicate postcondition_mut (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t) =
    let self_ = args in result = self_
  
  function fn_mut_once (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_mut_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. [%#sops'8] postcondition_once self args res
  = (exists res_state: (). postcondition_mut self args res_state res /\ resolve res_state)
  
  predicate hist_inv (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec: forall self: (), b: (), c: (). ([%#sops'5] hist_inv self b)
   -> ([%#sops'6] hist_inv b c)  -> ([%#sops'7] hist_inv self c)
  
  function hist_inv_refl (self: ()) : ()
  
  axiom hist_inv_refl_spec: forall self: (). [%#sops'4] hist_inv self self
  
  function postcondition_mut_hist_inv (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_spec: forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. ([%#sops'2] postcondition_mut self args res_state res)
   -> ([%#sops'3] hist_inv self res_state)
  
  function fn_hist_inv (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec: forall self: (), res_state: (). [%#sops'1] hist_inv self res_state = (self = res_state)
  
  predicate postcondition (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  function fn_once (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_once_spec: forall self: (), args: UInt64.t, res: UInt64.t. [%#sops'0] postcondition_once self args res
  = (postcondition self args res /\ resolve self)
  
  function fn_mut (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_spec: forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. [%#sops] postcondition_mut self args res_state res
  = (postcondition self args res /\ self = res_state)
  
  predicate postcondition_once'0 (self: ()) (args: t_Bdd) (result: t_Bdd) =
    [%#sbdd'1] let self'0 = args in result = self'0
  
  predicate resolve'0 (_0: ()) =
    true
  
  predicate postcondition_mut'0 (self: ()) (args: t_Bdd) (result_state: ()) (result: t_Bdd) =
    [%#sbdd'1] let self'0 = args in result = self'0
  
  function fn_mut_once'0 (self: ()) (args: t_Bdd) (res: t_Bdd) : ()
  
  axiom fn_mut_once_spec'0: forall self: (), args: t_Bdd, res: t_Bdd. [%#sops'8] postcondition_once'0 self args res
  = (exists res_state: (). postcondition_mut'0 self args res_state res /\ resolve'0 res_state)
  
  predicate hist_inv'0 (self: ()) (result_state: ()) =
    true
  
  function hist_inv_trans'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_spec'0: forall self: (), b: (), c: (). ([%#sops'5] hist_inv'0 self b)
   -> ([%#sops'6] hist_inv'0 b c)  -> ([%#sops'7] hist_inv'0 self c)
  
  function hist_inv_refl'0 (self: ()) : ()
  
  axiom hist_inv_refl_spec'0: forall self: (). [%#sops'4] hist_inv'0 self self
  
  function postcondition_mut_hist_inv'0 (self: ()) (args: t_Bdd) (res_state: ()) (res: t_Bdd) : ()
  
  axiom postcondition_mut_hist_inv_spec'0: forall self: (), args: t_Bdd, res_state: (), res: t_Bdd. ([%#sops'2] postcondition_mut'0 self args res_state res)
   -> ([%#sops'3] hist_inv'0 self res_state)
  
  function fn_hist_inv'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_spec'0: forall self: (), res_state: (). [%#sops'1] hist_inv'0 self res_state = (self = res_state)
  
  predicate postcondition'0 (self: ()) (args: t_Bdd) (result: t_Bdd) =
    [%#sbdd'1] let self'0 = args in result = self'0
  
  function fn_once'0 (self: ()) (args: t_Bdd) (res: t_Bdd) : ()
  
  axiom fn_once_spec'0: forall self: (), args: t_Bdd, res: t_Bdd. [%#sops'0] postcondition_once'0 self args res
  = (postcondition'0 self args res /\ resolve'0 self)
  
  function fn_mut'0 (self: ()) (args: t_Bdd) (res_state: ()) (res: t_Bdd) : ()
  
  axiom fn_mut_spec'0: forall self: (), args: t_Bdd, res_state: (), res: t_Bdd. [%#sops] postcondition_mut'0 self args res_state res
  = (postcondition'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone''1[#"bdd.rs" 93 24 93 29] (self:t_Node) (return'  (x:t_Node))= (! bb0
    [ bb0 = any
      [ br0 -> {self'0 = C_False} (! bb6)
      | br1 -> {self'0 = C_True} (! bb5)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {self'0 = C_If x0 x1 x2} (! bb4) ]
    
    | bb4 = s0
      [ s0 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v_1 <- rv ] s1)
      | s1 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt_1 <- rchildt ] s2)
      | s2 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf_1 <- rchildf ] s3)
      | s3 =  [ &_9 <- v_1 ] s4
      | s4 = clone' {_9} (fun (_ret:UInt64.t) ->  [ &_7 <- _ret ] s5)
      | s5 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &_12 <- childt_1 ] s1 | s1 = clone''0 {_12} (fun (_ret:t_Bdd) ->  [ &_10 <- _ret ] s2) | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &_15 <- childf_1 ] s1 | s1 = clone''0 {_15} (fun (_ret:t_Bdd) ->  [ &_13 <- _ret ] s2) | s2 = bb9 ]
    
    | bb9 = s0 [ s0 =  [ &_0 <- C_If _7 _10 _13 ] s1 | s1 = bb10 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- C_True ] s1 | s1 = bb10 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- C_False ] s1 | s1 = bb10 ] 
    | bb10 = return''0 {_0} ]
    
    [ & _0: t_Node = Any.any_l ()
    | & self'0: t_Node = self
    | & v_1: UInt64.t = Any.any_l ()
    | & childt_1: t_Bdd = Any.any_l ()
    | & childf_1: t_Bdd = Any.any_l ()
    | & _7: UInt64.t = Any.any_l ()
    | & _9: UInt64.t = Any.any_l ()
    | & _10: t_Bdd = Any.any_l ()
    | & _12: t_Bdd = Any.any_l ()
    | & _13: t_Bdd = Any.any_l ()
    | & _15: t_Bdd = Any.any_l () ]
    )
    [ return''0 (result:t_Node)-> {[@expl:clone ensures] [%#sbdd] match { _p0 = self; _p1 = result } with
        | {_p0 = C_False ; _p1 = C_False} -> true
        | {_p0 = C_True ; _p1 = C_True} -> true
        | {_p0 = C_If v_1 childt_1 childf_1 ; _p1 = C_If v_r childt_r childf_r} -> postcondition () v_1 v_r
        /\ postcondition'0 () childt_1 childt_r /\ postcondition'0 () childf_1 childf_r
        | _ -> false
        end}
      (! return' {result}) ]

end
module M_bdd__qyi1284786238026687571__assert_receiver_is_total_eq [#"bdd.rs" 107 15 107 17] (* <Bdd<'arena> as std::cmp::Eq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq[#"bdd.rs" 107 15 107 17] (self:t_Bdd) (return'  (x:()))= (! bb0
    [ bb0 = return''0 {_0} ]
     [ & _0: () = Any.any_l () ] ) [ return''0 (result:())-> (! return' {result}) ] 
end
module M_bdd__qyi2820858787824331484__clone [#"bdd.rs" 112 4 112 27] (* <Bdd<'arena> as creusot_contracts::Clone> *)
  let%span sbdd = "bdd.rs" 111 14 111 29
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone'[#"bdd.rs" 112 4 112 27] (self:t_Bdd) (return'  (x:t_Bdd))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0 ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: t_Bdd = Any.any_l () | & self'0: t_Bdd = self ] )
    [ return''0 (result:t_Bdd)-> {[@expl:clone ensures] [%#sbdd] result = self} (! return' {result}) ]

end
module M_bdd__qyi699402059438633899__hash [#"bdd.rs" 119 4 119 25] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 124 53 124 54
  let%span sbdd'0 = "bdd.rs" 124 92 124 93
  let%span sbdd'1 = "bdd.rs" 122 20 122 21
  let%span sbdd'2 = "bdd.rs" 121 21 121 22
  let%span sbdd'3 = "bdd.rs" 118 14 118 46
  let%span sbdd'4 = "bdd.rs" 132 12 137 13
  let%span sbdd'5 = "bdd.rs" 175 20 175 37
  let%span sbdd'6 = "bdd.rs" 160 12 164 13
  let%span snum = "../../creusot-contracts/src/std/num.rs" 220 26 220 48
  let%span snum'0 = "../../creusot-contracts/src/std/num.rs" 220 26 220 48
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  let rec wrapping_mul (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum] result = UInt64.mul self_ rhs} (! return' {result}) ]
  
  
  let rec wrapping_add (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#snum'0] result = UInt64.add self_ rhs} (! return' {result}) ]
  
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log [#"bdd.rs" 130 4 130 44] (x: t_NodeLog) : int =
    [%#sbdd'4] match x with
      | C_False'0 -> 1
      | C_True'0 -> 2
      | C_If'0 v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int v_MAX + 1)
      end
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'6] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'5] deep_model self
  
  function view'0 (self: t_Node) : t_NodeLog =
    [%#smodel] view self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash[#"bdd.rs" 119 4 119 25] (self:t_Node) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = any
      [ br0 -> {self'0 = C_False} (! bb6)
      | br1 -> {self'0 = C_True} (! bb5)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {self'0 = C_If x0 x1 x2} (! bb4) ]
    
    | bb4 = s0
      [ s0 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v <- rv ] s1)
      | s1 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt <- rchildt ] s2)
      | s2 = v_If {self'0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf <- rchildf ] s3)
      | s3 = wrapping_mul {childt.t_Bdd__1} {[%#sbdd] (5: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_9 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = s0 [ s0 = wrapping_add {v} {_9} (fun (_ret:UInt64.t) ->  [ &_7 <- _ret ] s1) | s1 = bb8 ] 
    | bb8 = s0
      [ s0 = wrapping_mul {childf.t_Bdd__1} {[%#sbdd'0] (7: UInt64.t)} (fun (_ret:UInt64.t) ->  [ &_11 <- _ret ] s1)
      | s1 = bb9 ]
    
    | bb9 = s0 [ s0 = wrapping_add {_7} {_11} (fun (_ret:UInt64.t) ->  [ &_0 <- _ret ] s1) | s1 = bb11 ] 
    | bb5 = s0 [ s0 =  [ &_0 <- [%#sbdd'1] (2: UInt64.t) ] s1 | s1 = bb11 ] 
    | bb6 = s0 [ s0 =  [ &_0 <- [%#sbdd'2] (1: UInt64.t) ] s1 | s1 = bb11 ] 
    | bb11 = return''0 {_0} ]
    
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: t_Node = self
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & _7: UInt64.t = Any.any_l ()
    | & _9: UInt64.t = Any.any_l ()
    | & _11: UInt64.t = Any.any_l () ]
    )
    [ return''0 (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd'3] UInt64.t'int result = hash_log (view'0 self)}
      (! return' {result}) ]

end
module M_bdd__qyi14323183011761258016__hash [#"bdd.rs" 144 4 144 25] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 143 14 143 46
  let%span sbdd'0 = "bdd.rs" 150 20 150 22
  let%span sbdd'1 = "bdd.rs" 193 20 193 37
  let%span sbdd'2 = "bdd.rs" 184 20 184 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function hash_log [#"bdd.rs" 149 4 149 44] (x: UInt64.t) : int =
    [%#sbdd'0] UInt64.t'int x
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'2] self.t_Bdd__1
  
  function view [#"bdd.rs" 192 4 192 33] (self: t_Bdd) : UInt64.t =
    [%#sbdd'1] deep_model self
  
  function view'0 (self: t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash[#"bdd.rs" 144 4 144 25] (self:t_Bdd) (return'  (x:UInt64.t))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_Bdd__1 ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: UInt64.t = Any.any_l () | & self'0: t_Bdd = self ] )
    [ return''0 (result:UInt64.t)-> {[@expl:hash ensures] [%#sbdd] UInt64.t'int result = hash_log (view'0 self)}
      (! return' {result}) ]

end
module M_bdd__qyi2581120635339165136__eq [#"bdd.rs" 199 4 199 34] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 198 14 198 37
  let%span sbdd'0 = "bdd.rs" 193 20 193 37
  let%span sbdd'1 = "bdd.rs" 184 20 184 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'1] self.t_Bdd__1
  
  function view [#"bdd.rs" 192 4 192 33] (self: t_Bdd) : UInt64.t =
    [%#sbdd'0] deep_model self
  
  function view'0 (self: t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq[#"bdd.rs" 199 4 199 34] (self:t_Bdd) (o:t_Bdd) (return'  (x:bool))= (! bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- self'0.t_Bdd__1 = o'0.t_Bdd__1 ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: bool = Any.any_l () | & self'0: t_Bdd = self | & o'0: t_Bdd = o ] )
    [ return''0 (result:bool)-> {[@expl:eq ensures] [%#sbdd] result = (view'0 self = view'0 o)} (! return' {result}) ]

end
module M_bdd__qyi13535665294507397779__size [#"bdd.rs" 221 4 221 24] (* Bdd<'arena> *)
  let%span sbdd = "bdd.rs" 220 14 220 25
  let%span sbdd'0 = "bdd.rs" 223 12 231 13
  
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Bdd
  
  function size [#"bdd.rs" 221 4 221 24] (self'0: t_Bdd) : int
  
  goal vc_size: match self with
    | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> [@expl:size ensures] [%#sbdd] 0 >= 0
    | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> [@expl:size ensures] [%#sbdd] 0 >= 0
    | {t_Bdd__0 = C_If _ childt childf ; t_Bdd__1 = _} -> ([%#sbdd] size childt >= 0)
     -> (let ht = size childt in ([%#sbdd] size childf >= 0)
     -> (let hf = size childf in [@expl:size ensures] [%#sbdd] 1 + ht + hf >= 0))
    end
end
module M_bdd__qyi11078426090797403070__grows_is_valid_bdd [#"bdd.rs" 329 4 329 56] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 326 15 326 27
  let%span sbdd'0 = "bdd.rs" 327 15 327 35
  let%span sbdd'1 = "bdd.rs" 328 14 328 37
  let%span sbdd'2 = "bdd.rs" 329 57 329 59
  let%span sbdd'3 = "bdd.rs" 293 12 298 17
  let%span sbdd'4 = "bdd.rs" 305 12 305 47
  let%span sbdd'5 = "bdd.rs" 175 20 175 37
  let%span sbdd'6 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'0 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'3] UInt64.le (view (self.current).t_Context__cnt) (view (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'0 (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view'0 (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'6] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'1 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'5] deep_model self
  
  function view'2 (self: t_Node) : t_NodeLog =
    [%#smodel] view'1 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'4] Map.get (view'0 self.t_Context__hashcons) (view'2 b.t_Bdd__0) = C_Some b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : MutBorrow.t t_Context
  
  constant b  : t_Bdd
  
  function grows_is_valid_bdd [#"bdd.rs" 329 4 329 56] (self'0: MutBorrow.t t_Context) (b'0: t_Bdd) : ()
  
  goal vc_grows_is_valid_bdd: ([%#sbdd] grows self)
   -> ([%#sbdd'0] is_valid_bdd self.current b)
   -> ([@expl:grows_is_valid_bdd ensures] [%#sbdd'1] is_valid_bdd self.final b)
end
module M_bdd__qyi11078426090797403070__grows_trans [#"bdd.rs" 337 4 337 62] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 332 15 332 27
  let%span sbdd'0 = "bdd.rs" 333 15 333 24
  let%span sbdd'1 = "bdd.rs" 334 15 334 26
  let%span sbdd'2 = "bdd.rs" 335 15 335 43
  let%span sbdd'3 = "bdd.rs" 336 14 336 24
  let%span sbdd'4 = "bdd.rs" 337 63 337 65
  let%span sbdd'5 = "bdd.rs" 293 12 298 17
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'0 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'5] UInt64.le (view (self.current).t_Context__cnt) (view (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'0 (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view'0 (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : MutBorrow.t t_Context
  
  constant o  : MutBorrow.t t_Context
  
  constant oo  : MutBorrow.t t_Context
  
  function grows_trans [#"bdd.rs" 337 4 337 62] (self'0: MutBorrow.t t_Context) (o'0: MutBorrow.t t_Context) (oo'0: MutBorrow.t t_Context) : ()
  
  
  goal vc_grows_trans: ([%#sbdd] grows self)
   -> ([%#sbdd'0] grows o)
   -> ([%#sbdd'1] self.final = o.current)
   -> ([%#sbdd'2] self.current = oo.current /\ self.final = oo.final)
   -> ([@expl:grows_trans ensures] [%#sbdd'3] grows oo)
end
module M_bdd__qyi11078426090797403070__set_irrelevent_var [#"bdd.rs" 344 4 344 87] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 340 15 340 24
  let%span sbdd'0 = "bdd.rs" 341 15 341 35
  let%span sbdd'1 = "bdd.rs" 342 15 342 32
  let%span sbdd'2 = "bdd.rs" 343 14 343 50
  let%span sbdd'3 = "bdd.rs" 346 12 352 13
  let%span sbdd'4 = "bdd.rs" 305 12 305 47
  let%span sbdd'5 = "bdd.rs" 238 12 242 13
  let%span sbdd'6 = "bdd.rs" 208 12 215 13
  let%span sbdd'7 = "bdd.rs" 260 12 284 19
  let%span sbdd'8 = "bdd.rs" 175 20 175 37
  let%span sbdd'9 = "bdd.rs" 312 12 321 13
  let%span sbdd'10 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'10] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'8] deep_model self
  
  function view'1 (self: t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'4] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'5] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'9] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'4 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'6] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'5 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'7] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'3 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'4 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'5 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Context
  
  constant a  : t_Bdd
  
  constant x  : UInt64.t
  
  constant v  : Map.map UInt64.t bool
  
  constant b  : bool
  
  function set_irrelevent_var [#"bdd.rs" 344 4 344 87] (self'0: t_Context) (a'0: t_Bdd) (x'0: UInt64.t) (v'0: Map.map UInt64.t bool) (b'0: bool) : ()
  
  
  goal vc_set_irrelevent_var: ([%#sbdd] inv self)
   -> ([%#sbdd'0] is_valid_bdd self a)
   -> ([%#sbdd'1] UInt64.t'int x < leastvar a)
   -> match a with
    | {t_Bdd__0 = C_If _ childt childf ; t_Bdd__1 = _} -> (([@expl:set_irrelevent_var requires #0] [%#sbdd] inv self)
    && ([@expl:set_irrelevent_var requires #1] [%#sbdd'0] is_valid_bdd self childt)
    && ([@expl:set_irrelevent_var requires #2] [%#sbdd'1] UInt64.t'int x < leastvar childt))
    /\ (([%#sbdd'2] interp childt v = interp childt (Map.set v x b))
     -> (let _ = set_irrelevent_var self childt x v b in (([@expl:set_irrelevent_var requires #0] [%#sbdd] inv self)
    && ([@expl:set_irrelevent_var requires #1] [%#sbdd'0] is_valid_bdd self childf)
    && ([@expl:set_irrelevent_var requires #2] [%#sbdd'1] UInt64.t'int x < leastvar childf))
    /\ (([%#sbdd'2] interp childf v = interp childf (Map.set v x b))
     -> (let _ = set_irrelevent_var self childf x v b in [@expl:set_irrelevent_var ensures] [%#sbdd'2] interp a v
    = interp a (Map.set v x b)))))
    | _ -> [@expl:set_irrelevent_var ensures] [%#sbdd'2] interp a v = interp a (Map.set v x b)
    end
end
module M_bdd__qyi11078426090797403070__discr_valuation [#"bdd.rs" 364 4 364 82] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 357 15 357 24
  let%span sbdd'0 = "bdd.rs" 358 15 358 35
  let%span sbdd'1 = "bdd.rs" 359 15 359 35
  let%span sbdd'2 = "bdd.rs" 360 15 360 21
  let%span sbdd'3 = "bdd.rs" 361 14 361 50
  let%span sbdd'4 = "bdd.rs" 362 14 362 33
  let%span sbdd'5 = "bdd.rs" 366 12 366 45
  let%span sbdd'6 = "bdd.rs" 305 12 305 47
  let%span sbdd'7 = "bdd.rs" 208 12 215 13
  let%span sbdd'8 = "bdd.rs" 220 14 220 25
  let%span sbdd'9 = "bdd.rs" 223 12 231 13
  let%span sbdd'10 = "bdd.rs" 340 15 340 24
  let%span sbdd'11 = "bdd.rs" 341 15 341 35
  let%span sbdd'12 = "bdd.rs" 342 15 342 32
  let%span sbdd'13 = "bdd.rs" 343 14 343 50
  let%span sbdd'14 = "bdd.rs" 346 12 352 13
  let%span sbdd'15 = "bdd.rs" 238 12 242 13
  let%span sbdd'16 = "bdd.rs" 260 12 284 19
  let%span sbdd'17 = "bdd.rs" 175 20 175 37
  let%span sbdd'18 = "bdd.rs" 312 12 321 13
  let%span sbdd'19 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'19] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'17] deep_model self
  
  function view'1 (self: t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'6] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'15] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'18] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'4 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'7] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'5 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'16] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'3 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'4 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'5 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  function size [#"bdd.rs" 221 4 221 24] (self: t_Bdd) : int =
    [%#sbdd'9] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf ; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. [%#sbdd'8] size self >= 0
  
  function set_irrelevent_var [#"bdd.rs" 344 4 344 87] (self: t_Context) (a: t_Bdd) (x: UInt64.t) (v: Map.map UInt64.t bool) (b: bool) : ()
  
   =
    [%#sbdd'14] match a with
      | {t_Bdd__0 = C_If _ childt childf ; t_Bdd__1 = _} -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var_spec: forall self: t_Context, a: t_Bdd, x: UInt64.t, v: Map.map UInt64.t bool, b: bool. ([%#sbdd'10] inv self)
   -> ([%#sbdd'11] is_valid_bdd self a)
   -> ([%#sbdd'12] UInt64.t'int x < leastvar a)  -> ([%#sbdd'13] interp a v = interp a (Map.set v x b))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Context
  
  constant a  : t_Bdd
  
  constant b  : t_Bdd
  
  function discr_valuation [#"bdd.rs" 364 4 364 82] (self'0: t_Context) (a'0: t_Bdd) (b'0: t_Bdd) : Map.map UInt64.t bool
  
  
  goal vc_discr_valuation: ([%#sbdd] inv self)
   -> ([%#sbdd'0] is_valid_bdd self a)
   -> ([%#sbdd'1] is_valid_bdd self b)
   -> ([%#sbdd'2] a <> b)
   -> (let _ = () in if leastvar a < leastvar b then
    match a with
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if childf <> b then
        ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
        && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childf)
        && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self b)
        && ([@expl:discr_valuation requires #3] [%#sbdd'2] childf <> b))
        /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size childf + size b) < ([%#sbdd'4] size a + size b))
        /\ (([%#sbdd'3] interp childf (discr_valuation self childf b) <> interp b (discr_valuation self childf b))
         -> (let result = Map.set (discr_valuation self childf b) v false in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
        <> interp b result))
      else
        ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
        && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childt)
        && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self b)
        && ([@expl:discr_valuation requires #3] [%#sbdd'2] childt <> b))
        /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size childt + size b) < ([%#sbdd'4] size a + size b))
        /\ (([%#sbdd'3] interp childt (discr_valuation self childt b) <> interp b (discr_valuation self childt b))
         -> (let result = Map.set (discr_valuation self childt b) v true in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
        <> interp b result))
      
      | _ -> let result = Const.const true in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
      <> interp b result
      end
  else
    if leastvar a > leastvar b then
      match b with
        | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if childf <> a then
          ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
          && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self a)
          && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childf)
          && ([@expl:discr_valuation requires #3] [%#sbdd'2] a <> childf))
          /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size a + size childf) < ([%#sbdd'4] size a + size b))
          /\ (([%#sbdd'3] interp a (discr_valuation self a childf) <> interp childf (discr_valuation self a childf))
           -> (let result = Map.set (discr_valuation self a childf) v false in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
          <> interp b result))
        else
          ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
          && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self a)
          && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childt)
          && ([@expl:discr_valuation requires #3] [%#sbdd'2] a <> childt))
          /\ 0 <= ([%#sbdd'4] size a + size b) /\ ([%#sbdd'4] size a + size childt) < ([%#sbdd'4] size a + size b))
          /\ (([%#sbdd'3] interp a (discr_valuation self a childt) <> interp childt (discr_valuation self a childt))
           -> (let result = Map.set (discr_valuation self a childt) v true in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
          <> interp b result))
        
        | _ -> let result = Const.const true in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
        <> interp b result
        end
    else
      match a with
        | {t_Bdd__0 = C_If v childta childfa ; t_Bdd__1 = _} -> match b with
          | {t_Bdd__0 = C_If _ childtb childfb ; t_Bdd__1 = _} -> if childfa <> childfb then
            ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
            && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childfa)
            && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childfb)
            && ([@expl:discr_valuation requires #3] [%#sbdd'2] childfa <> childfb))
            /\ 0 <= ([%#sbdd'4] size a + size b)
            /\ ([%#sbdd'4] size childfa + size childfb) < ([%#sbdd'4] size a + size b))
            /\ (([%#sbdd'3] interp childfa (discr_valuation self childfa childfb)
            <> interp childfb (discr_valuation self childfa childfb))
             -> (let result = Map.set (discr_valuation self childfa childfb) v false in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
            <> interp b result))
          else
            ((([@expl:discr_valuation requires #0] [%#sbdd] inv self)
            && ([@expl:discr_valuation requires #1] [%#sbdd'0] is_valid_bdd self childta)
            && ([@expl:discr_valuation requires #2] [%#sbdd'1] is_valid_bdd self childtb)
            && ([@expl:discr_valuation requires #3] [%#sbdd'2] childta <> childtb))
            /\ 0 <= ([%#sbdd'4] size a + size b)
            /\ ([%#sbdd'4] size childta + size childtb) < ([%#sbdd'4] size a + size b))
            /\ (([%#sbdd'3] interp childta (discr_valuation self childta childtb)
            <> interp childtb (discr_valuation self childta childtb))
             -> (let result = Map.set (discr_valuation self childta childtb) v true in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
            <> interp b result))
          
          | _ -> let result = Const.const true in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
          <> interp b result
          end
        | _ -> let result = Const.const true in [@expl:discr_valuation ensures] [%#sbdd'3] interp a result
        <> interp b result
        end
  
  )
end
module M_bdd__qyi11078426090797403070__bdd_canonical [#"bdd.rs" 412 4 412 62] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 406 15 406 24
  let%span sbdd'0 = "bdd.rs" 407 15 407 35
  let%span sbdd'1 = "bdd.rs" 408 15 408 35
  let%span sbdd'2 = "bdd.rs" 409 15 409 51
  let%span sbdd'3 = "bdd.rs" 410 14 410 20
  let%span sbdd'4 = "bdd.rs" 413 8 413 38
  let%span sbdd'5 = "bdd.rs" 305 12 305 47
  let%span sbdd'6 = "bdd.rs" 208 12 215 13
  let%span sbdd'7 = "bdd.rs" 357 15 357 24
  let%span sbdd'8 = "bdd.rs" 358 15 358 35
  let%span sbdd'9 = "bdd.rs" 359 15 359 35
  let%span sbdd'10 = "bdd.rs" 360 15 360 21
  let%span sbdd'11 = "bdd.rs" 361 14 361 50
  let%span sbdd'12 = "bdd.rs" 362 14 362 33
  let%span sbdd'13 = "bdd.rs" 366 12 366 45
  let%span sbdd'14 = "bdd.rs" 220 14 220 25
  let%span sbdd'15 = "bdd.rs" 223 12 231 13
  let%span sbdd'16 = "bdd.rs" 238 12 242 13
  let%span sbdd'17 = "bdd.rs" 260 12 284 19
  let%span sbdd'18 = "bdd.rs" 175 20 175 37
  let%span sbdd'19 = "bdd.rs" 312 12 321 13
  let%span sbdd'20 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'20] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'18] deep_model self
  
  function view'1 (self: t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'5] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'16] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'19] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'4 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'6] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'5 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'17] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'3 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'4 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'5 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  function size [#"bdd.rs" 221 4 221 24] (self: t_Bdd) : int =
    [%#sbdd'15] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf ; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. [%#sbdd'14] size self >= 0
  
  function discr_valuation [#"bdd.rs" 364 4 364 82] (self: t_Context) (a: t_Bdd) (b: t_Bdd) : Map.map UInt64.t bool
  
  axiom discr_valuation_def: forall self: t_Context, a: t_Bdd, b: t_Bdd. ([%#sbdd'7] inv self)
   -> ([%#sbdd'8] is_valid_bdd self a)
   -> ([%#sbdd'9] is_valid_bdd self b)
   -> ([%#sbdd'10] a <> b)
   -> discr_valuation self a b
  = ([%#sbdd'13] let _ = () in if leastvar a < leastvar b then
    match a with
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if childf <> b then
        Map.set (discr_valuation self childf b) v false
      else
        Map.set (discr_valuation self childt b) v true
      
      | _ -> Const.const true
      end
  else
    if leastvar a > leastvar b then
      match b with
        | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if childf <> a then
          Map.set (discr_valuation self a childf) v false
        else
          Map.set (discr_valuation self a childt) v true
        
        | _ -> Const.const true
        end
    else
      match a with
        | {t_Bdd__0 = C_If v childta childfa ; t_Bdd__1 = _} -> match b with
          | {t_Bdd__0 = C_If _ childtb childfb ; t_Bdd__1 = _} -> if childfa <> childfb then
            Map.set (discr_valuation self childfa childfb) v false
          else
            Map.set (discr_valuation self childta childtb) v true
          
          | _ -> Const.const true
          end
        | _ -> Const.const true
        end
  
  )
  
  axiom discr_valuation_spec: forall self: t_Context, a: t_Bdd, b: t_Bdd. ([%#sbdd'7] inv self)
   -> ([%#sbdd'8] is_valid_bdd self a)
   -> ([%#sbdd'9] is_valid_bdd self b)
   -> ([%#sbdd'10] a <> b)  -> ([%#sbdd'11] interp a (discr_valuation self a b) <> interp b (discr_valuation self a b))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self  : t_Context
  
  constant a  : t_Bdd
  
  constant b  : t_Bdd
  
  function bdd_canonical [#"bdd.rs" 412 4 412 62] (self'0: t_Context) (a'0: t_Bdd) (b'0: t_Bdd) : ()
  
  goal vc_bdd_canonical: ([%#sbdd] inv self)
   -> ([%#sbdd'0] is_valid_bdd self a)
   -> ([%#sbdd'1] is_valid_bdd self b)
   -> ([%#sbdd'2] forall v: Map.map UInt64.t bool. interp a v = interp b v)
   -> (let _ = () in [@expl:bdd_canonical ensures] [%#sbdd'3] a = b)
end
module M_bdd__qyi11078426090797403070__new [#"bdd.rs" 418 4 418 52] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 423 28 423 57
  let%span sbdd'0 = "bdd.rs" 418 48 418 52
  let%span sbdd'1 = "bdd.rs" 71 18 71 47
  let%span sbdd'2 = "bdd.rs" 260 12 284 19
  let%span sbdd'3 = "bdd.rs" 312 12 321 13
  let%span sbdd'4 = "bdd.rs" 305 12 305 47
  let%span sbdd'5 = "bdd.rs" 208 12 215 13
  let%span sbdd'6 = "bdd.rs" 238 12 242 13
  let%span sbdd'7 = "bdd.rs" 175 20 175 37
  let%span sbdd'8 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span speano = "../../creusot-contracts/src/peano.rs" 111 14 111 30
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use map.Map
  use map.Const
  use mach.int.Int
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  let rec promoted0__new (return'  (x:t_Node))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_True ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return' {_0} ]  ]
     [ & _0: t_Node = Any.any_l () | & _1: t_Node = Any.any_l () ] 
  
  type t_MyHashMap
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  let rec new (return'  (x:t_MyHashMap))= any
    [ return''0 (result:t_MyHashMap)-> {[%#sbdd'1] view result = Const.const (C_None)} (! return' {result}) ]
  
  
  type t_MyHashMap'0
  
  function view'0 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  let rec new'0 (return'  (x:t_MyHashMap'0))= any
    [ return''0 (result:t_MyHashMap'0)-> {[%#sbdd'1] view'0 result = Const.const (C_None)} (! return' {result}) ]
  
  
  type t_MyHashMap'1
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'1 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  let rec new'1 (return'  (x:t_MyHashMap'1))= any
    [ return''0 (result:t_MyHashMap'1)-> {[%#sbdd'1] view'1 result = Const.const (C_None)} (! return' {result}) ]
  
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  let rec new'2 (return'  (x:t_PeanoInt))= any
    [ return''0 (result:t_PeanoInt)-> {[%#speano] result.t_PeanoInt__0 = (0: UInt64.t)} (! return' {result}) ]
  
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'8] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'7] deep_model self
  
  function view'3 (self: t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'4] Map.get (view self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'4 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'6] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'3] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 (self: t_PeanoInt) : UInt64.t =
    [%#speano'0] self.t_PeanoInt__0
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'5] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'2] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'5 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'0 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'1 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'3[#"bdd.rs" 418 4 418 52] (alloc:()) (return'  (x:t_Context))= (! bb0
    [ bb0 = s0
      [ s0 = promoted0__new (fun (pr0:t_Node) ->  [ &_11 <- pr0 ] s1)
      | s1 =  [ &t <- _11 ] s2
      | s2 = new (fun (_ret:t_MyHashMap) ->  [ &_5 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &_6 <- [%#sbdd] Const.const t ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = new'0 (fun (_ret:t_MyHashMap'0) ->  [ &_8 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 = new'1 (fun (_ret:t_MyHashMap'1) ->  [ &_9 <- _ret ] s1) | s1 = bb4 ] 
    | bb4 = s0 [ s0 = new'2 (fun (_ret:t_PeanoInt) ->  [ &_10 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = 
        [ &_0 <- { t_Context__alloc = alloc'0;
                   t_Context__hashcons = _5;
                   t_Context__hashcons_ghost = _6;
                   t_Context__not_memo = _8;
                   t_Context__and_memo = _9;
                   t_Context__cnt = _10 } ]
        
        s1
      | s1 = return''0 {_0} ]
     ]
    
    [ & _0: t_Context = Any.any_l ()
    | & alloc'0: () = alloc
    | & t: t_Node = Any.any_l ()
    | & _5: t_MyHashMap = Any.any_l ()
    | & _6: Map.map UInt64.t t_Node = Any.any_l ()
    | & _8: t_MyHashMap'0 = Any.any_l ()
    | & _9: t_MyHashMap'1 = Any.any_l ()
    | & _10: t_PeanoInt = Any.any_l ()
    | & _11: t_Node = Any.any_l () ]
    ) [ return''0 (result:t_Context)-> {[@expl:new result type invariant] [%#sbdd'0] inv result} (! return' {result}) ] 
end
module M_bdd__qyi11078426090797403070__hashcons [#"bdd.rs" 434 4 434 58] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 441 30 441 77
  let%span sbdd'0 = "bdd.rs" 436 28 436 38
  let%span sbdd'1 = "bdd.rs" 434 21 434 25
  let%span sbdd'2 = "bdd.rs" 430 15 430 36
  let%span sbdd'3 = "bdd.rs" 431 14 431 28
  let%span sbdd'4 = "bdd.rs" 432 14 432 26
  let%span sbdd'5 = "bdd.rs" 433 14 433 42
  let%span sbdd'6 = "bdd.rs" 62 18 65 9
  let%span sbdd'7 = "bdd.rs" 22 18 22 32
  let%span sbdd'8 = "bdd.rs" 56 18 56 126
  let%span sbdd'9 = "bdd.rs" 175 20 175 37
  let%span sbdd'10 = "bdd.rs" 312 12 321 13
  let%span sbdd'11 = "bdd.rs" 293 12 298 17
  let%span sbdd'12 = "bdd.rs" 305 12 305 47
  let%span sbdd'13 = "bdd.rs" 160 12 164 13
  let%span sbdd'14 = "bdd.rs" 238 12 242 13
  let%span sbdd'15 = "bdd.rs" 260 12 284 19
  let%span sbdd'16 = "bdd.rs" 208 12 215 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'1 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span speano = "../../creusot-contracts/src/peano.rs" 132 14 132 38
  let%span speano'0 = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Bdd
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option'0
  
  function view'0 (self: t_MyHashMap) : Map.map t_NodeLog t_Option'0 =
    [%#smodel] view self
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'13] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'0 (self: t_Node) : t_NodeLog =
    [%#smodel'0] deep_model self
  
  let rec get (self:t_MyHashMap) (key:t_Node) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#sbdd'6] match result with
        | C_Some v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'0 v
        | C_None -> Map.get (view'0 self) (deep_model'0 key) = C_None'0
        end}
      (! return' {result}) ]
  
  
  let rec alloc (self:()) (val':t_Node) (return'  (x:MutBorrow.t t_Node))= any
    [ return''0 (result:MutBorrow.t t_Node)-> {[%#sbdd'7] result.current = val'} (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Node) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Node) =
    resolve _0
  
  function view'1 (self: MutBorrow.t t_MyHashMap) : Map.map t_NodeLog t_Option'0 =
    [%#smodel'1] view self.current
  
  let rec add (self:MutBorrow.t t_MyHashMap) (key:t_Node) (val':t_Bdd) (return'  (x:()))= any
    [ return''0 (result:())-> {[%#sbdd'8] forall i: t_NodeLog. Map.get (view self.final) i
      = (if i = deep_model key then C_Some'0 val' else Map.get (view'1 self) i)}
      (! return' {result}) ]
  
  
  let rec incr (self:t_PeanoInt) (return'  (x:t_PeanoInt))= any
    [ return''0 (result:t_PeanoInt)-> {[%#speano] UInt64.t'int result.t_PeanoInt__0
      = UInt64.t'int self.t_PeanoInt__0 + 1}
      (! return' {result}) ]
  
  
  function view'2 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'9] deep_model self
  
  function view'3 (self: t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'12] Map.get (view self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some'0 b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'4 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'14] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'10] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 (self: t_PeanoInt) : UInt64.t =
    [%#speano'0] self.t_PeanoInt__0
  
  function view'6 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option'0
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'16] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'7 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option'0
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'15] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some'0 b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'5 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None'0 -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'6 self.t_Context__not_memo) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'7 self.t_Context__and_memo) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                                t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                  t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc'0 ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve'1 (self: MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Context) =
    resolve'1 _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Bdd))= any
    [ good (field_0:t_Bdd)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Bdd [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'11] UInt64.le (view'5 (self.current).t_Context__cnt) (view'5 (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some'0 b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashcons[#"bdd.rs" 434 4 434 58] (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'1] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'2] is_valid_node self.current n}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_11 <- n'0 ] s1
      | s1 = get {(self'0.current).t_Context__hashcons} {_11} (fun (_ret:t_Option) ->  [ &_8 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = any [ br0 -> {_8 = C_None} (! bb4) | br1 (x0:t_Bdd)-> {_8 = C_Some x0} (! bb3) ] 
    | bb4 = s0
      [ s0 = alloc {(self'0.current).t_Context__alloc} {n'0} (fun (_ret:MutBorrow.t t_Node) ->  [ &_19 <- _ret ] s1)
      | s1 = bb5 ]
    
    | bb5 = s0
      [ s0 =  [ &r'0 <- { t_Bdd__0 = _19.current; t_Bdd__1 = ((self'0.current).t_Context__cnt).t_PeanoInt__0 } ] s1
      | s1 = -{resolve'0 _19}- s2
      | s2 = MutBorrow.borrow_final
          <t_MyHashMap>
          {(self'0.current).t_Context__hashcons}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 2}
          (fun (_ret:MutBorrow.t t_MyHashMap) ->
             [ &_24 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Context__hashcons = _ret.final } } ] 
            s3)
      | s3 = add {_24} {n'0} {r'0} (fun (_ret:()) ->  [ &_23 <- _ret ] s4)
      | s4 = bb6 ]
    
    | bb6 = s0
      [ s0 =  [ &_27 <- [%#sbdd] Map.set (self'0.current).t_Context__hashcons_ghost r'0.t_Bdd__1 r'0.t_Bdd__0 ] s1
      | s1 = bb7 ]
    
    | bb7 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_Context__hashcons_ghost = _27 } } ] s1
      | s1 = incr {(self'0.current).t_Context__cnt} (fun (_ret:t_PeanoInt) ->  [ &_29 <- _ret ] s2)
      | s2 = bb8 ]
    
    | bb8 = s0
      [ s0 =  [ &self'0 <- { self'0 with current = { self'0.current with t_Context__cnt = _29 } } ] s1
      | s1 = {[@expl:type invariant] inv'0 self'0} s2
      | s2 = -{resolve'2 self'0}- s3
      | s3 =  [ &_0 <- r'0 ] s4
      | s4 = bb9 ]
    
    | bb3 = s0
      [ s0 = v_Some {_8} (fun (r0:t_Bdd) ->  [ &r <- r0 ] s1)
      | s1 = {[@expl:type invariant] inv'0 self'0} s2
      | s2 = -{resolve'2 self'0}- s3
      | s3 = {[@expl:assertion] [%#sbdd'0] view'3 r.t_Bdd__0 = view'2 n'0} s4
      | s4 =  [ &_0 <- r ] s5
      | s5 = bb9 ]
    
    | bb9 = return''0 {_0} ]
    
    [ & _0: t_Bdd = Any.any_l ()
    | & self'0: MutBorrow.t t_Context = self
    | & n'0: t_Node = n
    | & _8: t_Option = Any.any_l ()
    | & _11: t_Node = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _19: MutBorrow.t t_Node = Any.any_l ()
    | & _23: () = Any.any_l ()
    | & _24: MutBorrow.t t_MyHashMap = Any.any_l ()
    | & _27: Map.map UInt64.t t_Node = Any.any_l ()
    | & _29: t_PeanoInt = Any.any_l () ]
    )
    [ return''0 (result:t_Bdd)-> {[@expl:hashcons ensures #0] [%#sbdd'3] result.t_Bdd__0 = n}
      {[@expl:hashcons ensures #1] [%#sbdd'4] grows self}
      {[@expl:hashcons ensures #2] [%#sbdd'5] is_valid_bdd self.final result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__node [#"bdd.rs" 453 4 453 87] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 453 17 453 21
  let%span sbdd'0 = "bdd.rs" 446 15 446 40
  let%span sbdd'1 = "bdd.rs" 447 15 447 40
  let%span sbdd'2 = "bdd.rs" 448 15 448 63
  let%span sbdd'3 = "bdd.rs" 449 14 449 26
  let%span sbdd'4 = "bdd.rs" 450 14 450 42
  let%span sbdd'5 = "bdd.rs" 451 14 451 102
  let%span sbdd'6 = "bdd.rs" 452 14 452 37
  let%span sbdd'7 = "bdd.rs" 198 14 198 37
  let%span sbdd'8 = "bdd.rs" 434 21 434 25
  let%span sbdd'9 = "bdd.rs" 430 15 430 36
  let%span sbdd'10 = "bdd.rs" 431 14 431 28
  let%span sbdd'11 = "bdd.rs" 432 14 432 26
  let%span sbdd'12 = "bdd.rs" 433 14 433 42
  let%span sbdd'13 = "bdd.rs" 305 12 305 47
  let%span sbdd'14 = "bdd.rs" 238 12 242 13
  let%span sbdd'15 = "bdd.rs" 293 12 298 17
  let%span sbdd'16 = "bdd.rs" 208 12 215 13
  let%span sbdd'17 = "bdd.rs" 312 12 321 13
  let%span sbdd'18 = "bdd.rs" 193 20 193 37
  let%span sbdd'19 = "bdd.rs" 260 12 284 19
  let%span sbdd'20 = "bdd.rs" 175 20 175 37
  let%span sbdd'21 = "bdd.rs" 184 20 184 26
  let%span sbdd'22 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'21] self.t_Bdd__1
  
  function view [#"bdd.rs" 192 4 192 33] (self: t_Bdd) : UInt64.t =
    [%#sbdd'18] deep_model self
  
  function view'0 (self: t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  let rec eq (self:t_Bdd) (o:t_Bdd) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sbdd'7] result = (view'0 self = view'0 o)} (! return' {result}) ]
  
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'1 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model'0 [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'22] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'20] deep_model'0 self
  
  function view'3 (self: t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'13] Map.get (view'1 self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'4 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'14] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'17] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'6 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'16] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'7 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'19] (forall n: t_NodeLog. match Map.get (view'1 self.t_Context__hashcons) n with
      | C_Some b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'5 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'6 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'7 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve (self: MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Context) =
    resolve _0
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'15] UInt64.le (view'5 (self.current).t_Context__cnt) (view'5 (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'1 (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view'1 (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec hashcons (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'8] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'9] is_valid_node self.current n}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'10] result.t_Bdd__0 = n}
      {[%#sbdd'11] grows self}
      {[%#sbdd'12] is_valid_bdd self.final result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec node[#"bdd.rs" 453 4 453 87] (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    (! bb0
    [ bb0 = s0 [ s0 = eq {childt'0} {childf'0} (fun (_ret:bool) ->  [ &_13 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = any [ br0 -> {_13 = false} (! bb3) | br1 -> {_13} (! bb2) ] 
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0 <- childt'0 ] s3
      | s3 = bb5 ]
    
    | bb3 = s0
      [ s0 =  [ &_18 <- C_If x'0 childt'0 childf'0 ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_17 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = hashcons {_17} {_18} (fun (_ret:t_Bdd) ->  [ &_0 <- _ret ] s3)
      | s3 = bb4 ]
    
    | bb4 = s0 [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = bb5 ] 
    | bb5 = return''0 {_0} ]
    
    [ & _0: t_Bdd = Any.any_l ()
    | & self'0: MutBorrow.t t_Context = self
    | & x'0: UInt64.t = x
    | & childt'0: t_Bdd = childt
    | & childf'0: t_Bdd = childf
    | & _13: bool = Any.any_l ()
    | & _17: MutBorrow.t t_Context = Any.any_l ()
    | & _18: t_Node = Any.any_l () ]
    )
    [ return''0 (result:t_Bdd)-> {[@expl:node ensures #0] [%#sbdd'3] grows self}
      {[@expl:node ensures #1] [%#sbdd'4] is_valid_bdd self.final result}
      {[@expl:node ensures #2] [%#sbdd'5] forall v: Map.map UInt64.t bool. interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[@expl:node ensures #3] [%#sbdd'6] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__trueqy95z [#"bdd.rs" 464 4 464 42] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 464 22 464 26
  let%span sbdd'0 = "bdd.rs" 460 14 460 26
  let%span sbdd'1 = "bdd.rs" 461 14 461 42
  let%span sbdd'2 = "bdd.rs" 462 14 462 40
  let%span sbdd'3 = "bdd.rs" 463 14 463 46
  let%span sbdd'4 = "bdd.rs" 434 21 434 25
  let%span sbdd'5 = "bdd.rs" 430 15 430 36
  let%span sbdd'6 = "bdd.rs" 431 14 431 28
  let%span sbdd'7 = "bdd.rs" 432 14 432 26
  let%span sbdd'8 = "bdd.rs" 433 14 433 42
  let%span sbdd'9 = "bdd.rs" 293 12 298 17
  let%span sbdd'10 = "bdd.rs" 305 12 305 47
  let%span sbdd'11 = "bdd.rs" 208 12 215 13
  let%span sbdd'12 = "bdd.rs" 238 12 242 13
  let%span sbdd'13 = "bdd.rs" 312 12 321 13
  let%span sbdd'14 = "bdd.rs" 260 12 284 19
  let%span sbdd'15 = "bdd.rs" 175 20 175 37
  let%span sbdd'16 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'16] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'15] deep_model self
  
  function view'1 (self: t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'10] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'12] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'13] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'4 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'11] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'5 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'14] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'3 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'4 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'5 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'9] UInt64.le (view'3 (self.current).t_Context__cnt) (view'3 (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec hashcons (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'4] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'5] is_valid_node self.current n}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'6] result.t_Bdd__0 = n}
      {[%#sbdd'7] grows self}
      {[%#sbdd'8] is_valid_bdd self.final result}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Context) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec trueqy95z[#"bdd.rs" 464 4 464 42] (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:true_ 'self' type invariant] [%#sbdd] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- C_True ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = hashcons {_6} {_7} (fun (_ret:t_Bdd) ->  [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0} ]  ]
    
    [ & _0: t_Bdd = Any.any_l ()
    | & self'0: MutBorrow.t t_Context = self
    | & _6: MutBorrow.t t_Context = Any.any_l ()
    | & _7: t_Node = Any.any_l () ]
    )
    [ return''0 (result:t_Bdd)-> {[@expl:true_ ensures #0] [%#sbdd'0] grows self}
      {[@expl:true_ ensures #1] [%#sbdd'1] is_valid_bdd self.final result}
      {[@expl:true_ ensures #2] [%#sbdd'2] forall v: Map.map UInt64.t bool. interp result v}
      {[@expl:true_ ensures #3] [%#sbdd'3] UInt64.t'int v_MAX + 1 = leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__falseqy95z [#"bdd.rs" 472 4 472 43] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 472 23 472 27
  let%span sbdd'0 = "bdd.rs" 468 14 468 26
  let%span sbdd'1 = "bdd.rs" 469 14 469 42
  let%span sbdd'2 = "bdd.rs" 470 14 470 41
  let%span sbdd'3 = "bdd.rs" 471 14 471 46
  let%span sbdd'4 = "bdd.rs" 434 21 434 25
  let%span sbdd'5 = "bdd.rs" 430 15 430 36
  let%span sbdd'6 = "bdd.rs" 431 14 431 28
  let%span sbdd'7 = "bdd.rs" 432 14 432 26
  let%span sbdd'8 = "bdd.rs" 433 14 433 42
  let%span sbdd'9 = "bdd.rs" 293 12 298 17
  let%span sbdd'10 = "bdd.rs" 305 12 305 47
  let%span sbdd'11 = "bdd.rs" 208 12 215 13
  let%span sbdd'12 = "bdd.rs" 238 12 242 13
  let%span sbdd'13 = "bdd.rs" 312 12 321 13
  let%span sbdd'14 = "bdd.rs" 260 12 284 19
  let%span sbdd'15 = "bdd.rs" 175 20 175 37
  let%span sbdd'16 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'16] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'15] deep_model self
  
  function view'1 (self: t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'10] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'12] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'13] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'4 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'11] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'5 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'14] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'3 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'4 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'5 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'9] UInt64.le (view'3 (self.current).t_Context__cnt) (view'3 (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec hashcons (self:MutBorrow.t t_Context) (n:t_Node) (return'  (x:t_Bdd))= {[@expl:hashcons 'self' type invariant] [%#sbdd'4] inv'0 self}
    {[@expl:hashcons requires] [%#sbdd'5] is_valid_node self.current n}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'6] result.t_Bdd__0 = n}
      {[%#sbdd'7] grows self}
      {[%#sbdd'8] is_valid_bdd self.final result}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Context) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec falseqy95z[#"bdd.rs" 472 4 472 43] (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_7 <- C_False ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_6 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = hashcons {_6} {_7} (fun (_ret:t_Bdd) ->  [ &_0 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0} ]  ]
    
    [ & _0: t_Bdd = Any.any_l ()
    | & self'0: MutBorrow.t t_Context = self
    | & _6: MutBorrow.t t_Context = Any.any_l ()
    | & _7: t_Node = Any.any_l () ]
    )
    [ return''0 (result:t_Bdd)-> {[@expl:false_ ensures #0] [%#sbdd'0] grows self}
      {[@expl:false_ ensures #1] [%#sbdd'1] is_valid_bdd self.final result}
      {[@expl:false_ ensures #2] [%#sbdd'2] forall v: Map.map UInt64.t bool. not interp result v}
      {[@expl:false_ ensures #3] [%#sbdd'3] UInt64.t'int v_MAX + 1 = leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__v [#"bdd.rs" 479 4 479 46] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 479 18 479 22
  let%span sbdd'0 = "bdd.rs" 476 14 476 26
  let%span sbdd'1 = "bdd.rs" 477 14 477 42
  let%span sbdd'2 = "bdd.rs" 478 14 478 52
  let%span sbdd'3 = "bdd.rs" 464 22 464 26
  let%span sbdd'4 = "bdd.rs" 460 14 460 26
  let%span sbdd'5 = "bdd.rs" 461 14 461 42
  let%span sbdd'6 = "bdd.rs" 462 14 462 40
  let%span sbdd'7 = "bdd.rs" 463 14 463 46
  let%span sbdd'8 = "bdd.rs" 472 23 472 27
  let%span sbdd'9 = "bdd.rs" 468 14 468 26
  let%span sbdd'10 = "bdd.rs" 469 14 469 42
  let%span sbdd'11 = "bdd.rs" 470 14 470 41
  let%span sbdd'12 = "bdd.rs" 471 14 471 46
  let%span sbdd'13 = "bdd.rs" 453 17 453 21
  let%span sbdd'14 = "bdd.rs" 446 15 446 40
  let%span sbdd'15 = "bdd.rs" 447 15 447 40
  let%span sbdd'16 = "bdd.rs" 448 15 448 63
  let%span sbdd'17 = "bdd.rs" 449 14 449 26
  let%span sbdd'18 = "bdd.rs" 450 14 450 42
  let%span sbdd'19 = "bdd.rs" 451 14 451 102
  let%span sbdd'20 = "bdd.rs" 452 14 452 37
  let%span sbdd'21 = "bdd.rs" 293 12 298 17
  let%span sbdd'22 = "bdd.rs" 305 12 305 47
  let%span sbdd'23 = "bdd.rs" 208 12 215 13
  let%span sbdd'24 = "bdd.rs" 238 12 242 13
  let%span sbdd'25 = "bdd.rs" 260 12 284 19
  let%span sbdd'26 = "bdd.rs" 175 20 175 37
  let%span sbdd'27 = "bdd.rs" 312 12 321 13
  let%span sbdd'28 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'28] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'0 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'26] deep_model self
  
  function view'1 (self: t_Node) : t_NodeLog =
    [%#smodel] view'0 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'22] Map.get (view self.t_Context__hashcons) (view'1 b.t_Bdd__0) = C_Some b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'2 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'24] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'2 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'27] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'3 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'4 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'23] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'5 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'25] (forall n: t_NodeLog. match Map.get (view self.t_Context__hashcons) n with
      | C_Some b -> view'1 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'3 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'4 self.t_Context__not_memo) bm with
      | C_None -> true
      | C_Some n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                              t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'5 self.t_Context__and_memo) abm with
      | C_None -> true
      | C_Some n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                              t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'21] UInt64.le (view'3 (self.current).t_Context__cnt) (view'3 (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view (self.current).t_Context__hashcons) n with
      | C_Some b -> Map.get (view (self.final).t_Context__hashcons) n = C_Some b
      | C_None -> true
      end)
  
  let rec trueqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:true_ 'self' type invariant] [%#sbdd'3] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'4] grows self}
      {[%#sbdd'5] is_valid_bdd self.final result}
      {[%#sbdd'6] forall v: Map.map UInt64.t bool. interp result v}
      {[%#sbdd'7] UInt64.t'int v_MAX + 1 = leastvar result}
      (! return' {result}) ]
  
  
  let rec falseqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd'8] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'9] grows self}
      {[%#sbdd'10] is_valid_bdd self.final result}
      {[%#sbdd'11] forall v: Map.map UInt64.t bool. not interp result v}
      {[%#sbdd'12] UInt64.t'int v_MAX + 1 = leastvar result}
      (! return' {result}) ]
  
  
  let rec node (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd'13] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'14] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'15] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'16] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'17] grows self}
      {[%#sbdd'18] is_valid_bdd self.final result}
      {[%#sbdd'19] forall v: Map.map UInt64.t bool. interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[%#sbdd'20] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Context) =
    resolve _0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec v[#"bdd.rs" 479 4 479 46] (self:MutBorrow.t t_Context) (x:UInt64.t) (return'  (x'0:t_Bdd))= {[@expl:v 'self' type invariant] [%#sbdd] inv'0 self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_7 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = trueqy95z {_7} (fun (_ret:t_Bdd) ->  [ &t <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_9 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = falseqy95z {_9} (fun (_ret:t_Bdd) ->  [ &f <- _ret ] s2)
      | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_final <t_Context> {self'0.current} {MutBorrow.get_id self'0}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_10 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = node {_10} {x'0} {t} {f} (fun (_ret:t_Bdd) ->  [ &_0 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = return''0 {_0} ]  ]
    
    [ & _0: t_Bdd = Any.any_l ()
    | & self'0: MutBorrow.t t_Context = self
    | & x'0: UInt64.t = x
    | & t: t_Bdd = Any.any_l ()
    | & _7: MutBorrow.t t_Context = Any.any_l ()
    | & f: t_Bdd = Any.any_l ()
    | & _9: MutBorrow.t t_Context = Any.any_l ()
    | & _10: MutBorrow.t t_Context = Any.any_l () ]
    )
    [ return''0 (result:t_Bdd)-> {[@expl:v ensures #0] [%#sbdd'0] grows self}
      {[@expl:v ensures #1] [%#sbdd'1] is_valid_bdd self.final result}
      {[@expl:v ensures #2] [%#sbdd'2] forall v'0: Map.map UInt64.t bool. interp result v'0 = Map.get v'0 x}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__not [#"bdd.rs" 491 4 491 56] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 491 20 491 24
  let%span sbdd'0 = "bdd.rs" 485 15 485 35
  let%span sbdd'1 = "bdd.rs" 486 14 486 26
  let%span sbdd'2 = "bdd.rs" 487 14 487 42
  let%span sbdd'3 = "bdd.rs" 488 14 488 56
  let%span sbdd'4 = "bdd.rs" 489 14 489 47
  let%span sbdd'5 = "bdd.rs" 490 14 490 22
  let%span sbdd'6 = "bdd.rs" 62 18 65 9
  let%span sbdd'7 = "bdd.rs" 453 17 453 21
  let%span sbdd'8 = "bdd.rs" 446 15 446 40
  let%span sbdd'9 = "bdd.rs" 447 15 447 40
  let%span sbdd'10 = "bdd.rs" 448 15 448 63
  let%span sbdd'11 = "bdd.rs" 449 14 449 26
  let%span sbdd'12 = "bdd.rs" 450 14 450 42
  let%span sbdd'13 = "bdd.rs" 451 14 451 102
  let%span sbdd'14 = "bdd.rs" 452 14 452 37
  let%span sbdd'15 = "bdd.rs" 472 23 472 27
  let%span sbdd'16 = "bdd.rs" 468 14 468 26
  let%span sbdd'17 = "bdd.rs" 469 14 469 42
  let%span sbdd'18 = "bdd.rs" 470 14 470 41
  let%span sbdd'19 = "bdd.rs" 471 14 471 46
  let%span sbdd'20 = "bdd.rs" 464 22 464 26
  let%span sbdd'21 = "bdd.rs" 460 14 460 26
  let%span sbdd'22 = "bdd.rs" 461 14 461 42
  let%span sbdd'23 = "bdd.rs" 462 14 462 40
  let%span sbdd'24 = "bdd.rs" 463 14 463 46
  let%span sbdd'25 = "bdd.rs" 56 18 56 126
  let%span sbdd'26 = "bdd.rs" 305 12 305 47
  let%span sbdd'27 = "bdd.rs" 293 12 298 17
  let%span sbdd'28 = "bdd.rs" 208 12 215 13
  let%span sbdd'29 = "bdd.rs" 238 12 242 13
  let%span sbdd'30 = "bdd.rs" 220 14 220 25
  let%span sbdd'31 = "bdd.rs" 223 12 231 13
  let%span sbdd'32 = "bdd.rs" 184 20 184 26
  let%span sbdd'33 = "bdd.rs" 260 12 284 19
  let%span sbdd'34 = "bdd.rs" 175 20 175 37
  let%span sbdd'35 = "bdd.rs" 312 12 321 13
  let%span sbdd'36 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'1 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Bdd
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option'0
  
  function view'0 (self: t_MyHashMap'0) : Map.map UInt64.t t_Option'0 =
    [%#smodel] view self
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'32] self.t_Bdd__1
  
  function deep_model'0 (self: t_Bdd) : UInt64.t =
    [%#smodel'0] deep_model self
  
  let rec get (self:t_MyHashMap'0) (key:t_Bdd) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#sbdd'6] match result with
        | C_Some v -> Map.get (view'0 self) (deep_model'0 key) = C_Some'0 v
        | C_None -> Map.get (view'0 self) (deep_model'0 key) = C_None'0
        end}
      (! return' {result}) ]
  
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'1 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option'0
  
  function deep_model'1 [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'36] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'34] deep_model'1 self
  
  function view'3 (self: t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'26] Map.get (view'1 self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some'0 b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'4 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'29] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'35] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'12] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'11] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'9] cmp_log x y = C_Greater)
   -> ([%#sord'10] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'7] cmp_log x y = C_Less)
   -> ([%#sord'8] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'4] cmp_log x y = o)
   -> ([%#sord'5] cmp_log y z = o)  -> ([%#sord'6] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'3] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'2] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'1] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'0] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'28] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  type tuple  =
    { _p0: UInt64.t; _p1: UInt64.t }
  
  function view'6 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple t_Option'0
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'33] (forall n: t_NodeLog. match Map.get (view'1 self.t_Context__hashcons) n with
      | C_Some'0 b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'5 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None'0 -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view self.t_Context__not_memo) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple. match Map.get (view'6 self.t_Context__and_memo) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0;
                                t_Bdd__1 = abm._p0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1;
                                                                  t_Bdd__1 = abm._p1 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'27] UInt64.le (view'5 (self.current).t_Context__cnt) (view'5 (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'1 (self.current).t_Context__hashcons) n with
      | C_Some'0 b -> Map.get (view'1 (self.final).t_Context__hashcons) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec node (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd'7] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'8] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'9] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'10] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'11] grows self}
      {[%#sbdd'12] is_valid_bdd self.final result}
      {[%#sbdd'13] forall v: Map.map UInt64.t bool. interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[%#sbdd'14] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]
  
  
  let rec falseqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd'15] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'16] grows self}
      {[%#sbdd'17] is_valid_bdd self.final result}
      {[%#sbdd'18] forall v: Map.map UInt64.t bool. not interp result v}
      {[%#sbdd'19] UInt64.t'int v_MAX + 1 = leastvar result}
      (! return' {result}) ]
  
  
  let rec trueqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:true_ 'self' type invariant] [%#sbdd'20] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'21] grows self}
      {[%#sbdd'22] is_valid_bdd self.final result}
      {[%#sbdd'23] forall v: Map.map UInt64.t bool. interp result v}
      {[%#sbdd'24] UInt64.t'int v_MAX + 1 = leastvar result}
      (! return' {result}) ]
  
  
  function view'7 (self: MutBorrow.t t_MyHashMap'0) : Map.map UInt64.t t_Option'0 =
    [%#smodel'1] view self.current
  
  let rec add (self:MutBorrow.t t_MyHashMap'0) (key:t_Bdd) (val':t_Bdd) (return'  (x:()))= any
    [ return''0 (result:())-> {[%#sbdd'25] forall i: UInt64.t. Map.get (view self.final) i
      = (if i = deep_model key then C_Some'0 val' else Map.get (view'7 self) i)}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Context) =
    resolve _0
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Bdd))= any
    [ good (field_0:t_Bdd)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Bdd [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function size [#"bdd.rs" 221 4 221 24] (self: t_Bdd) : int =
    [%#sbdd'31] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf ; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. [%#sbdd'30] size self >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec not'[#"bdd.rs" 491 4 491 56] (self:MutBorrow.t t_Context) (x:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:not 'self' type invariant] [%#sbdd] inv'0 self}
    {[@expl:not requires] [%#sbdd'0] is_valid_bdd self.current x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_13 <- x'0 ] s1
      | s1 = get {(self'0.current).t_Context__not_memo} {_13} (fun (_ret:t_Option) ->  [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = any [ br0 -> {_10 = C_None} (! bb4) | br1 (x0:t_Bdd)-> {_10 = C_Some x0} (! bb3) ] 
    | bb4 = any
      [ br0 -> {x'0.t_Bdd__0 = C_False} (! bb9)
      | br1 -> {x'0.t_Bdd__0 = C_True} (! bb10)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {x'0.t_Bdd__0 = C_If x0 x1 x2} (! bb8) ]
    
    | bb8 = s0
      [ s0 = v_If {x'0.t_Bdd__0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &v <- rv ] s1)
      | s1 = v_If {x'0.t_Bdd__0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childt <- rchildt ] s2)
      | s2 = v_If {x'0.t_Bdd__0} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childf <- rchildf ] s3)
      | s3 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_25 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s4)
      | s4 = not' {_25} {childt} (fun (_ret:t_Bdd) ->  [ &childt'0 <- _ret ] s5)
      | s5 = bb13 ]
    
    | bb13 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_28 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = not' {_28} {childf} (fun (_ret:t_Bdd) ->  [ &childf'0 <- _ret ] s2)
      | s2 = bb14 ]
    
    | bb14 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_30 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = node {_30} {v} {childt'0} {childf'0} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb10 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_19 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = falseqy95z {_19} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb9 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_20 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = trueqy95z {_20} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb16 ]
    
    | bb16 = s0
      [ s0 = MutBorrow.borrow_final
          <t_MyHashMap'0>
          {(self'0.current).t_Context__not_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 4}
          (fun (_ret:MutBorrow.t t_MyHashMap'0) ->
             [ &_35 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Context__not_memo = _ret.final } } ] 
            s1)
      | s1 = add {_35} {x'0} {r'0} (fun (_ret:()) ->  [ &_34 <- _ret ] s2)
      | s2 = bb17 ]
    
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0 <- r'0 ] s3
      | s3 = bb18 ]
    
    | bb3 = s0
      [ s0 = v_Some {_10} (fun (r0:t_Bdd) ->  [ &r <- r0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self'0} s3
      | s3 = -{resolve'0 self'0}- s4
      | s4 = bb18 ]
    
    | bb18 = return''0 {_0} ]
    
    [ & _0: t_Bdd = Any.any_l ()
    | & self'0: MutBorrow.t t_Context = self
    | & x'0: t_Bdd = x
    | & _10: t_Option = Any.any_l ()
    | & _13: t_Bdd = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _19: MutBorrow.t t_Context = Any.any_l ()
    | & _20: MutBorrow.t t_Context = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & childt'0: t_Bdd = Any.any_l ()
    | & _25: MutBorrow.t t_Context = Any.any_l ()
    | & childf'0: t_Bdd = Any.any_l ()
    | & _28: MutBorrow.t t_Context = Any.any_l ()
    | & _30: MutBorrow.t t_Context = Any.any_l ()
    | & _34: () = Any.any_l ()
    | & _35: MutBorrow.t t_MyHashMap'0 = Any.any_l () ]
    )
    [ return''0 (result:t_Bdd)-> {[@expl:not ensures #0] [%#sbdd'1] grows self}
      {[@expl:not ensures #1] [%#sbdd'2] is_valid_bdd self.final result}
      {[@expl:not ensures #2] [%#sbdd'3] forall v: Map.map UInt64.t bool. interp result v = (not interp x v)}
      {[@expl:not ensures #3] [%#sbdd'4] leastvar x <= leastvar result}
      (! return' {result}) ]

end
module M_bdd__qyi11078426090797403070__and [#"bdd.rs" 515 4 515 72] (* Context<'arena> *)
  let%span sbdd = "bdd.rs" 519 22 519 34
  let%span sbdd'0 = "bdd.rs" 515 20 515 24
  let%span sbdd'1 = "bdd.rs" 508 15 508 35
  let%span sbdd'2 = "bdd.rs" 509 15 509 35
  let%span sbdd'3 = "bdd.rs" 510 14 510 26
  let%span sbdd'4 = "bdd.rs" 511 14 511 42
  let%span sbdd'5 = "bdd.rs" 512 14 512 72
  let%span sbdd'6 = "bdd.rs" 513 14 513 84
  let%span sbdd'7 = "bdd.rs" 514 14 514 33
  let%span sbdd'8 = "bdd.rs" 62 18 65 9
  let%span sbdd'9 = "bdd.rs" 453 17 453 21
  let%span sbdd'10 = "bdd.rs" 446 15 446 40
  let%span sbdd'11 = "bdd.rs" 447 15 447 40
  let%span sbdd'12 = "bdd.rs" 448 15 448 63
  let%span sbdd'13 = "bdd.rs" 449 14 449 26
  let%span sbdd'14 = "bdd.rs" 450 14 450 42
  let%span sbdd'15 = "bdd.rs" 451 14 451 102
  let%span sbdd'16 = "bdd.rs" 452 14 452 37
  let%span sbdd'17 = "bdd.rs" 472 23 472 27
  let%span sbdd'18 = "bdd.rs" 468 14 468 26
  let%span sbdd'19 = "bdd.rs" 469 14 469 42
  let%span sbdd'20 = "bdd.rs" 470 14 470 41
  let%span sbdd'21 = "bdd.rs" 471 14 471 46
  let%span sbdd'22 = "bdd.rs" 56 18 56 126
  let%span sbdd'23 = "bdd.rs" 305 12 305 47
  let%span sbdd'24 = "bdd.rs" 293 12 298 17
  let%span sbdd'25 = "bdd.rs" 208 12 215 13
  let%span sbdd'26 = "bdd.rs" 238 12 242 13
  let%span sbdd'27 = "bdd.rs" 220 14 220 25
  let%span sbdd'28 = "bdd.rs" 223 12 231 13
  let%span sbdd'29 = "bdd.rs" 260 12 284 19
  let%span sbdd'30 = "bdd.rs" 184 20 184 26
  let%span sbdd'31 = "bdd.rs" 175 20 175 37
  let%span sbdd'32 = "bdd.rs" 312 12 321 13
  let%span sbdd'33 = "bdd.rs" 160 12 164 13
  let%span snum = "../../creusot-contracts/src/std/num.rs" 24 28 24 33
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'1 = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 21 28 21 57
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 101 20 101 44
  let%span speano = "../../creusot-contracts/src/peano.rs" 82 8 82 14
  let%span sord = "../../creusot-contracts/src/logic/ord.rs" 184 8 190 9
  let%span sord'0 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'1 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'2 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'3 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'4 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'5 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'6 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'7 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'8 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'9 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'10 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'11 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'12 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'13 = "../../creusot-contracts/src/logic/ord.rs" 129 39 129 89
  let%span sord'14 = "../../creusot-contracts/src/logic/ord.rs" 134 39 134 86
  let%span sord'15 = "../../creusot-contracts/src/logic/ord.rs" 139 39 139 86
  let%span sord'16 = "../../creusot-contracts/src/logic/ord.rs" 144 39 144 89
  let%span sord'17 = "../../creusot-contracts/src/logic/ord.rs" 149 39 149 70
  let%span sord'18 = "../../creusot-contracts/src/logic/ord.rs" 154 40 154 57
  let%span sord'19 = "../../creusot-contracts/src/logic/ord.rs" 155 40 155 57
  let%span sord'20 = "../../creusot-contracts/src/logic/ord.rs" 156 39 156 56
  let%span sord'21 = "../../creusot-contracts/src/logic/ord.rs" 161 40 161 70
  let%span sord'22 = "../../creusot-contracts/src/logic/ord.rs" 162 39 162 72
  let%span sord'23 = "../../creusot-contracts/src/logic/ord.rs" 167 40 167 73
  let%span sord'24 = "../../creusot-contracts/src/logic/ord.rs" 168 39 168 69
  let%span sord'25 = "../../creusot-contracts/src/logic/ord.rs" 173 39 173 84
  let%span sord'26 = "../../creusot-contracts/src/logic/ord.rs" 230 16 236 17
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span scmp = "../../creusot-contracts/src/std/cmp.rs" 194 18 194 77
  
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  type tuple  =
    { _p0: t_Bdd; _p1: t_Bdd }
  
  type t_MyHashMap
  
  type t_MyHashMap'0
  
  type t_MyHashMap'1
  
  type t_PeanoInt  =
    { t_PeanoInt__0: UInt64.t }
  
  type t_Context  =
    { t_Context__alloc: ();
      t_Context__hashcons: t_MyHashMap;
      t_Context__hashcons_ghost: Map.map UInt64.t t_Node;
      t_Context__not_memo: t_MyHashMap'0;
      t_Context__and_memo: t_MyHashMap'1;
      t_Context__cnt: t_PeanoInt }
  
  type t_Option  =
    | C_None
    | C_Some t_Bdd
  
  type tuple'0  =
    { _p0'0: UInt64.t; _p1'0: UInt64.t }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_Bdd
  
  function view [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'1) : Map.map tuple'0 t_Option'0
  
  function view'0 (self: t_MyHashMap'1) : Map.map tuple'0 t_Option'0 =
    [%#smodel] view self
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'30] self.t_Bdd__1
  
  function deep_model'0 (self: tuple) : tuple'0 =
    [%#stuples] { _p0'0 = deep_model self._p0; _p1'0 = deep_model self._p1 }
  
  function deep_model'1 (self: tuple) : tuple'0 =
    [%#smodel'0] deep_model'0 self
  
  let rec get (self:t_MyHashMap'1) (key:tuple) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#sbdd'8] match result with
        | C_Some v -> Map.get (view'0 self) (deep_model'1 key) = C_Some'0 v
        | C_None -> Map.get (view'0 self) (deep_model'1 key) = C_None'0
        end}
      (! return' {result}) ]
  
  
  type tuple'1  =
    { _p0'1: t_Node; _p1'1: t_Node }
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function view'1 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap) : Map.map t_NodeLog t_Option'0
  
  function deep_model'2 [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'33] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view'2 [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'31] deep_model'2 self
  
  function view'3 (self: t_Node) : t_NodeLog =
    [%#smodel] view'2 self
  
  predicate is_valid_bdd [#"bdd.rs" 303 4 303 53] (self: t_Context) (b: t_Bdd) =
    [%#sbdd'23] Map.get (view'1 self.t_Context__hashcons) (view'3 b.t_Bdd__0) = C_Some'0 b
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view'4 (self: UInt64.t) : int =
    [%#smodel] UInt64.t'int self
  
  function leastvar [#"bdd.rs" 236 4 236 32] (self: t_Bdd) : int =
    [%#sbdd'26] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> UInt64.t'int v_MAX + 1
      | {t_Bdd__0 = C_If v _ _ ; t_Bdd__1 = _} -> view'4 v
      end
  
  predicate is_valid_node [#"bdd.rs" 310 4 310 51] (self: t_Context) (n: t_Node) =
    [%#sbdd'32] match n with
      | C_True -> true
      | C_False -> true
      | C_If v childt childf -> childt.t_Bdd__0 <> childf.t_Bdd__0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  function cmp_log (self: UInt64.t) (o: UInt64.t) : t_Ordering =
    [%#sord'26] if UInt64.lt self o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'25] (x = y) = (cmp_log x y = C_Equal)
  
  function antisym2 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'23] cmp_log x y = C_Greater)
   -> ([%#sord'24] cmp_log y x = C_Less)
  
  function antisym1 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_spec: forall x: UInt64.t, y: UInt64.t. ([%#sord'21] cmp_log x y = C_Less)
   -> ([%#sord'22] cmp_log y x = C_Greater)
  
  function trans (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. ([%#sord'18] cmp_log x y = o)
   -> ([%#sord'19] cmp_log y z = o)  -> ([%#sord'20] cmp_log x z = o)
  
  function refl (x: UInt64.t) : ()
  
  axiom refl_spec: forall x: UInt64.t. [%#sord'17] cmp_log x x = C_Equal
  
  function cmp_gt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'16] UInt64.gt x y = (cmp_log x y = C_Greater)
  
  function cmp_ge_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'15] UInt64.ge x y = (cmp_log x y <> C_Less)
  
  function cmp_lt_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'14] UInt64.lt x y = (cmp_log x y = C_Less)
  
  function cmp_le_log (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_spec: forall x: UInt64.t, y: UInt64.t. [%#sord'13] UInt64.le x y = (cmp_log x y <> C_Greater)
  
  function view'5 (self: t_PeanoInt) : UInt64.t =
    [%#speano] self.t_PeanoInt__0
  
  function view'6 [#"bdd.rs" 50 8 50 37] (self: t_MyHashMap'0) : Map.map UInt64.t t_Option'0
  
  predicate interp [#"bdd.rs" 206 4 206 57] (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    [%#sbdd'25] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> true
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> false
      | {t_Bdd__0 = C_If v childt childf ; t_Bdd__1 = _} -> if Map.get vars v then
        interp childt vars
      else
        interp childf vars
      
      end
  
  predicate invariant' [#"bdd.rs" 258 4 258 30] (self: t_Context) =
    [%#sbdd'29] (forall n: t_NodeLog. match Map.get (view'1 self.t_Context__hashcons) n with
      | C_Some'0 b -> view'3 b.t_Bdd__0 = n
      /\ is_valid_node self b.t_Bdd__0
      /\ UInt64.lt b.t_Bdd__1 (view'5 self.t_Context__cnt)
      /\ Map.get self.t_Context__hashcons_ghost b.t_Bdd__1 = b.t_Bdd__0
      | C_None'0 -> true
      end)
    /\ (forall bm: UInt64.t. match Map.get (view'6 self.t_Context__not_memo) bm with
      | C_None'0 -> true
      | C_Some'0 n -> let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost bm;
                                t_Bdd__1 = bm } in is_valid_bdd self n
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
      end)
    /\ (forall abm: tuple'0. match Map.get (view self.t_Context__and_memo) abm with
      | C_None'0 -> true
      | C_Some'0 n -> let a = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p0'0;
                                t_Bdd__1 = abm._p0'0 } in let b = { t_Bdd__0 = Map.get self.t_Context__hashcons_ghost abm._p1'0;
                                                                    t_Bdd__1 = abm._p1'0 } in is_valid_bdd self n
      /\ is_valid_bdd self a
      /\ is_valid_bdd self b
      /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
      /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
      end)
  
  predicate inv (_0: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv x]. inv x
  = (invariant' x
  /\ match x with
    | {t_Context__alloc = alloc ; t_Context__hashcons = hashcons ; t_Context__hashcons_ghost = hashcons_ghost ; t_Context__not_memo = not_memo ; t_Context__and_memo = and_memo ; t_Context__cnt = cnt} -> true
    end)
  
  predicate invariant''0 (self: MutBorrow.t t_Context) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'0 (_0: MutBorrow.t t_Context)
  
  axiom inv_axiom'0 [@rewrite]: forall x: MutBorrow.t t_Context [inv'0 x]. inv'0 x = invariant''0 x
  
  predicate resolve (self: MutBorrow.t t_Context) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_Context) =
    resolve _0
  
  let rec v_If (input:t_Node) (ret  (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd))= any
    [ good (v:UInt64.t) (childt:t_Bdd) (childf:t_Bdd)-> {C_If v childt childf = input} (! ret {v} {childt} {childf})
    | bad -> {forall v: UInt64.t, childt: t_Bdd, childf: t_Bdd [C_If v childt childf: t_Node]. C_If v childt childf
      <> input}
      (! {false}
      any) ]
  
  
  function cmp_log'0 (self: int) (o: int) : t_Ordering =
    [%#sord] if self < o then C_Less else if self = o then C_Equal else C_Greater
  
  function eq_cmp'0 (x: int) (y: int) : ()
  
  axiom eq_cmp_spec'0: forall x: int, y: int. [%#sord'12] (x = y) = (cmp_log'0 x y = C_Equal)
  
  function antisym2'0 (x: int) (y: int) : ()
  
  axiom antisym2_spec'0: forall x: int, y: int. ([%#sord'10] cmp_log'0 x y = C_Greater)
   -> ([%#sord'11] cmp_log'0 y x = C_Less)
  
  function antisym1'0 (x: int) (y: int) : ()
  
  axiom antisym1_spec'0: forall x: int, y: int. ([%#sord'8] cmp_log'0 x y = C_Less)
   -> ([%#sord'9] cmp_log'0 y x = C_Greater)
  
  function trans'0 (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_spec'0: forall x: int, y: int, z: int, o: t_Ordering. ([%#sord'5] cmp_log'0 x y = o)
   -> ([%#sord'6] cmp_log'0 y z = o)  -> ([%#sord'7] cmp_log'0 x z = o)
  
  function refl'0 (x: int) : ()
  
  axiom refl_spec'0: forall x: int. [%#sord'4] cmp_log'0 x x = C_Equal
  
  function cmp_gt_log'0 (x: int) (y: int) : ()
  
  axiom cmp_gt_log_spec'0: forall x: int, y: int. [%#sord'3] (x > y) = (cmp_log'0 x y = C_Greater)
  
  function cmp_ge_log'0 (x: int) (y: int) : ()
  
  axiom cmp_ge_log_spec'0: forall x: int, y: int. [%#sord'2] (x >= y) = (cmp_log'0 x y <> C_Less)
  
  function cmp_lt_log'0 (x: int) (y: int) : ()
  
  axiom cmp_lt_log_spec'0: forall x: int, y: int. [%#sord'1] (x < y) = (cmp_log'0 x y = C_Less)
  
  function cmp_le_log'0 (x: int) (y: int) : ()
  
  axiom cmp_le_log_spec'0: forall x: int, y: int. [%#sord'0] (x <= y) = (cmp_log'0 x y <> C_Greater)
  
  function deep_model'3 (self: UInt64.t) : int =
    [%#snum] UInt64.t'int self
  
  let rec cmp (self_:UInt64.t) (rhs:UInt64.t) (return'  (x:t_Ordering))= any
    [ return''0 (result:t_Ordering)-> {[%#scmp] result = cmp_log'0 (deep_model'3 self_) (deep_model'3 rhs)}
      (! return' {result}) ]
  
  
  predicate grows [#"bdd.rs" 291 4 291 35] (self: MutBorrow.t t_Context) =
    [%#sbdd'24] UInt64.le (view'5 (self.current).t_Context__cnt) (view'5 (self.final).t_Context__cnt)
    /\ (forall n: t_NodeLog. match Map.get (view'1 (self.current).t_Context__hashcons) n with
      | C_Some'0 b -> Map.get (view'1 (self.final).t_Context__hashcons) n = C_Some'0 b
      | C_None'0 -> true
      end)
  
  let rec node (self:MutBorrow.t t_Context) (x:UInt64.t) (childt:t_Bdd) (childf:t_Bdd) (return'  (x'0:t_Bdd))= {[@expl:node 'self' type invariant] [%#sbdd'9] inv'0 self}
    {[@expl:node requires #0] [%#sbdd'10] is_valid_bdd self.current childt}
    {[@expl:node requires #1] [%#sbdd'11] is_valid_bdd self.current childf}
    {[@expl:node requires #2] [%#sbdd'12] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'13] grows self}
      {[%#sbdd'14] is_valid_bdd self.final result}
      {[%#sbdd'15] forall v: Map.map UInt64.t bool. interp result v
      = (if Map.get v x then interp childt v else interp childf v)}
      {[%#sbdd'16] UInt64.t'int x <= leastvar result}
      (! return' {result}) ]
  
  
  let rec falseqy95z (self:MutBorrow.t t_Context) (return'  (x:t_Bdd))= {[@expl:false_ 'self' type invariant] [%#sbdd'17] inv'0 self}
    any
    [ return''0 (result:t_Bdd)-> {[%#sbdd'18] grows self}
      {[%#sbdd'19] is_valid_bdd self.final result}
      {[%#sbdd'20] forall v: Map.map UInt64.t bool. not interp result v}
      {[%#sbdd'21] UInt64.t'int v_MAX + 1 = leastvar result}
      (! return' {result}) ]
  
  
  function view'7 (self: MutBorrow.t t_MyHashMap'1) : Map.map tuple'0 t_Option'0 =
    [%#smodel'1] view self.current
  
  let rec add (self:MutBorrow.t t_MyHashMap'1) (key:tuple) (val':t_Bdd) (return'  (x:()))= any
    [ return''0 (result:())-> {[%#sbdd'22] forall i: tuple'0. Map.get (view self.final) i
      = (if i = deep_model'0 key then C_Some'0 val' else Map.get (view'7 self) i)}
      (! return' {result}) ]
  
  
  let rec v_Some (input:t_Option) (ret  (field_0:t_Bdd))= any
    [ good (field_0:t_Bdd)-> {C_Some field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: t_Bdd [C_Some field_0: t_Option]. C_Some field_0 <> input} (! {false} any) ]
  
  
  function size [#"bdd.rs" 221 4 221 24] (self: t_Bdd) : int =
    [%#sbdd'28] match self with
      | {t_Bdd__0 = C_True ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_False ; t_Bdd__1 = _} -> 0
      | {t_Bdd__0 = C_If _ childt childf ; t_Bdd__1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. [%#sbdd'27] size self >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec and[#"bdd.rs" 515 4 515 72] (self:MutBorrow.t t_Context) (a:t_Bdd) (b:t_Bdd) (return'  (x:t_Bdd))= {[@expl:and 'self' type invariant] [%#sbdd'0] inv'0 self}
    {[@expl:and requires #0] [%#sbdd'1] is_valid_bdd self.current a}
    {[@expl:and requires #1] [%#sbdd'2] is_valid_bdd self.current b}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &_16 <- { _p0 = a'0; _p1 = b'0 } ] s1
      | s1 =  [ &_15 <- _16 ] s2
      | s2 = get {(self'0.current).t_Context__and_memo} {_15} (fun (_ret:t_Option) ->  [ &_12 <- _ret ] s3)
      | s3 = bb1 ]
    
    | bb1 = any [ br0 -> {_12 = C_None} (! bb4) | br1 (x0:t_Bdd)-> {_12 = C_Some x0} (! bb3) ] 
    | bb4 = s0
      [ s0 =  [ &_23 <- { _p0'1 = a'0.t_Bdd__0; _p1'1 = b'0.t_Bdd__0 } ] s1
      | s1 = any
        [ br0 -> {_23._p0'1 = C_False} (! bb5)
        | br1 -> {_23._p0'1 = C_True} (! bb16)
        | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._p0'1 = C_If x0 x1 x2} (! bb5) ]
       ]
    
    | bb5 = any
      [ br0 -> {_23._p1'1 = C_False} (! bb7)
      | br1 -> {_23._p1'1 = C_True} (! bb15)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._p1'1 = C_If x0 x1 x2} (! bb7) ]
    
    | bb7 = any
      [ br0 -> {_23._p0'1 = C_False} (! bb14)
      | br1 -> {_23._p0'1 = C_True} (! bb9)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._p0'1 = C_If x0 x1 x2} (! bb9) ]
    
    | bb9 = any
      [ br0 -> {_23._p1'1 = C_False} (! bb14)
      | br1 -> {_23._p1'1 = C_True} (! bb10)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._p1'1 = C_If x0 x1 x2} (! bb11) ]
    
    | bb11 = any
      [ br0 -> {_23._p0'1 = C_False} (! bb10)
      | br1 -> {_23._p0'1 = C_True} (! bb10)
      | br2 (x0:UInt64.t) (x1:t_Bdd) (x2:t_Bdd)-> {_23._p0'1 = C_If x0 x1 x2} (! bb12) ]
    
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1 | s1 = -{resolve'0 self'0}- s2 | s2 = {[%#sbdd] false} any ]
    
    | bb12 = s0
      [ s0 = v_If {_23._p0'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &va <- rv ] s1)
      | s1 = v_If {_23._p0'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childta <- rchildt ] s2)
      | s2 = v_If {_23._p0'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childfa <- rchildf ] s3)
      | s3 = v_If {_23._p1'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &vb <- rv ] s4)
      | s4 = v_If {_23._p1'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childtb <- rchildt ] s5)
      | s5 = v_If {_23._p1'1} (fun (rv:UInt64.t) (rchildt:t_Bdd) (rchildf:t_Bdd) ->  [ &childfb <- rchildf ] s6)
      | s6 =  [ &_45 <- vb ] s7
      | s7 = cmp {va} {_45} (fun (_ret:t_Ordering) ->  [ &_42 <- _ret ] s8)
      | s8 = bb18 ]
    
    | bb18 = any
      [ br0 -> {_42 = C_Less} (! bb23) | br1 -> {_42 = C_Equal} (! bb22) | br2 -> {_42 = C_Greater} (! bb24) ]
    
    | bb24 = s0
      [ s0 =  [ &v <- vb ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_49 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_49} {a'0} {childtb} (fun (_ret:t_Bdd) ->  [ &_48 <- _ret ] s3)
      | s3 = bb25 ]
    
    | bb25 = s0
      [ s0 =  [ &childt <- _48 ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_53 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_53} {a'0} {childfb} (fun (_ret:t_Bdd) ->  [ &_52 <- _ret ] s3)
      | s3 = bb26 ]
    
    | bb26 = s0 [ s0 =  [ &childf <- _52 ] s1 | s1 = bb31 ] 
    | bb22 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_67 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_67} {childta} {childtb} (fun (_ret:t_Bdd) ->  [ &_66 <- _ret ] s3)
      | s3 = bb29 ]
    
    | bb29 = s0
      [ s0 =  [ &childt <- _66 ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_71 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_71} {childfa} {childfb} (fun (_ret:t_Bdd) ->  [ &_70 <- _ret ] s3)
      | s3 = bb30 ]
    
    | bb30 = s0 [ s0 =  [ &childf <- _70 ] s1 | s1 = bb31 ] 
    | bb23 = s0
      [ s0 =  [ &v <- va ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_58 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_58} {childta} {b'0} (fun (_ret:t_Bdd) ->  [ &_57 <- _ret ] s3)
      | s3 = bb27 ]
    
    | bb27 = s0
      [ s0 =  [ &childt <- _57 ] s1
      | s1 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_62 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s2)
      | s2 = and {_62} {childfa} {b'0} (fun (_ret:t_Bdd) ->  [ &_61 <- _ret ] s3)
      | s3 = bb28 ]
    
    | bb28 = s0 [ s0 =  [ &childf <- _61 ] s1 | s1 = bb31 ] 
    | bb31 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_74 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = node {_74} {v} {childt} {childf} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb33 ]
    
    | bb14 = s0
      [ s0 = {inv self'0.current}
        MutBorrow.borrow_mut <t_Context> {self'0.current}
          (fun (_ret:MutBorrow.t t_Context) ->
             [ &_31 <- _ret ] 
            -{inv _ret.final}-
             [ &self'0 <- { self'0 with current = _ret.final } ] 
            s1)
      | s1 = falseqy95z {_31} (fun (_ret:t_Bdd) ->  [ &r'0 <- _ret ] s2)
      | s2 = bb33 ]
    
    | bb15 = s0 [ s0 =  [ &r'0 <- a'0 ] s1 | s1 = bb33 ] 
    | bb16 = s0 [ s0 =  [ &r'0 <- b'0 ] s1 | s1 = bb33 ] 
    | bb33 = s0
      [ s0 =  [ &_80 <- { _p0 = a'0; _p1 = b'0 } ] s1
      | s1 = MutBorrow.borrow_final
          <t_MyHashMap'1>
          {(self'0.current).t_Context__and_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 5}
          (fun (_ret:MutBorrow.t t_MyHashMap'1) ->
             [ &_79 <- _ret ] 
             [ &self'0 <- { self'0 with current = { self'0.current with t_Context__and_memo = _ret.final } } ] 
            s2)
      | s2 = add {_79} {_80} {r'0} (fun (_ret:()) ->  [ &_78 <- _ret ] s3)
      | s3 = bb34 ]
    
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv'0 self'0} s1
      | s1 = -{resolve'0 self'0}- s2
      | s2 =  [ &_0 <- r'0 ] s3
      | s3 = bb35 ]
    
    | bb3 = s0
      [ s0 = v_Some {_12} (fun (r0:t_Bdd) ->  [ &r <- r0 ] s1)
      | s1 =  [ &_0 <- r ] s2
      | s2 = {[@expl:type invariant] inv'0 self'0} s3
      | s3 = -{resolve'0 self'0}- s4
      | s4 = bb35 ]
    
    | bb35 = return''0 {_0} ]
    
    [ & _0: t_Bdd = Any.any_l ()
    | & self'0: MutBorrow.t t_Context = self
    | & a'0: t_Bdd = a
    | & b'0: t_Bdd = b
    | & _12: t_Option = Any.any_l ()
    | & _15: tuple = Any.any_l ()
    | & _16: tuple = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _23: tuple'1 = Any.any_l ()
    | & _31: MutBorrow.t t_Context = Any.any_l ()
    | & va: UInt64.t = Any.any_l ()
    | & childta: t_Bdd = Any.any_l ()
    | & childfa: t_Bdd = Any.any_l ()
    | & vb: UInt64.t = Any.any_l ()
    | & childtb: t_Bdd = Any.any_l ()
    | & childfb: t_Bdd = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & _42: t_Ordering = Any.any_l ()
    | & _45: UInt64.t = Any.any_l ()
    | & _48: t_Bdd = Any.any_l ()
    | & _49: MutBorrow.t t_Context = Any.any_l ()
    | & _52: t_Bdd = Any.any_l ()
    | & _53: MutBorrow.t t_Context = Any.any_l ()
    | & _57: t_Bdd = Any.any_l ()
    | & _58: MutBorrow.t t_Context = Any.any_l ()
    | & _61: t_Bdd = Any.any_l ()
    | & _62: MutBorrow.t t_Context = Any.any_l ()
    | & _66: t_Bdd = Any.any_l ()
    | & _67: MutBorrow.t t_Context = Any.any_l ()
    | & _70: t_Bdd = Any.any_l ()
    | & _71: MutBorrow.t t_Context = Any.any_l ()
    | & _74: MutBorrow.t t_Context = Any.any_l ()
    | & _78: () = Any.any_l ()
    | & _79: MutBorrow.t t_MyHashMap'1 = Any.any_l ()
    | & _80: tuple = Any.any_l () ]
    )
    [ return''0 (result:t_Bdd)-> {[@expl:and ensures #0] [%#sbdd'3] grows self}
      {[@expl:and ensures #1] [%#sbdd'4] is_valid_bdd self.final result}
      {[@expl:and ensures #2] [%#sbdd'5] forall v: Map.map UInt64.t bool. interp result v = (interp a v /\ interp b v)}
      {[@expl:and ensures #3] [%#sbdd'6] leastvar a <= leastvar result \/ leastvar b <= leastvar result}
      (! return' {result}) ]

end
module M_bdd__hashmap__qyi1953663170559623169__hash__refines [#"bdd.rs" 80 8 80 29] (* <(U, V) as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 80 8 80 29
  let%span sbdd'0 = "bdd.rs" 86 24 86 84
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span stuples = "../../creusot-contracts/src/std/tuples.rs" 21 28 21 57
  let%span sinvariant = "../../creusot-contracts/src/invariant.rs" 91 8 91 18
  
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_U
  
  type t_V
  
  type tuple  =
    { _p0: t_U; _p1: t_V }
  
  predicate inv (_0: t_U)
  
  predicate inv'0 (_0: t_V)
  
  predicate inv'1 (_0: tuple)
  
  axiom inv_axiom [@rewrite]: forall x: tuple [inv'1 x]. inv'1 x = (let {_p0 = x0 ; _p1 = x1} = x in inv x0 /\ inv'0 x1)
  
  predicate invariant' (self: tuple) =
    [%#sinvariant] inv'1 self
  
  predicate inv'2 (_0: tuple)
  
  axiom inv_axiom'0 [@rewrite]: forall x: tuple [inv'2 x]. inv'2 x = invariant' x
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type tuple'0  =
    { _p0'0: t_DeepModelTy; _p1'0: t_DeepModelTy'0 }
  
  function hash_log [#"bdd.rs" 39 8 39 49] (_0: t_DeepModelTy) : int
  
  function hash_log'0 [#"bdd.rs" 39 8 39 49] (_0: t_DeepModelTy'0) : int
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log'1 [#"bdd.rs" 85 8 85 48] (x: tuple'0) : int =
    [%#sbdd'0] Int.mod (hash_log x._p0'0 + hash_log'0 x._p1'0 * 17) (UInt64.t'int v_MAX + 1)
  
  function deep_model (self: t_U) : t_DeepModelTy
  
  function deep_model'0 (self: t_V) : t_DeepModelTy'0
  
  function deep_model'1 (self: tuple) : tuple'0 =
    [%#stuples] { _p0'0 = deep_model self._p0; _p1'0 = deep_model'0 self._p1 }
  
  function deep_model'2 (self: tuple) : tuple'0 =
    [%#smodel] deep_model'1 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sbdd] forall self: tuple. inv'2 self
   -> inv'2 self
  /\ (forall result: UInt64.t. UInt64.t'int result = hash_log'1 (deep_model'2 self)
   -> UInt64.t'int result = hash_log'1 (deep_model'2 self))
end
module M_bdd__qyi699402059438633899__hash__refines [#"bdd.rs" 119 4 119 25] (* <Node<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 119 4 119 25
  let%span sbdd'0 = "bdd.rs" 132 12 137 13
  let%span sbdd'1 = "bdd.rs" 175 20 175 37
  let%span sbdd'2 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NodeLog  =
    | C_False
    | C_True
    | C_If UInt64.t UInt64.t UInt64.t
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log [#"bdd.rs" 130 4 130 44] (x: t_NodeLog) : int =
    [%#sbdd'0] match x with
      | C_False -> 1
      | C_True -> 2
      | C_If v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int v_MAX + 1)
      end
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t t_Bdd t_Bdd
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'2] match self with
      | C_False'0 -> C_False
      | C_True'0 -> C_True
      | C_If'0 v childt childf -> C_If v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function view [#"bdd.rs" 174 4 174 33] (self: t_Node) : t_NodeLog =
    [%#sbdd'1] deep_model self
  
  function view'0 (self: t_Node) : t_NodeLog =
    [%#smodel] view self
  
  function deep_model'0 (self: t_Node) : t_NodeLog =
    [%#smodel'0] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sbdd] forall self: t_Node. forall result: UInt64.t. UInt64.t'int result = hash_log (view'0 self)
   -> UInt64.t'int result = hash_log (deep_model'0 self)
end
module M_bdd__qyi14323183011761258016__hash__refines [#"bdd.rs" 144 4 144 25] (* <Bdd<'arena> as hashmap::Hash> *)
  let%span sbdd = "bdd.rs" 144 4 144 25
  let%span sbdd'0 = "bdd.rs" 150 20 150 22
  let%span sbdd'1 = "bdd.rs" 193 20 193 37
  let%span sbdd'2 = "bdd.rs" 184 20 184 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt64
  
  function hash_log [#"bdd.rs" 149 4 149 44] (x: UInt64.t) : int =
    [%#sbdd'0] UInt64.t'int x
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'2] self.t_Bdd__1
  
  function view [#"bdd.rs" 192 4 192 33] (self: t_Bdd) : UInt64.t =
    [%#sbdd'1] deep_model self
  
  function view'0 (self: t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  function deep_model'0 (self: t_Bdd) : UInt64.t =
    [%#smodel'0] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sbdd] forall self: t_Bdd. forall result: UInt64.t. UInt64.t'int result = hash_log (view'0 self)
   -> UInt64.t'int result = hash_log (deep_model'0 self)
end
module M_bdd__qyi4854841669736991510__eq__refines [#"bdd.rs" 93 13 93 22] (* <Node<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 93 13 93 22
  let%span sbdd'0 = "bdd.rs" 160 12 164 13
  let%span smodel = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt64
  
  type t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  with t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  
  type t_NodeLog  =
    | C_False'0
    | C_True'0
    | C_If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model [#"bdd.rs" 158 4 158 44] (self: t_Node) : t_NodeLog =
    [%#sbdd'0] match self with
      | C_False -> C_False'0
      | C_True -> C_True'0
      | C_If v childt childf -> C_If'0 v (childt.t_Bdd__1) (childf.t_Bdd__1)
      end
  
  function deep_model'0 (self: t_Node) : t_NodeLog =
    [%#smodel] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sbdd] forall self_: t_Node. forall rhs: t_Node. forall result: bool. result
  = (deep_model'0 self_ = deep_model'0 rhs)  -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
module M_bdd__qyi2581120635339165136__eq__refines [#"bdd.rs" 199 4 199 34] (* <Bdd<'arena> as creusot_contracts::PartialEq> *)
  let%span sbdd = "bdd.rs" 199 4 199 34
  let%span sbdd'0 = "bdd.rs" 193 20 193 37
  let%span sbdd'1 = "bdd.rs" 184 20 184 26
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../creusot-contracts/src/model.rs" 35 8 35 28
  
  use creusot.int.UInt64
  
  type t_Node  =
    | C_False
    | C_True
    | C_If UInt64.t t_Bdd t_Bdd
  with t_Bdd  =
    { t_Bdd__0: t_Node; t_Bdd__1: UInt64.t }
  
  function deep_model [#"bdd.rs" 183 4 183 44] (self: t_Bdd) : UInt64.t =
    [%#sbdd'1] self.t_Bdd__1
  
  function view [#"bdd.rs" 192 4 192 33] (self: t_Bdd) : UInt64.t =
    [%#sbdd'0] deep_model self
  
  function view'0 (self: t_Bdd) : UInt64.t =
    [%#smodel] view self
  
  function deep_model'0 (self: t_Bdd) : UInt64.t =
    [%#smodel'0] deep_model self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: [%#sbdd] forall self_: t_Bdd. forall rhs: t_Bdd. forall result: bool. result
  = (view'0 self_ = view'0 rhs)  -> result = (deep_model'0 self_ = deep_model'0 rhs)
end
