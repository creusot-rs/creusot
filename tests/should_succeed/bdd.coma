module M_hashmap__impl_Hash_for_tup2_U_V__hash (* <(U, V) as hashmap::Hash> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_U
  
  type t_V
  
  type tup2_U_V = { f0: t_U; f1: t_V }
  
  predicate inv_U (_1: t_U)
  
  predicate invariant_ref_U [@inline:trivial] (self: t_U) = inv_U self
  
  meta "rewrite_def" predicate invariant_ref_U
  
  predicate inv_ref_U [@inline:trivial] (_1: t_U) = invariant_ref_U _1
  
  meta "rewrite_def" predicate inv_ref_U
  
  predicate precondition_hash (self: ()) (args: t_U)
  
  axiom precondition_fndef: forall args: t_U [precondition_hash () args]. (let self = args in inv_ref_U self)
      -> precondition_hash () args
  
  type t_DeepModelTy
  
  function hash_log_U (_1: t_DeepModelTy) : int
  
  function deep_model_U (self: t_U) : t_DeepModelTy
  
  function deep_model_ref_U [@inline:trivial] (self: t_U) : t_DeepModelTy = deep_model_U self
  
  meta "rewrite_def" function deep_model_ref_U
  
  predicate postcondition_once_hash (self: ()) (args: t_U) (result: UInt64.t)
  
  axiom postcondition_fndef:
    forall args: t_U, res: UInt64.t [postcondition_once_hash () args res]. postcondition_once_hash () args res
      -> (let self = args in UInt64.t'int res = hash_log_U (deep_model_ref_U self))
  
  let rec hash_U (self: t_U) (return (x: UInt64.t)) = {[@expl:hash requires] precondition_hash () self}
    any [ return (result: UInt64.t) -> {postcondition_once_hash () self result} (! return {result}) ]
  
  predicate inv_V (_1: t_V)
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate precondition_hash'0 (self: ()) (args: t_V)
  
  axiom precondition_fndef'0: forall args: t_V [precondition_hash'0 () args]. (let self = args in inv_ref_V self)
      -> precondition_hash'0 () args
  
  type t_DeepModelTy'0
  
  function hash_log_V (_1: t_DeepModelTy'0) : int
  
  function deep_model_V (self: t_V) : t_DeepModelTy'0
  
  function deep_model_ref_V [@inline:trivial] (self: t_V) : t_DeepModelTy'0 = deep_model_V self
  
  meta "rewrite_def" function deep_model_ref_V
  
  predicate postcondition_once_hash'0 (self: ()) (args: t_V) (result: UInt64.t)
  
  axiom postcondition_fndef'0:
    forall args: t_V, res: UInt64.t [postcondition_once_hash'0 () args res]. postcondition_once_hash'0 () args res
      -> (let self = args in UInt64.t'int res = hash_log_V (deep_model_ref_V self))
  
  let rec hash_V (self: t_V) (return (x: UInt64.t)) = {[@expl:hash requires] precondition_hash'0 () self}
    any [ return (result: UInt64.t) -> {postcondition_once_hash'0 () self result} (! return {result}) ]
  
  let rec wrapping_mul (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.mul self_ rhs} (! return {result}) ]
  
  let rec wrapping_add (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.add self_ rhs} (! return {result}) ]
  
  predicate inv_tup2_U_V [@inline:trivial] (_1: tup2_U_V) = inv_U _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_U_V
  
  predicate invariant_ref_tup2_U_V [@inline:trivial] (self: tup2_U_V) = inv_tup2_U_V self
  
  meta "rewrite_def" predicate invariant_ref_tup2_U_V
  
  predicate inv_ref_tup2_U_V [@inline:trivial] (_1: tup2_U_V) = invariant_ref_tup2_U_V _1
  
  meta "rewrite_def" predicate inv_ref_tup2_U_V
  
  type tup2_DeepModelTy_DeepModelTy = { f0'0: t_DeepModelTy; f1'0: t_DeepModelTy'0 }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log_tup2_U_V (x: tup2_DeepModelTy_DeepModelTy) : int = Int.mod (hash_log_U x.f0'0
    + hash_log_V x.f1'0 * 17) (UInt64.t'int const_MAX + 1)
  
  function deep_model_tup2_U_V [@inline:trivial] (self: tup2_U_V) : tup2_DeepModelTy_DeepModelTy =
    { f0'0 = deep_model_U self.f0; f1'0 = deep_model_V self.f1 }
  
  meta "rewrite_def" function deep_model_tup2_U_V
  
  function deep_model_ref_tup2_U_V [@inline:trivial] (self: tup2_U_V) : tup2_DeepModelTy_DeepModelTy =
    deep_model_tup2_U_V self
  
  meta "rewrite_def" function deep_model_ref_tup2_U_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash_tup2_U_V (self: tup2_U_V) (return (x: UInt64.t)) =
    {[@expl:hash 'self' type invariant] inv_ref_tup2_U_V self}
    (! bb0
    [ bb0 = s0 [ s0 = hash_U {self.f0} (fun (_x: UInt64.t) -> [ &_4 <- _x ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = hash_V {self.f1} (fun (_x: UInt64.t) -> [ &_7 <- _x ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = wrapping_mul {_7} {(17: UInt64.t)} (fun (_x: UInt64.t) -> [ &_6 <- _x ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = wrapping_add {_4} {_6} (fun (_x: UInt64.t) -> [ &_ret <- _x ] s1) | s1 = bb4 ]
    | bb4 = return {_ret} ]
    [ & _ret: UInt64.t = Any.any_l ()
    | & self: tup2_U_V = self
    | & _4: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l ()
    | & _7: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:hash ensures] UInt64.t'int result
      = hash_log_tup2_U_V (deep_model_ref_tup2_U_V self)}
      (! return {result}) ]
end
module M_impl_Eq_for_Node__assert_receiver_is_total_eq (* <Node<'arena> as std::cmp::Eq> *)
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq_Node (self: t_Node) (return (x: ())) = (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_impl_PartialEq_for_Node__eq (* <Node<'arena> as std::cmp::PartialEq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type tup2_ref_Node_ref_Node = { f0'0: t_Node; f1'0: t_Node }
  
  let rec elim_If (_x: t_Node) (return (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ _k (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {If v childt childf = _x} (! return {v} {childt} {childf})
    | _chk -> (! {match _x with
        | If _ _ _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function view_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function view_Bdd
  
  let rec eq_Bdd (self: t_Bdd) (o: t_Bdd) (return (x: bool)) = any
    [ return (result: bool) -> {result = (view_Bdd self = view_Bdd o)} (! return {result}) ]
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function deep_model_ref_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function deep_model_ref_Node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_Node (self: t_Node) (rhs: t_Node) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- { f0'0 = self; f1'0 = rhs } ] s1
      | s1 = any
        [ br0 -> {_6.f0'0 = False'} (! bb2)
        | br1 -> {_6.f0'0 = True'} (! bb4)
        | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_6.f0'0 = If x0 x1 x2} (! bb6) ] ]
    | bb6 = any
      [ br0 -> {_6.f1'0 = False'} (! bb1)
      | br1 -> {_6.f1'0 = True'} (! bb1)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_6.f1'0 = If x0 x1 x2} (! bb8) ]
    | bb8 = s0
      [ s0 = elim_If {_6.f0'0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v_1 <- rv ] s1)
      | s1 = elim_If {_6.f0'0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt_1 <- rchildt ] s2)
      | s2 = elim_If {_6.f0'0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf_1 <- rchildf ] s3)
      | s3 = elim_If {_6.f1'0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v_2 <- rv ] s4)
      | s4 = elim_If {_6.f1'0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt_2 <- rchildt ] s5)
      | s5 = elim_If {_6.f1'0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf_2 <- rchildf ] s6)
      | s6 = eq_Bdd {childf_1} {childf_2} (fun (_x: bool) -> [ &_19 <- _x ] s7)
      | s7 = bb11 ]
    | bb11 = any [ br0 -> {_19 = false} (! bb19) | br1 -> {_19} (! bb12) ]
    | bb12 = s0 [ s0 = eq_Bdd {childt_1} {childt_2} (fun (_x: bool) -> [ &_22 <- _x ] s1) | s1 = bb13 ]
    | bb13 = any [ br0 -> {_22 = false} (! bb19) | br1 -> {_22} (! bb14) ]
    | bb14 = s0 [ s0 = [ &_25 <- v_1 = v_2 ] s1 | s1 = any [ br0 -> {_25 = false} (! bb19) | br1 -> {_25} (! bb15) ] ]
    | bb15 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = bb21 ]
    | bb19 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = bb21 ]
    | bb4 = any
      [ br0 -> {_6.f1'0 = False'} (! bb1)
      | br1 -> {_6.f1'0 = True'} (! bb9)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_6.f1'0 = If x0 x1 x2} (! bb1) ]
    | bb9 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = bb21 ]
    | bb2 = any
      [ br0 -> {_6.f1'0 = False'} (! bb10)
      | br1 -> {_6.f1'0 = True'} (! bb1)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_6.f1'0 = If x0 x1 x2} (! bb1) ]
    | bb1 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = bb21 ]
    | bb10 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = bb21 ]
    | bb21 = return {_ret} ]
    [ & _ret: bool = Any.any_l ()
    | & self: t_Node = self
    | & rhs: t_Node = rhs
    | & _6: tup2_ref_Node_ref_Node = Any.any_l ()
    | & v_1: UInt64.t = Any.any_l ()
    | & childt_1: t_Bdd = Any.any_l ()
    | & childf_1: t_Bdd = Any.any_l ()
    | & v_2: UInt64.t = Any.any_l ()
    | & childt_2: t_Bdd = Any.any_l ()
    | & childf_2: t_Bdd = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _25: bool = Any.any_l () ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (deep_model_ref_Node self = deep_model_ref_Node rhs)}
      (! return {result}) ]
end
module M_impl_Clone_for_Node__clone (* <Node<'arena> as std::clone::Clone> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  let rec elim_If (_x: t_Node) (return (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ _k (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {If v childt childf = _x} (! return {v} {childt} {childf})
    | _chk -> (! {match _x with
        | If _ _ _ -> true
        | _ -> false
        end}
      any) ]
  
  let rec clone_u64 (self_: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = self_} (! return {result}) ]
  
  let rec clone_Bdd (self: t_Bdd) (return (x: t_Bdd)) = any
    [ return (result: t_Bdd) -> {result = self} (! return {result}) ]
  
  type tup2_Node_Node = { f0'0: t_Node; f1'0: t_Node }
  
  predicate postcondition_once_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once_clone
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut_clone
  
  function fn_mut_once_clone (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_clone
  
  function fn_once_clone (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate postcondition_once_clone'0 [@inline:trivial] (self: ()) (args: t_Bdd) (result: t_Bdd) =
    let self'0 = args in result = self'0
  
  meta "rewrite_def" predicate postcondition_once_clone'0
  
  predicate resolve_clone'0 [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone'0
  
  predicate postcondition_mut_clone'0 [@inline:trivial] (self: ()) (args: t_Bdd) (result_state: ()) (result: t_Bdd) =
    let self'0 = args in result = self'0
  
  meta "rewrite_def" predicate postcondition_mut_clone'0
  
  function fn_mut_once_clone'0 (self: ()) (args: t_Bdd) (res: t_Bdd) : ()
  
  axiom fn_mut_once_clone_spec'0: forall self: (), args: t_Bdd, res: t_Bdd. postcondition_once_clone'0 self args res
      = (exists res_state: (). postcondition_mut_clone'0 self args res_state res /\ resolve_clone'0 res_state)
  
  predicate hist_inv_clone'0 [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone'0
  
  function hist_inv_trans_clone'0 (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec'0: forall self: (), b: (), c: (). hist_inv_clone'0 self b
      -> hist_inv_clone'0 b c -> hist_inv_clone'0 self c
  
  function hist_inv_refl_clone'0 (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec'0: forall self: (). hist_inv_clone'0 self self
  
  function postcondition_mut_hist_inv_clone'0 (self: ()) (args: t_Bdd) (res_state: ()) (res: t_Bdd) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec'0:
    forall self: (), args: t_Bdd, res_state: (), res: t_Bdd. postcondition_mut_clone'0 self args res_state res
      -> hist_inv_clone'0 self res_state
  
  function fn_hist_inv_clone'0 (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec'0: forall self: (), res_state: (). hist_inv_clone'0 self res_state = (self = res_state)
  
  predicate postcondition_clone'0 [@inline:trivial] (self: ()) (args: t_Bdd) (result: t_Bdd) =
    let self'0 = args in result = self'0
  
  meta "rewrite_def" predicate postcondition_clone'0
  
  function fn_once_clone'0 (self: ()) (args: t_Bdd) (res: t_Bdd) : ()
  
  axiom fn_once_clone_spec'0: forall self: (), args: t_Bdd, res: t_Bdd. postcondition_once_clone'0 self args res
      = (postcondition_clone'0 self args res /\ resolve_clone'0 self)
  
  function fn_mut_clone'0 (self: ()) (args: t_Bdd) (res_state: ()) (res: t_Bdd) : ()
  
  axiom fn_mut_clone_spec'0:
    forall self: (), args: t_Bdd, res_state: (), res: t_Bdd. postcondition_mut_clone'0 self args res_state res
      = (postcondition_clone'0 self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Node (self: t_Node) (return (x: t_Node)) = (! bb0
    [ bb0 = any
      [ br0 -> {self = False'} (! bb6)
      | br1 -> {self = True'} (! bb5)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {self = If x0 x1 x2} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v_1 <- rv ] s1)
      | s1 = elim_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt_1 <- rchildt ] s2)
      | s2 = elim_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf_1 <- rchildf ] s3)
      | s3 = [ &_10 <- v_1 ] s4
      | s4 = clone_u64 {_10} (fun (_x: UInt64.t) -> [ &_8 <- _x ] s5)
      | s5 = bb7 ]
    | bb7 = s0 [ s0 = [ &_13 <- childt_1 ] s1 | s1 = clone_Bdd {_13} (fun (_x: t_Bdd) -> [ &_11 <- _x ] s2) | s2 = bb8 ]
    | bb8 = s0 [ s0 = [ &_16 <- childf_1 ] s1 | s1 = clone_Bdd {_16} (fun (_x: t_Bdd) -> [ &_14 <- _x ] s2) | s2 = bb9 ]
    | bb9 = s0 [ s0 = [ &_ret <- If _8 _11 _14 ] s1 | s1 = bb10 ]
    | bb5 = s0 [ s0 = [ &_ret <- True' ] s1 | s1 = bb10 ]
    | bb6 = s0 [ s0 = [ &_ret <- False' ] s1 | s1 = bb10 ]
    | bb10 = return {_ret} ]
    [ & _ret: t_Node = Any.any_l ()
    | & self: t_Node = self
    | & v_1: UInt64.t = Any.any_l ()
    | & childt_1: t_Bdd = Any.any_l ()
    | & childf_1: t_Bdd = Any.any_l ()
    | & _8: UInt64.t = Any.any_l ()
    | & _10: UInt64.t = Any.any_l ()
    | & _11: t_Bdd = Any.any_l ()
    | & _13: t_Bdd = Any.any_l ()
    | & _14: t_Bdd = Any.any_l ()
    | & _16: t_Bdd = Any.any_l () ])
    [ return (result: t_Node) -> {[@expl:clone ensures] match { f0'0 = self; f1'0 = result } with
        | {f0'0 = False'; f1'0 = False'} -> true
        | {f0'0 = True'; f1'0 = True'} -> true
        | {f0'0 = If v_1 childt_1 childf_1; f1'0 = If v_r childt_r childf_r} -> postcondition_clone () v_1 v_r
        /\ postcondition_clone'0 () childt_1 childt_r /\ postcondition_clone'0 () childf_1 childf_r
        | _ -> false
        end}
      (! return {result}) ]
end
module M_impl_Eq_for_Bdd__assert_receiver_is_total_eq (* <Bdd<'arena> as std::cmp::Eq> *)
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq_Bdd (self: t_Bdd) (return (x: ())) = (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_impl_Clone_for_Bdd__clone (* <Bdd<'arena> as std::clone::Clone> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Bdd (self: t_Bdd) (return (x: t_Bdd)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Bdd = Any.any_l () | & self: t_Bdd = self ])
    [ return (result: t_Bdd) -> {[@expl:clone ensures] result = self} (! return {result}) ]
end
module M_impl_Hash_for_Node__hash (* <Node<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  let rec elim_If (_x: t_Node) (return (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ _k (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {If v childt childf = _x} (! return {v} {childt} {childf})
    | _chk -> (! {match _x with
        | If _ _ _ -> true
        | _ -> false
        end}
      any) ]
  
  let rec wrapping_mul (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.mul self_ rhs} (! return {result}) ]
  
  let rec wrapping_add (self_: UInt64.t) (rhs: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = UInt64.add self_ rhs} (! return {result}) ]
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log_Node (x: t_NodeLog) : int = match x with
      | False''0 -> 1
      | True''0 -> 2
      | If'0 v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int const_MAX + 1)
      end
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash_Node (self: t_Node) (return (x: UInt64.t)) = (! bb0
    [ bb0 = any
      [ br0 -> {self = False'} (! bb6)
      | br1 -> {self = True'} (! bb5)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {self = If x0 x1 x2} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v <- rv ] s1)
      | s1 = elim_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt <- rchildt ] s2)
      | s2 = elim_If {self} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf <- rchildf ] s3)
      | s3 = wrapping_mul {childt.f1} {(5: UInt64.t)} (fun (_x: UInt64.t) -> [ &_10 <- _x ] s4)
      | s4 = bb7 ]
    | bb7 = s0 [ s0 = wrapping_add {v} {_10} (fun (_x: UInt64.t) -> [ &_8 <- _x ] s1) | s1 = bb8 ]
    | bb8 = s0 [ s0 = wrapping_mul {childf.f1} {(7: UInt64.t)} (fun (_x: UInt64.t) -> [ &_12 <- _x ] s1) | s1 = bb9 ]
    | bb9 = s0 [ s0 = wrapping_add {_8} {_12} (fun (_x: UInt64.t) -> [ &_ret <- _x ] s1) | s1 = bb11 ]
    | bb5 = s0 [ s0 = [ &_ret <- (2: UInt64.t) ] s1 | s1 = bb11 ]
    | bb6 = s0 [ s0 = [ &_ret <- (1: UInt64.t) ] s1 | s1 = bb11 ]
    | bb11 = return {_ret} ]
    [ & _ret: UInt64.t = Any.any_l ()
    | & self: t_Node = self
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & _8: UInt64.t = Any.any_l ()
    | & _10: UInt64.t = Any.any_l ()
    | & _12: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:hash ensures] UInt64.t'int result = hash_log_Node (view_Node self)}
      (! return {result}) ]
end
module M_impl_Hash_for_Bdd__hash (* <Bdd<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  function hash_log_Bdd [@inline:trivial] (x: UInt64.t) : int = UInt64.t'int x
  
  meta "rewrite_def" function hash_log_Bdd
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function view_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function view_Bdd
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hash_Bdd (self: t_Bdd) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self.f1 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt64.t = Any.any_l () | & self: t_Bdd = self ])
    [ return (result: UInt64.t) -> {[@expl:hash ensures] UInt64.t'int result = hash_log_Bdd (view_Bdd self)}
      (! return {result}) ]
end
module M_impl_PartialEq_for_Bdd__eq (* <Bdd<'arena> as std::cmp::PartialEq> *)
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function view_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function view_Bdd
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_Bdd (self: t_Bdd) (o: t_Bdd) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self.f1 = o.f1 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self: t_Bdd = self | & o: t_Bdd = o ])
    [ return (result: bool) -> {[@expl:eq ensures] result = (view_Bdd self = view_Bdd o)} (! return {result}) ]
end
module M_impl_Bdd__size (* Bdd<'arena> *)
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Bdd
  
  function size (self: t_Bdd) : int
  
  goal vc_size: match self with
      | {f0 = True'; f1 = _} -> [@expl:size ensures] 0 >= 0
      | {f0 = False'; f1 = _} -> [@expl:size ensures] 0 >= 0
      | {f0 = If _ childt childf; f1 = _} -> size childt >= 0
      -> (let ht = size childt in size childf >= 0 -> (let hf = size childf in [@expl:size ensures] 1 + ht + hf >= 0))
      end
end
module M_impl_Context__grows_is_valid_bdd (* Context<'arena> *)
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some b
        | None -> true
        end)
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_Context
  
  constant b : t_Bdd
  
  function grows_is_valid_bdd (self: MutBorrow.t t_Context) (b: t_Bdd) : ()
  
  goal vc_grows_is_valid_bdd: grows self
    -> is_valid_bdd self.current b -> ([@expl:grows_is_valid_bdd ensures] is_valid_bdd self.final b)
end
module M_impl_Context__grows_trans (* Context<'arena> *)
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use map.Map
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some b
        | None -> true
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_Context
  
  constant o : MutBorrow.t t_Context
  
  constant oo : MutBorrow.t t_Context
  
  function grows_trans (self: MutBorrow.t t_Context) (o: MutBorrow.t t_Context) (oo: MutBorrow.t t_Context) : ()
  
  goal vc_grows_trans: grows self
    -> grows o
    -> self.final = o.current
    -> self.current = oo.current /\ self.final = oo.final -> ([@expl:grows_trans ensures] grows oo)
end
module M_impl_Context__set_irrelevent_var (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                              f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                           f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Context
  
  constant a : t_Bdd
  
  constant x : UInt64.t
  
  constant v : Map.map UInt64.t bool
  
  constant b : bool
  
  function set_irrelevent_var (self: t_Context) (a: t_Bdd) (x: UInt64.t) (v: Map.map UInt64.t bool) (b: bool) : ()
  
  goal vc_set_irrelevent_var: inv_Context self
    -> is_valid_bdd self a
    -> UInt64.t'int x < leastvar a
    -> match a with
      | {f0 = If _ childt childf; f1 = _} -> (([@expl:set_irrelevent_var requires #0] inv_Context self)
        && ([@expl:set_irrelevent_var requires #1] is_valid_bdd self childt)
        && ([@expl:set_irrelevent_var requires #2] UInt64.t'int x < leastvar childt))
      /\ (interp childt v = interp childt (Map.set v x b)
      -> (let _ = set_irrelevent_var self childt x v b in (([@expl:set_irrelevent_var requires #0] inv_Context self)
        && ([@expl:set_irrelevent_var requires #1] is_valid_bdd self childf)
        && ([@expl:set_irrelevent_var requires #2] UInt64.t'int x < leastvar childf))
      /\ (interp childf v = interp childf (Map.set v x b)
      -> (let _ = set_irrelevent_var self childf x v b in [@expl:set_irrelevent_var ensures] interp a v
      = interp a (Map.set v x b)))))
      | _ -> [@expl:set_irrelevent_var ensures] interp a v = interp a (Map.set v x b)
      end
end
module M_impl_Context__discr_valuation (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  function size (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> 0
      | {f0 = False'; f1 = _} -> 0
      | {f0 = If _ childt childf; f1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                              f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                           f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  function set_irrelevent_var (self: t_Context) (a: t_Bdd) (x: UInt64.t) (v: Map.map UInt64.t bool) (b: bool) : () =
    match a with
      | {f0 = If _ childt childf; f1 = _} -> let _ = set_irrelevent_var self childt x v b in let _ = set_irrelevent_var self childf x v b in ()
      | _ -> ()
      end
  
  axiom set_irrelevent_var_spec:
    forall self: t_Context, a: t_Bdd, x: UInt64.t, v: Map.map UInt64.t bool, b: bool. inv_Context self
      -> is_valid_bdd self a -> UInt64.t'int x < leastvar a -> interp a v = interp a (Map.set v x b)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Context
  
  constant a : t_Bdd
  
  constant b : t_Bdd
  
  function discr_valuation (self: t_Context) (a: t_Bdd) (b: t_Bdd) : Map.map UInt64.t bool
  
  goal vc_discr_valuation: inv_Context self
    -> is_valid_bdd self a
    -> is_valid_bdd self b
    -> a <> b
    -> (if leastvar a < leastvar b then
      match a with
        | {f0 = If v childt childf; f1 = _} -> if childf <> b then
          ((([@expl:discr_valuation requires #0] inv_Context self)
              && ([@expl:discr_valuation requires #1] is_valid_bdd self childf)
              && ([@expl:discr_valuation requires #2] is_valid_bdd self b)
              && ([@expl:discr_valuation requires #3] childf <> b))
            /\ well_founded_relation_Int (size a + size b) (size childf + size b))
          /\ (interp childf (discr_valuation self childf b) <> interp b (discr_valuation self childf b)
          -> (let result = Map.set (discr_valuation self childf b) v false in [@expl:discr_valuation ensures] interp a result
          <> interp b result))
        else
          ((([@expl:discr_valuation requires #0] inv_Context self)
              && ([@expl:discr_valuation requires #1] is_valid_bdd self childt)
              && ([@expl:discr_valuation requires #2] is_valid_bdd self b)
              && ([@expl:discr_valuation requires #3] childt <> b))
            /\ well_founded_relation_Int (size a + size b) (size childt + size b))
          /\ (interp childt (discr_valuation self childt b) <> interp b (discr_valuation self childt b)
          -> (let result = Map.set (discr_valuation self childt b) v true in [@expl:discr_valuation ensures] interp a result
          <> interp b result))
        
        | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
        end
    else
      if leastvar a > leastvar b then
        match b with
          | {f0 = If v childt childf; f1 = _} -> if childf <> a then
            ((([@expl:discr_valuation requires #0] inv_Context self)
                && ([@expl:discr_valuation requires #1] is_valid_bdd self a)
                && ([@expl:discr_valuation requires #2] is_valid_bdd self childf)
                && ([@expl:discr_valuation requires #3] a <> childf))
              /\ well_founded_relation_Int (size a + size b) (size a + size childf))
            /\ (interp a (discr_valuation self a childf) <> interp childf (discr_valuation self a childf)
            -> (let result = Map.set (discr_valuation self a childf) v false in [@expl:discr_valuation ensures] interp a result
            <> interp b result))
          else
            ((([@expl:discr_valuation requires #0] inv_Context self)
                && ([@expl:discr_valuation requires #1] is_valid_bdd self a)
                && ([@expl:discr_valuation requires #2] is_valid_bdd self childt)
                && ([@expl:discr_valuation requires #3] a <> childt))
              /\ well_founded_relation_Int (size a + size b) (size a + size childt))
            /\ (interp a (discr_valuation self a childt) <> interp childt (discr_valuation self a childt)
            -> (let result = Map.set (discr_valuation self a childt) v true in [@expl:discr_valuation ensures] interp a result
            <> interp b result))
          
          | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
          end
      else
        match a with
          | {f0 = If v childta childfa; f1 = _} -> match b with
            | {f0 = If _ childtb childfb; f1 = _} -> if childfa <> childfb then
              ((([@expl:discr_valuation requires #0] inv_Context self)
                  && ([@expl:discr_valuation requires #1] is_valid_bdd self childfa)
                  && ([@expl:discr_valuation requires #2] is_valid_bdd self childfb)
                  && ([@expl:discr_valuation requires #3] childfa <> childfb))
                /\ well_founded_relation_Int (size a + size b) (size childfa + size childfb))
              /\ (interp childfa (discr_valuation self childfa childfb)
                <> interp childfb (discr_valuation self childfa childfb)
              -> (let result = Map.set (discr_valuation self childfa childfb) v false in [@expl:discr_valuation ensures] interp a result
              <> interp b result))
            else
              ((([@expl:discr_valuation requires #0] inv_Context self)
                  && ([@expl:discr_valuation requires #1] is_valid_bdd self childta)
                  && ([@expl:discr_valuation requires #2] is_valid_bdd self childtb)
                  && ([@expl:discr_valuation requires #3] childta <> childtb))
                /\ well_founded_relation_Int (size a + size b) (size childta + size childtb))
              /\ (interp childta (discr_valuation self childta childtb)
                <> interp childtb (discr_valuation self childta childtb)
              -> (let result = Map.set (discr_valuation self childta childtb) v true in [@expl:discr_valuation ensures] interp a result
              <> interp b result))
            
            | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
            end
          | _ -> let result = Const.const true in [@expl:discr_valuation ensures] interp a result <> interp b result
          end
    
    )
end
module M_impl_Context__bdd_canonical (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use map.Const
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                              f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                           f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  function size (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> 0
      | {f0 = False'; f1 = _} -> 0
      | {f0 = If _ childt childf; f1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  function discr_valuation (self: t_Context) (a: t_Bdd) (b: t_Bdd) : Map.map UInt64.t bool
  
  axiom discr_valuation_def: forall self: t_Context, a: t_Bdd, b: t_Bdd. inv_Context self
      -> is_valid_bdd self a
      -> is_valid_bdd self b
      -> a <> b
      -> discr_valuation self a b
      = (if leastvar a < leastvar b then
        match a with
          | {f0 = If v childt childf; f1 = _} -> if childf <> b then
            Map.set (discr_valuation self childf b) v false
          else
            Map.set (discr_valuation self childt b) v true
          
          | _ -> Const.const true
          end
      else
        if leastvar a > leastvar b then
          match b with
            | {f0 = If v childt childf; f1 = _} -> if childf <> a then
              Map.set (discr_valuation self a childf) v false
            else
              Map.set (discr_valuation self a childt) v true
            
            | _ -> Const.const true
            end
        else
          match a with
            | {f0 = If v childta childfa; f1 = _} -> match b with
              | {f0 = If _ childtb childfb; f1 = _} -> if childfa <> childfb then
                Map.set (discr_valuation self childfa childfb) v false
              else
                Map.set (discr_valuation self childta childtb) v true
              
              | _ -> Const.const true
              end
            | _ -> Const.const true
            end
      
      )
  
  axiom discr_valuation_spec: forall self: t_Context, a: t_Bdd, b: t_Bdd. inv_Context self
      -> is_valid_bdd self a
      -> is_valid_bdd self b -> a <> b -> interp a (discr_valuation self a b) <> interp b (discr_valuation self a b)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Context
  
  constant a : t_Bdd
  
  constant b : t_Bdd
  
  function bdd_canonical (self: t_Context) (a: t_Bdd) (b: t_Bdd) : ()
  
  goal vc_bdd_canonical: inv_Context self
    -> is_valid_bdd self a
    -> is_valid_bdd self b
    -> (forall v: Map.map UInt64.t bool. interp a v = interp b v) -> ([@expl:bdd_canonical ensures] a = b)
end
module M_impl_Context_0__new (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use map.Const
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_MyHashMap_Node_Bdd
  
  type t_NodeLog = False' | True' | If UInt64.t UInt64.t UInt64.t
  
  type t_Node = False''0 | True''0 | If'0 UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  type t_Option_Bdd = None | Some t_Bdd
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  let rec new_Node (return (x: t_MyHashMap_Node_Bdd)) = any
    [ return (result: t_MyHashMap_Node_Bdd) -> {view_MyHashMap_Node_Bdd result = Const.const (None)}
      (! return {result}) ]
  
  type t_MyHashMap_Bdd_Bdd
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  let rec new_Bdd (return (x: t_MyHashMap_Bdd_Bdd)) = any
    [ return (result: t_MyHashMap_Bdd_Bdd) -> {view_MyHashMap_Bdd_Bdd result = Const.const (None)} (! return {result}) ]
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type tup2_u64_u64 = { f0'0: UInt64.t; f1'0: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  let rec new_tup2_Bdd_Bdd (return (x: t_MyHashMap_tup2_Bdd_Bdd_Bdd)) = any
    [ return (result: t_MyHashMap_tup2_Bdd_Bdd_Bdd) -> {view_MyHashMap_tup2_Bdd_Bdd_Bdd result = Const.const (None)}
      (! return {result}) ]
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  let rec new (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {result.f0'1 = (0: UInt64.t)} (! return {result}) ]
  
  type t_Bump
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False''0 -> False'
      | True''0 -> True'
      | If'0 v childt childf -> If v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True''0; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False''0; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If'0 v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True''0 -> true
      | False''0 -> true
      | If'0 v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'1
  
  meta "rewrite_def" function view_PeanoInt
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True''0; f1 = _} -> true
      | {f0 = False''0; f1 = _} -> false
      | {f0 = If'0 v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'0;
                              f1 = abm.f0'0 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'0;
                                                           f1 = abm.f1'0 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new'0 (alloc'0: t_Bump) (return (x: t_Context)) = (! bb0
    [ bb0 = s0 [ s0 = new_Node (fun (_x: t_MyHashMap_Node_Bdd) -> [ &_3 <- _x ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_4 <- Const.const (True''0) ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = new_Bdd (fun (_x: t_MyHashMap_Bdd_Bdd) -> [ &_6 <- _x ] s1) | s1 = bb3 ]
    | bb3 = s0 [ s0 = new_tup2_Bdd_Bdd (fun (_x: t_MyHashMap_tup2_Bdd_Bdd_Bdd) -> [ &_7 <- _x ] s1) | s1 = bb4 ]
    | bb4 = s0 [ s0 = new (fun (_x: t_PeanoInt) -> [ &_8 <- _x ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_ret <- { alloc = alloc'0;
                          hashcons = _3;
                          hashcons_ghost = _4;
                          not_memo = _6;
                          and_memo = _7;
                          cnt = _8 } ] s1
      | s1 = return {_ret} ] ]
    [ & _ret: t_Context = Any.any_l ()
    | & alloc'0: t_Bump = alloc'0
    | & _3: t_MyHashMap_Node_Bdd = Any.any_l ()
    | & _4: Map.map UInt64.t t_Node = Any.any_l ()
    | & _6: t_MyHashMap_Bdd_Bdd = Any.any_l ()
    | & _7: t_MyHashMap_tup2_Bdd_Bdd_Bdd = Any.any_l ()
    | & _8: t_PeanoInt = Any.any_l () ])
    [ return (result: t_Context) -> {[@expl:new result type invariant] inv_Context result} (! return {result}) ]
end
module M_impl_Context_0__hashcons (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_MyHashMap_Node_Bdd
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_Bump
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_ref_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  type t_Option_Bdd = None'0 | Some'0 t_Bdd
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function deep_model_ref_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function deep_model_ref_Node
  
  let rec get_Node (self: t_MyHashMap_Node_Bdd) (key: t_Node) (return (x: t_Option_ref_Bdd)) = any
    [ return (result: t_Option_ref_Bdd) -> {match result with
        | Some v -> Map.get (view_MyHashMap_Node_Bdd self) (deep_model_ref_Node key) = Some'0 v
        | None -> Map.get (view_MyHashMap_Node_Bdd self) (deep_model_ref_Node key) = None'0
        end}
      (! return {result}) ]
  
  let rec alloc_Node (self: t_Bump) (val': t_Node) (return (x: MutBorrow.t t_Node)) = any
    [ return (result: MutBorrow.t t_Node) -> {result.current = val'} (! return {result}) ]
  
  predicate resolve_ref_Node [@inline:trivial] (_1: MutBorrow.t t_Node) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Node
  
  let rec add_Node (self: MutBorrow.t t_MyHashMap_Node_Bdd) (key: t_Node) (val': t_Bdd) (return (x: ())) = any
    [ return (result: ()) -> {forall i: t_NodeLog. Map.get (view_MyHashMap_Node_Bdd self.final) i
        = (if i = deep_model_Node key then Some'0 val' else Map.get (view_MyHashMap_Node_Bdd self.current) i)}
      (! return {result}) ]
  
  let rec incr (self: t_PeanoInt) (return (x: t_PeanoInt)) = any
    [ return (result: t_PeanoInt) -> {UInt64.t'int result.f0'0 = UInt64.t'int self.f0'0 + 1} (! return {result}) ]
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some'0 b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some'0 b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None'0 -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None'0 -> true
          | Some'0 n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None'0 -> true
        | Some'0 n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                                f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                             f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  predicate invariant_ref_Context [@inline:trivial] (self: MutBorrow.t t_Context) =
    inv_Context self.current /\ inv_Context self.final
  
  meta "rewrite_def" predicate invariant_ref_Context
  
  predicate inv_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = invariant_ref_Context _1
  
  meta "rewrite_def" predicate inv_ref_Context
  
  predicate resolve_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Context
  
  let rec elim_Some (_x: t_Option_ref_Bdd) (return (f0'2: t_Bdd)) = any
    [ _k (f0'2: t_Bdd) -> {Some f0'2 = _x} (! return {f0'2})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some'0 b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some'0 b
        | None'0 -> true
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec hashcons'0 (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv_ref_Context self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_16 <- n ] s1
      | s1 = get_Node {self.current.hashcons} {_16} (fun (_x: t_Option_ref_Bdd) -> [ &_13 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = any [ br0 -> {_13 = None} (! bb4) | br1 (x0: t_Bdd) -> {_13 = Some x0} (! bb2) ]
    | bb4 = s0
      [ s0 = alloc_Node {self.current.alloc} {n} (fun (_x: MutBorrow.t t_Node) -> [ &_26 <- _x ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = -{resolve_ref_Node _26}- s1
      | s1 = [ &r'0 <- { f0 = _26.current; f1 = self.current.cnt.f0'0 } ] s2
      | s2 = MutBorrow.borrow_final <t_MyHashMap_Node_Bdd> {self.current.hashcons}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 2}
          (fun (_bor: MutBorrow.t t_MyHashMap_Node_Bdd) ->
            [ &_31 <- _bor ] [ &self <- { self with current = { self.current with hashcons = _bor.final } } ] s3)
      | s3 = add_Node {_31} {n} {r'0} (fun (_x: ()) -> [ &_30 <- _x ] s4)
      | s4 = bb6 ]
    | bb6 = s0 [ s0 = [ &_34 <- Map.set self.current.hashcons_ghost r'0.f1 r'0.f0 ] s1 | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &self <- { self with current = { self.current with hashcons_ghost = _34 } } ] s1
      | s1 = incr {self.current.cnt} (fun (_x: t_PeanoInt) -> [ &_39 <- _x ] s2)
      | s2 = bb8 ]
    | bb8 = s0
      [ s0 = [ &self <- { self with current = { self.current with cnt = _39 } } ] s1
      | s1 = {[@expl:type invariant] inv_ref_Context self} s2
      | s2 = -{resolve_ref_Context self}- s3
      | s3 = [ &_ret <- r'0 ] s4
      | s4 = bb9 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1 | s1 = -{resolve_ref_Context self}- s2 | s2 = bb3 ]
    | bb3 = s0
      [ s0 = elim_Some {_13} (fun (r0: t_Bdd) -> [ &r <- r0 ] s1)
      | s1 = {[@expl:assertion] view_Node r.f0 = view_Node n} s2
      | s2 = [ &_ret <- r ] s3
      | s3 = bb9 ]
    | bb9 = return {_ret} ]
    [ & _ret: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & n: t_Node = n
    | & _13: t_Option_ref_Bdd = Any.any_l ()
    | & _16: t_Node = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _26: MutBorrow.t t_Node = Any.any_l ()
    | & _30: () = Any.any_l ()
    | & _31: MutBorrow.t t_MyHashMap_Node_Bdd = Any.any_l ()
    | & _34: Map.map UInt64.t t_Node = Any.any_l ()
    | & _39: t_PeanoInt = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:hashcons ensures #0] result.f0 = n}
      {[@expl:hashcons ensures #1] grows self}
      {[@expl:hashcons ensures #2] is_valid_bdd self.final result}
      (! return {result}) ]
end
module M_impl_Context_0__node (* Context<'arena> *)
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function view_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function view_Bdd
  
  let rec eq_Bdd (self: t_Bdd) (o: t_Bdd) (return (x: bool)) = any
    [ return (result: bool) -> {result = (view_Bdd self = view_Bdd o)} (! return {result}) ]
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                              f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                           f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  predicate invariant_ref_Context [@inline:trivial] (self: MutBorrow.t t_Context) =
    inv_Context self.current /\ inv_Context self.final
  
  meta "rewrite_def" predicate invariant_ref_Context
  
  predicate inv_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = invariant_ref_Context _1
  
  meta "rewrite_def" predicate inv_ref_Context
  
  predicate resolve_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Context
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some b
        | None -> true
        end)
  
  let rec hashcons'0 (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv_ref_Context self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    any [ return (result: t_Bdd) -> {result.f0 = n} {grows self} {is_valid_bdd self.final result} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv_ref_Context self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    (! bb0
    [ bb0 = s0 [ s0 = eq_Bdd {childt} {childf} (fun (_x: bool) -> [ &_26 <- _x ] s1) | s1 = bb1 ]
    | bb1 = any [ br0 -> {_26 = false} (! bb3) | br1 -> {_26} (! bb2) ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1
      | s1 = -{resolve_ref_Context self}- s2
      | s2 = [ &_ret <- childt ] s3
      | s3 = bb5 ]
    | bb3 = s0
      [ s0 = [ &_31 <- If x childt childf ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_30 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = hashcons'0 {_30} {_31} (fun (_x: t_Bdd) -> [ &_ret <- _x ] s3)
      | s3 = bb4 ]
    | bb4 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1 | s1 = -{resolve_ref_Context self}- s2 | s2 = bb5 ]
    | bb5 = return {_ret} ]
    [ & _ret: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & x: UInt64.t = x
    | & childt: t_Bdd = childt
    | & childf: t_Bdd = childf
    | & _26: bool = Any.any_l ()
    | & _30: MutBorrow.t t_Context = Any.any_l ()
    | & _31: t_Node = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:node ensures #0] grows self}
      {[@expl:node ensures #1] is_valid_bdd self.final result}
      {[@expl:node ensures #2] forall v: Map.map UInt64.t bool. interp result v
        = (if Map.get v x then interp childt v else interp childf v)}
      {[@expl:node ensures #3] UInt64.t'int x <= leastvar result}
      (! return {result}) ]
end
module M_impl_Context_0__true (* Context<'arena> *)
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                              f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                           f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  predicate invariant_ref_Context [@inline:trivial] (self: MutBorrow.t t_Context) =
    inv_Context self.current /\ inv_Context self.final
  
  meta "rewrite_def" predicate invariant_ref_Context
  
  predicate inv_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = invariant_ref_Context _1
  
  meta "rewrite_def" predicate inv_ref_Context
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some b
        | None -> true
        end)
  
  let rec hashcons'0 (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv_ref_Context self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    any [ return (result: t_Bdd) -> {result.f0 = n} {grows self} {is_valid_bdd self.final result} (! return {result}) ]
  
  predicate resolve_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Context
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec true_ (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:true_ 'self' type invariant] inv_ref_Context self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_9 <- True' ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_8 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = hashcons'0 {_8} {_9} (fun (_x: t_Bdd) -> [ &_ret <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1
      | s1 = -{resolve_ref_Context self}- s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & _8: MutBorrow.t t_Context = Any.any_l ()
    | & _9: t_Node = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:true_ ensures #0] grows self}
      {[@expl:true_ ensures #1] is_valid_bdd self.final result}
      {[@expl:true_ ensures #2] forall v: Map.map UInt64.t bool. interp result v}
      {[@expl:true_ ensures #3] UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
end
module M_impl_Context_0__false (* Context<'arena> *)
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                              f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                           f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  predicate invariant_ref_Context [@inline:trivial] (self: MutBorrow.t t_Context) =
    inv_Context self.current /\ inv_Context self.final
  
  meta "rewrite_def" predicate invariant_ref_Context
  
  predicate inv_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = invariant_ref_Context _1
  
  meta "rewrite_def" predicate inv_ref_Context
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some b
        | None -> true
        end)
  
  let rec hashcons'0 (self: MutBorrow.t t_Context) (n: t_Node) (return (x: t_Bdd)) =
    {[@expl:hashcons 'self' type invariant] inv_ref_Context self}
    {[@expl:hashcons requires] is_valid_node self.current n}
    any [ return (result: t_Bdd) -> {result.f0 = n} {grows self} {is_valid_bdd self.final result} (! return {result}) ]
  
  predicate resolve_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Context
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec false_ (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv_ref_Context self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_9 <- False' ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_8 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = hashcons'0 {_8} {_9} (fun (_x: t_Bdd) -> [ &_ret <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1
      | s1 = -{resolve_ref_Context self}- s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & _8: MutBorrow.t t_Context = Any.any_l ()
    | & _9: t_Node = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:false_ ensures #0] grows self}
      {[@expl:false_ ensures #1] is_valid_bdd self.final result}
      {[@expl:false_ ensures #2] forall v: Map.map UInt64.t bool. not interp result v}
      {[@expl:false_ ensures #3] UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
end
module M_impl_Context_0__v (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_Bdd = None | Some t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None -> true
          | Some n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None -> true
        | Some n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                              f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                           f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  predicate invariant_ref_Context [@inline:trivial] (self: MutBorrow.t t_Context) =
    inv_Context self.current /\ inv_Context self.final
  
  meta "rewrite_def" predicate invariant_ref_Context
  
  predicate inv_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = invariant_ref_Context _1
  
  meta "rewrite_def" predicate inv_ref_Context
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some b
        | None -> true
        end)
  
  let rec true_ (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:true_ 'self' type invariant] inv_ref_Context self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec false_ (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv_ref_Context self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. not interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv_ref_Context self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v = (if Map.get v x then interp childt v else interp childf v)}
      {UInt64.t'int x <= leastvar result}
      (! return {result}) ]
  
  predicate resolve_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Context
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec v (self: MutBorrow.t t_Context) (x: UInt64.t) (return (x'0: t_Bdd)) =
    {[@expl:v 'self' type invariant] inv_ref_Context self}
    (! bb0
    [ bb0 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_10 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = true_ {_10} (fun (_x: t_Bdd) -> [ &t <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_12 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = false_ {_12} (fun (_x: t_Bdd) -> [ &f <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_final <t_Context> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_13 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = node {_13} {x} {t} {f} (fun (_x: t_Bdd) -> [ &_ret <- _x ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1
      | s1 = -{resolve_ref_Context self}- s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & x: UInt64.t = x
    | & t: t_Bdd = Any.any_l ()
    | & _10: MutBorrow.t t_Context = Any.any_l ()
    | & f: t_Bdd = Any.any_l ()
    | & _12: MutBorrow.t t_Context = Any.any_l ()
    | & _13: MutBorrow.t t_Context = Any.any_l () ])
    [ return (result: t_Bdd) -> {[@expl:v ensures #0] grows self}
      {[@expl:v ensures #1] is_valid_bdd self.final result}
      {[@expl:v ensures #2] forall v'0: Map.map UInt64.t bool. interp result v'0 = Map.get v'0 x}
      (! return {result}) ]
end
module M_impl_Context_0__not (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_PeanoInt = { f0'0: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_ref_Bdd = None | Some t_Bdd
  
  type t_Option_Bdd = None'0 | Some'0 t_Bdd
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function deep_model_ref_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function deep_model_ref_Bdd
  
  let rec get_Bdd (self: t_MyHashMap_Bdd_Bdd) (key: t_Bdd) (return (x: t_Option_ref_Bdd)) = any
    [ return (result: t_Option_ref_Bdd) -> {match result with
        | Some v -> Map.get (view_MyHashMap_Bdd_Bdd self) (deep_model_ref_Bdd key) = Some'0 v
        | None -> Map.get (view_MyHashMap_Bdd_Bdd self) (deep_model_ref_Bdd key) = None'0
        end}
      (! return {result}) ]
  
  let rec elim_If (_x: t_Node) (return (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ _k (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {If v childt childf = _x} (! return {v} {childt} {childf})
    | _chk -> (! {match _x with
        | If _ _ _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some'0 b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'0
  
  meta "rewrite_def" function view_PeanoInt
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  type tup2_u64_u64 = { f0'1: UInt64.t; f1'1: UInt64.t }
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some'0 b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None'0 -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None'0 -> true
          | Some'0 n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None'0 -> true
        | Some'0 n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'1;
                                f1 = abm.f0'1 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'1;
                                                             f1 = abm.f1'1 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  predicate invariant_ref_Context [@inline:trivial] (self: MutBorrow.t t_Context) =
    inv_Context self.current /\ inv_Context self.final
  
  meta "rewrite_def" predicate invariant_ref_Context
  
  predicate inv_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = invariant_ref_Context _1
  
  meta "rewrite_def" predicate inv_ref_Context
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some'0 b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some'0 b
        | None'0 -> true
        end)
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv_ref_Context self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v = (if Map.get v x then interp childt v else interp childf v)}
      {UInt64.t'int x <= leastvar result}
      (! return {result}) ]
  
  let rec false_ (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv_ref_Context self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. not interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec true_ (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:true_ 'self' type invariant] inv_ref_Context self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec add_Bdd (self: MutBorrow.t t_MyHashMap_Bdd_Bdd) (key: t_Bdd) (val': t_Bdd) (return (x: ())) = any
    [ return (result: ()) -> {forall i: UInt64.t. Map.get (view_MyHashMap_Bdd_Bdd self.final) i
        = (if i = deep_model_Bdd key then Some'0 val' else Map.get (view_MyHashMap_Bdd_Bdd self.current) i)}
      (! return {result}) ]
  
  predicate resolve_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Context
  
  let rec elim_Some (_x: t_Option_ref_Bdd) (return (f0'2: t_Bdd)) = any
    [ _k (f0'2: t_Bdd) -> {Some f0'2 = _x} (! return {f0'2})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function size (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> 0
      | {f0 = False'; f1 = _} -> 0
      | {f0 = If _ childt childf; f1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec not' (self: MutBorrow.t t_Context) (x: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:not 'self' type invariant] inv_ref_Context self}
    {[@expl:not requires] is_valid_bdd self.current x}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_20 <- x ] s1
      | s1 = get_Bdd {self.current.not_memo} {_20} (fun (_x: t_Option_ref_Bdd) -> [ &_17 <- _x ] s2)
      | s2 = bb1 ]
    | bb1 = any [ br0 -> {_17 = None} (! bb4) | br1 (x0: t_Bdd) -> {_17 = Some x0} (! bb2) ]
    | bb4 = any
      [ br0 -> {x.f0 = False'} (! bb9)
      | br1 -> {x.f0 = True'} (! bb10)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {x.f0 = If x0 x1 x2} (! bb8) ]
    | bb8 = s0
      [ s0 = elim_If {x.f0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &v <- rv ] s1)
      | s1 = elim_If {x.f0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childt <- rchildt ] s2)
      | s2 = elim_If {x.f0} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childf <- rchildf ] s3)
      | s3 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_32 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s4)
      | s4 = not' {_32} {childt} (fun (_x: t_Bdd) -> [ &childt'0 <- _x ] s5)
      | s5 = bb13 ]
    | bb13 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_35 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = not' {_35} {childf} (fun (_x: t_Bdd) -> [ &childf'0 <- _x ] s2)
      | s2 = bb14 ]
    | bb14 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_37 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = node {_37} {v} {childt'0} {childf'0} (fun (_x: t_Bdd) -> [ &r'0 <- _x ] s2)
      | s2 = bb16 ]
    | bb10 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_26 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = false_ {_26} (fun (_x: t_Bdd) -> [ &r'0 <- _x ] s2)
      | s2 = bb16 ]
    | bb9 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_27 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = true_ {_27} (fun (_x: t_Bdd) -> [ &r'0 <- _x ] s2)
      | s2 = bb16 ]
    | bb16 = s0
      [ s0 = MutBorrow.borrow_final <t_MyHashMap_Bdd_Bdd> {self.current.not_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 4}
          (fun (_bor: MutBorrow.t t_MyHashMap_Bdd_Bdd) ->
            [ &_42 <- _bor ] [ &self <- { self with current = { self.current with not_memo = _bor.final } } ] s1)
      | s1 = add_Bdd {_42} {x} {r'0} (fun (_x: ()) -> [ &_41 <- _x ] s2)
      | s2 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1
      | s1 = -{resolve_ref_Context self}- s2
      | s2 = [ &_ret <- r'0 ] s3
      | s3 = bb18 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1 | s1 = -{resolve_ref_Context self}- s2 | s2 = bb3 ]
    | bb3 = s0 [ s0 = elim_Some {_17} (fun (r0: t_Bdd) -> [ &r <- r0 ] s1) | s1 = [ &_ret <- r ] s2 | s2 = bb18 ]
    | bb18 = return {_ret} ]
    [ & _ret: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & x: t_Bdd = x
    | & _17: t_Option_ref_Bdd = Any.any_l ()
    | & _20: t_Bdd = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _26: MutBorrow.t t_Context = Any.any_l ()
    | & _27: MutBorrow.t t_Context = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & childt'0: t_Bdd = Any.any_l ()
    | & _32: MutBorrow.t t_Context = Any.any_l ()
    | & childf'0: t_Bdd = Any.any_l ()
    | & _35: MutBorrow.t t_Context = Any.any_l ()
    | & _37: MutBorrow.t t_Context = Any.any_l ()
    | & _41: () = Any.any_l ()
    | & _42: MutBorrow.t t_MyHashMap_Bdd_Bdd = Any.any_l () ]
    [ not' (self: MutBorrow.t t_Context) (x: t_Bdd) (_k (_ret: t_Bdd)) ->
    {[@expl:function variant] well_founded_relation_Int function_variant (size x)}
      not' {self} {x} (_k) ] [ function_variant: int = size x ])
    [ return (result: t_Bdd) -> {[@expl:not ensures #0] grows self}
      {[@expl:not ensures #1] is_valid_bdd self.final result}
      {[@expl:not ensures #2] forall v: Map.map UInt64.t bool. interp result v = (not interp x v)}
      {[@expl:not ensures #3] leastvar x <= leastvar result}
      (! return {result}) ]
end
module M_impl_Context_0__and (* Context<'arena> *)
  use creusot.int.UInt64
  use map.Map
  use creusot.prelude.MutBorrow
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  type tup2_Bdd_Bdd = { f0'0: t_Bdd; f1'0: t_Bdd }
  
  type t_MyHashMap_tup2_Bdd_Bdd_Bdd
  
  type t_Bump
  
  type t_MyHashMap_Node_Bdd
  
  type t_MyHashMap_Bdd_Bdd
  
  type t_PeanoInt = { f0'1: UInt64.t }
  
  type t_Context = {
    alloc: t_Bump;
    hashcons: t_MyHashMap_Node_Bdd;
    hashcons_ghost: Map.map UInt64.t t_Node;
    not_memo: t_MyHashMap_Bdd_Bdd;
    and_memo: t_MyHashMap_tup2_Bdd_Bdd_Bdd;
    cnt: t_PeanoInt }
  
  type t_Option_ref_Bdd = None | Some t_Bdd
  
  type tup2_u64_u64 = { f0'2: UInt64.t; f1'2: UInt64.t }
  
  type t_Option_Bdd = None'0 | Some'0 t_Bdd
  
  function view_MyHashMap_tup2_Bdd_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) : Map.map tup2_u64_u64 t_Option_Bdd
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function deep_model_tup2_Bdd_Bdd [@inline:trivial] (self: tup2_Bdd_Bdd) : tup2_u64_u64 =
    { f0'2 = deep_model_Bdd self.f0'0; f1'2 = deep_model_Bdd self.f1'0 }
  
  meta "rewrite_def" function deep_model_tup2_Bdd_Bdd
  
  function deep_model_ref_tup2_Bdd_Bdd [@inline:trivial] (self: tup2_Bdd_Bdd) : tup2_u64_u64 =
    deep_model_tup2_Bdd_Bdd self
  
  meta "rewrite_def" function deep_model_ref_tup2_Bdd_Bdd
  
  let rec get_tup2_Bdd_Bdd (self: t_MyHashMap_tup2_Bdd_Bdd_Bdd) (key: tup2_Bdd_Bdd) (return (x: t_Option_ref_Bdd)) = any
    [ return (result: t_Option_ref_Bdd) -> {match result with
        | Some v -> Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self) (deep_model_ref_tup2_Bdd_Bdd key) = Some'0 v
        | None -> Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self) (deep_model_ref_tup2_Bdd_Bdd key) = None'0
        end}
      (! return {result}) ]
  
  type tup2_Node_Node = { f0'3: t_Node; f1'3: t_Node }
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function view_MyHashMap_Node_Bdd (self: t_MyHashMap_Node_Bdd) : Map.map t_NodeLog t_Option_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  predicate is_valid_bdd (self: t_Context) (b: t_Bdd) =
    Map.get (view_MyHashMap_Node_Bdd self.hashcons) (view_Node b.f0) = Some'0 b
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function leastvar (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = False'; f1 = _} -> UInt64.t'int const_MAX + 1
      | {f0 = If v _ _; f1 = _} -> UInt64.t'int v
      end
  
  predicate is_valid_node (self: t_Context) (n: t_Node) =
    match n with
      | True' -> true
      | False' -> true
      | If v childt childf -> childt.f0 <> childf.f0
      /\ is_valid_bdd self childt
      /\ is_valid_bdd self childf /\ UInt64.t'int v < leastvar childt /\ UInt64.t'int v < leastvar childf
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0'1
  
  meta "rewrite_def" function view_PeanoInt
  
  function view_MyHashMap_Bdd_Bdd (self: t_MyHashMap_Bdd_Bdd) : Map.map UInt64.t t_Option_Bdd
  
  predicate interp (self: t_Bdd) (vars: Map.map UInt64.t bool) =
    match self with
      | {f0 = True'; f1 = _} -> true
      | {f0 = False'; f1 = _} -> false
      | {f0 = If v childt childf; f1 = _} -> if Map.get vars v then interp childt vars else interp childf vars
      end
  
  predicate invariant_Context [@inline:trivial] (self: t_Context) =
    (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.hashcons) n with
          | Some'0 b -> view_Node b.f0 = n
          /\ is_valid_node self b.f0
          /\ UInt64.lt b.f1 (view_PeanoInt self.cnt) /\ Map.get self.hashcons_ghost b.f1 = b.f0
          | None'0 -> true
          end)
    /\ (forall bm: UInt64.t. match Map.get (view_MyHashMap_Bdd_Bdd self.not_memo) bm with
          | None'0 -> true
          | Some'0 n -> let b = { f0 = Map.get self.hashcons_ghost bm; f1 = bm } in is_valid_bdd self n
          /\ is_valid_bdd self b
          /\ (forall v: Map.map UInt64.t bool. interp n v = (not interp b v)) /\ leastvar b <= leastvar n
          end)
    /\ (forall abm: tup2_u64_u64. match Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.and_memo) abm with
        | None'0 -> true
        | Some'0 n -> let a = { f0 = Map.get self.hashcons_ghost abm.f0'2;
                                f1 = abm.f0'2 } in let b = { f0 = Map.get self.hashcons_ghost abm.f1'2;
                                                             f1 = abm.f1'2 } in is_valid_bdd self n
        /\ is_valid_bdd self a
        /\ is_valid_bdd self b
        /\ (forall v: Map.map UInt64.t bool. interp n v = (interp a v /\ interp b v))
        /\ (leastvar a <= leastvar n \/ leastvar b <= leastvar n)
        end)
  
  meta "rewrite_def" predicate invariant_Context
  
  predicate inv_Context (_1: t_Context)
  
  axiom inv_axiom [@rewrite]: forall x: t_Context [inv_Context x]. inv_Context x = invariant_Context x
  
  predicate invariant_ref_Context [@inline:trivial] (self: MutBorrow.t t_Context) =
    inv_Context self.current /\ inv_Context self.final
  
  meta "rewrite_def" predicate invariant_ref_Context
  
  predicate inv_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = invariant_ref_Context _1
  
  meta "rewrite_def" predicate inv_ref_Context
  
  predicate resolve_ref_Context [@inline:trivial] (_1: MutBorrow.t t_Context) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Context
  
  let rec elim_If (_x: t_Node) (return (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd)) = any
    [ _k (v: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) -> {If v childt childf = _x} (! return {v} {childt} {childf})
    | _chk -> (! {match _x with
        | If _ _ _ -> true
        | _ -> false
        end}
      any) ]
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {result = cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs)}
      (! return {result}) ]
  
  predicate grows (self: MutBorrow.t t_Context) =
    UInt64.le (view_PeanoInt self.current.cnt) (view_PeanoInt self.final.cnt)
    /\ (forall n: t_NodeLog. match Map.get (view_MyHashMap_Node_Bdd self.current.hashcons) n with
        | Some'0 b -> Map.get (view_MyHashMap_Node_Bdd self.final.hashcons) n = Some'0 b
        | None'0 -> true
        end)
  
  let rec node (self: MutBorrow.t t_Context) (x: UInt64.t) (childt: t_Bdd) (childf: t_Bdd) (return (x'0: t_Bdd)) =
    {[@expl:node 'self' type invariant] inv_ref_Context self}
    {[@expl:node requires #0] is_valid_bdd self.current childt}
    {[@expl:node requires #1] is_valid_bdd self.current childf}
    {[@expl:node requires #2] UInt64.t'int x < leastvar childt /\ UInt64.t'int x < leastvar childf}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. interp result v = (if Map.get v x then interp childt v else interp childf v)}
      {UInt64.t'int x <= leastvar result}
      (! return {result}) ]
  
  let rec false_ (self: MutBorrow.t t_Context) (return (x: t_Bdd)) =
    {[@expl:false_ 'self' type invariant] inv_ref_Context self}
    any
    [ return (result: t_Bdd) -> {grows self}
      {is_valid_bdd self.final result}
      {forall v: Map.map UInt64.t bool. not interp result v}
      {UInt64.t'int const_MAX + 1 = leastvar result}
      (! return {result}) ]
  
  let rec add_tup2_Bdd_Bdd (self: MutBorrow.t t_MyHashMap_tup2_Bdd_Bdd_Bdd) (key: tup2_Bdd_Bdd) (val': t_Bdd)
    (return (x: ())) = any
    [ return (result: ()) -> {forall i: tup2_u64_u64. Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.final) i
        = (if i = deep_model_tup2_Bdd_Bdd key then
          Some'0 val'
        else
          Map.get (view_MyHashMap_tup2_Bdd_Bdd_Bdd self.current) i
        )}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_ref_Bdd) (return (f0'4: t_Bdd)) = any
    [ _k (f0'4: t_Bdd) -> {Some f0'4 = _x} (! return {f0'4})
    | _chk -> (! {match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function size (self: t_Bdd) : int = match self with
      | {f0 = True'; f1 = _} -> 0
      | {f0 = False'; f1 = _} -> 0
      | {f0 = If _ childt childf; f1 = _} -> let ht = size childt in let hf = size childf in 1 + ht + hf
      end
  
  axiom size_spec: forall self: t_Bdd. size self >= 0
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec and (self: MutBorrow.t t_Context) (a: t_Bdd) (b: t_Bdd) (return (x: t_Bdd)) =
    {[@expl:and 'self' type invariant] inv_ref_Context self}
    {[@expl:and requires #0] is_valid_bdd self.current a}
    {[@expl:and requires #1] is_valid_bdd self.current b}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_28 <- { f0'0 = a; f1'0 = b } ] s1
      | s1 = [ &_27 <- _28 ] s2
      | s2 = get_tup2_Bdd_Bdd {self.current.and_memo} {_27} (fun (_x: t_Option_ref_Bdd) -> [ &_24 <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = any [ br0 -> {_24 = None} (! bb4) | br1 (x0: t_Bdd) -> {_24 = Some x0} (! bb2) ]
    | bb4 = s0
      [ s0 = [ &_35 <- { f0'3 = a.f0; f1'3 = b.f0 } ] s1
      | s1 = any
        [ br0 -> {_35.f0'3 = False'} (! bb5)
        | br1 -> {_35.f0'3 = True'} (! bb16)
        | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_35.f0'3 = If x0 x1 x2} (! bb5) ] ]
    | bb5 = any
      [ br0 -> {_35.f1'3 = False'} (! bb7)
      | br1 -> {_35.f1'3 = True'} (! bb15)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_35.f1'3 = If x0 x1 x2} (! bb7) ]
    | bb7 = any
      [ br0 -> {_35.f0'3 = False'} (! bb14)
      | br1 -> {_35.f0'3 = True'} (! bb9)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_35.f0'3 = If x0 x1 x2} (! bb9) ]
    | bb9 = any
      [ br0 -> {_35.f1'3 = False'} (! bb14)
      | br1 -> {_35.f1'3 = True'} (! bb10)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_35.f1'3 = If x0 x1 x2} (! bb11) ]
    | bb11 = any
      [ br0 -> {_35.f0'3 = False'} (! bb10)
      | br1 -> {_35.f0'3 = True'} (! bb10)
      | br2 (x0: UInt64.t) (x1: t_Bdd) (x2: t_Bdd) -> {_35.f0'3 = If x0 x1 x2} (! bb12) ]
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1
      | s1 = -{resolve_ref_Context self}- s2
      | s2 = {false} any ]
    | bb12 = s0
      [ s0 = elim_If {_35.f0'3} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &va <- rv ] s1)
      | s1 = elim_If {_35.f0'3} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childta <- rchildt ] s2)
      | s2 = elim_If {_35.f0'3} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childfa <- rchildf ] s3)
      | s3 = elim_If {_35.f1'3} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &vb <- rv ] s4)
      | s4 = elim_If {_35.f1'3} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childtb <- rchildt ] s5)
      | s5 = elim_If {_35.f1'3} (fun (rv: UInt64.t) (rchildt: t_Bdd) (rchildf: t_Bdd) -> [ &childfb <- rchildf ] s6)
      | s6 = [ &_57 <- vb ] s7
      | s7 = cmp_u64 {va} {_57} (fun (_x: t_Ordering) -> [ &_54 <- _x ] s8)
      | s8 = bb18 ]
    | bb18 = any [ br0 -> {_54 = Less} (! bb23) | br1 -> {_54 = Equal} (! bb22) | br2 -> {_54 = Greater} (! bb24) ]
    | bb24 = s0
      [ s0 = [ &v <- vb ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_61 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = and {_61} {a} {childtb} (fun (_x: t_Bdd) -> [ &_60 <- _x ] s3)
      | s3 = bb25 ]
    | bb25 = s0
      [ s0 = [ &childt <- _60 ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_65 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = and {_65} {a} {childfb} (fun (_x: t_Bdd) -> [ &_64 <- _x ] s3)
      | s3 = bb26 ]
    | bb26 = s0 [ s0 = [ &childf <- _64 ] s1 | s1 = bb31 ]
    | bb22 = s0
      [ s0 = [ &v <- va ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_79 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = and {_79} {childta} {childtb} (fun (_x: t_Bdd) -> [ &_78 <- _x ] s3)
      | s3 = bb29 ]
    | bb29 = s0
      [ s0 = [ &childt <- _78 ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_83 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = and {_83} {childfa} {childfb} (fun (_x: t_Bdd) -> [ &_82 <- _x ] s3)
      | s3 = bb30 ]
    | bb30 = s0 [ s0 = [ &childf <- _82 ] s1 | s1 = bb31 ]
    | bb23 = s0
      [ s0 = [ &v <- va ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_70 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = and {_70} {childta} {b} (fun (_x: t_Bdd) -> [ &_69 <- _x ] s3)
      | s3 = bb27 ]
    | bb27 = s0
      [ s0 = [ &childt <- _69 ] s1
      | s1 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_74 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s2)
      | s2 = and {_74} {childfa} {b} (fun (_x: t_Bdd) -> [ &_73 <- _x ] s3)
      | s3 = bb28 ]
    | bb28 = s0 [ s0 = [ &childf <- _73 ] s1 | s1 = bb31 ]
    | bb31 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_86 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = node {_86} {v} {childt} {childf} (fun (_x: t_Bdd) -> [ &r'0 <- _x ] s2)
      | s2 = bb33 ]
    | bb14 = s0
      [ s0 = {inv_Context self.current}
        MutBorrow.borrow_mut <t_Context> {self.current}
          (fun (_bor: MutBorrow.t t_Context) ->
            [ &_43 <- _bor ] -{inv_Context _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
      | s1 = false_ {_43} (fun (_x: t_Bdd) -> [ &r'0 <- _x ] s2)
      | s2 = bb33 ]
    | bb15 = s0 [ s0 = [ &r'0 <- a ] s1 | s1 = bb33 ]
    | bb16 = s0 [ s0 = [ &r'0 <- b ] s1 | s1 = bb33 ]
    | bb33 = s0
      [ s0 = [ &_92 <- { f0'0 = a; f1'0 = b } ] s1
      | s1 = MutBorrow.borrow_final <t_MyHashMap_tup2_Bdd_Bdd_Bdd> {self.current.and_memo}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 5}
          (fun (_bor: MutBorrow.t t_MyHashMap_tup2_Bdd_Bdd_Bdd) ->
            [ &_91 <- _bor ] [ &self <- { self with current = { self.current with and_memo = _bor.final } } ] s2)
      | s2 = add_tup2_Bdd_Bdd {_91} {_92} {r'0} (fun (_x: ()) -> [ &_90 <- _x ] s3)
      | s3 = bb34 ]
    | bb34 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1
      | s1 = -{resolve_ref_Context self}- s2
      | s2 = [ &_ret <- r'0 ] s3
      | s3 = bb35 ]
    | bb2 = s0
      [ s0 = {[@expl:type invariant] inv_ref_Context self} s1 | s1 = -{resolve_ref_Context self}- s2 | s2 = bb3 ]
    | bb3 = s0 [ s0 = elim_Some {_24} (fun (r0: t_Bdd) -> [ &r <- r0 ] s1) | s1 = [ &_ret <- r ] s2 | s2 = bb35 ]
    | bb35 = return {_ret} ]
    [ & _ret: t_Bdd = Any.any_l ()
    | & self: MutBorrow.t t_Context = self
    | & a: t_Bdd = a
    | & b: t_Bdd = b
    | & _24: t_Option_ref_Bdd = Any.any_l ()
    | & _27: tup2_Bdd_Bdd = Any.any_l ()
    | & _28: tup2_Bdd_Bdd = Any.any_l ()
    | & r: t_Bdd = Any.any_l ()
    | & r'0: t_Bdd = Any.any_l ()
    | & _35: tup2_Node_Node = Any.any_l ()
    | & _43: MutBorrow.t t_Context = Any.any_l ()
    | & va: UInt64.t = Any.any_l ()
    | & childta: t_Bdd = Any.any_l ()
    | & childfa: t_Bdd = Any.any_l ()
    | & vb: UInt64.t = Any.any_l ()
    | & childtb: t_Bdd = Any.any_l ()
    | & childfb: t_Bdd = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & childt: t_Bdd = Any.any_l ()
    | & childf: t_Bdd = Any.any_l ()
    | & _54: t_Ordering = Any.any_l ()
    | & _57: UInt64.t = Any.any_l ()
    | & _60: t_Bdd = Any.any_l ()
    | & _61: MutBorrow.t t_Context = Any.any_l ()
    | & _64: t_Bdd = Any.any_l ()
    | & _65: MutBorrow.t t_Context = Any.any_l ()
    | & _69: t_Bdd = Any.any_l ()
    | & _70: MutBorrow.t t_Context = Any.any_l ()
    | & _73: t_Bdd = Any.any_l ()
    | & _74: MutBorrow.t t_Context = Any.any_l ()
    | & _78: t_Bdd = Any.any_l ()
    | & _79: MutBorrow.t t_Context = Any.any_l ()
    | & _82: t_Bdd = Any.any_l ()
    | & _83: MutBorrow.t t_Context = Any.any_l ()
    | & _86: MutBorrow.t t_Context = Any.any_l ()
    | & _90: () = Any.any_l ()
    | & _91: MutBorrow.t t_MyHashMap_tup2_Bdd_Bdd_Bdd = Any.any_l ()
    | & _92: tup2_Bdd_Bdd = Any.any_l () ]
    [ and (self: MutBorrow.t t_Context) (a: t_Bdd) (b: t_Bdd) (_k (_ret: t_Bdd)) ->
    {[@expl:function variant] well_founded_relation_Int function_variant (size a + size b)}
      and {self} {a} {b} (_k) ] [ function_variant: int = size a + size b ])
    [ return (result: t_Bdd) -> {[@expl:and ensures #0] grows self}
      {[@expl:and ensures #1] is_valid_bdd self.final result}
      {[@expl:and ensures #2] forall v: Map.map UInt64.t bool. interp result v = (interp a v /\ interp b v)}
      {[@expl:and ensures #3] leastvar a <= leastvar result \/ leastvar b <= leastvar result}
      (! return {result}) ]
end
module M_hashmap__impl_Hash_for_tup2_U_V__hash__refines (* <(U, V) as hashmap::Hash> *)
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_U
  
  type t_V
  
  type tup2_U_V = { f0: t_U; f1: t_V }
  
  predicate inv_U (_1: t_U)
  
  predicate inv_V (_1: t_V)
  
  predicate inv_tup2_U_V [@inline:trivial] (_1: tup2_U_V) = inv_U _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_U_V
  
  predicate invariant_ref_tup2_U_V [@inline:trivial] (self: tup2_U_V) = inv_tup2_U_V self
  
  meta "rewrite_def" predicate invariant_ref_tup2_U_V
  
  predicate inv_ref_tup2_U_V [@inline:trivial] (_1: tup2_U_V) = invariant_ref_tup2_U_V _1
  
  meta "rewrite_def" predicate inv_ref_tup2_U_V
  
  type t_DeepModelTy
  
  type t_DeepModelTy'0
  
  type tup2_DeepModelTy_DeepModelTy = { f0'0: t_DeepModelTy; f1'0: t_DeepModelTy'0 }
  
  function hash_log_U (_1: t_DeepModelTy) : int
  
  function hash_log_V (_1: t_DeepModelTy'0) : int
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log_tup2_U_V (x: tup2_DeepModelTy_DeepModelTy) : int = Int.mod (hash_log_U x.f0'0
    + hash_log_V x.f1'0 * 17) (UInt64.t'int const_MAX + 1)
  
  function deep_model_U (self: t_U) : t_DeepModelTy
  
  function deep_model_V (self: t_V) : t_DeepModelTy'0
  
  function deep_model_tup2_U_V [@inline:trivial] (self: tup2_U_V) : tup2_DeepModelTy_DeepModelTy =
    { f0'0 = deep_model_U self.f0; f1'0 = deep_model_V self.f1 }
  
  meta "rewrite_def" function deep_model_tup2_U_V
  
  function deep_model_ref_tup2_U_V [@inline:trivial] (self: tup2_U_V) : tup2_DeepModelTy_DeepModelTy =
    deep_model_tup2_U_V self
  
  meta "rewrite_def" function deep_model_ref_tup2_U_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_U_V. inv_ref_tup2_U_V self
      -> inv_ref_tup2_U_V self
      /\ (forall result: UInt64.t. UInt64.t'int result = hash_log_tup2_U_V (deep_model_ref_tup2_U_V self)
        -> UInt64.t'int result = hash_log_tup2_U_V (deep_model_ref_tup2_U_V self))
end
module M_impl_Hash_for_Node__hash__refines (* <Node<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  use mach.int.Int
  
  type t_NodeLog = False' | True' | If UInt64.t UInt64.t UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function hash_log_Node (x: t_NodeLog) : int = match x with
      | False' -> 1
      | True' -> 2
      | If v childt childf -> Int.mod (UInt64.t'int v + UInt64.t'int childt * 5
      + UInt64.t'int childf * 7) (UInt64.t'int const_MAX + 1)
      end
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False''0 | True''0 | If'0 UInt64.t t_Bdd t_Bdd
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False''0 -> False'
      | True''0 -> True'
      | If'0 v childt childf -> If v (childt.f1) (childf.f1)
      end
  
  function view_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function view_Node
  
  function deep_model_ref_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function deep_model_ref_Node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Node. forall result: UInt64.t. UInt64.t'int result = hash_log_Node (view_Node self)
        -> UInt64.t'int result = hash_log_Node (deep_model_ref_Node self)
end
module M_impl_Hash_for_Bdd__hash__refines (* <Bdd<'arena> as hashmap::Hash> *)
  use creusot.int.UInt64
  
  function hash_log_Bdd [@inline:trivial] (x: UInt64.t) : int = UInt64.t'int x
  
  meta "rewrite_def" function hash_log_Bdd
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function view_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function view_Bdd
  
  function deep_model_ref_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function deep_model_ref_Bdd
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Bdd. forall result: UInt64.t. UInt64.t'int result = hash_log_Bdd (view_Bdd self)
        -> UInt64.t'int result = hash_log_Bdd (deep_model_ref_Bdd self)
end
module M_impl_PartialEq_for_Node__eq__refines (* <Node<'arena> as std::cmp::PartialEq> *)
  use creusot.int.UInt64
  
  type t_Bdd = { f0: t_Node; f1: UInt64.t }
  with t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  
  type t_NodeLog = False''0 | True''0 | If'0 UInt64.t UInt64.t UInt64.t
  
  function deep_model_Node (self: t_Node) : t_NodeLog = match self with
      | False' -> False''0
      | True' -> True''0
      | If v childt childf -> If'0 v (childt.f1) (childf.f1)
      end
  
  function deep_model_ref_Node [@inline:trivial] (self: t_Node) : t_NodeLog = deep_model_Node self
  
  meta "rewrite_def" function deep_model_ref_Node
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Node. forall rhs: t_Node. forall result: bool. result
            = (deep_model_ref_Node self_ = deep_model_ref_Node rhs)
          -> result = (deep_model_ref_Node self_ = deep_model_ref_Node rhs)
end
module M_impl_PartialEq_for_Bdd__eq__refines (* <Bdd<'arena> as std::cmp::PartialEq> *)
  use creusot.int.UInt64
  
  type t_Node = False' | True' | If UInt64.t t_Bdd t_Bdd
  with t_Bdd = { f0: t_Node; f1: UInt64.t }
  
  function deep_model_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = self.f1
  
  meta "rewrite_def" function deep_model_Bdd
  
  function view_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function view_Bdd
  
  function deep_model_ref_Bdd [@inline:trivial] (self: t_Bdd) : UInt64.t = deep_model_Bdd self
  
  meta "rewrite_def" function deep_model_ref_Bdd
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Bdd. forall rhs: t_Bdd. forall result: bool. result = (view_Bdd self_ = view_Bdd rhs)
          -> result = (deep_model_ref_Bdd self_ = deep_model_ref_Bdd rhs)
end
