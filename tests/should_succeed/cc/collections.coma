module M_collections__roundtrip_hashmap_into_iter [#"collections.rs" 15 0 17 18]
  let%span scollections = "collections.rs" 18 18 18 31
  let%span scollections'0 = "collections.rs" 20 14 20 30
  let%span scollections'1 = "collections.rs" 23 8 26 80
  let%span scollections'2 = "collections.rs" 28 20 28 87
  let%span scollections'3 = "collections.rs" 29 20 29 69
  let%span scollections'4 = "collections.rs" 14 10 14 24
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 41 18 41 34
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 92 20 92 54
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 75 12 85 29
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 220 20 222 81
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 97 14 97 45
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 98 27 98 29
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 102 15 102 32
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 103 15 103 32
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 104 14 104 42
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 106 8 106 99
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 164 26 165 120
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 127 8 130 9
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 174 8 174 34
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 249 14 249 38
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 250 14 250 83
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 252 8 252 35
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sutil = "../../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 55 10 55 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0  =
    { t_HashMap__base: t_HashMap }
  
  type t_FMap
  
  function view (self: t_HashMap'0) : t_FMap
  
  function view'0 (self: t_IntoIter'0) : t_FMap
  
  let rec into_iter (self_:t_HashMap'0) (return'  (x:t_IntoIter'0))= any
    [ return''0 (result:t_IntoIter'0)-> {[%#shash_map] view self_ = view'0 result} (! return' {result}) ]
  
  
  predicate resolve (_0: t_IntoIter'0) =
    true
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'3] len self >= 0
  
  predicate contains (self: Seq.seq tuple'0) (x: tuple'0) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'1 (self: t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'11] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'1 m1 <> view'1 m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option'1 =
    [%#sfmap'4] Map.get (view'1 self) k
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0 =
    [%#sfmap] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  predicate produces (self: t_IntoIter'0) (visited: Seq.seq tuple'0) (o: t_IntoIter'0) =
    [%#shash_map'1] len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view'0 self) (deep_model k) = C_Some'0 v /\ get (view'0 o) (deep_model k) = C_None'0)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 o) k = C_Some'0 v
     -> get (view'0 self) k = C_Some'0 v
    /\ not (exists k2: t_K, v2: t_V. deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'0 self) k = C_Some'0 v
     -> (exists k1: t_K. deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view'0 o) k = C_Some'0 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  function produces_trans (a: t_IntoIter'0) (ab: Seq.seq tuple'0) (b: t_IntoIter'0) (bc: Seq.seq tuple'0) (c: t_IntoIter'0) : ()
  
   =
    [%#shash_map'8] let _ = () in ()
  
  axiom produces_trans_spec: forall a: t_IntoIter'0, ab: Seq.seq tuple'0, b: t_IntoIter'0, bc: Seq.seq tuple'0, c: t_IntoIter'0. ([%#shash_map'5] produces a ab b)
   -> ([%#shash_map'6] produces b bc c)  -> ([%#shash_map'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_IntoIter'0) : () =
    [%#shash_map'4] ()
  
  axiom produces_refl_spec: forall self: t_IntoIter'0. [%#shash_map'3] produces self (Seq.empty: Seq.seq tuple'0) self
  
  predicate resolve'0 (self: MutBorrow.t t_IntoIter'0) =
    [%#sresolve] self.final = self.current
  
  function ext_eq (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'8] view'1 self = view'1 other
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'6] ext_eq self other  -> self = other)
  && ([%#sfmap'7] (forall k: t_DeepModelTy. get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  constant empty  : t_FMap
  
  axiom empty_spec: ([%#sfmap'9] len empty = 0) && ([%#sfmap'10] view'1 empty = Const.const (C_None'1))
  
  function is_empty (self: t_FMap) : bool =
    [%#sfmap'2] ext_eq self empty
  
  function view'2 (self: MutBorrow.t t_IntoIter'0) : t_FMap =
    [%#smodel] view'0 self.current
  
  predicate completed (self: MutBorrow.t t_IntoIter'0) =
    [%#shash_map'0] resolve'0 self /\ is_empty (view'2 self)
  
  predicate from_iter_post (prod: Seq.seq tuple'0) (res: t_HashMap'0) =
    [%#shash_map'2] forall k: t_DeepModelTy, v: t_V. (get (view res) k = C_Some'0 v)
    = (exists i: int, k1: t_K. 0 <= i
    /\ i < Seq.length prod
    /\ deep_model k1 = k
    /\ Seq.get prod i = { _p0'0 = k1; _p1'0 = v }
    /\ (forall j: int. i < j /\ j < Seq.length prod  -> deep_model (Seq.get prod j)._p0'0 <> k))
  
  let rec collect (self_:t_IntoIter'0) (return'  (x:t_HashMap'0))= any
    [ return''0 (result:t_HashMap'0)-> {[%#siter] exists done': MutBorrow.t t_IntoIter'0, prod: Seq.seq tuple'0. resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  function contains'0 [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : bool =
    [%#sfmap'0] get_unsized self k <> C_None'1
  
  function unwrap (op: t_Option'1) : t_V
  
  axiom unwrap_spec: forall op: t_Option'1. ([%#sutil] op <> C_None'1)  -> ([%#sutil'0] C_Some'1 (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V =
    [%#sfmap'12] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V =
    [%#sfmap'5] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V =
    [%#sfmap'1] lookup self key
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_into_iter[#"collections.rs" 15 0 17 18] (xs:t_HashMap'0) (return'  (x:t_HashMap'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &xs_snap <- [%#scollections] xs'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = into_iter {xs'0} (fun (_ret:t_IntoIter'0) ->  [ &it <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &it0 <- [%#scollections'0] it ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 = collect {it} (fun (_ret:t_HashMap'0) ->  [ &r <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:assertion] [%#scollections'1] exists prod: Seq.seq tuple'0, it1: MutBorrow.t t_IntoIter'0. completed it1
        /\ produces it0 prod it1.current
        /\ (forall k: t_DeepModelTy, v: t_V. get (view r) k = C_Some'0 v
         -> (exists k1: t_K. deep_model k1 = k /\ contains prod { _p0'0 = k1; _p1'0 = v }))}
        s1
      | s1 = bb6 ]
    
    | bb6 = s0
      [ s0 = {[@expl:assertion] [%#scollections'2] forall k: t_DeepModelTy. contains'0 (view r) k
        = contains'0 (view xs_snap) k}
        s1
      | s1 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:assertion] [%#scollections'3] forall k: t_DeepModelTy. index_logic (view r) k
        = index_logic (view xs_snap) k}
        s1
      | s1 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0: t_HashMap'0 = Any.any_l ()
    | & xs'0: t_HashMap'0 = xs
    | & xs_snap: t_HashMap'0 = Any.any_l ()
    | & it: t_IntoIter'0 = Any.any_l ()
    | & it0: t_IntoIter'0 = Any.any_l ()
    | & r: t_HashMap'0 = Any.any_l () ]
    
    [ return''0 (result:t_HashMap'0)-> {[@expl:roundtrip_hashmap_into_iter ensures] [%#scollections'4] view result
      = view xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter [#"collections.rs" 34 0 34 97]
  let%span scollections = "collections.rs" 36 14 36 30
  let%span scollections'0 = "collections.rs" 40 4 43 77
  let%span scollections'1 = "collections.rs" 33 10 33 98
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 28 30 28 46
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 144 20 144 54
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 127 12 137 29
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 220 20 222 81
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 149 14 149 45
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 150 27 150 29
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 154 15 154 32
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 155 15 155 32
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 156 14 156 42
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 158 8 158 99
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 164 26 165 120
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 127 8 130 9
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 174 8 174 34
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 249 14 249 38
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 250 14 250 83
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 252 8 252 35
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0  =
    { t_HashMap__base: t_HashMap }
  
  type t_FMap
  
  function view (self: t_HashMap'0) : t_FMap
  
  function view'0 (self: t_HashMap'0) : t_FMap =
    [%#smodel'0] view self
  
  function view'1 (self: t_Iter'0) : t_FMap
  
  let rec iter (self_:t_HashMap'0) (return'  (x:t_Iter'0))= any
    [ return''0 (result:t_Iter'0)-> {[%#shash_map] view'0 self_ = view'1 result} (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2  =
    { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve (_0: t_Iter'0) =
    true
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'1] len self >= 0
  
  predicate contains (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'2 (self: t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'8] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view'2 m1 <> view'2 m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option'0 =
    [%#sfmap'2] Map.get (view'2 self) k
  
  function get [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option =
    [%#sfmap] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces (self: t_Iter'0) (visited: Seq.seq tuple) (o: t_Iter'0) =
    [%#shash_map'1] len (view'1 self) = Seq.length visited + len (view'1 o)
    /\ (forall k: t_K, v: t_V. contains visited { _p0 = k; _p1 = v }
     -> get (view'1 self) (deep_model'0 k) = C_Some v /\ get (view'1 o) (deep_model'0 k) = C_None)
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'1 o) k = C_Some v
     -> get (view'1 self) k = C_Some v
    /\ not (exists k2: t_K, v2: t_V. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get (view'1 self) k = C_Some v
     -> (exists k2: t_K. deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v }) \/ get (view'1 o) k = C_Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  function produces_trans (a: t_Iter'0) (ab: Seq.seq tuple) (b: t_Iter'0) (bc: Seq.seq tuple) (c: t_Iter'0) : () =
    [%#shash_map'8] let _ = () in ()
  
  axiom produces_trans_spec: forall a: t_Iter'0, ab: Seq.seq tuple, b: t_Iter'0, bc: Seq.seq tuple, c: t_Iter'0. ([%#shash_map'5] produces a ab b)
   -> ([%#shash_map'6] produces b bc c)  -> ([%#shash_map'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Iter'0) : () =
    [%#shash_map'4] ()
  
  axiom produces_refl_spec: forall self: t_Iter'0. [%#shash_map'3] produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 (self: MutBorrow.t t_Iter'0) =
    [%#sresolve] self.final = self.current
  
  function ext_eq (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'5] view'2 self = view'2 other
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'3] ext_eq self other  -> self = other)
  && ([%#sfmap'4] (forall k: t_DeepModelTy. get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  constant empty  : t_FMap
  
  axiom empty_spec: ([%#sfmap'6] len empty = 0) && ([%#sfmap'7] view'2 empty = Const.const (C_None'0))
  
  function is_empty (self: t_FMap) : bool =
    [%#sfmap'0] ext_eq self empty
  
  function view'3 (self: MutBorrow.t t_Iter'0) : t_FMap =
    [%#smodel'1] view'1 self.current
  
  predicate completed (self: MutBorrow.t t_Iter'0) =
    [%#shash_map'0] resolve'0 self /\ is_empty (view'3 self)
  
  type t_FMap'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function view'4 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'2
  
  axiom view_spec'0: forall self: t_FMap'0. [%#sfmap'8] forall m1: t_FMap'0, m2: t_FMap'0. m1 <> m2
   -> view'4 m1 <> view'4 m2
  
  function get_unsized'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'2 =
    [%#sfmap'2] Map.get (view'4 self) k
  
  function get'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'1 =
    [%#sfmap] match get_unsized'0 self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  function view'5 (self: t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'2) =
    [%#shash_map'2] forall k: t_DeepModelTy, v: t_V. (get'0 (view'5 res) k = C_Some'1 v)
    = (exists i: int, k1: t_K. 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = { _p0 = k1; _p1 = v }
    /\ (forall j: int. i < j /\ j < Seq.length prod  -> deep_model'0 (Seq.get prod j)._p0 <> k))
  
  let rec collect (self_:t_Iter'0) (return'  (x:t_HashMap'2))= any
    [ return''0 (result:t_HashMap'2)-> {[%#siter] exists done': MutBorrow.t t_Iter'0, prod: Seq.seq tuple. resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter[#"collections.rs" 34 0 34 97] (xs:t_HashMap'0) (return'  (x:t_HashMap'2))= (! bb0
    [ bb0 = s0 [ s0 = iter {xs'0} (fun (_ret:t_Iter'0) ->  [ &it <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections] it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {it} (fun (_ret:t_HashMap'2) ->  [ &r <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections'0] exists prod: Seq.seq tuple, it1: MutBorrow.t t_Iter'0. completed it1
        /\ produces it0 prod it1.current
        /\ (forall k: t_DeepModelTy, v: t_V. get'0 (view'5 r) k = C_Some'1 v
         -> (exists k1: t_K. deep_model'0 k1 = k /\ contains prod { _p0 = k1; _p1 = v }))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    )
    [ & _0: t_HashMap'2 = Any.any_l ()
    | & xs'0: t_HashMap'0 = xs
    | & it: t_Iter'0 = Any.any_l ()
    | & it0: t_Iter'0 = Any.any_l ()
    | & r: t_HashMap'2 = Any.any_l () ]
    
    [ return''0 (result:t_HashMap'2)-> {[@expl:roundtrip_hashmap_iter ensures] [%#scollections'1] forall k: t_DeepModelTy, v: t_V. (get'0 (view'5 result) k
      = C_Some'1 v)
      = (get (view'0 xs) k = C_Some v)}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter_mut [#"collections.rs" 50 0 52 24]
  let%span scollections = "collections.rs" 54 14 54 30
  let%span scollections'0 = "collections.rs" 57 8 60 81
  let%span scollections'1 = "collections.rs" 47 10 47 128
  let%span scollections'2 = "collections.rs" 48 10 48 107
  let%span scollections'3 = "collections.rs" 49 10 49 110
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 31 30 31 100
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 32 30 32 99
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 33 30 33 137
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 196 20 196 54
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 179 12 189 29
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 220 20 222 81
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 201 14 201 45
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 202 27 202 29
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 206 15 206 32
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 207 15 207 32
  let%span shash_map'9 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 208 14 208 42
  let%span shash_map'10 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 210 8 210 99
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 164 26 165 120
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 127 8 130 9
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 167 8 167 35
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 286 8 286 24
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 174 8 174 34
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 138 8 138 26
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 151 8 151 31
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 249 14 249 38
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 250 14 250 83
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 252 8 252 35
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 159 8 159 35
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sutil = "../../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 55 10 55 28
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0  =
    { t_HashMap__base: t_HashMap }
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_FMap
  
  type t_DeepModelTy
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view (self: t_FMap) : Map.map t_DeepModelTy t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'11] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option =
    [%#sfmap'4] Map.get (view self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : bool =
    [%#sfmap'0] get_unsized self k <> C_None
  
  function view'0 (self: t_HashMap'0) : t_FMap
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'1 (self: t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  axiom view_spec'0: forall self: t_FMap'0. [%#sfmap'11] forall m1: t_FMap'0, m2: t_FMap'0. m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'0 =
    [%#sfmap'4] Map.get (view'1 self) k
  
  function contains'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : bool =
    [%#sfmap'0] get_unsized'0 self k <> C_None'0
  
  function view'2 (self: t_IterMut'0) : t_FMap'0
  
  function unwrap (op: t_Option) : t_V
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V =
    [%#sfmap'12] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_V =
    [%#sfmap'5] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self: t_FMap) (key: t_DeepModelTy) : t_V =
    [%#sfmap'1] lookup self key
  
  function unwrap'0 (op: t_Option'0) : MutBorrow.t t_V
  
  axiom unwrap_spec'0: forall op: t_Option'0. ([%#sutil] op <> C_None'0)  -> ([%#sutil'0] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'12] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'5] lookup_unsized'0 self k
  
  function index_logic'0 [@inline:trivial] (self: t_FMap'0) (key: t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'1] lookup'0 self key
  
  let rec iter_mut (self_:MutBorrow.t t_HashMap'0) (return'  (x:t_IterMut'0))= any
    [ return''0 (result:t_IterMut'0)-> {[%#shash_map] forall k: t_DeepModelTy. contains (view'0 self_.current) k
      = contains (view'0 self_.final) k}
      {[%#shash_map'0] forall k: t_DeepModelTy. contains (view'0 self_.current) k = contains'0 (view'2 result) k}
      {[%#shash_map'1] forall k: t_DeepModelTy. contains (view'0 self_.current) k
       -> index_logic (view'0 self_.current) k = (index_logic'0 (view'2 result) k).current
      /\ index_logic (view'0 self_.final) k = (index_logic'0 (view'2 result) k).final}
      (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2  =
    { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve (_0: t_IterMut'0) =
    true
  
  type t_K
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  function len (self: t_FMap'0) : int
  
  axiom len_spec: forall self: t_FMap'0. [%#sfmap'3] len self >= 0
  
  predicate contains'1 (self: Seq.seq tuple) (x: tuple) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V)
  
  function get [@inline:trivial] (self: t_FMap'0) (k: t_DeepModelTy) : t_Option'1 =
    [%#sfmap] match get_unsized'0 self k with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 x
      end
  
  function deep_model (self: t_K) : t_DeepModelTy
  
  function deep_model'0 (self: t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces (self: t_IterMut'0) (visited: Seq.seq tuple) (o: t_IterMut'0) =
    [%#shash_map'3] len (view'2 self) = Seq.length visited + len (view'2 o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains'1 visited { _p0 = k; _p1 = v }
     -> get (view'2 self) (deep_model k) = C_Some'1 v /\ get (view'2 o) (deep_model k) = C_None'1)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view'2 o) k = C_Some'1 v
     -> get (view'2 self) k = C_Some'1 v
    /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model'0 k2 = k /\ contains'1 visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view'2 self) k = C_Some'1 v
     -> (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 visited { _p0 = k1; _p1 = v })
    \/ get (view'2 o) k = C_Some'1 v)
    /\ (forall i1: int, i2: int. 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  function produces_trans (a: t_IterMut'0) (ab: Seq.seq tuple) (b: t_IterMut'0) (bc: Seq.seq tuple) (c: t_IterMut'0) : ()
  
   =
    [%#shash_map'10] let _ = () in ()
  
  axiom produces_trans_spec: forall a: t_IterMut'0, ab: Seq.seq tuple, b: t_IterMut'0, bc: Seq.seq tuple, c: t_IterMut'0. ([%#shash_map'7] produces a ab b)
   -> ([%#shash_map'8] produces b bc c)  -> ([%#shash_map'9] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_IterMut'0) : () =
    [%#shash_map'6] ()
  
  axiom produces_refl_spec: forall self: t_IterMut'0. [%#shash_map'5] produces self (Seq.empty: Seq.seq tuple) self
  
  predicate resolve'0 (self: MutBorrow.t t_IterMut'0) =
    [%#sresolve] self.final = self.current
  
  function ext_eq (self: t_FMap'0) (other: t_FMap'0) : bool =
    [%#sfmap'8] view'1 self = view'1 other
  
  axiom ext_eq_spec: forall self: t_FMap'0, other: t_FMap'0. ([%#sfmap'6] ext_eq self other  -> self = other)
  && ([%#sfmap'7] (forall k: t_DeepModelTy. get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq self other)
  
  constant empty  : t_FMap'0
  
  axiom empty_spec: ([%#sfmap'9] len empty = 0) && ([%#sfmap'10] view'1 empty = Const.const (C_None'0))
  
  function is_empty (self: t_FMap'0) : bool =
    [%#sfmap'2] ext_eq self empty
  
  function view'3 (self: MutBorrow.t t_IterMut'0) : t_FMap'0 =
    [%#smodel'0] view'2 self.current
  
  predicate completed (self: MutBorrow.t t_IterMut'0) =
    [%#shash_map'2] resolve'0 self /\ is_empty (view'3 self)
  
  function view'4 (self: t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod: Seq.seq tuple) (res: t_HashMap'2) =
    [%#shash_map'4] forall k: t_DeepModelTy, v: MutBorrow.t t_V. (get (view'4 res) k = C_Some'1 v)
    = (exists i: int, k1: t_K. 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = { _p0 = k1; _p1 = v }
    /\ (forall j: int. i < j /\ j < Seq.length prod  -> deep_model'0 (Seq.get prod j)._p0 <> k))
  
  let rec collect (self_:t_IterMut'0) (return'  (x:t_HashMap'2))= any
    [ return''0 (result:t_HashMap'2)-> {[%#siter] exists done': MutBorrow.t t_IterMut'0, prod: Seq.seq tuple. resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t t_HashMap'0) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_HashMap'0) =
    resolve'1 _0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function get'0 [@inline:trivial] (self: t_FMap) (k: t_DeepModelTy) : t_Option'2 =
    [%#sfmap] match get_unsized self k with
      | C_None -> C_None'2
      | C_Some x -> C_Some'2 x
      end
  
  function view'5 (self: MutBorrow.t t_HashMap'0) : t_FMap =
    [%#smodel'0] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter_mut[#"collections.rs" 50 0 52 24] (xs:MutBorrow.t t_HashMap'0) (return'  (x:t_HashMap'2))= (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_HashMap'0> {xs'0.current} {MutBorrow.get_id xs'0}
          (fun (_ret:MutBorrow.t t_HashMap'0) ->  [ &_6 <- _ret ]  [ &xs'0 <- { xs'0 with current = _ret.final } ] s1)
      | s1 = iter_mut {_6} (fun (_ret:t_IterMut'0) ->  [ &it <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections] it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {it} (fun (_ret:t_HashMap'2) ->  [ &r <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections'0] exists prod: Seq.seq tuple, it1: MutBorrow.t t_IterMut'0. completed it1
        /\ produces it0 prod it1.current
        /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view'4 r) k = C_Some'1 v
         -> (exists k1: t_K. deep_model'0 k1 = k /\ contains'1 prod { _p0 = k1; _p1 = v }))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 = -{resolve'2 xs'0}- s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0: t_HashMap'2 = Any.any_l ()
    | & xs'0: MutBorrow.t t_HashMap'0 = xs
    | & it: t_IterMut'0 = Any.any_l ()
    | & _6: MutBorrow.t t_HashMap'0 = Any.any_l ()
    | & it0: t_IterMut'0 = Any.any_l ()
    | & r: t_HashMap'2 = Any.any_l () ]
    
    [ return''0 (result:t_HashMap'2)-> {[@expl:roundtrip_hashmap_iter_mut ensures #0] [%#scollections'1] forall k: t_DeepModelTy, v: MutBorrow.t t_V. get (view'4 result) k
      = C_Some'1 v  -> get'0 (view'5 xs) k = C_Some'2 (v.current) /\ get'0 (view'0 xs.final) k = C_Some'2 (v.final)}
      {[@expl:roundtrip_hashmap_iter_mut ensures #1] [%#scollections'2] forall k: t_DeepModelTy, v: t_V. get'0 (view'5 xs) k
      = C_Some'2 v  -> contains'0 (view'4 result) k /\ (index_logic'0 (view'4 result) k).current = v}
      {[@expl:roundtrip_hashmap_iter_mut ensures #2] [%#scollections'3] forall k: t_DeepModelTy, v: t_V. get'0 (view'0 xs.final) k
      = C_Some'2 v  -> contains'0 (view'4 result) k /\ (index_logic'0 (view'4 result) k).final = v}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_into_iter [#"collections.rs" 66 0 66 90]
  let%span scollections = "collections.rs" 65 10 65 24
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 164 26 165 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span smodel = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 49 18 49 34
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 115 20 115 38
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 109 8 109 38
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 176 20 176 121
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 120 14 120 45
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 121 27 121 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 125 15 125 32
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 126 15 126 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 127 14 127 42
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 129 8 129 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_DeepModelTy
  
  function view (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  let rec into_iter (self_:t_HashSet'0) (return'  (x:t_IntoIter'1))= any
    [ return''0 (result:t_IntoIter'1)-> {[%#shash_set] view self_ = view'0 result} (! return' {result}) ]
  
  
  predicate resolve (_0: t_IntoIter'1) =
    true
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_IntoIter'1) (visited: Seq.seq t_T) (end': t_IntoIter'1) =
    [%#shash_set'9] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x: t_DeepModelTy. contains (view'0 start) x
     -> (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1) \/ contains (view'0 end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view'0 start) (deep_model x) /\ not contains (view'0 end') (deep_model x))
    /\ (forall x: t_DeepModelTy. contains (view'0 end') x
     -> contains (view'0 start) x /\ not (exists x1: t_T. deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
  
   =
    [%#shash_set'13] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. ([%#shash_set'10] set_produces a ab b)
   -> ([%#shash_set'11] set_produces b bc c)  -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_IntoIter'1) (visited: Seq.seq t_T) (o: t_IntoIter'1) =
    [%#shash_set'1] set_produces self visited o
  
  function produces_trans (a: t_IntoIter'1) (ab: Seq.seq t_T) (b: t_IntoIter'1) (bc: Seq.seq t_T) (c: t_IntoIter'1) : ()
   =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec: forall a: t_IntoIter'1, ab: Seq.seq t_T, b: t_IntoIter'1, bc: Seq.seq t_T, c: t_IntoIter'1. ([%#shash_set'5] produces a ab b)
   -> ([%#shash_set'6] produces b bc c)  -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_IntoIter'1) : () =
    [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_IntoIter'1. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  function view'1 (self: MutBorrow.t t_IntoIter'1) : Fset.fset t_DeepModelTy =
    [%#smodel] view'0 self.current
  
  predicate completed (self: MutBorrow.t t_IntoIter'1) =
    [%#shash_set'0] Fset.is_empty (view'1 self)
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    [%#shash_set'2] forall x: t_DeepModelTy. contains (view res) x
    = (exists x1: t_T. deep_model x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_:t_IntoIter'1) (return'  (x:t_HashSet'0))= any
    [ return''0 (result:t_HashSet'0)-> {[%#siter] exists done': MutBorrow.t t_IntoIter'1, prod: Seq.seq t_T. resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_into_iter[#"collections.rs" 66 0 66 90] (xs:t_HashSet'0) (return'  (x:t_HashSet'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter {xs'0} (fun (_ret:t_IntoIter'1) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {_3} (fun (_ret:t_HashSet'0) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    ) [ & _0: t_HashSet'0 = Any.any_l () | & xs'0: t_HashSet'0 = xs | & _3: t_IntoIter'1 = Any.any_l () ] 
    [ return''0 (result:t_HashSet'0)-> {[@expl:roundtrip_hashset_into_iter ensures] [%#scollections] view result
      = view xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_iter [#"collections.rs" 71 0 71 87]
  let%span scollections = "collections.rs" 70 10 70 24
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 164 26 165 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span smodel = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 24 30 24 46
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 154 20 154 38
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 148 8 148 38
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 176 20 176 121
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 159 14 159 45
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 160 27 160 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 164 15 164 32
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 165 15 165 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 166 14 166 42
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 168 8 168 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_DeepModelTy
  
  function view (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet'0) : Fset.fset t_DeepModelTy =
    [%#smodel] view self
  
  function view'1 (self: t_Iter'1) : Fset.fset t_DeepModelTy
  
  let rec iter (self_:t_HashSet'0) (return'  (x:t_Iter'1))= any
    [ return''0 (result:t_Iter'1)-> {[%#shash_set] view'0 self_ = view'1 result} (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'2  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  predicate resolve (_0: t_Iter'1) =
    true
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 (self: t_T) : t_DeepModelTy =
    [%#smodel'1] deep_model self
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Iter'1) (visited: Seq.seq t_T) (end': t_Iter'1) =
    [%#shash_set'9] Fset.cardinal (view'1 start) = Seq.length visited + Fset.cardinal (view'1 end')
    /\ (forall x: t_DeepModelTy. contains (view'1 start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view'1 end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view'1 start) (deep_model'0 x) /\ not contains (view'1 end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view'1 end') x
     -> contains (view'1 start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : () =
    [%#shash_set'13] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. ([%#shash_set'10] set_produces a ab b)
   -> ([%#shash_set'11] set_produces b bc c)  -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_Iter'1) (visited: Seq.seq t_T) (o: t_Iter'1) =
    [%#shash_set'1] set_produces self visited o
  
  function produces_trans (a: t_Iter'1) (ab: Seq.seq t_T) (b: t_Iter'1) (bc: Seq.seq t_T) (c: t_Iter'1) : () =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec: forall a: t_Iter'1, ab: Seq.seq t_T, b: t_Iter'1, bc: Seq.seq t_T, c: t_Iter'1. ([%#shash_set'5] produces a ab b)
   -> ([%#shash_set'6] produces b bc c)  -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Iter'1) : () =
    [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_Iter'1. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  function view'2 (self: MutBorrow.t t_Iter'1) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view'1 self.current
  
  predicate completed (self: MutBorrow.t t_Iter'1) =
    [%#shash_set'0] Fset.is_empty (view'2 self)
  
  function view'3 (self: t_HashSet'2) : Fset.fset t_DeepModelTy
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'2) =
    [%#shash_set'2] forall x: t_DeepModelTy. contains (view'3 res) x
    = (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_:t_Iter'1) (return'  (x:t_HashSet'2))= any
    [ return''0 (result:t_HashSet'2)-> {[%#siter] exists done': MutBorrow.t t_Iter'1, prod: Seq.seq t_T. resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_iter[#"collections.rs" 71 0 71 87] (xs:t_HashSet'0) (return'  (x:t_HashSet'2))= (! bb0
    [ bb0 = s0 [ s0 = iter {xs'0} (fun (_ret:t_Iter'1) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret:t_HashSet'2) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0: t_HashSet'2 = Any.any_l () | & xs'0: t_HashSet'0 = xs | & _3: t_Iter'1 = Any.any_l () ] 
    [ return''0 (result:t_HashSet'2)-> {[@expl:roundtrip_hashset_iter ensures] [%#scollections] view'3 result
      = view'0 xs}
      (! return' {result}) ]

end
module M_collections__hashset_intersection [#"collections.rs" 76 0 79 15]
  let%span scollections = "collections.rs" 75 10 75 42
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 115 26 115 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 164 26 165 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 32 30 32 67
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 176 20 176 121
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 212 20 212 56
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 206 8 206 38
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 217 14 217 45
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 218 27 218 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 222 15 222 32
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 223 15 223 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 224 14 224 42
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 226 8 226 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span scopied = "../../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  let%span scopied'0 = "../../../creusot-contracts/src/std/iter/copied.rs" 42 12 42 104
  let%span scopied'1 = "../../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'2 = "../../../creusot-contracts/src/std/iter/copied.rs" 23 8 23 29
  let%span scopied'3 = "../../../creusot-contracts/src/std/iter/copied.rs" 58 14 58 45
  let%span scopied'4 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied'5 = "../../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied'6 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self: t_Intersection) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'1 (self: t_HashSet'0) : Fset.fset t_DeepModelTy =
    [%#smodel] view'0 self
  
  let rec intersection (self_:t_HashSet'0) (other:t_HashSet'0) (return'  (x:t_Intersection))= any
    [ return''0 (result:t_Intersection)-> {[%#shash_set] view result = Fset.inter (view'1 self_) (view'1 other)}
      (! return' {result}) ]
  
  
  type t_Copied  =
    { t_Copied__it: t_Intersection }
  
  predicate inv (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv x]. inv x = true
  
  predicate inv'0 (_0: t_Intersection)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Intersection [inv'0 x]. inv'0 x = true
  
  function iter (self: t_Copied) : t_Intersection
  
  axiom iter_spec: forall self: t_Copied. [%#scopied] inv self  -> inv'0 (iter self)
  
  let rec copied (self_:t_Intersection) (return'  (x:t_Copied))= any
    [ return''0 (result:t_Copied)-> {[%#siter] iter result = self_} (! return' {result}) ]
  
  
  predicate resolve (_0: t_Intersection) =
    true
  
  predicate resolve'0 (self: t_Copied) =
    [%#scopied'2] resolve (iter self)
  
  predicate resolve'1 (_0: t_Copied) =
    resolve'0 _0
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 (self: t_T) : t_DeepModelTy =
    [%#smodel'1] deep_model self
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Intersection) (visited: Seq.seq t_T) (end': t_Intersection) =
    [%#shash_set'9] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
  
   =
    [%#shash_set'13] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. ([%#shash_set'10] set_produces a ab b)
   -> ([%#shash_set'11] set_produces b bc c)  -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_Intersection) (visited: Seq.seq t_T) (o: t_Intersection) =
    [%#shash_set'2] set_produces self visited o
  
  function produces_trans (a: t_Intersection) (ab: Seq.seq t_T) (b: t_Intersection) (bc: Seq.seq t_T) (c: t_Intersection) : ()
  
   =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec: forall a: t_Intersection, ab: Seq.seq t_T, b: t_Intersection, bc: Seq.seq t_T, c: t_Intersection. ([%#shash_set'5] produces a ab b)
   -> ([%#shash_set'6] produces b bc c)  -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Intersection) : () =
    [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_Intersection. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    [%#scopied'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0: forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. ([%#scopied'4] produces'0 a ab b)
   -> ([%#scopied'5] produces'0 b bc c)  -> ([%#scopied'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. [%#scopied'3] produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 (self: MutBorrow.t t_Intersection) =
    [%#sresolve] self.final = self.current
  
  function view'2 (self: MutBorrow.t t_Intersection) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view self.current
  
  predicate completed (self: MutBorrow.t t_Intersection) =
    [%#shash_set'1] resolve'2 self /\ Fset.is_empty (view'2 self)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    [%#scopied'0] exists inner: MutBorrow.t t_Intersection. inner.current = iter self.current
    /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    [%#shash_set'0] forall x: t_DeepModelTy. contains (view'0 res) x
    = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_:t_Copied) (return'  (x:t_HashSet'0))= any
    [ return''0 (result:t_HashSet'0)-> {[%#siter'0] exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec hashset_intersection[#"collections.rs" 76 0 79 15] (xs:t_HashSet'0) (ys:t_HashSet'0) (return'  (x:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = intersection {xs'0} {ys'0} (fun (_ret:t_Intersection) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret:t_Copied) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret:t_HashSet'0) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = return''0 {_0} ]
    )
    [ & _0: t_HashSet'0 = Any.any_l ()
    | & xs'0: t_HashSet'0 = xs
    | & ys'0: t_HashSet'0 = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Intersection = Any.any_l () ]
    
    [ return''0 (result:t_HashSet'0)-> {[@expl:hashset_intersection ensures] [%#scollections] view'0 result
      = Fset.inter (view'1 xs) (view'1 ys)}
      (! return' {result}) ]

end
module M_collections__hashset_difference [#"collections.rs" 84 0 87 15]
  let%span scollections = "collections.rs" 83 10 83 40
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 115 26 115 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 164 26 165 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 71
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 35 8 35 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 35 30 35 65
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 176 20 176 121
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 240 20 240 56
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 234 8 234 38
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 245 14 245 45
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 246 27 246 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 250 15 250 32
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 251 15 251 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 252 14 252 42
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 254 8 254 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 77 16 84 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 11 90 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 91 11 91 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 92 10 92 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 100 4 100 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span scopied = "../../../creusot-contracts/src/std/iter/copied.rs" 13 14 13 39
  let%span scopied'0 = "../../../creusot-contracts/src/std/iter/copied.rs" 42 12 42 104
  let%span scopied'1 = "../../../creusot-contracts/src/std/iter/copied.rs" 50 12 53 74
  let%span scopied'2 = "../../../creusot-contracts/src/std/iter/copied.rs" 23 8 23 29
  let%span scopied'3 = "../../../creusot-contracts/src/std/iter/copied.rs" 58 14 58 45
  let%span scopied'4 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied'5 = "../../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied'6 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self: t_Difference) : Fset.fset t_DeepModelTy
  
  function view'0 (self: t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'1 (self: t_HashSet'0) : Fset.fset t_DeepModelTy =
    [%#smodel] view'0 self
  
  let rec difference (self_:t_HashSet'0) (other:t_HashSet'0) (return'  (x:t_Difference))= any
    [ return''0 (result:t_Difference)-> {[%#shash_set] view result = Fset.diff (view'1 self_) (view'1 other)}
      (! return' {result}) ]
  
  
  type t_Copied  =
    { t_Copied__it: t_Difference }
  
  predicate inv (_0: t_Copied)
  
  axiom inv_axiom [@rewrite]: forall x: t_Copied [inv x]. inv x = true
  
  predicate inv'0 (_0: t_Difference)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Difference [inv'0 x]. inv'0 x = true
  
  function iter (self: t_Copied) : t_Difference
  
  axiom iter_spec: forall self: t_Copied. [%#scopied] inv self  -> inv'0 (iter self)
  
  let rec copied (self_:t_Difference) (return'  (x:t_Copied))= any
    [ return''0 (result:t_Copied)-> {[%#siter] iter result = self_} (! return' {result}) ]
  
  
  predicate resolve (_0: t_Difference) =
    true
  
  predicate resolve'0 (self: t_Copied) =
    [%#scopied'2] resolve (iter self)
  
  predicate resolve'1 (_0: t_Copied) =
    resolve'0 _0
  
  type t_T
  
  predicate contains [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self: t_T) : t_DeepModelTy
  
  function deep_model'0 (self: t_T) : t_DeepModelTy =
    [%#smodel'1] deep_model self
  
  predicate contains'0 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start: t_Difference) (visited: Seq.seq t_T) (end': t_Difference) =
    [%#shash_set'9] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x: t_DeepModelTy. contains (view start) x
     -> (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x: t_T. contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x: t_DeepModelTy. contains (view end') x
     -> contains (view start) x /\ not (exists x1: t_T. deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i: int, j: int. 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  constant concat_contains: () = [%#sseq'1] ()
  
  axiom concat_contains_spec: [%#sseq'0] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
  
   =
    [%#shash_set'13] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec: forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. ([%#shash_set'10] set_produces a ab b)
   -> ([%#shash_set'11] set_produces b bc c)  -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self: t_Difference) (visited: Seq.seq t_T) (o: t_Difference) =
    [%#shash_set'2] set_produces self visited o
  
  function produces_trans (a: t_Difference) (ab: Seq.seq t_T) (b: t_Difference) (bc: Seq.seq t_T) (c: t_Difference) : ()
   =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec: forall a: t_Difference, ab: Seq.seq t_T, b: t_Difference, bc: Seq.seq t_T, c: t_Difference. ([%#shash_set'5] produces a ab b)
   -> ([%#shash_set'6] produces b bc c)  -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self: t_Difference) : () =
    [%#shash_set'4] ()
  
  axiom produces_refl_spec: forall self: t_Difference. [%#shash_set'3] produces self (Seq.empty: Seq.seq t_T) self
  
  predicate produces'0 (self: t_Copied) (visited: Seq.seq t_T) (o: t_Copied) =
    [%#scopied'1] exists s: Seq.seq t_T. produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i: int. 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a: t_Copied) (ab: Seq.seq t_T) (b: t_Copied) (bc: Seq.seq t_T) (c: t_Copied) : ()
  
  axiom produces_trans_spec'0: forall a: t_Copied, ab: Seq.seq t_T, b: t_Copied, bc: Seq.seq t_T, c: t_Copied. ([%#scopied'4] produces'0 a ab b)
   -> ([%#scopied'5] produces'0 b bc c)  -> ([%#scopied'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self: t_Copied) : ()
  
  axiom produces_refl_spec'0: forall self: t_Copied. [%#scopied'3] produces'0 self (Seq.empty: Seq.seq t_T) self
  
  predicate resolve'2 (self: MutBorrow.t t_Difference) =
    [%#sresolve] self.final = self.current
  
  function view'2 (self: MutBorrow.t t_Difference) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view self.current
  
  predicate completed (self: MutBorrow.t t_Difference) =
    [%#shash_set'1] resolve'2 self /\ Fset.is_empty (view'2 self)
  
  predicate completed'0 (self: MutBorrow.t t_Copied) =
    [%#scopied'0] exists inner: MutBorrow.t t_Difference. inner.current = iter self.current
    /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self: Seq.seq t_T) (x: t_T) =
    [%#sseq] exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod: Seq.seq t_T) (res: t_HashSet'0) =
    [%#shash_set'0] forall x: t_DeepModelTy. contains (view'0 res) x
    = (exists x1: t_T. deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_:t_Copied) (return'  (x:t_HashSet'0))= any
    [ return''0 (result:t_HashSet'0)-> {[%#siter'0] exists done': MutBorrow.t t_Copied, prod: Seq.seq t_T. resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec hashset_difference[#"collections.rs" 84 0 87 15] (xs:t_HashSet'0) (ys:t_HashSet'0) (return'  (x:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = difference {xs'0} {ys'0} (fun (_ret:t_Difference) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret:t_Copied) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret:t_HashSet'0) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = return''0 {_0} ]
    )
    [ & _0: t_HashSet'0 = Any.any_l ()
    | & xs'0: t_HashSet'0 = xs
    | & ys'0: t_HashSet'0 = ys
    | & _4: t_Copied = Any.any_l ()
    | & _5: t_Difference = Any.any_l () ]
    
    [ return''0 (result:t_HashSet'0)-> {[@expl:hashset_difference ensures] [%#scollections] view'0 result
      = Fset.diff (view'1 xs) (view'1 ys)}
      (! return' {result}) ]

end
