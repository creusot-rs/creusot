module M_collections__roundtrip_hashmap_into_iter [#"collections.rs" 15 0 17 18]
  let%span scollections = "collections.rs" 18 18 18 31
  let%span scollections'0 = "collections.rs" 20 14 20 30
  let%span scollections'1 = "collections.rs" 23 8 26 80
  let%span scollections'2 = "collections.rs" 28 20 28 87
  let%span scollections'3 = "collections.rs" 29 20 29 69
  let%span scollections'4 = "collections.rs" 14 10 14 24
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span siter'1 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 73 20 73 54
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 56 12 66 29
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 199 20 199 24
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 205 20 205 33
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 78 14 78 45
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 79 27 79 29
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 83 15 83 32
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 84 15 84 32
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 85 14 85 42
  let%span shash_map'9 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 87 8 87 104
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sutil = "../../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 56 10 56 28
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__base: t_IntoIter }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0  =
    { t_HashMap__base: t_HashMap }
  
  predicate into_iter_pre (self : t_HashMap'0) =
    [%#shash_map'1] true
  
  type t_FMap
  
  function view (self : t_HashMap'0) : t_FMap
  
  function view'0 (self : t_IntoIter'0) : t_FMap
  
  predicate into_iter_post (self : t_HashMap'0) (res : t_IntoIter'0) =
    [%#shash_map'2] view self = view'0 res
  
  let rec into_iter (self_:t_HashMap'0) (return'  (x:t_IntoIter'0))= {[@expl:into_iter requires] [%#siter] into_iter_pre self_}
    any [ return''0 (result:t_IntoIter'0)-> {[%#siter'0] into_iter_post self_ result} (! return' {result}) ] 
  
  predicate resolve (_0 : t_IntoIter'0) =
    true
  
  type t_K
  
  type t_V
  
  type tuple'0  =
    { _p0'0: t_K; _p1'0: t_V }
  
  function len (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap'3] len self >= 0
  
  predicate contains (self : Seq.seq tuple'0) (x : tuple'0) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  function view'1 (self : t_FMap) : Map.map t_DeepModelTy t_Option'1
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'11] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_Option'1 =
    [%#sfmap'4] Map.get (view'1 self) k
  
  function get [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0 =
    [%#sfmap] match get_unsized self k with
      | C_None'1 -> C_None'0
      | C_Some'1 x -> C_Some'0 x
      end
  
  function deep_model (self : t_K) : t_DeepModelTy
  
  predicate produces (self : t_IntoIter'0) (visited : Seq.seq tuple'0) (o : t_IntoIter'0) =
    [%#shash_map'0] len (view'0 self) = Seq.length visited + len (view'0 o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0'0 = k; _p1'0 = v }
     -> get (view'0 self) (deep_model k) = C_Some'0 v /\ get (view'0 o) (deep_model k) = C_None'0)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view'0 o) k = C_Some'0 v
     -> get (view'0 self) k = C_Some'0 v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model k2 = k /\ contains visited { _p0'0 = k2; _p1'0 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view'0 self) k = C_Some'0 v
     -> (exists k1 : t_K . deep_model k1 = k /\ contains visited { _p0'0 = k1; _p1'0 = v })
    \/ get (view'0 o) k = C_Some'0 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model (Seq.get visited i1)._p0'0 = deep_model (Seq.get visited i2)._p0'0
     -> i1 = i2)
  
  function produces_trans (a : t_IntoIter'0) (ab : Seq.seq tuple'0) (b : t_IntoIter'0) (bc : Seq.seq tuple'0) (c : t_IntoIter'0) : ()
  
   =
    [%#shash_map'9] let _ = () in ()
  
  axiom produces_trans_spec : forall a : t_IntoIter'0, ab : Seq.seq tuple'0, b : t_IntoIter'0, bc : Seq.seq tuple'0, c : t_IntoIter'0 . ([%#shash_map'6] produces a ab b)
   -> ([%#shash_map'7] produces b bc c)  -> ([%#shash_map'8] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_IntoIter'0) : () =
    [%#shash_map'5] ()
  
  axiom produces_refl_spec : forall self : t_IntoIter'0 . [%#shash_map'4] produces self (Seq.empty : Seq.seq tuple'0) self
  
  predicate resolve'0 (self : MutBorrow.t t_IntoIter'0) =
    [%#sresolve] self.final = self.current
  
  function ext_eq (self : t_FMap) (other : t_FMap) : bool =
    [%#sfmap'8] view'1 self = view'1 other
  
  axiom ext_eq_spec : forall self : t_FMap, other : t_FMap . ([%#sfmap'6] ext_eq self other  -> self = other)
  && ([%#sfmap'7] (forall k : t_DeepModelTy . get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  function empty  : t_FMap
  
  axiom empty_spec : ([%#sfmap'9] len empty = 0) && ([%#sfmap'10] view'1 empty = Const.const (C_None'1))
  
  function is_empty (self : t_FMap) : bool =
    [%#sfmap'2] ext_eq self empty
  
  function view'2 (self : MutBorrow.t t_IntoIter'0) : t_FMap =
    [%#smodel] view'0 self.current
  
  predicate completed (self : MutBorrow.t t_IntoIter'0) =
    [%#shash_map] resolve'0 self /\ is_empty (view'2 self)
  
  predicate from_iter_post (prod : Seq.seq tuple'0) (res : t_HashMap'0) =
    [%#shash_map'3] forall k : t_DeepModelTy, v : t_V . (get (view res) k = C_Some'0 v)
    = (exists i : int, k1 : t_K . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model k1 = k
    /\ Seq.get prod i = { _p0'0 = k1; _p1'0 = v }
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model (Seq.get prod j)._p0'0 <> k))
  
  let rec collect (self_:t_IntoIter'0) (return'  (x:t_HashMap'0))= any
    [ return''0 (result:t_HashMap'0)-> {[%#siter'1] exists done' : MutBorrow.t t_IntoIter'0, prod : Seq.seq tuple'0 . resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  function contains'0 [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : bool =
    [%#sfmap'0] get_unsized self k <> C_None'1
  
  function unwrap (op : t_Option'1) : t_V
  
  axiom unwrap_spec : forall op : t_Option'1 . ([%#sutil] op <> C_None'1)  -> ([%#sutil'0] C_Some'1 (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_V =
    [%#sfmap'12] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_V =
    [%#sfmap'5] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self : t_FMap) (key : t_DeepModelTy) : t_V =
    [%#sfmap'1] lookup self key
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_into_iter[#"collections.rs" 15 0 17 18] (xs:t_HashMap'0) (return'  (x:t_HashMap'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 =  [ &xs_snap <- [%#scollections] xs'0 ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = into_iter {xs'0} (fun (_ret:t_IntoIter'0) ->  [ &it <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &it0 <- [%#scollections'0] it ] s1 | s1 = bb4 ] 
    | bb4 = s0 [ s0 = collect {it} (fun (_ret:t_HashMap'0) ->  [ &r <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:assertion] [%#scollections'1] exists prod : Seq.seq tuple'0, it1 : MutBorrow.t t_IntoIter'0 . completed it1
        /\ produces it0 prod it1.current
        /\ (forall k : t_DeepModelTy, v : t_V . get (view r) k = C_Some'0 v
         -> (exists k1 : t_K . deep_model k1 = k /\ contains prod { _p0'0 = k1; _p1'0 = v }))}
        s1
      | s1 = bb6 ]
    
    | bb6 = s0
      [ s0 = {[@expl:assertion] [%#scollections'2] forall k : t_DeepModelTy . contains'0 (view r) k
        = contains'0 (view xs_snap) k}
        s1
      | s1 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:assertion] [%#scollections'3] forall k : t_DeepModelTy . index_logic (view r) k
        = index_logic (view xs_snap) k}
        s1
      | s1 = bb8 ]
    
    | bb8 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb9 ] 
    | bb9 = bb10
    | bb10 = bb11
    | bb11 = return''0 {_0} ]
    )
    [ & _0 : t_HashMap'0 = Any.any_l ()
    | & xs'0 : t_HashMap'0 = xs
    | & xs_snap : t_HashMap'0 = Any.any_l ()
    | & it : t_IntoIter'0 = Any.any_l ()
    | & it0 : t_IntoIter'0 = Any.any_l ()
    | & r : t_HashMap'0 = Any.any_l () ]
    
    [ return''0 (result:t_HashMap'0)-> {[@expl:roundtrip_hashmap_into_iter ensures] [%#scollections'4] view result
      = view xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter [#"collections.rs" 34 0 34 97]
  let%span scollections = "collections.rs" 36 14 36 30
  let%span scollections'0 = "collections.rs" 40 4 43 77
  let%span scollections'1 = "collections.rs" 33 10 33 98
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 28 30 28 46
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 125 20 125 54
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 108 12 118 29
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 130 14 130 45
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 131 27 131 29
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 135 15 135 32
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 136 15 136 32
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 137 14 137 42
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 139 8 139 104
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Iter'0  =
    { t_Iter__base: t_Iter }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0  =
    { t_HashMap__base: t_HashMap }
  
  type t_FMap
  
  function view (self : t_HashMap'0) : t_FMap
  
  function view'0 (self : t_HashMap'0) : t_FMap =
    [%#smodel'0] view self
  
  function view'1 (self : t_Iter'0) : t_FMap
  
  let rec iter (self_:t_HashMap'0) (return'  (x:t_Iter'0))= any
    [ return''0 (result:t_Iter'0)-> {[%#shash_map] view'0 self_ = view'1 result} (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2  =
    { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve (_0 : t_Iter'0) =
    true
  
  type t_K
  
  type t_V
  
  type tuple  =
    { _p0: t_K; _p1: t_V }
  
  function len (self : t_FMap) : int
  
  axiom len_spec : forall self : t_FMap . [%#sfmap'1] len self >= 0
  
  predicate contains (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 t_V
  
  function view'2 (self : t_FMap) : Map.map t_DeepModelTy t_Option'0
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'8] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view'2 m1 <> view'2 m2
  
  function get_unsized [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_Option'0 =
    [%#sfmap'2] Map.get (view'2 self) k
  
  function get [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_Option =
    [%#sfmap] match get_unsized self k with
      | C_None'0 -> C_None
      | C_Some'0 x -> C_Some x
      end
  
  function deep_model (self : t_K) : t_DeepModelTy
  
  function deep_model'0 (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces (self : t_Iter'0) (visited : Seq.seq tuple) (o : t_Iter'0) =
    [%#shash_map'1] len (view'1 self) = Seq.length visited + len (view'1 o)
    /\ (forall k : t_K, v : t_V . contains visited { _p0 = k; _p1 = v }
     -> get (view'1 self) (deep_model'0 k) = C_Some v /\ get (view'1 o) (deep_model'0 k) = C_None)
    /\ (forall k : t_DeepModelTy, v : t_V . get (view'1 o) k = C_Some v
     -> get (view'1 self) k = C_Some v
    /\ not (exists k2 : t_K, v2 : t_V . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : t_V . get (view'1 self) k = C_Some v
     -> (exists k2 : t_K . deep_model'0 k2 = k /\ contains visited { _p0 = k2; _p1 = v })
    \/ get (view'1 o) k = C_Some v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  function produces_trans (a : t_Iter'0) (ab : Seq.seq tuple) (b : t_Iter'0) (bc : Seq.seq tuple) (c : t_Iter'0) : () =
    [%#shash_map'8] let _ = () in ()
  
  axiom produces_trans_spec : forall a : t_Iter'0, ab : Seq.seq tuple, b : t_Iter'0, bc : Seq.seq tuple, c : t_Iter'0 . ([%#shash_map'5] produces a ab b)
   -> ([%#shash_map'6] produces b bc c)  -> ([%#shash_map'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_Iter'0) : () =
    [%#shash_map'4] ()
  
  axiom produces_refl_spec : forall self : t_Iter'0 . [%#shash_map'3] produces self (Seq.empty : Seq.seq tuple) self
  
  predicate resolve'0 (self : MutBorrow.t t_Iter'0) =
    [%#sresolve] self.final = self.current
  
  function ext_eq (self : t_FMap) (other : t_FMap) : bool =
    [%#sfmap'5] view'2 self = view'2 other
  
  axiom ext_eq_spec : forall self : t_FMap, other : t_FMap . ([%#sfmap'3] ext_eq self other  -> self = other)
  && ([%#sfmap'4] (forall k : t_DeepModelTy . get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  function empty  : t_FMap
  
  axiom empty_spec : ([%#sfmap'6] len empty = 0) && ([%#sfmap'7] view'2 empty = Const.const (C_None'0))
  
  function is_empty (self : t_FMap) : bool =
    [%#sfmap'0] ext_eq self empty
  
  function view'3 (self : MutBorrow.t t_Iter'0) : t_FMap =
    [%#smodel'1] view'1 self.current
  
  predicate completed (self : MutBorrow.t t_Iter'0) =
    [%#shash_map'0] resolve'0 self /\ is_empty (view'3 self)
  
  type t_FMap'0
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 t_V
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function view'4 (self : t_FMap'0) : Map.map t_DeepModelTy t_Option'2
  
  axiom view_spec'0 : forall self : t_FMap'0 . [%#sfmap'8] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'4 m1 <> view'4 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy) : t_Option'2 =
    [%#sfmap'2] Map.get (view'4 self) k
  
  function get'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy) : t_Option'1 =
    [%#sfmap] match get_unsized'0 self k with
      | C_None'2 -> C_None'1
      | C_Some'2 x -> C_Some'1 x
      end
  
  function view'5 (self : t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod : Seq.seq tuple) (res : t_HashMap'2) =
    [%#shash_map'2] forall k : t_DeepModelTy, v : t_V . (get'0 (view'5 res) k = C_Some'1 v)
    = (exists i : int, k1 : t_K . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = { _p0 = k1; _p1 = v }
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (Seq.get prod j)._p0 <> k))
  
  let rec collect (self_:t_Iter'0) (return'  (x:t_HashMap'2))= any
    [ return''0 (result:t_HashMap'2)-> {[%#siter] exists done' : MutBorrow.t t_Iter'0, prod : Seq.seq tuple . resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter[#"collections.rs" 34 0 34 97] (xs:t_HashMap'0) (return'  (x:t_HashMap'2))= (! bb0
    [ bb0 = s0 [ s0 = iter {xs'0} (fun (_ret:t_Iter'0) ->  [ &it <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections] it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {it} (fun (_ret:t_HashMap'2) ->  [ &r <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections'0] exists prod : Seq.seq tuple, it1 : MutBorrow.t t_Iter'0 . completed it1
        /\ produces it0 prod it1.current
        /\ (forall k : t_DeepModelTy, v : t_V . get'0 (view'5 r) k = C_Some'1 v
         -> (exists k1 : t_K . deep_model'0 k1 = k /\ contains prod { _p0 = k1; _p1 = v }))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = return''0 {_0} ]
    )
    [ & _0 : t_HashMap'2 = Any.any_l ()
    | & xs'0 : t_HashMap'0 = xs
    | & it : t_Iter'0 = Any.any_l ()
    | & it0 : t_Iter'0 = Any.any_l ()
    | & r : t_HashMap'2 = Any.any_l () ]
    
    [ return''0 (result:t_HashMap'2)-> {[@expl:roundtrip_hashmap_iter ensures] [%#scollections'1] forall k : t_DeepModelTy, v : t_V . (get'0 (view'5 result) k
      = C_Some'1 v)
      = (get (view'0 xs) k = C_Some v)}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashmap_iter_mut [#"collections.rs" 50 0 52 24]
  let%span scollections = "collections.rs" 54 14 54 30
  let%span scollections'0 = "collections.rs" 57 8 60 81
  let%span scollections'1 = "collections.rs" 47 10 47 128
  let%span scollections'2 = "collections.rs" 48 10 48 107
  let%span scollections'3 = "collections.rs" 49 10 49 110
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span shash_map = "../../../creusot-contracts/src/std/collections/hash_map.rs" 31 30 31 57
  let%span shash_map'0 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 177 20 177 54
  let%span shash_map'1 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 160 12 170 29
  let%span shash_map'2 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 233 20 235 112
  let%span shash_map'3 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 245 20 247 86
  let%span shash_map'4 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 182 14 182 45
  let%span shash_map'5 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 183 27 183 29
  let%span shash_map'6 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 187 15 187 32
  let%span shash_map'7 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 188 15 188 32
  let%span shash_map'8 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 189 14 189 42
  let%span shash_map'9 = "../../../creusot-contracts/src/std/collections/hash_map.rs" 191 8 191 104
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 229 8 229 24
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span sutil = "../../../creusot-contracts/src/util.rs" 55 11 55 21
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 56 10 56 28
  
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use creusot.int.UInt16
  use map.Map
  use seq.Seq
  use mach.int.Int
  use map.Const
  use creusot.prelude.Any
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashMap'0  =
    { t_HashMap__base: t_HashMap }
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull'0 }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_IterMut  =
    { t_IterMut__inner: t_RawIter; t_IterMut__marker: () }
  
  type t_IterMut'0  =
    { t_IterMut__base: t_IterMut }
  
  type t_FMap
  
  type t_DeepModelTy
  
  type t_V
  
  type t_Option  =
    | C_None
    | C_Some t_V
  
  function view (self : t_FMap) : Map.map t_DeepModelTy t_Option
  
  axiom view_spec : forall self : t_FMap . [%#sfmap'11] forall m1 : t_FMap, m2 : t_FMap . m1 <> m2
   -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_Option =
    [%#sfmap'4] Map.get (view self) k
  
  function contains [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : bool =
    [%#sfmap'0] get_unsized self k <> C_None
  
  function view'0 (self : t_HashMap'0) : t_FMap
  
  type t_FMap'0
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 (MutBorrow.t t_V)
  
  function view'1 (self : t_FMap'0) : Map.map t_DeepModelTy t_Option'0
  
  axiom view_spec'0 : forall self : t_FMap'0 . [%#sfmap'11] forall m1 : t_FMap'0, m2 : t_FMap'0 . m1 <> m2
   -> view'1 m1 <> view'1 m2
  
  function get_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy) : t_Option'0 =
    [%#sfmap'4] Map.get (view'1 self) k
  
  function contains'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy) : bool =
    [%#sfmap'0] get_unsized'0 self k <> C_None'0
  
  function view'2 (self : t_IterMut'0) : t_FMap'0
  
  function unwrap (op : t_Option) : t_V
  
  axiom unwrap_spec : forall op : t_Option . ([%#sutil] op <> C_None)  -> ([%#sutil'0] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_V =
    [%#sfmap'12] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_V =
    [%#sfmap'5] lookup_unsized self k
  
  function index_logic [@inline:trivial] (self : t_FMap) (key : t_DeepModelTy) : t_V =
    [%#sfmap'1] lookup self key
  
  function unwrap'0 (op : t_Option'0) : MutBorrow.t t_V
  
  axiom unwrap_spec'0 : forall op : t_Option'0 . ([%#sutil] op <> C_None'0)
   -> ([%#sutil'0] C_Some'0 (unwrap'0 op) = op)
  
  function lookup_unsized'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'12] unwrap'0 (get_unsized'0 self k)
  
  function lookup'0 [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'5] lookup_unsized'0 self k
  
  function index_logic'0 [@inline:trivial] (self : t_FMap'0) (key : t_DeepModelTy) : MutBorrow.t t_V =
    [%#sfmap'1] lookup'0 self key
  
  predicate into_iter_post (self : MutBorrow.t t_HashMap'0) (res : t_IterMut'0) =
    [%#shash_map'2] forall k : t_DeepModelTy . contains (view'0 self.current) k = contains (view'0 self.final) k
    /\ (forall k'0 : t_DeepModelTy . contains (view'0 self.current) k'0 = contains'0 (view'2 res) k'0)
    /\ (forall k'0 : t_DeepModelTy . contains (view'0 self.current) k'0
     -> index_logic (view'0 self.current) k'0 = (index_logic'0 (view'2 res) k'0).current
    /\ index_logic (view'0 self.final) k'0 = (index_logic'0 (view'2 res) k'0).final)
  
  let rec iter_mut (self_:MutBorrow.t t_HashMap'0) (return'  (x:t_IterMut'0))= any
    [ return''0 (result:t_IterMut'0)-> {[%#shash_map] into_iter_post self_ result} (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'1  =
    { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashMap'2  =
    { t_HashMap__base'0: t_HashMap'1 }
  
  predicate resolve (_0 : t_IterMut'0) =
    true
  
  type t_K
  
  type tuple  =
    { _p0: t_K; _p1: MutBorrow.t t_V }
  
  function len (self : t_FMap'0) : int
  
  axiom len_spec : forall self : t_FMap'0 . [%#sfmap'3] len self >= 0
  
  predicate contains'1 (self : Seq.seq tuple) (x : tuple) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t t_V)
  
  function get [@inline:trivial] (self : t_FMap'0) (k : t_DeepModelTy) : t_Option'1 =
    [%#sfmap] match get_unsized'0 self k with
      | C_None'0 -> C_None'1
      | C_Some'0 x -> C_Some'1 x
      end
  
  function deep_model (self : t_K) : t_DeepModelTy
  
  function deep_model'0 (self : t_K) : t_DeepModelTy =
    [%#smodel] deep_model self
  
  predicate produces (self : t_IterMut'0) (visited : Seq.seq tuple) (o : t_IterMut'0) =
    [%#shash_map'1] len (view'2 self) = Seq.length visited + len (view'2 o)
    /\ (forall k : t_K, v : MutBorrow.t t_V . contains'1 visited { _p0 = k; _p1 = v }
     -> get (view'2 self) (deep_model k) = C_Some'1 v /\ get (view'2 o) (deep_model k) = C_None'1)
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view'2 o) k = C_Some'1 v
     -> get (view'2 self) k = C_Some'1 v
    /\ not (exists k2 : t_K, v2 : MutBorrow.t t_V . deep_model'0 k2 = k /\ contains'1 visited { _p0 = k2; _p1 = v2 }))
    /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view'2 self) k = C_Some'1 v
     -> (exists k1 : t_K . deep_model'0 k1 = k /\ contains'1 visited { _p0 = k1; _p1 = v })
    \/ get (view'2 o) k = C_Some'1 v)
    /\ (forall i1 : int, i2 : int . 0 <= i1
    /\ i1 < Seq.length visited
    /\ 0 <= i2
    /\ i2 < Seq.length visited /\ deep_model'0 (Seq.get visited i1)._p0 = deep_model'0 (Seq.get visited i2)._p0
     -> i1 = i2)
  
  function produces_trans (a : t_IterMut'0) (ab : Seq.seq tuple) (b : t_IterMut'0) (bc : Seq.seq tuple) (c : t_IterMut'0) : ()
  
   =
    [%#shash_map'9] let _ = () in ()
  
  axiom produces_trans_spec : forall a : t_IterMut'0, ab : Seq.seq tuple, b : t_IterMut'0, bc : Seq.seq tuple, c : t_IterMut'0 . ([%#shash_map'6] produces a ab b)
   -> ([%#shash_map'7] produces b bc c)  -> ([%#shash_map'8] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_IterMut'0) : () =
    [%#shash_map'5] ()
  
  axiom produces_refl_spec : forall self : t_IterMut'0 . [%#shash_map'4] produces self (Seq.empty : Seq.seq tuple) self
  
  predicate resolve'0 (self : MutBorrow.t t_IterMut'0) =
    [%#sresolve] self.final = self.current
  
  function ext_eq (self : t_FMap'0) (other : t_FMap'0) : bool =
    [%#sfmap'8] view'1 self = view'1 other
  
  axiom ext_eq_spec : forall self : t_FMap'0, other : t_FMap'0 . ([%#sfmap'6] ext_eq self other  -> self = other)
  && ([%#sfmap'7] (forall k : t_DeepModelTy . get_unsized'0 self k = get_unsized'0 other k)  -> ext_eq self other)
  
  function empty  : t_FMap'0
  
  axiom empty_spec : ([%#sfmap'9] len empty = 0) && ([%#sfmap'10] view'1 empty = Const.const (C_None'0))
  
  function is_empty (self : t_FMap'0) : bool =
    [%#sfmap'2] ext_eq self empty
  
  function view'3 (self : MutBorrow.t t_IterMut'0) : t_FMap'0 =
    [%#smodel'0] view'2 self.current
  
  predicate completed (self : MutBorrow.t t_IterMut'0) =
    [%#shash_map'0] resolve'0 self /\ is_empty (view'3 self)
  
  function view'4 (self : t_HashMap'2) : t_FMap'0
  
  predicate from_iter_post (prod : Seq.seq tuple) (res : t_HashMap'2) =
    [%#shash_map'3] forall k : t_DeepModelTy, v : MutBorrow.t t_V . (get (view'4 res) k = C_Some'1 v)
    = (exists i : int, k1 : t_K . 0 <= i
    /\ i < Seq.length prod
    /\ deep_model'0 k1 = k
    /\ Seq.get prod i = { _p0 = k1; _p1 = v }
    /\ (forall j : int . i < j /\ j < Seq.length prod  -> deep_model'0 (Seq.get prod j)._p0 <> k))
  
  let rec collect (self_:t_IterMut'0) (return'  (x:t_HashMap'2))= any
    [ return''0 (result:t_HashMap'2)-> {[%#siter] exists done' : MutBorrow.t t_IterMut'0, prod : Seq.seq tuple . resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self : MutBorrow.t t_HashMap'0) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0 : MutBorrow.t t_HashMap'0) =
    resolve'1 _0
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 t_V
  
  function get'0 [@inline:trivial] (self : t_FMap) (k : t_DeepModelTy) : t_Option'2 =
    [%#sfmap] match get_unsized self k with
      | C_None -> C_None'2
      | C_Some x -> C_Some'2 x
      end
  
  function view'5 (self : MutBorrow.t t_HashMap'0) : t_FMap =
    [%#smodel'0] view'0 self.current
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashmap_iter_mut[#"collections.rs" 50 0 52 24] (xs:MutBorrow.t t_HashMap'0) (return'  (x:t_HashMap'2))= (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_HashMap'0> {xs'0.current} {MutBorrow.get_id xs'0}
          (fun (_ret:MutBorrow.t t_HashMap'0) ->  [ &_6 <- _ret ]  [ &xs'0 <- { xs'0 with current = _ret.final } ] s1)
      | s1 = iter_mut {_6} (fun (_ret:t_IterMut'0) ->  [ &it <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &it0 <- [%#scollections] it ] s1 | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {it} (fun (_ret:t_HashMap'2) ->  [ &r <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = s0
      [ s0 = {[@expl:assertion] [%#scollections'0] exists prod : Seq.seq tuple, it1 : MutBorrow.t t_IterMut'0 . completed it1
        /\ produces it0 prod it1.current
        /\ (forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view'4 r) k = C_Some'1 v
         -> (exists k1 : t_K . deep_model'0 k1 = k /\ contains'1 prod { _p0 = k1; _p1 = v }))}
        s1
      | s1 = bb4 ]
    
    | bb4 = s0 [ s0 =  [ &_0 <- r ] s1 | s1 = bb5 ] 
    | bb5 = s0 [ s0 = -{resolve'2 xs'0}- s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0 : t_HashMap'2 = Any.any_l ()
    | & xs'0 : MutBorrow.t t_HashMap'0 = xs
    | & it : t_IterMut'0 = Any.any_l ()
    | & _6 : MutBorrow.t t_HashMap'0 = Any.any_l ()
    | & it0 : t_IterMut'0 = Any.any_l ()
    | & r : t_HashMap'2 = Any.any_l () ]
    
    [ return''0 (result:t_HashMap'2)-> {[@expl:roundtrip_hashmap_iter_mut ensures #0] [%#scollections'1] forall k : t_DeepModelTy, v : MutBorrow.t t_V . get (view'4 result) k
      = C_Some'1 v  -> get'0 (view'5 xs) k = C_Some'2 (v.current) /\ get'0 (view'0 xs.final) k = C_Some'2 (v.final)}
      {[@expl:roundtrip_hashmap_iter_mut ensures #1] [%#scollections'2] forall k : t_DeepModelTy, v : t_V . get'0 (view'5 xs) k
      = C_Some'2 v  -> contains'0 (view'4 result) k /\ (index_logic'0 (view'4 result) k).current = v}
      {[@expl:roundtrip_hashmap_iter_mut ensures #2] [%#scollections'3] forall k : t_DeepModelTy, v : t_V . get'0 (view'0 xs.final) k
      = C_Some'2 v  -> contains'0 (view'4 result) k /\ (index_logic'0 (view'4 result) k).final = v}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_into_iter [#"collections.rs" 66 0 66 90]
  let%span scollections = "collections.rs" 65 10 65 24
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 206 27 206 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 207 26 207 53
  let%span siter'1 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span smodel = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 166 20 166 24
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 172 20 172 33
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 105 20 105 38
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 99 8 99 38
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 110 14 110 45
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 111 27 111 29
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 115 15 115 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 116 15 116 32
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 117 14 117 42
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 119 8 119 43
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set'14 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_AlignmentEnum  =
    | C_qy95zAlign1Shl0
    | C_qy95zAlign1Shl1
    | C_qy95zAlign1Shl2
    | C_qy95zAlign1Shl3
    | C_qy95zAlign1Shl4
    | C_qy95zAlign1Shl5
    | C_qy95zAlign1Shl6
    | C_qy95zAlign1Shl7
    | C_qy95zAlign1Shl8
    | C_qy95zAlign1Shl9
    | C_qy95zAlign1Shl10
    | C_qy95zAlign1Shl11
    | C_qy95zAlign1Shl12
    | C_qy95zAlign1Shl13
    | C_qy95zAlign1Shl14
    | C_qy95zAlign1Shl15
    | C_qy95zAlign1Shl16
    | C_qy95zAlign1Shl17
    | C_qy95zAlign1Shl18
    | C_qy95zAlign1Shl19
    | C_qy95zAlign1Shl20
    | C_qy95zAlign1Shl21
    | C_qy95zAlign1Shl22
    | C_qy95zAlign1Shl23
    | C_qy95zAlign1Shl24
    | C_qy95zAlign1Shl25
    | C_qy95zAlign1Shl26
    | C_qy95zAlign1Shl27
    | C_qy95zAlign1Shl28
    | C_qy95zAlign1Shl29
    | C_qy95zAlign1Shl30
    | C_qy95zAlign1Shl31
    | C_qy95zAlign1Shl32
    | C_qy95zAlign1Shl33
    | C_qy95zAlign1Shl34
    | C_qy95zAlign1Shl35
    | C_qy95zAlign1Shl36
    | C_qy95zAlign1Shl37
    | C_qy95zAlign1Shl38
    | C_qy95zAlign1Shl39
    | C_qy95zAlign1Shl40
    | C_qy95zAlign1Shl41
    | C_qy95zAlign1Shl42
    | C_qy95zAlign1Shl43
    | C_qy95zAlign1Shl44
    | C_qy95zAlign1Shl45
    | C_qy95zAlign1Shl46
    | C_qy95zAlign1Shl47
    | C_qy95zAlign1Shl48
    | C_qy95zAlign1Shl49
    | C_qy95zAlign1Shl50
    | C_qy95zAlign1Shl51
    | C_qy95zAlign1Shl52
    | C_qy95zAlign1Shl53
    | C_qy95zAlign1Shl54
    | C_qy95zAlign1Shl55
    | C_qy95zAlign1Shl56
    | C_qy95zAlign1Shl57
    | C_qy95zAlign1Shl58
    | C_qy95zAlign1Shl59
    | C_qy95zAlign1Shl60
    | C_qy95zAlign1Shl61
    | C_qy95zAlign1Shl62
    | C_qy95zAlign1Shl63
  
  type t_Alignment  =
    { t_Alignment__0: t_AlignmentEnum }
  
  type t_Layout  =
    { t_Layout__size: UInt64.t; t_Layout__align: t_Alignment }
  
  type tuple  =
    { _p0: t_NonNull'0; _p1: t_Layout; _p2: () }
  
  type t_Option  =
    | C_None
    | C_Some tuple
  
  type t_RawIntoIter  =
    { t_RawIntoIter__iter: t_RawIter; t_RawIntoIter__allocation: t_Option; t_RawIntoIter__marker: () }
  
  type t_IntoIter  =
    { t_IntoIter__inner: t_RawIntoIter }
  
  type t_IntoIter'0  =
    { t_IntoIter__iter: t_IntoIter }
  
  type t_IntoIter'1  =
    { t_IntoIter__base: t_IntoIter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  predicate into_iter_pre (self : t_HashSet'0) =
    [%#shash_set] true
  
  type t_DeepModelTy
  
  function view (self : t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 (self : t_IntoIter'1) : Fset.fset t_DeepModelTy
  
  predicate into_iter_post (self : t_HashSet'0) (res : t_IntoIter'1) =
    [%#shash_set'0] view self = view'0 res
  
  let rec into_iter (self_:t_HashSet'0) (return'  (x:t_IntoIter'1))= {[@expl:into_iter requires] [%#siter] into_iter_pre self_}
    any [ return''0 (result:t_IntoIter'1)-> {[%#siter'0] into_iter_post self_ result} (! return' {result}) ] 
  
  predicate resolve (_0 : t_IntoIter'1) =
    true
  
  type t_T
  
  predicate contains [@inline:trivial] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self : t_T) : t_DeepModelTy
  
  predicate contains'0 (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start : t_IntoIter'1) (visited : Seq.seq t_T) (end' : t_IntoIter'1) =
    [%#shash_set'10] Fset.cardinal (view'0 start) = Seq.length visited + Fset.cardinal (view'0 end')
    /\ (forall x : t_DeepModelTy . contains (view'0 start) x
     -> (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1) \/ contains (view'0 end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view'0 start) (deep_model x) /\ not contains (view'0 end') (deep_model x))
    /\ (forall x : t_DeepModelTy . contains (view'0 end') x
     -> contains (view'0 start) x /\ not (exists x1 : t_T . deep_model x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model (Seq.get visited i) = deep_model (Seq.get visited j)  -> i = j)
  
  function concat_contains  : () =
    [%#sseq'1] ()
  
  axiom concat_contains_spec : [%#sseq'0] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a : t_IntoIter'1) (ab : Seq.seq t_T) (b : t_IntoIter'1) (bc : Seq.seq t_T) (c : t_IntoIter'1) : ()
  
   =
    [%#shash_set'14] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_IntoIter'1, ab : Seq.seq t_T, b : t_IntoIter'1, bc : Seq.seq t_T, c : t_IntoIter'1 . ([%#shash_set'11] set_produces a ab b)
   -> ([%#shash_set'12] set_produces b bc c)  -> ([%#shash_set'13] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self : t_IntoIter'1) (visited : Seq.seq t_T) (o : t_IntoIter'1) =
    [%#shash_set'2] set_produces self visited o
  
  function produces_trans (a : t_IntoIter'1) (ab : Seq.seq t_T) (b : t_IntoIter'1) (bc : Seq.seq t_T) (c : t_IntoIter'1) : ()
  
   =
    [%#shash_set'9] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec : forall a : t_IntoIter'1, ab : Seq.seq t_T, b : t_IntoIter'1, bc : Seq.seq t_T, c : t_IntoIter'1 . ([%#shash_set'6] produces a ab b)
   -> ([%#shash_set'7] produces b bc c)  -> ([%#shash_set'8] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_IntoIter'1) : () =
    [%#shash_set'5] ()
  
  axiom produces_refl_spec : forall self : t_IntoIter'1 . [%#shash_set'4] produces self (Seq.empty : Seq.seq t_T) self
  
  function view'1 (self : MutBorrow.t t_IntoIter'1) : Fset.fset t_DeepModelTy =
    [%#smodel] view'0 self.current
  
  predicate completed (self : MutBorrow.t t_IntoIter'1) =
    [%#shash_set'1] Fset.is_empty (view'1 self)
  
  predicate from_iter_post (prod : Seq.seq t_T) (res : t_HashSet'0) =
    [%#shash_set'3] forall x : t_DeepModelTy . contains (view res) x
    = (exists x1 : t_T . deep_model x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_:t_IntoIter'1) (return'  (x:t_HashSet'0))= any
    [ return''0 (result:t_HashSet'0)-> {[%#siter'1] exists done' : MutBorrow.t t_IntoIter'1, prod : Seq.seq t_T . resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_into_iter[#"collections.rs" 66 0 66 90] (xs:t_HashSet'0) (return'  (x:t_HashSet'0))= (! bb0
    [ bb0 = bb1
    | bb1 = s0 [ s0 = into_iter {xs'0} (fun (_ret:t_IntoIter'1) ->  [ &_3 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {_3} (fun (_ret:t_HashSet'0) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = bb4
    | bb4 = return''0 {_0} ]
    ) [ & _0 : t_HashSet'0 = Any.any_l () | & xs'0 : t_HashSet'0 = xs | & _3 : t_IntoIter'1 = Any.any_l () ] 
    [ return''0 (result:t_HashSet'0)-> {[@expl:roundtrip_hashset_into_iter ensures] [%#scollections] view result
      = view xs}
      (! return' {result}) ]

end
module M_collections__roundtrip_hashset_iter [#"collections.rs" 71 0 71 87]
  let%span scollections = "collections.rs" 70 10 70 24
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span smodel = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 24 30 24 46
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 144 20 144 38
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 138 8 138 38
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 149 14 149 45
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 150 27 150 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 154 15 154 32
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 155 15 155 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 156 14 156 42
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 158 8 158 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_DeepModelTy
  
  function view (self : t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy =
    [%#smodel] view self
  
  function view'1 (self : t_Iter'1) : Fset.fset t_DeepModelTy
  
  let rec iter (self_:t_HashSet'0) (return'  (x:t_Iter'1))= any
    [ return''0 (result:t_Iter'1)-> {[%#shash_set] view'0 self_ = view'1 result} (! return' {result}) ]
  
  
  type t_RawTable'0  =
    { t_RawTable__table'0: t_RawTableInner; t_RawTable__alloc'0: (); t_RawTable__marker'0: () }
  
  type t_HashMap'0  =
    { t_HashMap__hash_builder'0: t_RandomState; t_HashMap__table'0: t_RawTable'0 }
  
  type t_HashSet'1  =
    { t_HashSet__map'0: t_HashMap'0 }
  
  type t_HashSet'2  =
    { t_HashSet__base'0: t_HashSet'1 }
  
  predicate resolve (_0 : t_Iter'1) =
    true
  
  type t_T
  
  predicate contains [@inline:trivial] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self : t_T) : t_DeepModelTy
  
  function deep_model'0 (self : t_T) : t_DeepModelTy =
    [%#smodel'1] deep_model self
  
  predicate contains'0 (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start : t_Iter'1) (visited : Seq.seq t_T) (end' : t_Iter'1) =
    [%#shash_set'9] Fset.cardinal (view'1 start) = Seq.length visited + Fset.cardinal (view'1 end')
    /\ (forall x : t_DeepModelTy . contains (view'1 start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view'1 end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view'1 start) (deep_model'0 x) /\ not contains (view'1 end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view'1 end') x
     -> contains (view'1 start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  function concat_contains  : () =
    [%#sseq'1] ()
  
  axiom concat_contains_spec : [%#sseq'0] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a : t_Iter'1) (ab : Seq.seq t_T) (b : t_Iter'1) (bc : Seq.seq t_T) (c : t_Iter'1) : () =
    [%#shash_set'13] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_Iter'1, ab : Seq.seq t_T, b : t_Iter'1, bc : Seq.seq t_T, c : t_Iter'1 . ([%#shash_set'10] set_produces a ab b)
   -> ([%#shash_set'11] set_produces b bc c)  -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self : t_Iter'1) (visited : Seq.seq t_T) (o : t_Iter'1) =
    [%#shash_set'1] set_produces self visited o
  
  function produces_trans (a : t_Iter'1) (ab : Seq.seq t_T) (b : t_Iter'1) (bc : Seq.seq t_T) (c : t_Iter'1) : () =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec : forall a : t_Iter'1, ab : Seq.seq t_T, b : t_Iter'1, bc : Seq.seq t_T, c : t_Iter'1 . ([%#shash_set'5] produces a ab b)
   -> ([%#shash_set'6] produces b bc c)  -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_Iter'1) : () =
    [%#shash_set'4] ()
  
  axiom produces_refl_spec : forall self : t_Iter'1 . [%#shash_set'3] produces self (Seq.empty : Seq.seq t_T) self
  
  function view'2 (self : MutBorrow.t t_Iter'1) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view'1 self.current
  
  predicate completed (self : MutBorrow.t t_Iter'1) =
    [%#shash_set'0] Fset.is_empty (view'2 self)
  
  function view'3 (self : t_HashSet'2) : Fset.fset t_DeepModelTy
  
  predicate from_iter_post (prod : Seq.seq t_T) (res : t_HashSet'2) =
    [%#shash_set'2] forall x : t_DeepModelTy . contains (view'3 res) x
    = (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 prod x1)
  
  let rec collect (self_:t_Iter'1) (return'  (x:t_HashSet'2))= any
    [ return''0 (result:t_HashSet'2)-> {[%#siter] exists done' : MutBorrow.t t_Iter'1, prod : Seq.seq t_T . resolve done'.final
      /\ completed done' /\ produces self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec roundtrip_hashset_iter[#"collections.rs" 71 0 71 87] (xs:t_HashSet'0) (return'  (x:t_HashSet'2))= (! bb0
    [ bb0 = s0 [ s0 = iter {xs'0} (fun (_ret:t_Iter'1) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = collect {_3} (fun (_ret:t_HashSet'2) ->  [ &_0 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = return''0 {_0} ]
    ) [ & _0 : t_HashSet'2 = Any.any_l () | & xs'0 : t_HashSet'0 = xs | & _3 : t_Iter'1 = Any.any_l () ] 
    [ return''0 (result:t_HashSet'2)-> {[@expl:roundtrip_hashset_iter ensures] [%#scollections] view'3 result
      = view'0 xs}
      (! return' {result}) ]

end
module M_collections__hashset_intersection [#"collections.rs" 76 0 79 15]
  let%span scollections = "collections.rs" 75 10 75 42
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 143 26 143 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 32 30 32 67
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 230 20 230 56
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 224 8 224 38
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 235 14 235 45
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 236 27 236 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 240 15 240 32
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 241 15 241 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 242 14 242 42
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 244 8 244 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span scopied = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span scopied'0 = "../../../creusot-contracts/src/std/iter/copied.rs" 40 12 40 105
  let%span scopied'1 = "../../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied'2 = "../../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied'3 = "../../../creusot-contracts/src/std/iter/copied.rs" 57 14 57 45
  let%span scopied'4 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied'5 = "../../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied'6 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Intersection  =
    { t_Intersection__iter: t_Iter'1; t_Intersection__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self : t_Intersection) : Fset.fset t_DeepModelTy
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'1 (self : t_HashSet'0) : Fset.fset t_DeepModelTy =
    [%#smodel] view'0 self
  
  let rec intersection (self_:t_HashSet'0) (other:t_HashSet'0) (return'  (x:t_Intersection))= any
    [ return''0 (result:t_Intersection)-> {[%#shash_set] view result = Fset.inter (view'1 self_) (view'1 other)}
      (! return' {result}) ]
  
  
  type t_Copied  =
    { t_Copied__it: t_Intersection }
  
  predicate inv (_0 : t_Copied)
  
  axiom inv_axiom [@rewrite] : forall x : t_Copied [inv x] . inv x = true
  
  predicate inv'0 (_0 : t_Intersection)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Intersection [inv'0 x] . inv'0 x = true
  
  function iter (self : t_Copied) : t_Intersection
  
  axiom iter_spec : forall self : t_Copied . [%#scopied] inv self  -> inv'0 (iter self)
  
  let rec copied (self_:t_Intersection) (return'  (x:t_Copied))= any
    [ return''0 (result:t_Copied)-> {[%#siter] iter result = self_} (! return' {result}) ]
  
  
  predicate resolve (_0 : t_Intersection) =
    true
  
  predicate resolve'0 (self : t_Copied) =
    [%#scopied'2] resolve (iter self)
  
  predicate resolve'1 (_0 : t_Copied) =
    resolve'0 _0
  
  type t_T
  
  predicate contains [@inline:trivial] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self : t_T) : t_DeepModelTy
  
  function deep_model'0 (self : t_T) : t_DeepModelTy =
    [%#smodel'1] deep_model self
  
  predicate contains'0 (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start : t_Intersection) (visited : Seq.seq t_T) (end' : t_Intersection) =
    [%#shash_set'9] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  function concat_contains  : () =
    [%#sseq'1] ()
  
  axiom concat_contains_spec : [%#sseq'0] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a : t_Intersection) (ab : Seq.seq t_T) (b : t_Intersection) (bc : Seq.seq t_T) (c : t_Intersection) : ()
  
   =
    [%#shash_set'13] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_Intersection, ab : Seq.seq t_T, b : t_Intersection, bc : Seq.seq t_T, c : t_Intersection . ([%#shash_set'10] set_produces a ab b)
   -> ([%#shash_set'11] set_produces b bc c)  -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self : t_Intersection) (visited : Seq.seq t_T) (o : t_Intersection) =
    [%#shash_set'2] set_produces self visited o
  
  function produces_trans (a : t_Intersection) (ab : Seq.seq t_T) (b : t_Intersection) (bc : Seq.seq t_T) (c : t_Intersection) : ()
  
   =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec : forall a : t_Intersection, ab : Seq.seq t_T, b : t_Intersection, bc : Seq.seq t_T, c : t_Intersection . ([%#shash_set'5] produces a ab b)
   -> ([%#shash_set'6] produces b bc c)  -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_Intersection) : () =
    [%#shash_set'4] ()
  
  axiom produces_refl_spec : forall self : t_Intersection . [%#shash_set'3] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate produces'0 (self : t_Copied) (visited : Seq.seq t_T) (o : t_Copied) =
    [%#scopied'1] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a : t_Copied) (ab : Seq.seq t_T) (b : t_Copied) (bc : Seq.seq t_T) (c : t_Copied) : ()
  
  axiom produces_trans_spec'0 : forall a : t_Copied, ab : Seq.seq t_T, b : t_Copied, bc : Seq.seq t_T, c : t_Copied . ([%#scopied'4] produces'0 a ab b)
   -> ([%#scopied'5] produces'0 b bc c)  -> ([%#scopied'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Copied) : ()
  
  axiom produces_refl_spec'0 : forall self : t_Copied . [%#scopied'3] produces'0 self (Seq.empty : Seq.seq t_T) self
  
  predicate resolve'2 (self : MutBorrow.t t_Intersection) =
    [%#sresolve] self.final = self.current
  
  function view'2 (self : MutBorrow.t t_Intersection) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view self.current
  
  predicate completed (self : MutBorrow.t t_Intersection) =
    [%#shash_set'1] resolve'2 self /\ Fset.is_empty (view'2 self)
  
  predicate completed'0 (self : MutBorrow.t t_Copied) =
    [%#scopied'0] exists inner : MutBorrow.t t_Intersection . inner.current = iter self.current
    /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod : Seq.seq t_T) (res : t_HashSet'0) =
    [%#shash_set'0] forall x : t_DeepModelTy . contains (view'0 res) x
    = (exists x1 : t_T . deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_:t_Copied) (return'  (x:t_HashSet'0))= any
    [ return''0 (result:t_HashSet'0)-> {[%#siter'0] exists done' : MutBorrow.t t_Copied, prod : Seq.seq t_T . resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec hashset_intersection[#"collections.rs" 76 0 79 15] (xs:t_HashSet'0) (ys:t_HashSet'0) (return'  (x:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = intersection {xs'0} {ys'0} (fun (_ret:t_Intersection) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret:t_Copied) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret:t_HashSet'0) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = return''0 {_0} ]
    )
    [ & _0 : t_HashSet'0 = Any.any_l ()
    | & xs'0 : t_HashSet'0 = xs
    | & ys'0 : t_HashSet'0 = ys
    | & _4 : t_Copied = Any.any_l ()
    | & _5 : t_Intersection = Any.any_l () ]
    
    [ return''0 (result:t_HashSet'0)-> {[@expl:hashset_intersection ensures] [%#scollections] view'0 result
      = Fset.inter (view'1 xs) (view'1 ys)}
      (! return' {result}) ]

end
module M_collections__hashset_difference [#"collections.rs" 84 0 87 15]
  let%span scollections = "collections.rs" 83 10 83 40
  let%span siter = "../../../creusot-contracts/src/std/iter.rs" 143 26 143 47
  let%span siter'0 = "../../../creusot-contracts/src/std/iter.rs" 192 26 193 120
  let%span sseq = "../../../creusot-contracts/src/logic/seq.rs" 362 20 362 77
  let%span sseq'0 = "../../../creusot-contracts/src/logic/seq.rs" 389 14 390 65
  let%span sseq'1 = "../../../creusot-contracts/src/logic/seq.rs" 394 4 395 5
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span shash_set = "../../../creusot-contracts/src/std/collections/hash_set.rs" 35 30 35 65
  let%span shash_set'0 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 194 20 194 121
  let%span shash_set'1 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 258 20 258 56
  let%span shash_set'2 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 252 8 252 38
  let%span shash_set'3 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 263 14 263 45
  let%span shash_set'4 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 264 27 264 29
  let%span shash_set'5 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 268 15 268 32
  let%span shash_set'6 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 269 15 269 32
  let%span shash_set'7 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 270 14 270 42
  let%span shash_set'8 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 272 8 272 43
  let%span shash_set'9 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 67 16 74 23
  let%span shash_set'10 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 80 11 80 33
  let%span shash_set'11 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 81 11 81 33
  let%span shash_set'12 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 82 10 82 43
  let%span shash_set'13 = "../../../creusot-contracts/src/std/collections/hash_set.rs" 90 4 90 31
  let%span sfset = "../../../creusot-contracts/src/logic/fset.rs" 47 8 47 26
  let%span scopied = "../../../creusot-contracts/src/std/iter/copied.rs" 11 14 11 39
  let%span scopied'0 = "../../../creusot-contracts/src/std/iter/copied.rs" 40 12 40 105
  let%span scopied'1 = "../../../creusot-contracts/src/std/iter/copied.rs" 48 12 51 79
  let%span scopied'2 = "../../../creusot-contracts/src/std/iter/copied.rs" 21 8 21 29
  let%span scopied'3 = "../../../creusot-contracts/src/std/iter/copied.rs" 57 14 57 45
  let%span scopied'4 = "../../../creusot-contracts/src/std/iter/copied.rs" 62 15 62 32
  let%span scopied'5 = "../../../creusot-contracts/src/std/iter/copied.rs" 63 15 63 32
  let%span scopied'6 = "../../../creusot-contracts/src/std/iter/copied.rs" 64 14 64 42
  
  use creusot.int.UInt16
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use set.Fset
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_BitMask  =
    { t_BitMask__0: UInt16.t }
  
  type t_BitMaskIter  =
    { t_BitMaskIter__0: t_BitMask }
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Bucket  =
    { t_Bucket__ptr: t_NonNull }
  
  type t_RawIterRange  =
    { t_RawIterRange__current_group: t_BitMaskIter;
      t_RawIterRange__data: t_Bucket;
      t_RawIterRange__next_ctrl: Opaque.ptr;
      t_RawIterRange__end: Opaque.ptr }
  
  type t_RawIter  =
    { t_RawIter__iter: t_RawIterRange; t_RawIter__items: UInt64.t }
  
  type t_Iter  =
    { t_Iter__inner: t_RawIter; t_Iter__marker: () }
  
  type t_Keys  =
    { t_Keys__inner: t_Iter }
  
  type t_Iter'0  =
    { t_Iter__iter: t_Keys }
  
  type t_Iter'1  =
    { t_Iter__base: t_Iter'0 }
  
  type t_RandomState  =
    { t_RandomState__k0: UInt64.t; t_RandomState__k1: UInt64.t }
  
  type t_NonNull'0  =
    { t_NonNull__pointer'0: Opaque.ptr }
  
  type t_RawTableInner  =
    { t_RawTableInner__bucket_mask: UInt64.t;
      t_RawTableInner__ctrl: t_NonNull'0;
      t_RawTableInner__growth_left: UInt64.t;
      t_RawTableInner__items: UInt64.t }
  
  type t_RawTable  =
    { t_RawTable__table: t_RawTableInner; t_RawTable__alloc: (); t_RawTable__marker: () }
  
  type t_HashMap  =
    { t_HashMap__hash_builder: t_RandomState; t_HashMap__table: t_RawTable }
  
  type t_HashSet  =
    { t_HashSet__map: t_HashMap }
  
  type t_HashSet'0  =
    { t_HashSet__base: t_HashSet }
  
  type t_Difference  =
    { t_Difference__iter: t_Iter'1; t_Difference__other: t_HashSet'0 }
  
  type t_DeepModelTy
  
  function view (self : t_Difference) : Fset.fset t_DeepModelTy
  
  function view'0 (self : t_HashSet'0) : Fset.fset t_DeepModelTy
  
  function view'1 (self : t_HashSet'0) : Fset.fset t_DeepModelTy =
    [%#smodel] view'0 self
  
  let rec difference (self_:t_HashSet'0) (other:t_HashSet'0) (return'  (x:t_Difference))= any
    [ return''0 (result:t_Difference)-> {[%#shash_set] view result = Fset.diff (view'1 self_) (view'1 other)}
      (! return' {result}) ]
  
  
  type t_Copied  =
    { t_Copied__it: t_Difference }
  
  predicate inv (_0 : t_Copied)
  
  axiom inv_axiom [@rewrite] : forall x : t_Copied [inv x] . inv x = true
  
  predicate inv'0 (_0 : t_Difference)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Difference [inv'0 x] . inv'0 x = true
  
  function iter (self : t_Copied) : t_Difference
  
  axiom iter_spec : forall self : t_Copied . [%#scopied] inv self  -> inv'0 (iter self)
  
  let rec copied (self_:t_Difference) (return'  (x:t_Copied))= any
    [ return''0 (result:t_Copied)-> {[%#siter] iter result = self_} (! return' {result}) ]
  
  
  predicate resolve (_0 : t_Difference) =
    true
  
  predicate resolve'0 (self : t_Copied) =
    [%#scopied'2] resolve (iter self)
  
  predicate resolve'1 (_0 : t_Copied) =
    resolve'0 _0
  
  type t_T
  
  predicate contains [@inline:trivial] (self : Fset.fset t_DeepModelTy) (e : t_DeepModelTy) =
    [%#sfset] Fset.mem e self
  
  function deep_model (self : t_T) : t_DeepModelTy
  
  function deep_model'0 (self : t_T) : t_DeepModelTy =
    [%#smodel'1] deep_model self
  
  predicate contains'0 (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces (start : t_Difference) (visited : Seq.seq t_T) (end' : t_Difference) =
    [%#shash_set'9] Fset.cardinal (view start) = Seq.length visited + Fset.cardinal (view end')
    /\ (forall x : t_DeepModelTy . contains (view start) x
     -> (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1) \/ contains (view end') x)
    /\ (forall x : t_T . contains'0 visited x
     -> contains (view start) (deep_model'0 x) /\ not contains (view end') (deep_model'0 x))
    /\ (forall x : t_DeepModelTy . contains (view end') x
     -> contains (view start) x /\ not (exists x1 : t_T . deep_model'0 x1 = x /\ contains'0 visited x1))
    /\ (forall i : int, j : int . 0 <= i
    /\ i < Seq.length visited
    /\ 0 <= j /\ j < Seq.length visited /\ deep_model'0 (Seq.get visited i) = deep_model'0 (Seq.get visited j)
     -> i = j)
  
  function concat_contains  : () =
    [%#sseq'1] ()
  
  axiom concat_contains_spec : [%#sseq'0] forall a : Seq.seq t_T, b : Seq.seq t_T, x : t_T . contains'0 (Seq.(++) a b) x
  = contains'0 a x
  \/ contains'0 b x
  
  function set_produces_trans (a : t_Difference) (ab : Seq.seq t_T) (b : t_Difference) (bc : Seq.seq t_T) (c : t_Difference) : ()
  
   =
    [%#shash_set'13] let _ = concat_contains in let _ = let _ = () in () in let _ = let _ = () in () in ()
  
  axiom set_produces_trans_spec : forall a : t_Difference, ab : Seq.seq t_T, b : t_Difference, bc : Seq.seq t_T, c : t_Difference . ([%#shash_set'10] set_produces a ab b)
   -> ([%#shash_set'11] set_produces b bc c)  -> ([%#shash_set'12] set_produces a (Seq.(++) ab bc) c)
  
  predicate produces (self : t_Difference) (visited : Seq.seq t_T) (o : t_Difference) =
    [%#shash_set'2] set_produces self visited o
  
  function produces_trans (a : t_Difference) (ab : Seq.seq t_T) (b : t_Difference) (bc : Seq.seq t_T) (c : t_Difference) : ()
  
   =
    [%#shash_set'8] let _ = set_produces_trans a ab b bc c in ()
  
  axiom produces_trans_spec : forall a : t_Difference, ab : Seq.seq t_T, b : t_Difference, bc : Seq.seq t_T, c : t_Difference . ([%#shash_set'5] produces a ab b)
   -> ([%#shash_set'6] produces b bc c)  -> ([%#shash_set'7] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_Difference) : () =
    [%#shash_set'4] ()
  
  axiom produces_refl_spec : forall self : t_Difference . [%#shash_set'3] produces self (Seq.empty : Seq.seq t_T) self
  
  predicate produces'0 (self : t_Copied) (visited : Seq.seq t_T) (o : t_Copied) =
    [%#scopied'1] exists s : Seq.seq t_T . produces (iter self) s (iter o)
    /\ Seq.length visited = Seq.length s
    /\ (forall i : int . 0 <= i /\ i < Seq.length s  -> Seq.get visited i = Seq.get s i)
  
  function produces_trans'0 (a : t_Copied) (ab : Seq.seq t_T) (b : t_Copied) (bc : Seq.seq t_T) (c : t_Copied) : ()
  
  axiom produces_trans_spec'0 : forall a : t_Copied, ab : Seq.seq t_T, b : t_Copied, bc : Seq.seq t_T, c : t_Copied . ([%#scopied'4] produces'0 a ab b)
   -> ([%#scopied'5] produces'0 b bc c)  -> ([%#scopied'6] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Copied) : ()
  
  axiom produces_refl_spec'0 : forall self : t_Copied . [%#scopied'3] produces'0 self (Seq.empty : Seq.seq t_T) self
  
  predicate resolve'2 (self : MutBorrow.t t_Difference) =
    [%#sresolve] self.final = self.current
  
  function view'2 (self : MutBorrow.t t_Difference) : Fset.fset t_DeepModelTy =
    [%#smodel'0] view self.current
  
  predicate completed (self : MutBorrow.t t_Difference) =
    [%#shash_set'1] resolve'2 self /\ Fset.is_empty (view'2 self)
  
  predicate completed'0 (self : MutBorrow.t t_Copied) =
    [%#scopied'0] exists inner : MutBorrow.t t_Difference . inner.current = iter self.current
    /\ inner.final = iter self.final /\ completed inner
  
  predicate contains'1 (self : Seq.seq t_T) (x : t_T) =
    [%#sseq] exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate from_iter_post (prod : Seq.seq t_T) (res : t_HashSet'0) =
    [%#shash_set'0] forall x : t_DeepModelTy . contains (view'0 res) x
    = (exists x1 : t_T . deep_model x1 = x /\ contains'1 prod x1)
  
  let rec collect (self_:t_Copied) (return'  (x:t_HashSet'0))= any
    [ return''0 (result:t_HashSet'0)-> {[%#siter'0] exists done' : MutBorrow.t t_Copied, prod : Seq.seq t_T . resolve'1 done'.final
      /\ completed'0 done' /\ produces'0 self_ prod done'.current /\ from_iter_post prod result}
      (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec hashset_difference[#"collections.rs" 84 0 87 15] (xs:t_HashSet'0) (ys:t_HashSet'0) (return'  (x:t_HashSet'0))= (! bb0
    [ bb0 = s0 [ s0 = difference {xs'0} {ys'0} (fun (_ret:t_Difference) ->  [ &_5 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 = copied {_5} (fun (_ret:t_Copied) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
    | bb2 = s0 [ s0 = collect {_4} (fun (_ret:t_HashSet'0) ->  [ &_0 <- _ret ] s1) | s1 = bb3 ] 
    | bb3 = return''0 {_0} ]
    )
    [ & _0 : t_HashSet'0 = Any.any_l ()
    | & xs'0 : t_HashSet'0 = xs
    | & ys'0 : t_HashSet'0 = ys
    | & _4 : t_Copied = Any.any_l ()
    | & _5 : t_Difference = Any.any_l () ]
    
    [ return''0 (result:t_HashSet'0)-> {[@expl:hashset_difference ensures] [%#scollections] view'0 result
      = Fset.diff (view'1 xs) (view'1 ys)}
      (! return' {result}) ]

end
