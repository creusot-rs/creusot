module M_resolves
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use map.Map
  use mach.int.Int
  use map.Const
  use seq.Seq
  use creusot.prelude.Any
  
  type t_FMap_refmut_usize_refmut_usize
  
  type t_Option_refmut_usize = None | Some (MutBorrow.t UInt64.t)
  
  function view_FMap_refmut_usize_refmut_usize (self: t_FMap_refmut_usize_refmut_usize) : Map.map (MutBorrow.t UInt64.t) t_Option_refmut_usize
  
  function get_refmut_usize [@inline:trivial] (self: t_FMap_refmut_usize_refmut_usize) (k: MutBorrow.t UInt64.t) : t_Option_refmut_usize
   = Map.get (view_FMap_refmut_usize_refmut_usize self) k
  
  meta "rewrite_def" function get_refmut_usize
  
  predicate ext_eq_refmut_usize (self: t_FMap_refmut_usize_refmut_usize) (other: t_FMap_refmut_usize_refmut_usize) =
    forall k: MutBorrow.t UInt64.t. get_refmut_usize self k = get_refmut_usize other k
  
  axiom ext_eq_refmut_usize_spec:
    forall self: t_FMap_refmut_usize_refmut_usize, other: t_FMap_refmut_usize_refmut_usize. ext_eq_refmut_usize self other
      = (self = other)
  
  function len_refmut_usize (self: t_FMap_refmut_usize_refmut_usize) : int
  
  axiom len_refmut_usize_spec: forall self: t_FMap_refmut_usize_refmut_usize. len_refmut_usize self >= 0
  
  constant empty_refmut_usize : t_FMap_refmut_usize_refmut_usize
  
  axiom empty_refmut_usize_spec: len_refmut_usize empty_refmut_usize = 0
  
  axiom empty_refmut_usize_spec'0: view_FMap_refmut_usize_refmut_usize empty_refmut_usize = Const.const (None)
  
  predicate is_empty_refmut_usize (self: t_FMap_refmut_usize_refmut_usize) = ext_eq_refmut_usize self empty_refmut_usize
  
  let rec new_refmut_usize (return (x: t_FMap_refmut_usize_refmut_usize)) = any
    [ return (result: t_FMap_refmut_usize_refmut_usize) -> {is_empty_refmut_usize result} (! return {result}) ]
  
  let rec into_inner_FMap_refmut_usize_refmut_usize (self: t_FMap_refmut_usize_refmut_usize)
    (return (x: t_FMap_refmut_usize_refmut_usize)) = any
    [ return (result: t_FMap_refmut_usize_refmut_usize) -> {result = self} (! return {result}) ]
  
  predicate contains_refmut_usize [@inline:trivial] (self: t_FMap_refmut_usize_refmut_usize) (k: MutBorrow.t UInt64.t) =
    get_refmut_usize self k <> None
  
  meta "rewrite_def" predicate contains_refmut_usize
  
  function insert_refmut_usize (self: t_FMap_refmut_usize_refmut_usize) (k: MutBorrow.t UInt64.t) (v: MutBorrow.t UInt64.t) : t_FMap_refmut_usize_refmut_usize
  
  axiom insert_refmut_usize_spec:
    forall self: t_FMap_refmut_usize_refmut_usize, k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t. view_FMap_refmut_usize_refmut_usize (insert_refmut_usize self k v)
      = Map.set (view_FMap_refmut_usize_refmut_usize self) k (Some v)
  
  axiom insert_refmut_usize_spec'0:
    forall self: t_FMap_refmut_usize_refmut_usize, k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t. len_refmut_usize (insert_refmut_usize self k v)
      = (if contains_refmut_usize self k then len_refmut_usize self else len_refmut_usize self + 1)
  
  let rec insert_ghost_refmut_usize (self: MutBorrow.t t_FMap_refmut_usize_refmut_usize) (key: MutBorrow.t UInt64.t)
    (value: MutBorrow.t UInt64.t) (return (x: t_Option_refmut_usize)) = any
    [ return (result: t_Option_refmut_usize) -> {self.final = insert_refmut_usize self.current key value}
      {result = get_refmut_usize self.current key}
      (! return {result}) ]
  
  predicate resolve_refmut_usize [@inline:trivial] (_1: MutBorrow.t UInt64.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_usize
  
  predicate resolve_Option_refmut_usize (_1: t_Option_refmut_usize)
  
  axiom resolve_axiom [@rewrite]:
    forall x: t_Option_refmut_usize [resolve_Option_refmut_usize x]. resolve_Option_refmut_usize x
      = match x with
        | None -> true
        | Some x0 -> resolve_refmut_usize x0
        end
  
  type t_FMapIter_refmut_usize_refmut_usize
  
  predicate inv_FMapIter_refmut_usize_refmut_usize (_1: t_FMapIter_refmut_usize_refmut_usize)
  
  function view_FMapIter_refmut_usize_refmut_usize (self: t_FMapIter_refmut_usize_refmut_usize) : t_FMap_refmut_usize_refmut_usize
  
  let rec into_iter_FMap_refmut_usize_refmut_usize (self: t_FMap_refmut_usize_refmut_usize)
    (return (x: t_FMapIter_refmut_usize_refmut_usize)) = any
    [ return (result: t_FMapIter_refmut_usize_refmut_usize) -> {inv_FMapIter_refmut_usize_refmut_usize result}
      {view_FMapIter_refmut_usize_refmut_usize result = self}
      (! return {result}) ]
  
  type tup2_refmut_usize_refmut_usize = { f0: MutBorrow.t UInt64.t; f1: MutBorrow.t UInt64.t }
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  type t_Option_tup2_refmut_usize_refmut_usize = None'0 | Some'0 tup2_refmut_usize_refmut_usize
  
  predicate invariant_refmut_FMapIter_refmut_usize_refmut_usize [@inline:trivial] (self: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize) =
    inv_FMapIter_refmut_usize_refmut_usize self.current /\ inv_FMapIter_refmut_usize_refmut_usize self.final
  
  meta "rewrite_def" predicate invariant_refmut_FMapIter_refmut_usize_refmut_usize
  
  predicate inv_refmut_FMapIter_refmut_usize_refmut_usize [@inline:trivial] (_1: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize) =
    invariant_refmut_FMapIter_refmut_usize_refmut_usize _1
  
  meta "rewrite_def" predicate inv_refmut_FMapIter_refmut_usize_refmut_usize
  
  function get_tup2_refmut_usize_refmut_usize (self: Seq.seq tup2_refmut_usize_refmut_usize) (ix: int) : t_Option_tup2_refmut_usize_refmut_usize
   = if 0 <= ix /\ ix < Seq.length self then Some'0 (Seq.get self ix) else None'0
  
  predicate produces_FMapIter_refmut_usize_refmut_usize (self: t_FMapIter_refmut_usize_refmut_usize) (visited: Seq.seq tup2_refmut_usize_refmut_usize) (o: t_FMapIter_refmut_usize_refmut_usize) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t, i: int. get_tup2_refmut_usize_refmut_usize visited i
          = Some'0 { f0 = k; f1 = v }
        -> not contains_refmut_usize (view_FMapIter_refmut_usize_refmut_usize o) k
        /\ get_refmut_usize (view_FMapIter_refmut_usize_refmut_usize self) k = Some v)
    /\ len_refmut_usize (view_FMapIter_refmut_usize_refmut_usize self)
      = Seq.length visited + len_refmut_usize (view_FMapIter_refmut_usize_refmut_usize o)
    /\ (forall k: MutBorrow.t UInt64.t. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_refmut_usize (view_FMapIter_refmut_usize_refmut_usize o) k
      = get_refmut_usize (view_FMapIter_refmut_usize_refmut_usize self) k)
  
  function produces_trans_FMapIter_refmut_usize_refmut_usize (a: t_FMapIter_refmut_usize_refmut_usize) (ab: Seq.seq tup2_refmut_usize_refmut_usize) (b: t_FMapIter_refmut_usize_refmut_usize) (bc: Seq.seq tup2_refmut_usize_refmut_usize) (c: t_FMapIter_refmut_usize_refmut_usize) : ()
  
  axiom produces_trans_FMapIter_refmut_usize_refmut_usize_spec:
    forall a: t_FMapIter_refmut_usize_refmut_usize, ab: Seq.seq tup2_refmut_usize_refmut_usize, b: t_FMapIter_refmut_usize_refmut_usize, bc: Seq.seq tup2_refmut_usize_refmut_usize, c: t_FMapIter_refmut_usize_refmut_usize. produces_FMapIter_refmut_usize_refmut_usize a ab b
      -> produces_FMapIter_refmut_usize_refmut_usize b bc c
      -> produces_FMapIter_refmut_usize_refmut_usize a (Seq.(++) ab bc) c
  
  function produces_refl_FMapIter_refmut_usize_refmut_usize (self: t_FMapIter_refmut_usize_refmut_usize) : ()
  
  axiom produces_refl_FMapIter_refmut_usize_refmut_usize_spec:
    forall self: t_FMapIter_refmut_usize_refmut_usize. produces_FMapIter_refmut_usize_refmut_usize self (Seq.empty: Seq.seq tup2_refmut_usize_refmut_usize) self
  
  predicate completed_FMapIter_refmut_usize_refmut_usize (self: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize) =
    is_empty_refmut_usize (view_FMapIter_refmut_usize_refmut_usize self.current)
  
  let rec next_FMapIter_refmut_usize_refmut_usize (self: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize)
    (return (x: t_Option_tup2_refmut_usize_refmut_usize)) =
    {[@expl:next 'self' type invariant] inv_refmut_FMapIter_refmut_usize_refmut_usize self}
    any
    [ return (result: t_Option_tup2_refmut_usize_refmut_usize) -> {match result with
        | None'0 -> completed_FMapIter_refmut_usize_refmut_usize self
        | Some'0 {f0 = k; f1 = v} -> produces_FMapIter_refmut_usize_refmut_usize self.current (Seq.singleton { f0 = k;
                                                                                                               f1 = v }) self.final
        /\ view_FMapIter_refmut_usize_refmut_usize self.current
        = insert_refmut_usize (view_FMapIter_refmut_usize_refmut_usize self.final) k v
        end}
      (! return {result}) ]
  
  predicate resolve_refmut_FMapIter_refmut_usize_refmut_usize [@inline:trivial] (_1: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize) =
    _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_FMapIter_refmut_usize_refmut_usize
  
  function fin_Snapshot_refmut_usize [@inline:trivial] (self: MutBorrow.t UInt64.t) : UInt64.t = self.final
  
  meta "rewrite_def" function fin_Snapshot_refmut_usize
  
  predicate inv_Seq_tup2_refmut_usize_refmut_usize [@inline:trivial] (_1: Seq.seq tup2_refmut_usize_refmut_usize) = true
  
  meta "rewrite_def" predicate inv_Seq_tup2_refmut_usize_refmut_usize
  
  let rec elim_Some (_x: t_Option_tup2_refmut_usize_refmut_usize) (return (f0'0: tup2_refmut_usize_refmut_usize)) = any
    [ _k (f0'0: tup2_refmut_usize_refmut_usize) -> {Some'0 f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Some'0 _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate resolve_FMap_refmut_usize_refmut_usize (self: t_FMap_refmut_usize_refmut_usize) =
    forall k: MutBorrow.t UInt64.t, v: MutBorrow.t UInt64.t. get_refmut_usize self k = Some v
      -> resolve_refmut_usize k /\ resolve_refmut_usize v
  
  predicate resolve_FMap_refmut_usize_refmut_usize'0 (_1: t_FMap_refmut_usize_refmut_usize)
  
  axiom resolve_axiom'0:
    forall x: t_FMap_refmut_usize_refmut_usize [resolve_FMap_refmut_usize_refmut_usize'0 x]. resolve_FMap_refmut_usize_refmut_usize'0 x
      -> resolve_FMap_refmut_usize_refmut_usize x
  
  predicate resolve_FMapIter_refmut_usize_refmut_usize (self: t_FMapIter_refmut_usize_refmut_usize) =
    resolve_FMap_refmut_usize_refmut_usize'0 (view_FMapIter_refmut_usize_refmut_usize self)
  
  predicate resolve_FMapIter_refmut_usize_refmut_usize'0 (_1: t_FMapIter_refmut_usize_refmut_usize)
  
  axiom resolve_axiom'1:
    forall x: t_FMapIter_refmut_usize_refmut_usize [resolve_FMapIter_refmut_usize_refmut_usize'0 x]. resolve_FMapIter_refmut_usize_refmut_usize'0 x
      -> resolve_FMapIter_refmut_usize_refmut_usize x
  
  let rec new_usize (x: UInt64.t) (return (x'0: UInt64.t)) = any
    [ return (result: UInt64.t) -> {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec resolves (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &k <- (0: UInt64.t) ] s1
      | s1 = [ &v <- (0: UInt64.t) ] s2
      | s2 = new_refmut_usize (fun (_x: t_FMap_refmut_usize_refmut_usize) -> [ &_6 <- _x ] s3)
      | s3 = into_inner_FMap_refmut_usize_refmut_usize {_6}
          (fun (_x: t_FMap_refmut_usize_refmut_usize) -> [ &s <- _x ] s4)
      | s4 = MutBorrow.borrow_mut <UInt64.t> {k}
          (fun (_bor: MutBorrow.t UInt64.t) -> [ &bor_k <- _bor ] [ &k <- _bor.final ] s5)
      | s5 = MutBorrow.borrow_mut <UInt64.t> {v}
          (fun (_bor: MutBorrow.t UInt64.t) -> [ &bor_v <- _bor ] [ &v <- _bor.final ] s6)
      | s6 = [ &snap_k <- bor_k ] s7
      | s7 = [ &snap_v <- bor_v ] s8
      | s8 = MutBorrow.borrow_mut <t_FMap_refmut_usize_refmut_usize> {s}
          (fun (_bor: MutBorrow.t t_FMap_refmut_usize_refmut_usize) -> [ &_16 <- _bor ] [ &s <- _bor.final ] s9)
      | s9 = insert_ghost_refmut_usize {_16} {bor_k} {bor_v} (fun (_x: t_Option_refmut_usize) -> [ &_15 <- _x ] s10)
      | s10 = -{resolve_Option_refmut_usize _15}- s11
      | s11 = into_iter_FMap_refmut_usize_refmut_usize {s}
          (fun (_x: t_FMapIter_refmut_usize_refmut_usize) -> [ &iter <- _x ] s12)
      | s12 = [ &iter_old <- iter ] s13
      | s13 = [ &produced <- Seq.empty: Seq.seq tup2_refmut_usize_refmut_usize ] s14
      | s14 = bb9 ]
    | bb9 = bb9invariant
      [ bb9 = {[@expl:loop variant] well_founded_relation_Int variant_old_bb9 (1 - Seq.length produced)} bb9invariant
      | bb9invariant = {[@expl:inferred invariant: type invariant] inv_FMapIter_refmut_usize_refmut_usize iter}
        {[@expl:for invariant] inv_Seq_tup2_refmut_usize_refmut_usize produced}
        {[@expl:for invariant] produces_FMapIter_refmut_usize_refmut_usize iter_old produced iter}
        {[@expl:loop invariant #0] Seq.length produced <= 1}
        {[@expl:loop invariant #1] Seq.length produced = 0
        \/ fin_Snapshot_refmut_usize snap_k = (1: UInt64.t) /\ fin_Snapshot_refmut_usize snap_v = (1: UInt64.t)}
        (! [ &variant_old_bb9 <- 1 - Seq.length produced ] s0)
        [ s0 = MutBorrow.borrow_mut <t_FMapIter_refmut_usize_refmut_usize> {iter}
            (fun (_bor: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize) ->
              [ &_45 <- _bor ] -{inv_FMapIter_refmut_usize_refmut_usize _bor.final}-
              [ &iter <- _bor.final ] s1) [ _ck -> (! {inv_FMapIter_refmut_usize_refmut_usize iter} any) ]
        | s1 = MutBorrow.borrow_final <t_FMapIter_refmut_usize_refmut_usize> {_45.current} {MutBorrow.get_id _45}
            (fun (_bor: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize) ->
              [ &_44 <- _bor ] -{inv_FMapIter_refmut_usize_refmut_usize _bor.final}-
              [ &_45 <- { _45 with current = _bor.final } ] s2)
          [ _ck -> (! {inv_FMapIter_refmut_usize_refmut_usize _45.current} any) ]
        | s2 = next_FMapIter_refmut_usize_refmut_usize {_44}
            (fun (_x: t_Option_tup2_refmut_usize_refmut_usize) -> [ &_43 <- _x ] s3)
        | s3 = s4 [ _ck -> (! {[@expl:type invariant] inv_refmut_FMapIter_refmut_usize_refmut_usize _45} any) ]
        | s4 = -{resolve_refmut_FMapIter_refmut_usize_refmut_usize _45}- s5
        | s5 = any
          [ br0 -> {_43 = None'0} (! bb14) | br1 (x0: tup2_refmut_usize_refmut_usize) -> {_43 = Some'0 x0} (! bb15) ] ]
        [ bb15 = s0
          [ s0 = elim_Some {_43} (fun (r0: tup2_refmut_usize_refmut_usize) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &produced <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = [ &k2 <- __creusot_proc_iter_elem.f0 ] s3
          | s3 = [ &v2 <- __creusot_proc_iter_elem.f1 ] s4
          | s4 = [ &k2 <- { k2 with current = (1: UInt64.t) } ] s5
          | s5 = -{resolve_refmut_usize k2}- s6
          | s6 = [ &v2 <- { v2 with current = (1: UInt64.t) } ] s7
          | s7 = -{resolve_refmut_usize v2}- s8
          | s8 = bb9 ] ] ]
    | bb14 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_FMapIter_refmut_usize_refmut_usize iter} any) ]
      | s1 = -{resolve_FMapIter_refmut_usize_refmut_usize'0 iter}- s2
      | s2 = UInt64.add {k} {v} (fun (_x: UInt64.t) -> [ &_2 <- _x ] s3)
      | s3 = new_usize {_2} (fun (_x: UInt64.t) -> [ &_ret <- _x ] s4)
      | s4 = return {_ret} ] ]
    [ & _ret: UInt64.t = Any.any_l ()
    | & _2: UInt64.t = Any.any_l ()
    | & k: UInt64.t = Any.any_l ()
    | & v: UInt64.t = Any.any_l ()
    | & s: t_FMap_refmut_usize_refmut_usize = Any.any_l ()
    | & _6: t_FMap_refmut_usize_refmut_usize = Any.any_l ()
    | & bor_k: MutBorrow.t UInt64.t = Any.any_l ()
    | & bor_v: MutBorrow.t UInt64.t = Any.any_l ()
    | & snap_k: MutBorrow.t UInt64.t = Any.any_l ()
    | & snap_v: MutBorrow.t UInt64.t = Any.any_l ()
    | & _15: t_Option_refmut_usize = Any.any_l ()
    | & _16: MutBorrow.t t_FMap_refmut_usize_refmut_usize = Any.any_l ()
    | & iter: t_FMapIter_refmut_usize_refmut_usize = Any.any_l ()
    | & iter_old: t_FMapIter_refmut_usize_refmut_usize = Any.any_l ()
    | & produced: Seq.seq tup2_refmut_usize_refmut_usize = Any.any_l ()
    | & _43: t_Option_tup2_refmut_usize_refmut_usize = Any.any_l ()
    | & _44: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize = Any.any_l ()
    | & _45: MutBorrow.t t_FMapIter_refmut_usize_refmut_usize = Any.any_l ()
    | & __creusot_proc_iter_elem: tup2_refmut_usize_refmut_usize = Any.any_l ()
    | & k2: MutBorrow.t UInt64.t = Any.any_l ()
    | & v2: MutBorrow.t UInt64.t = Any.any_l ()
    | & variant_old_bb9: int = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:resolves ensures] result = (2: UInt64.t)} (! return {result}) ]
end
