module M_iter__test_mut_ref [#"iter.rs" 5 0 5 21]
  let%span siter = "iter.rs" 6 17 6 18
  let%span siter'0 = "iter.rs" 6 20 6 21
  let%span siter'1 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span siter'2 = "iter.rs" 7 38 7 39
  let%span siter'3 = "iter.rs" 8 38 8 39
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 303 18 303 33
  let%span sslice'0 = "../../../creusot-contracts/src/std/slice.rs" 428 20 428 61
  let%span sslice'1 = "../../../creusot-contracts/src/std/slice.rs" 435 12 435 66
  let%span sslice'2 = "../../../creusot-contracts/src/std/slice.rs" 441 14 441 45
  let%span sslice'3 = "../../../creusot-contracts/src/std/slice.rs" 442 27 442 29
  let%span sslice'4 = "../../../creusot-contracts/src/std/slice.rs" 446 15 446 32
  let%span sslice'5 = "../../../creusot-contracts/src/std/slice.rs" 447 15 447 32
  let%span sslice'6 = "../../../creusot-contracts/src/std/slice.rs" 448 14 448 42
  let%span sslice'7 = "../../../creusot-contracts/src/std/slice.rs" 449 91 449 93
  let%span sslice'8 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'9 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span sslice'10 = "../../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice'11 = "../../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex = "../../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span snum = "../../../creusot-contracts/src/std/num.rs" 25 28 25 33
  
  use creusot.slice.Slice64
  use creusot.int.Int32
  use creusot.prelude.Any
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  
  let rec promoted3__test_mut_ref (return'  (x:Slice64.array Int32.t))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array Int32.t)-> (! -{Seq.get __arr_temp.Slice64.elts 0 = ([%#siter] (1 : Int32.t))
          /\ Seq.get __arr_temp.Slice64.elts 1 = ([%#siter'0] (2 : Int32.t)) /\ Seq.length __arr_temp.Slice64.elts = 2}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0 : Slice64.array Int32.t = Any.any_l () | & _1 : Slice64.array Int32.t = Any.any_l () ] 
    [ return''0 (result:Slice64.array Int32.t)-> return' {result} ]
  
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  function view (self : t_Iter) : Slice64.slice Int32.t
  
  let rec iter (self_:Slice64.slice Int32.t) (return'  (x:t_Iter))= any
    [ return''0 (result:t_Iter)-> {[%#sslice] view result = self_} (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some Int32.t
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'0 (self : Slice64.slice Int32.t) : Seq.seq Int32.t
  
  axiom view_spec : forall self : Slice64.slice Int32.t . ([%#sslice'8] Seq.length (view'0 self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'9] view'0 self = Slice64.id self)
  
  function view'1 (self : Slice64.slice Int32.t) : Seq.seq Int32.t =
    [%#smodel'1] view'0 self
  
  function index_logic [@inline:trivial] (self : Slice64.slice Int32.t) (ix : int) : Int32.t =
    [%#sindex] Seq.get (view'0 self) ix
  
  function to_ref_seq (self : Slice64.slice Int32.t) : Seq.seq Int32.t
  
  axiom to_ref_seq_spec : forall self : Slice64.slice Int32.t . ([%#sslice'10] Seq.length (to_ref_seq self)
  = Seq.length (view'1 self))
  && ([%#sslice'11] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  predicate produces (self : t_Iter) (visited : Seq.seq Int32.t) (tl : t_Iter) =
    [%#sslice'1] to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  function produces_trans (a : t_Iter) (ab : Seq.seq Int32.t) (b : t_Iter) (bc : Seq.seq Int32.t) (c : t_Iter) : () =
    [%#sslice'7] ()
  
  axiom produces_trans_spec : forall a : t_Iter, ab : Seq.seq Int32.t, b : t_Iter, bc : Seq.seq Int32.t, c : t_Iter . ([%#sslice'4] produces a ab b)
   -> ([%#sslice'5] produces b bc c)  -> ([%#sslice'6] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_Iter) : () =
    [%#sslice'3] ()
  
  axiom produces_refl_spec : forall self : t_Iter . [%#sslice'2] produces self (Seq.empty : Seq.seq Int32.t) self
  
  predicate resolve (self : MutBorrow.t t_Iter) =
    [%#sresolve] self.final = self.current
  
  function view'2 (self : MutBorrow.t t_Iter) : Slice64.slice Int32.t =
    [%#smodel'0] view self.current
  
  predicate completed (self : MutBorrow.t t_Iter) =
    [%#sslice'0] resolve self /\ view'0 (view'2 self) = (Seq.empty : Seq.seq Int32.t)
  
  let rec next (self_:MutBorrow.t t_Iter) (return'  (x:t_Option))= any
    [ return''0 (result:t_Option)-> {[%#siter'1] match result with
        | C_None -> completed self_
        | C_Some v -> produces self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'0 (_0 : MutBorrow.t t_Iter) =
    resolve _0
  
  let rec promoted2__test_mut_ref (return'  (x:t_Option))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1 <- C_Some ([%#siter'2] (1 : Int32.t)) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]
     ]
     [ & _0 : t_Option = Any.any_l () | & _1 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  type tuple  =
    { _0: t_Option; _1: t_Option }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 int
  
  function deep_model (self : Int32.t) : int =
    [%#snum] Int32.to_int self
  
  function deep_model'0 (self : Int32.t) : int =
    [%#smodel] deep_model self
  
  function deep_model'1 (self : t_Option) : t_Option'0 =
    [%#soption'0] match self with
      | C_Some t -> C_Some'0 (deep_model'0 t)
      | C_None -> C_None'0
      end
  
  function deep_model'2 (self : t_Option) : t_Option'0 =
    [%#smodel] deep_model'1 self
  
  let rec eq (self_:t_Option) (rhs:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (deep_model'2 self_ = deep_model'2 rhs)} (! return' {result}) ]
  
  
  let rec promoted1__test_mut_ref (return'  (x:t_Option))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1'0 <- C_Some ([%#siter'3] (2 : Int32.t)) ] s1 | s1 =  [ &_0'0 <- _1'0 ] s2 | s2 = return''0 {_0'0} ]
     ]
     [ & _0'0 : t_Option = Any.any_l () | & _1'0 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  let rec promoted0__test_mut_ref (return'  (x:t_Option))= bb0
    [ bb0 = s0 [ s0 =  [ &_1'0 <- C_None ] s1 | s1 =  [ &_0'0 <- _1'0 ] s2 | s2 = return''0 {_0'0} ]  ]
     [ & _0'0 : t_Option = Any.any_l () | & _1'0 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_mut_ref[#"iter.rs" 5 0 5 21] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_mut_ref (fun (pr3:Slice64.array Int32.t) ->  [ &_78 <- pr3 ] s1)
      | s1 = iter {_78} (fun (_ret:t_Iter) ->  [ &a <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = MutBorrow.borrow_mut <t_Iter> {a}
          (fun (_ret:MutBorrow.t t_Iter) ->  [ &_10 <- _ret ]  [ &a <- _ret.final ] s1)
      | s1 = MutBorrow.borrow_final <t_Iter> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret:MutBorrow.t t_Iter) ->  [ &_9 <- _ret ]  [ &_10 <- { _10 with current = _ret.final } ] s2)
      | s2 = next {_9} (fun (_ret:t_Option) ->  [ &_8 <- _ret ] s3)
      | s3 = bb2 ]
    
    | bb2 = s0
      [ s0 = -{resolve'0 _10}- s1
      | s1 = promoted2__test_mut_ref (fun (pr2:t_Option) ->  [ &_77 <- pr2 ] s2)
      | s2 =  [ &_6 <- { _0 = _8; _1 = _77 } ] s3
      | s3 =  [ &left_val <- _6._0 ] s4
      | s4 =  [ &right_val <- _6._1 ] s5
      | s5 = eq {left_val} {right_val} (fun (_ret:bool) ->  [ &_17 <- _ret ] s6)
      | s6 = bb3 ]
    
    | bb3 = any [ br0 -> {_17 = false} (! bb5) | br1 -> {_17} (! bb4) ] 
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut <t_Iter> {a}
          (fun (_ret:MutBorrow.t t_Iter) ->  [ &_34 <- _ret ]  [ &a <- _ret.final ] s1)
      | s1 = MutBorrow.borrow_final <t_Iter> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret:MutBorrow.t t_Iter) ->  [ &_33 <- _ret ]  [ &_34 <- { _34 with current = _ret.final } ] s2)
      | s2 = next {_33} (fun (_ret:t_Option) ->  [ &_32 <- _ret ] s3)
      | s3 = bb6 ]
    
    | bb6 = s0
      [ s0 = -{resolve'0 _34}- s1
      | s1 = promoted1__test_mut_ref (fun (pr1:t_Option) ->  [ &_76 <- pr1 ] s2)
      | s2 =  [ &_30 <- { _0 = _32; _1 = _76 } ] s3
      | s3 =  [ &left_val'0 <- _30._0 ] s4
      | s4 =  [ &right_val'0 <- _30._1 ] s5
      | s5 = eq {left_val'0} {right_val'0} (fun (_ret:bool) ->  [ &_41 <- _ret ] s6)
      | s6 = bb7 ]
    
    | bb7 = any [ br0 -> {_41 = false} (! bb9) | br1 -> {_41} (! bb8) ] 
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Iter> {a}
          (fun (_ret:MutBorrow.t t_Iter) ->  [ &_58 <- _ret ]  [ &a <- _ret.final ] s1)
      | s1 = MutBorrow.borrow_final <t_Iter> {_58.current} {MutBorrow.get_id _58}
          (fun (_ret:MutBorrow.t t_Iter) ->  [ &_57 <- _ret ]  [ &_58 <- { _58 with current = _ret.final } ] s2)
      | s2 = next {_57} (fun (_ret:t_Option) ->  [ &_56 <- _ret ] s3)
      | s3 = bb10 ]
    
    | bb10 = s0
      [ s0 = -{resolve'0 _58}- s1
      | s1 = promoted0__test_mut_ref (fun (pr0:t_Option) ->  [ &_75 <- pr0 ] s2)
      | s2 =  [ &_54 <- { _0 = _56; _1 = _75 } ] s3
      | s3 =  [ &left_val'1 <- _54._0 ] s4
      | s4 =  [ &right_val'1 <- _54._1 ] s5
      | s5 = eq {left_val'1} {right_val'1} (fun (_ret:bool) ->  [ &_63 <- _ret ] s6)
      | s6 = bb11 ]
    
    | bb11 = any [ br0 -> {_63 = false} (! bb13) | br1 -> {_63} (! bb12) ] 
    | bb12 = return''0 {_0'0}
    | bb13 = s0
      [ s0 =  [ &kind'1 <- C_Eq ] s1
      | s1 =  [ &_71 <- left_val'1 ] s2
      | s2 =  [ &_73 <- right_val'1 ] s3
      | s3 = {false} any ]
    
    | bb9 = s0
      [ s0 =  [ &kind'0 <- C_Eq ] s1
      | s1 =  [ &_49 <- left_val'0 ] s2
      | s2 =  [ &_51 <- right_val'0 ] s3
      | s3 = {false} any ]
    
    | bb5 = s0
      [ s0 =  [ &kind <- C_Eq ] s1 | s1 =  [ &_25 <- left_val ] s2 | s2 =  [ &_27 <- right_val ] s3 | s3 = {false} any ]
     ]
    )
    [ & _0'0 : () = Any.any_l ()
    | & a : t_Iter = Any.any_l ()
    | & _6 : tuple = Any.any_l ()
    | & _8 : t_Option = Any.any_l ()
    | & _9 : MutBorrow.t t_Iter = Any.any_l ()
    | & _10 : MutBorrow.t t_Iter = Any.any_l ()
    | & left_val : t_Option = Any.any_l ()
    | & right_val : t_Option = Any.any_l ()
    | & _17 : bool = Any.any_l ()
    | & kind : t_AssertKind = Any.any_l ()
    | & _25 : t_Option = Any.any_l ()
    | & _27 : t_Option = Any.any_l ()
    | & _30 : tuple = Any.any_l ()
    | & _32 : t_Option = Any.any_l ()
    | & _33 : MutBorrow.t t_Iter = Any.any_l ()
    | & _34 : MutBorrow.t t_Iter = Any.any_l ()
    | & left_val'0 : t_Option = Any.any_l ()
    | & right_val'0 : t_Option = Any.any_l ()
    | & _41 : bool = Any.any_l ()
    | & kind'0 : t_AssertKind = Any.any_l ()
    | & _49 : t_Option = Any.any_l ()
    | & _51 : t_Option = Any.any_l ()
    | & _54 : tuple = Any.any_l ()
    | & _56 : t_Option = Any.any_l ()
    | & _57 : MutBorrow.t t_Iter = Any.any_l ()
    | & _58 : MutBorrow.t t_Iter = Any.any_l ()
    | & left_val'1 : t_Option = Any.any_l ()
    | & right_val'1 : t_Option = Any.any_l ()
    | & _63 : bool = Any.any_l ()
    | & kind'1 : t_AssertKind = Any.any_l ()
    | & _71 : t_Option = Any.any_l ()
    | & _73 : t_Option = Any.any_l ()
    | & _75 : t_Option = Any.any_l ()
    | & _76 : t_Option = Any.any_l ()
    | & _77 : t_Option = Any.any_l ()
    | & _78 : Slice64.array Int32.t = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_iter__test_filter [#"iter.rs" 12 0 12 20]
  let%span siter = "iter.rs" 13 17 13 21
  let%span siter'0 = "iter.rs" 13 23 13 28
  let%span siter'1 = "iter.rs" 13 30 13 34
  let%span siter'2 = "iter.rs" 14 18 14 31
  let%span siter'3 = "../../../creusot-contracts/src/std/iter.rs" 159 27 159 47
  let%span siter'4 = "../../../creusot-contracts/src/std/iter.rs" 160 27 160 53
  let%span siter'5 = "../../../creusot-contracts/src/std/iter.rs" 161 27 161 45
  let%span siter'6 = "../../../creusot-contracts/src/std/iter.rs" 162 26 162 69
  let%span siter'7 = "../../../creusot-contracts/src/std/iter.rs" 122 16 122 17
  let%span siter'8 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span siter'9 = "iter.rs" 17 38 17 42
  let%span siter'10 = "iter.rs" 18 38 18 42
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 303 18 303 33
  let%span sslice'0 = "../../../creusot-contracts/src/std/slice.rs" 435 12 435 66
  let%span sslice'1 = "../../../creusot-contracts/src/std/slice.rs" 428 20 428 61
  let%span sslice'2 = "../../../creusot-contracts/src/std/slice.rs" 441 14 441 45
  let%span sslice'3 = "../../../creusot-contracts/src/std/slice.rs" 442 27 442 29
  let%span sslice'4 = "../../../creusot-contracts/src/std/slice.rs" 446 15 446 32
  let%span sslice'5 = "../../../creusot-contracts/src/std/slice.rs" 447 15 447 32
  let%span sslice'6 = "../../../creusot-contracts/src/std/slice.rs" 448 14 448 42
  let%span sslice'7 = "../../../creusot-contracts/src/std/slice.rs" 449 91 449 93
  let%span sslice'8 = "../../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice'9 = "../../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span sslice'10 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'11 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span smodel'2 = "../../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span sindex = "../../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sfilter = "../../../creusot-contracts/src/std/iter/filter.rs" 58 16 58 59
  let%span sfilter'0 = "../../../creusot-contracts/src/std/iter/filter.rs" 50 16 50 57
  let%span sfilter'1 = "../../../creusot-contracts/src/std/iter/filter.rs" 65 16 65 126
  let%span sfilter'2 = "../../../creusot-contracts/src/std/iter/filter.rs" 15 14 15 39
  let%span sfilter'3 = "../../../creusot-contracts/src/std/iter/filter.rs" 22 14 22 39
  let%span sfilter'4 = "../../../creusot-contracts/src/std/iter/filter.rs" 77 12 79 47
  let%span sfilter'5 = "../../../creusot-contracts/src/std/iter/filter.rs" 87 12 98 143
  let%span sfilter'6 = "../../../creusot-contracts/src/std/iter/filter.rs" 104 14 104 45
  let%span sfilter'7 = "../../../creusot-contracts/src/std/iter/filter.rs" 109 15 109 32
  let%span sfilter'8 = "../../../creusot-contracts/src/std/iter/filter.rs" 110 15 110 32
  let%span sfilter'9 = "../../../creusot-contracts/src/std/iter/filter.rs" 111 14 111 42
  let%span sops = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 59
  let%span sops'0 = "../../../creusot-contracts/src/std/ops.rs" 117 14 117 36
  let%span sops'1 = "../../../creusot-contracts/src/std/ops.rs" 122 14 122 31
  let%span sops'2 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 29
  let%span sops'3 = "../../../creusot-contracts/src/std/ops.rs" 128 15 128 26
  let%span sops'4 = "../../../creusot-contracts/src/std/ops.rs" 129 14 129 28
  let%span sops'5 = "../../../creusot-contracts/src/std/ops.rs" 134 14 135 105
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  use map.Map
  
  let rec promoted3__test_filter (return'  (x:Slice64.array bool))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array bool)-> (! -{Seq.get __arr_temp.Slice64.elts 0
          /\ Seq.get __arr_temp.Slice64.elts 1 = ([%#siter'0] false)
          /\ Seq.get __arr_temp.Slice64.elts 2 /\ Seq.length __arr_temp.Slice64.elts = 3}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0 : Slice64.array bool = Any.any_l () | & _1 : Slice64.array bool = Any.any_l () ] 
    [ return''0 (result:Slice64.array bool)-> return' {result} ]
  
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  function view (self : t_Iter) : Slice64.slice bool
  
  let rec iter (self_:Slice64.slice bool) (return'  (x:t_Iter))= any
    [ return''0 (result:t_Iter)-> {[%#sslice] view result = self_} (! return' {result}) ]
  
  
  predicate resolve (self : MutBorrow.t ()) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0 : MutBorrow.t ()) =
    resolve _0
  
  predicate postcondition_once (self : ()) (args : bool) (result : bool) =
    [%#siter'2] let b = args in result = b
  
  predicate resolve'1 (_0 : ()) =
    true
  
  predicate unnest (self : ()) (_1 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : bool) (result_state : ()) (result : bool) =
    (let b = args in result = b) /\ unnest self result_state
  
  function fn_mut_once (self : ()) (args : bool) (res : bool) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : bool, res : bool . [%#sops'5] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  function unnest_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom unnest_trans_spec : forall self : (), b : (), c : () . ([%#sops'2] unnest self b)
   -> ([%#sops'3] unnest b c)  -> ([%#sops'4] unnest self c)
  
  function unnest_refl (self : ()) : ()
  
  axiom unnest_refl_spec : forall self : () . [%#sops'1] unnest self self
  
  function postcondition_mut_unnest (self : ()) (args : bool) (res_state : ()) (res : bool) : ()
  
  axiom postcondition_mut_unnest_spec : forall self : (), args : bool, res_state : (), res : bool . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] unnest self res_state)
  
  let rec closure0[#"iter.rs" 14 8 14 33] (self:MutBorrow.t ()) (b:bool) (return'  (x:bool))= (! bb0
    [ bb0 = s0
      [ s0 = -{resolve'0 _1}- s1 | s1 =  [ &res <- b'0 ] s2 | s2 =  [ &_0 <- res ] s3 | s3 = return''0 {_0} ]
     ]
    ) [ & _0 : bool = Any.any_l () | & _1 : MutBorrow.t () = self | & b'0 : bool = b | & res : bool = Any.any_l () ] 
    [ return''0 (result:bool)-> {[@expl:closure ensures] [%#siter'2] result = b}
      {[@expl:closure unnest] unnest self.current self.final}
      (! return' {result}) ]
  
  
  type t_Filter  =
    { t_Filter__iter: t_Iter; t_Filter__predicate: () }
  
  predicate immutable (_0 : ()) =
    [%#sfilter] forall f : (), g : () . unnest f g  -> f = g
  
  predicate precondition (self : ()) (args : bool) =
    let b = args in true
  
  predicate no_precondition (_0 : ()) =
    [%#sfilter'0] forall f : (), i : bool . precondition f i
  
  predicate precise (_0 : ()) =
    [%#sfilter'1] forall f1 : (), f2 : (), i : bool . not (postcondition_mut f1 i f2 true
    /\ postcondition_mut f1 i f2 false)
  
  predicate invariant' (self : t_Filter)
  
  predicate inv (_0 : t_Filter)
  
  axiom inv_axiom [@rewrite] : forall x : t_Filter [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_Filter__iter = iter'0 ; t_Filter__predicate = predicate'} -> true
    end)
  
  predicate inv'0 (_0 : t_Iter)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter [inv'0 x] . inv'0 x = true
  
  function iter'0 (self : t_Filter) : t_Iter
  
  axiom iter_spec : forall self : t_Filter . [%#sfilter'2] inv self  -> inv'0 (iter'0 self)
  
  predicate inv'1 (_0 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'1 x] . inv'1 x = true
  
  function func (self : t_Filter) : ()
  
  axiom func_spec : forall self : t_Filter . [%#sfilter'3] inv self  -> inv'1 (func self)
  
  let rec filter (self_:t_Iter) (f:()) (return'  (x:t_Filter))= {[@expl:filter requires #0] [%#siter'3] immutable f}
    {[@expl:filter requires #1] [%#siter'4] no_precondition f}
    {[@expl:filter requires #2] [%#siter'5] precise f}
    any
    [ return''0 (result:t_Filter)-> {inv result}
      {[%#siter'6] iter'0 result = self_ /\ func result = f}
      (! return' {result}) ]
  
  
  type t_Option  =
    | C_None
    | C_Some bool
  
  predicate invariant''0 (self : MutBorrow.t t_Filter) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'2 (_0 : MutBorrow.t t_Filter)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_Filter [inv'2 x] . inv'2 x = invariant''0 x
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'0 (self : Slice64.slice bool) : Seq.seq bool
  
  axiom view_spec : forall self : Slice64.slice bool . ([%#sslice'10] Seq.length (view'0 self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'11] view'0 self = Slice64.id self)
  
  function view'1 (self : Slice64.slice bool) : Seq.seq bool =
    [%#smodel'1] view'0 self
  
  function index_logic [@inline:trivial] (self : Slice64.slice bool) (ix : int) : bool =
    [%#sindex] Seq.get (view'0 self) ix
  
  function to_ref_seq (self : Slice64.slice bool) : Seq.seq bool
  
  axiom to_ref_seq_spec : forall self : Slice64.slice bool . ([%#sslice'8] Seq.length (to_ref_seq self)
  = Seq.length (view'1 self))
  && ([%#sslice'9] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  predicate produces (self : t_Iter) (visited : Seq.seq bool) (tl : t_Iter) =
    [%#sslice'0] to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  function produces_trans (a : t_Iter) (ab : Seq.seq bool) (b : t_Iter) (bc : Seq.seq bool) (c : t_Iter) : () =
    [%#sslice'7] ()
  
  axiom produces_trans_spec : forall a : t_Iter, ab : Seq.seq bool, b : t_Iter, bc : Seq.seq bool, c : t_Iter . ([%#sslice'4] produces a ab b)
   -> ([%#sslice'5] produces b bc c)  -> ([%#sslice'6] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_Iter) : () =
    [%#sslice'3] ()
  
  axiom produces_refl_spec : forall self : t_Iter . [%#sslice'2] produces self (Seq.empty : Seq.seq bool) self
  
  predicate produces'0 (self : t_Filter) (visited : Seq.seq bool) (succ : t_Filter) =
    [%#sfilter'5] invariant' self
     -> unnest (func self) (func succ)
    /\ (exists s : Seq.seq bool, f : Map.map int int . produces (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> Seq.get visited i = Seq.get s (Map.get f i))
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> (exists j : int . 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
    = postcondition_mut (func self) (Seq.get s i) (func self) true))
  
  function produces_trans'0 (a : t_Filter) (ab : Seq.seq bool) (b : t_Filter) (bc : Seq.seq bool) (c : t_Filter) : ()
  
  axiom produces_trans_spec'0 : forall a : t_Filter, ab : Seq.seq bool, b : t_Filter, bc : Seq.seq bool, c : t_Filter . ([%#sfilter'7] produces'0 a ab b)
   -> ([%#sfilter'8] produces'0 b bc c)  -> ([%#sfilter'9] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_Filter) : ()
  
  axiom produces_refl_spec'0 : forall self : t_Filter . [%#sfilter'6] produces'0 self (Seq.empty : Seq.seq bool) self
  
  predicate resolve'2 (self : MutBorrow.t t_Iter) =
    [%#sresolve] self.final = self.current
  
  function view'2 (self : MutBorrow.t t_Iter) : Slice64.slice bool =
    [%#smodel'0] view self.current
  
  predicate completed (self : MutBorrow.t t_Iter) =
    [%#sslice'1] resolve'2 self /\ view'0 (view'2 self) = (Seq.empty : Seq.seq bool)
  
  predicate completed'0 (self : MutBorrow.t t_Filter) =
    [%#sfilter'4] (exists s : Seq.seq bool, e : MutBorrow.t t_Iter . produces (iter'0 self.current) s e.current
    /\ completed e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut (func self.current) (Seq.get s i) (func self.final) false))
    /\ func self.current = func self.final
  
  let rec next (self_:MutBorrow.t t_Filter) (return'  (x:t_Option))= {[@expl:next 'self_' type invariant] [%#siter'7] inv'2 self_}
    any
    [ return''0 (result:t_Option)-> {[%#siter'8] match result with
        | C_None -> completed'0 self_
        | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self : MutBorrow.t t_Filter) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0 : MutBorrow.t t_Filter) =
    resolve'3 _0
  
  let rec promoted2__test_filter (return'  (x:t_Option))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_Some ([%#siter'9] true) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]  ]
     [ & _0 : t_Option = Any.any_l () | & _1 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  type tuple  =
    { _0: t_Option; _1: t_Option }
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 bool
  
  function deep_model (self : bool) : bool =
    [%#smodel'2] self
  
  function deep_model'0 (self : bool) : bool =
    [%#smodel] deep_model self
  
  function deep_model'1 (self : t_Option) : t_Option'0 =
    [%#soption'0] match self with
      | C_Some t -> C_Some'0 (deep_model'0 t)
      | C_None -> C_None'0
      end
  
  function deep_model'2 (self : t_Option) : t_Option'0 =
    [%#smodel] deep_model'1 self
  
  let rec eq (self_:t_Option) (rhs:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (deep_model'2 self_ = deep_model'2 rhs)} (! return' {result}) ]
  
  
  let rec promoted1__test_filter (return'  (x:t_Option))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1'0 <- C_Some ([%#siter'10] true) ] s1 | s1 =  [ &_0'0 <- _1'0 ] s2 | s2 = return''0 {_0'0} ]
     ]
     [ & _0'0 : t_Option = Any.any_l () | & _1'0 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  let rec promoted0__test_filter (return'  (x:t_Option))= bb0
    [ bb0 = s0 [ s0 =  [ &_1'0 <- C_None ] s1 | s1 =  [ &_0'0 <- _1'0 ] s2 | s2 = return''0 {_0'0} ]  ]
     [ & _0'0 : t_Option = Any.any_l () | & _1'0 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_filter[#"iter.rs" 12 0 12 20] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_filter (fun (pr3:Slice64.array bool) ->  [ &_80 <- pr3 ] s1)
      | s1 = iter {_80} (fun (_ret:t_Iter) ->  [ &_2 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_6 <- () ] s1 | s1 = filter {_2} {_6} (fun (_ret:t_Filter) ->  [ &a <- _ret ] s2) | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv a}
        MutBorrow.borrow_mut <t_Filter> {a}
          (fun (_ret:MutBorrow.t t_Filter) ->  [ &_12 <- _ret ] -{inv _ret.final}-  [ &a <- _ret.final ] s1)
      | s1 = {inv _12.current}
        MutBorrow.borrow_final <t_Filter> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret:MutBorrow.t t_Filter) ->
             [ &_11 <- _ret ] 
            -{inv _ret.final}-
             [ &_12 <- { _12 with current = _ret.final } ] 
            s2)
      | s2 = next {_11} (fun (_ret:t_Option) ->  [ &_10 <- _ret ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _12} s1
      | s1 = -{resolve'4 _12}- s2
      | s2 = promoted2__test_filter (fun (pr2:t_Option) ->  [ &_79 <- pr2 ] s3)
      | s3 =  [ &_8 <- { _0 = _10; _1 = _79 } ] s4
      | s4 =  [ &left_val <- _8._0 ] s5
      | s5 =  [ &right_val <- _8._1 ] s6
      | s6 = eq {left_val} {right_val} (fun (_ret:bool) ->  [ &_19 <- _ret ] s7)
      | s7 = bb4 ]
    
    | bb4 = any [ br0 -> {_19 = false} (! bb6) | br1 -> {_19} (! bb5) ] 
    | bb5 = s0
      [ s0 = {inv a}
        MutBorrow.borrow_mut <t_Filter> {a}
          (fun (_ret:MutBorrow.t t_Filter) ->  [ &_36 <- _ret ] -{inv _ret.final}-  [ &a <- _ret.final ] s1)
      | s1 = {inv _36.current}
        MutBorrow.borrow_final <t_Filter> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret:MutBorrow.t t_Filter) ->
             [ &_35 <- _ret ] 
            -{inv _ret.final}-
             [ &_36 <- { _36 with current = _ret.final } ] 
            s2)
      | s2 = next {_35} (fun (_ret:t_Option) ->  [ &_34 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'2 _36} s1
      | s1 = -{resolve'4 _36}- s2
      | s2 = promoted1__test_filter (fun (pr1:t_Option) ->  [ &_78 <- pr1 ] s3)
      | s3 =  [ &_32 <- { _0 = _34; _1 = _78 } ] s4
      | s4 =  [ &left_val'0 <- _32._0 ] s5
      | s5 =  [ &right_val'0 <- _32._1 ] s6
      | s6 = eq {left_val'0} {right_val'0} (fun (_ret:bool) ->  [ &_43 <- _ret ] s7)
      | s7 = bb8 ]
    
    | bb8 = any [ br0 -> {_43 = false} (! bb10) | br1 -> {_43} (! bb9) ] 
    | bb9 = s0
      [ s0 = {inv a}
        MutBorrow.borrow_mut <t_Filter> {a}
          (fun (_ret:MutBorrow.t t_Filter) ->  [ &_60 <- _ret ] -{inv _ret.final}-  [ &a <- _ret.final ] s1)
      | s1 = {inv _60.current}
        MutBorrow.borrow_final <t_Filter> {_60.current} {MutBorrow.get_id _60}
          (fun (_ret:MutBorrow.t t_Filter) ->
             [ &_59 <- _ret ] 
            -{inv _ret.final}-
             [ &_60 <- { _60 with current = _ret.final } ] 
            s2)
      | s2 = next {_59} (fun (_ret:t_Option) ->  [ &_58 <- _ret ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'2 _60} s1
      | s1 = -{resolve'4 _60}- s2
      | s2 = {[@expl:type invariant] inv a} s3
      | s3 = promoted0__test_filter (fun (pr0:t_Option) ->  [ &_77 <- pr0 ] s4)
      | s4 =  [ &_56 <- { _0 = _58; _1 = _77 } ] s5
      | s5 =  [ &left_val'1 <- _56._0 ] s6
      | s6 =  [ &right_val'1 <- _56._1 ] s7
      | s7 = eq {left_val'1} {right_val'1} (fun (_ret:bool) ->  [ &_65 <- _ret ] s8)
      | s8 = bb12 ]
    
    | bb12 = any [ br0 -> {_65 = false} (! bb14) | br1 -> {_65} (! bb13) ] 
    | bb13 = return''0 {_0'0}
    | bb14 = s0
      [ s0 =  [ &kind'1 <- C_Eq ] s1
      | s1 =  [ &_73 <- left_val'1 ] s2
      | s2 =  [ &_75 <- right_val'1 ] s3
      | s3 = {false} any ]
    
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv a} s1
      | s1 =  [ &kind'0 <- C_Eq ] s2
      | s2 =  [ &_51 <- left_val'0 ] s3
      | s3 =  [ &_53 <- right_val'0 ] s4
      | s4 = {false} any ]
    
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv a} s1
      | s1 =  [ &kind <- C_Eq ] s2
      | s2 =  [ &_27 <- left_val ] s3
      | s3 =  [ &_29 <- right_val ] s4
      | s4 = {false} any ]
     ]
    )
    [ & _0'0 : () = Any.any_l ()
    | & a : t_Filter = Any.any_l ()
    | & _2 : t_Iter = Any.any_l ()
    | & _6 : () = Any.any_l ()
    | & _8 : tuple = Any.any_l ()
    | & _10 : t_Option = Any.any_l ()
    | & _11 : MutBorrow.t t_Filter = Any.any_l ()
    | & _12 : MutBorrow.t t_Filter = Any.any_l ()
    | & left_val : t_Option = Any.any_l ()
    | & right_val : t_Option = Any.any_l ()
    | & _19 : bool = Any.any_l ()
    | & kind : t_AssertKind = Any.any_l ()
    | & _27 : t_Option = Any.any_l ()
    | & _29 : t_Option = Any.any_l ()
    | & _32 : tuple = Any.any_l ()
    | & _34 : t_Option = Any.any_l ()
    | & _35 : MutBorrow.t t_Filter = Any.any_l ()
    | & _36 : MutBorrow.t t_Filter = Any.any_l ()
    | & left_val'0 : t_Option = Any.any_l ()
    | & right_val'0 : t_Option = Any.any_l ()
    | & _43 : bool = Any.any_l ()
    | & kind'0 : t_AssertKind = Any.any_l ()
    | & _51 : t_Option = Any.any_l ()
    | & _53 : t_Option = Any.any_l ()
    | & _56 : tuple = Any.any_l ()
    | & _58 : t_Option = Any.any_l ()
    | & _59 : MutBorrow.t t_Filter = Any.any_l ()
    | & _60 : MutBorrow.t t_Filter = Any.any_l ()
    | & left_val'1 : t_Option = Any.any_l ()
    | & right_val'1 : t_Option = Any.any_l ()
    | & _65 : bool = Any.any_l ()
    | & kind'1 : t_AssertKind = Any.any_l ()
    | & _73 : t_Option = Any.any_l ()
    | & _75 : t_Option = Any.any_l ()
    | & _77 : t_Option = Any.any_l ()
    | & _78 : t_Option = Any.any_l ()
    | & _79 : t_Option = Any.any_l ()
    | & _80 : Slice64.array bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
module M_iter__test_filter_map [#"iter.rs" 22 0 22 24]
  let%span siter = "iter.rs" 23 17 23 21
  let%span siter'0 = "iter.rs" 23 23 23 28
  let%span siter'1 = "iter.rs" 23 30 23 34
  let%span siter'2 = "iter.rs" 25 32 25 37
  let%span siter'3 = "iter.rs" 24 18 24 63
  let%span siter'4 = "../../../creusot-contracts/src/std/iter.rs" 167 27 167 51
  let%span siter'5 = "../../../creusot-contracts/src/std/iter.rs" 168 27 168 57
  let%span siter'6 = "../../../creusot-contracts/src/std/iter.rs" 169 27 169 49
  let%span siter'7 = "../../../creusot-contracts/src/std/iter.rs" 170 26 170 69
  let%span siter'8 = "../../../creusot-contracts/src/std/iter.rs" 122 16 122 17
  let%span siter'9 = "../../../creusot-contracts/src/std/iter.rs" 122 26 125 17
  let%span siter'10 = "iter.rs" 27 37 27 42
  let%span siter'11 = "iter.rs" 28 37 28 42
  let%span sslice = "../../../creusot-contracts/src/std/slice.rs" 303 18 303 33
  let%span sslice'0 = "../../../creusot-contracts/src/std/slice.rs" 435 12 435 66
  let%span sslice'1 = "../../../creusot-contracts/src/std/slice.rs" 428 20 428 61
  let%span sslice'2 = "../../../creusot-contracts/src/std/slice.rs" 441 14 441 45
  let%span sslice'3 = "../../../creusot-contracts/src/std/slice.rs" 442 27 442 29
  let%span sslice'4 = "../../../creusot-contracts/src/std/slice.rs" 446 15 446 32
  let%span sslice'5 = "../../../creusot-contracts/src/std/slice.rs" 447 15 447 32
  let%span sslice'6 = "../../../creusot-contracts/src/std/slice.rs" 448 14 448 42
  let%span sslice'7 = "../../../creusot-contracts/src/std/slice.rs" 449 91 449 93
  let%span sslice'8 = "../../../creusot-contracts/src/std/slice.rs" 97 14 97 41
  let%span sslice'9 = "../../../creusot-contracts/src/std/slice.rs" 98 14 98 80
  let%span sslice'10 = "../../../creusot-contracts/src/std/slice.rs" 27 14 27 41
  let%span sslice'11 = "../../../creusot-contracts/src/std/slice.rs" 28 14 28 42
  let%span soption = "../../../creusot-contracts/src/std/option.rs" 23 26 23 75
  let%span soption'0 = "../../../creusot-contracts/src/std/option.rs" 11 8 14 9
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 54 20 54 34
  let%span smodel = "../../../creusot-contracts/src/model.rs" 45 8 45 28
  let%span smodel'0 = "../../../creusot-contracts/src/model.rs" 72 8 72 22
  let%span smodel'1 = "../../../creusot-contracts/src/model.rs" 82 8 82 12
  let%span smodel'2 = "../../../creusot-contracts/src/model.rs" 54 8 54 22
  let%span sindex = "../../../creusot-contracts/src/logic/ops/index.rs" 52 8 52 31
  let%span sops = "../../../creusot-contracts/src/std/ops.rs" 116 15 116 59
  let%span sops'0 = "../../../creusot-contracts/src/std/ops.rs" 117 14 117 36
  let%span sops'1 = "../../../creusot-contracts/src/std/ops.rs" 122 14 122 31
  let%span sops'2 = "../../../creusot-contracts/src/std/ops.rs" 127 15 127 29
  let%span sops'3 = "../../../creusot-contracts/src/std/ops.rs" 128 15 128 26
  let%span sops'4 = "../../../creusot-contracts/src/std/ops.rs" 129 14 129 28
  let%span sops'5 = "../../../creusot-contracts/src/std/ops.rs" 134 14 135 105
  let%span sinvariant = "../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  let%span sfilter_map = "../../../creusot-contracts/src/std/iter/filter_map.rs" 56 16 56 52
  let%span sfilter_map'0 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 48 16 48 50
  let%span sfilter_map'1 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 63 16 63 135
  let%span sfilter_map'2 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 15 14 15 39
  let%span sfilter_map'3 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 22 14 22 39
  let%span sfilter_map'4 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 75 12 77 47
  let%span sfilter_map'5 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 85 12 98 148
  let%span sfilter_map'6 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 104 14 104 45
  let%span sfilter_map'7 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 109 15 109 32
  let%span sfilter_map'8 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 110 15 110 32
  let%span sfilter_map'9 = "../../../creusot-contracts/src/std/iter/filter_map.rs" 111 14 111 42
  
  use creusot.slice.Slice64
  use creusot.prelude.Any
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.int.UInt64
  use mach.int.Int
  use map.Map
  
  let rec promoted3__test_filter_map (return'  (x:Slice64.array bool))= bb0
    [ bb0 = s0
      [ s0 = any
        [ any_ (__arr_temp:Slice64.array bool)-> (! -{Seq.get __arr_temp.Slice64.elts 0
          /\ Seq.get __arr_temp.Slice64.elts 1 = ([%#siter'0] false)
          /\ Seq.get __arr_temp.Slice64.elts 2 /\ Seq.length __arr_temp.Slice64.elts = 3}-
           [ &_1 <- __arr_temp ] 
          s1) ]
      
      | s1 =  [ &_0 <- _1 ] s2
      | s2 = return''0 {_0} ]
     ]
     [ & _0 : Slice64.array bool = Any.any_l () | & _1 : Slice64.array bool = Any.any_l () ] 
    [ return''0 (result:Slice64.array bool)-> return' {result} ]
  
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Iter  =
    { t_Iter__ptr: t_NonNull; t_Iter__end_or_len: Opaque.ptr; t_Iter__qy95zmarker: () }
  
  function view (self : t_Iter) : Slice64.slice bool
  
  let rec iter (self_:Slice64.slice bool) (return'  (x:t_Iter))= any
    [ return''0 (result:t_Iter)-> {[%#sslice] view result = self_} (! return' {result}) ]
  
  
  predicate resolve (self : MutBorrow.t ()) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0 : MutBorrow.t ()) =
    resolve _0
  
  type t_Option  =
    | C_None
    | C_Some bool
  
  predicate postcondition_once (self : ()) (args : bool) (result : t_Option) =
    [%#siter'3] let b = args in result = (if b then C_Some false else C_None)
  
  predicate resolve'1 (_0 : ()) =
    true
  
  predicate unnest (self : ()) (_1 : ()) =
    true
  
  predicate postcondition_mut (self : ()) (args : bool) (result_state : ()) (result : t_Option) =
    (let b = args in result = (if b then C_Some false else C_None)) /\ unnest self result_state
  
  function fn_mut_once (self : ()) (args : bool) (res : t_Option) : ()
  
  axiom fn_mut_once_spec : forall self : (), args : bool, res : t_Option . [%#sops'5] postcondition_once self args res
  = (exists res_state : () . postcondition_mut self args res_state res /\ resolve'1 res_state)
  
  function unnest_trans (self : ()) (b : ()) (c : ()) : ()
  
  axiom unnest_trans_spec : forall self : (), b : (), c : () . ([%#sops'2] unnest self b)
   -> ([%#sops'3] unnest b c)  -> ([%#sops'4] unnest self c)
  
  function unnest_refl (self : ()) : ()
  
  axiom unnest_refl_spec : forall self : () . [%#sops'1] unnest self self
  
  function postcondition_mut_unnest (self : ()) (args : bool) (res_state : ()) (res : t_Option) : ()
  
  axiom postcondition_mut_unnest_spec : forall self : (), args : bool, res_state : (), res : t_Option . ([%#sops] postcondition_mut self args res_state res)
   -> ([%#sops'0] unnest self res_state)
  
  let rec closure0[#"iter.rs" 24 8 24 65] (self:MutBorrow.t ()) (b:bool) (return'  (x:t_Option))= (! bb0
    [ bb0 = s0 [ s0 = -{resolve'0 _1}- s1 | s1 = any [ br0 -> {b'0 = false} (! bb2) | br1 -> {b'0} (! bb1) ]  ] 
    | bb1 = s0 [ s0 =  [ &res <- C_Some ([%#siter'2] false) ] s1 | s1 = bb3 ] 
    | bb2 = s0 [ s0 =  [ &res <- C_None ] s1 | s1 = bb3 ] 
    | bb3 = s0 [ s0 =  [ &_0 <- res ] s1 | s1 = return''0 {_0} ]  ]
    )
    [ & _0 : t_Option = Any.any_l ()
    | & _1 : MutBorrow.t () = self
    | & b'0 : bool = b
    | & res : t_Option = Any.any_l () ]
    
    [ return''0 (result:t_Option)-> {[@expl:closure ensures] [%#siter'3] result = (if b then C_Some false else C_None)}
      {[@expl:closure unnest] unnest self.current self.final}
      (! return' {result}) ]
  
  
  type t_FilterMap  =
    { t_FilterMap__iter: t_Iter; t_FilterMap__f: () }
  
  predicate immutable (f : ()) =
    [%#sfilter_map] forall g : () . unnest f g  -> f = g
  
  predicate precondition (self : ()) (args : bool) =
    let b = args in true
  
  predicate no_precondition (f : ()) =
    [%#sfilter_map'0] forall i : bool . precondition f i
  
  predicate precise (f1 : ()) =
    [%#sfilter_map'1] forall f2 : (), i : bool . not ((exists b : bool . postcondition_mut f1 i f2 (C_Some b))
    /\ postcondition_mut f1 i f2 (C_None))
  
  predicate invariant' (self : t_FilterMap)
  
  predicate inv (_0 : t_FilterMap)
  
  axiom inv_axiom [@rewrite] : forall x : t_FilterMap [inv x] . inv x
  = (invariant' x
  /\ match x with
    | {t_FilterMap__iter = iter'0 ; t_FilterMap__f = f} -> true
    end)
  
  predicate inv'0 (_0 : t_Iter)
  
  axiom inv_axiom'0 [@rewrite] : forall x : t_Iter [inv'0 x] . inv'0 x = true
  
  function iter'0 (self : t_FilterMap) : t_Iter
  
  axiom iter_spec : forall self : t_FilterMap . [%#sfilter_map'2] inv self  -> inv'0 (iter'0 self)
  
  predicate inv'1 (_0 : ())
  
  axiom inv_axiom'1 [@rewrite] : forall x : () [inv'1 x] . inv'1 x = true
  
  function func (self : t_FilterMap) : ()
  
  axiom func_spec : forall self : t_FilterMap . [%#sfilter_map'3] inv self  -> inv'1 (func self)
  
  let rec filter_map (self_:t_Iter) (f:()) (return'  (x:t_FilterMap))= {[@expl:filter_map requires #0] [%#siter'4] immutable f}
    {[@expl:filter_map requires #1] [%#siter'5] no_precondition f}
    {[@expl:filter_map requires #2] [%#siter'6] precise f}
    any
    [ return''0 (result:t_FilterMap)-> {inv result}
      {[%#siter'7] iter'0 result = self_ /\ func result = f}
      (! return' {result}) ]
  
  
  predicate invariant''0 (self : MutBorrow.t t_FilterMap) =
    [%#sinvariant] inv self.current /\ inv self.final
  
  predicate inv'2 (_0 : MutBorrow.t t_FilterMap)
  
  axiom inv_axiom'2 [@rewrite] : forall x : MutBorrow.t t_FilterMap [inv'2 x] . inv'2 x = invariant''0 x
  
  constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)
  
  function view'0 (self : Slice64.slice bool) : Seq.seq bool
  
  axiom view_spec : forall self : Slice64.slice bool . ([%#sslice'10] Seq.length (view'0 self)
  <= UInt64.t'int (v_MAX : UInt64.t))
  && ([%#sslice'11] view'0 self = Slice64.id self)
  
  function view'1 (self : Slice64.slice bool) : Seq.seq bool =
    [%#smodel'2] view'0 self
  
  function index_logic [@inline:trivial] (self : Slice64.slice bool) (ix : int) : bool =
    [%#sindex] Seq.get (view'0 self) ix
  
  function to_ref_seq (self : Slice64.slice bool) : Seq.seq bool
  
  axiom to_ref_seq_spec : forall self : Slice64.slice bool . ([%#sslice'8] Seq.length (to_ref_seq self)
  = Seq.length (view'1 self))
  && ([%#sslice'9] forall i : int . 0 <= i /\ i < Seq.length (to_ref_seq self)
   -> Seq.get (to_ref_seq self) i = index_logic self i)
  
  predicate produces (self : t_Iter) (visited : Seq.seq bool) (tl : t_Iter) =
    [%#sslice'0] to_ref_seq (view self) = Seq.(++) visited (to_ref_seq (view tl))
  
  function produces_trans (a : t_Iter) (ab : Seq.seq bool) (b : t_Iter) (bc : Seq.seq bool) (c : t_Iter) : () =
    [%#sslice'7] ()
  
  axiom produces_trans_spec : forall a : t_Iter, ab : Seq.seq bool, b : t_Iter, bc : Seq.seq bool, c : t_Iter . ([%#sslice'4] produces a ab b)
   -> ([%#sslice'5] produces b bc c)  -> ([%#sslice'6] produces a (Seq.(++) ab bc) c)
  
  function produces_refl (self : t_Iter) : () =
    [%#sslice'3] ()
  
  axiom produces_refl_spec : forall self : t_Iter . [%#sslice'2] produces self (Seq.empty : Seq.seq bool) self
  
  predicate produces'0 (self : t_FilterMap) (visited : Seq.seq bool) (succ : t_FilterMap) =
    [%#sfilter_map'5] invariant' self
     -> unnest (func self) (func succ)
    /\ (exists s : Seq.seq bool, f : Map.map int int . produces (iter'0 self) s (iter'0 succ)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited  -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
    /\ (forall i : int, j : int . 0 <= i /\ i < j /\ j < Seq.length visited  -> Map.get f i < Map.get f j)
    /\ (forall i : int . 0 <= i /\ i < Seq.length visited
     -> postcondition_mut (func self) (Seq.get s (Map.get f i)) (func self) (C_Some (Seq.get visited i)))
    /\ (forall j : int . 0 <= j /\ j < Seq.length s
     -> (not (exists i : int . 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
    = postcondition_mut (func self) (Seq.get s j) (func self) (C_None)))
  
  function produces_trans'0 (a : t_FilterMap) (ab : Seq.seq bool) (b : t_FilterMap) (bc : Seq.seq bool) (c : t_FilterMap) : ()
  
  
  axiom produces_trans_spec'0 : forall a : t_FilterMap, ab : Seq.seq bool, b : t_FilterMap, bc : Seq.seq bool, c : t_FilterMap . ([%#sfilter_map'7] produces'0 a ab b)
   -> ([%#sfilter_map'8] produces'0 b bc c)  -> ([%#sfilter_map'9] produces'0 a (Seq.(++) ab bc) c)
  
  function produces_refl'0 (self : t_FilterMap) : ()
  
  axiom produces_refl_spec'0 : forall self : t_FilterMap . [%#sfilter_map'6] produces'0 self (Seq.empty : Seq.seq bool) self
  
  predicate resolve'2 (self : MutBorrow.t t_Iter) =
    [%#sresolve] self.final = self.current
  
  function view'2 (self : MutBorrow.t t_Iter) : Slice64.slice bool =
    [%#smodel'0] view self.current
  
  predicate completed (self : MutBorrow.t t_Iter) =
    [%#sslice'1] resolve'2 self /\ view'0 (view'2 self) = (Seq.empty : Seq.seq bool)
  
  predicate completed'0 (self : MutBorrow.t t_FilterMap) =
    [%#sfilter_map'4] (exists s : Seq.seq bool, e : MutBorrow.t t_Iter . produces (iter'0 self.current) s e.current
    /\ completed e
    /\ (forall i : int . 0 <= i /\ i < Seq.length s
     -> postcondition_mut (func self.current) (Seq.get s i) (func self.final) (C_None)))
    /\ func self.current = func self.final
  
  let rec next (self_:MutBorrow.t t_FilterMap) (return'  (x:t_Option))= {[@expl:next 'self_' type invariant] [%#siter'8] inv'2 self_}
    any
    [ return''0 (result:t_Option)-> {[%#siter'9] match result with
        | C_None -> completed'0 self_
        | C_Some v -> produces'0 self_.current (Seq.singleton v) self_.final
        end}
      (! return' {result}) ]
  
  
  predicate resolve'3 (self : MutBorrow.t t_FilterMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'4 (_0 : MutBorrow.t t_FilterMap) =
    resolve'3 _0
  
  let rec promoted2__test_filter_map (return'  (x:t_Option))= bb0
    [ bb0 = s0 [ s0 =  [ &_1 <- C_Some ([%#siter'10] false) ] s1 | s1 =  [ &_0 <- _1 ] s2 | s2 = return''0 {_0} ]  ]
     [ & _0 : t_Option = Any.any_l () | & _1 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  type tuple  =
    { _0: t_Option; _1: t_Option }
  
  function deep_model (self : bool) : bool =
    [%#smodel'1] self
  
  function deep_model'0 (self : t_Option) : t_Option =
    [%#soption'0] match self with
      | C_Some t -> C_Some (deep_model t)
      | C_None -> C_None
      end
  
  function deep_model'1 (self : t_Option) : t_Option =
    [%#smodel] deep_model'0 self
  
  let rec eq (self_:t_Option) (rhs:t_Option) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#soption] result = (deep_model'1 self_ = deep_model'1 rhs)} (! return' {result}) ]
  
  
  let rec promoted1__test_filter_map (return'  (x:t_Option))= bb0
    [ bb0 = s0
      [ s0 =  [ &_1'0 <- C_Some ([%#siter'11] false) ] s1 | s1 =  [ &_0'0 <- _1'0 ] s2 | s2 = return''0 {_0'0} ]
     ]
     [ & _0'0 : t_Option = Any.any_l () | & _1'0 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  let rec promoted0__test_filter_map (return'  (x:t_Option))= bb0
    [ bb0 = s0 [ s0 =  [ &_1'0 <- C_None ] s1 | s1 =  [ &_0'0 <- _1'0 ] s2 | s2 = return''0 {_0'0} ]  ]
     [ & _0'0 : t_Option = Any.any_l () | & _1'0 : t_Option = Any.any_l () ] 
    [ return''0 (result:t_Option)-> return' {result} ]
  
  
  type t_AssertKind  =
    | C_Eq
    | C_Ne
    | C_Match
  
  meta "compute_max_steps" 1000000
  
  let rec test_filter_map[#"iter.rs" 22 0 22 24] (return'  (x:()))= (! bb0
    [ bb0 = s0
      [ s0 = promoted3__test_filter_map (fun (pr3:Slice64.array bool) ->  [ &_76 <- pr3 ] s1)
      | s1 = iter {_76} (fun (_ret:t_Iter) ->  [ &_2 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 =  [ &_6 <- () ] s1 | s1 = filter_map {_2} {_6} (fun (_ret:t_FilterMap) ->  [ &a <- _ret ] s2) | s2 = bb2 ]
    
    | bb2 = s0
      [ s0 = {inv a}
        MutBorrow.borrow_mut <t_FilterMap> {a}
          (fun (_ret:MutBorrow.t t_FilterMap) ->  [ &_12 <- _ret ] -{inv _ret.final}-  [ &a <- _ret.final ] s1)
      | s1 = {inv _12.current}
        MutBorrow.borrow_final <t_FilterMap> {_12.current} {MutBorrow.get_id _12}
          (fun (_ret:MutBorrow.t t_FilterMap) ->
             [ &_11 <- _ret ] 
            -{inv _ret.final}-
             [ &_12 <- { _12 with current = _ret.final } ] 
            s2)
      | s2 = next {_11} (fun (_ret:t_Option) ->  [ &_10 <- _ret ] s3)
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 = {[@expl:type invariant] inv'2 _12} s1
      | s1 = -{resolve'4 _12}- s2
      | s2 = promoted2__test_filter_map (fun (pr2:t_Option) ->  [ &_75 <- pr2 ] s3)
      | s3 =  [ &_8 <- { _0 = _10; _1 = _75 } ] s4
      | s4 =  [ &left_val <- _8._0 ] s5
      | s5 =  [ &right_val <- _8._1 ] s6
      | s6 = eq {left_val} {right_val} (fun (_ret:bool) ->  [ &_17 <- _ret ] s7)
      | s7 = bb4 ]
    
    | bb4 = any [ br0 -> {_17 = false} (! bb6) | br1 -> {_17} (! bb5) ] 
    | bb5 = s0
      [ s0 = {inv a}
        MutBorrow.borrow_mut <t_FilterMap> {a}
          (fun (_ret:MutBorrow.t t_FilterMap) ->  [ &_34 <- _ret ] -{inv _ret.final}-  [ &a <- _ret.final ] s1)
      | s1 = {inv _34.current}
        MutBorrow.borrow_final <t_FilterMap> {_34.current} {MutBorrow.get_id _34}
          (fun (_ret:MutBorrow.t t_FilterMap) ->
             [ &_33 <- _ret ] 
            -{inv _ret.final}-
             [ &_34 <- { _34 with current = _ret.final } ] 
            s2)
      | s2 = next {_33} (fun (_ret:t_Option) ->  [ &_32 <- _ret ] s3)
      | s3 = bb7 ]
    
    | bb7 = s0
      [ s0 = {[@expl:type invariant] inv'2 _34} s1
      | s1 = -{resolve'4 _34}- s2
      | s2 = promoted1__test_filter_map (fun (pr1:t_Option) ->  [ &_74 <- pr1 ] s3)
      | s3 =  [ &_30 <- { _0 = _32; _1 = _74 } ] s4
      | s4 =  [ &left_val'0 <- _30._0 ] s5
      | s5 =  [ &right_val'0 <- _30._1 ] s6
      | s6 = eq {left_val'0} {right_val'0} (fun (_ret:bool) ->  [ &_39 <- _ret ] s7)
      | s7 = bb8 ]
    
    | bb8 = any [ br0 -> {_39 = false} (! bb10) | br1 -> {_39} (! bb9) ] 
    | bb9 = s0
      [ s0 = {inv a}
        MutBorrow.borrow_mut <t_FilterMap> {a}
          (fun (_ret:MutBorrow.t t_FilterMap) ->  [ &_56 <- _ret ] -{inv _ret.final}-  [ &a <- _ret.final ] s1)
      | s1 = {inv _56.current}
        MutBorrow.borrow_final <t_FilterMap> {_56.current} {MutBorrow.get_id _56}
          (fun (_ret:MutBorrow.t t_FilterMap) ->
             [ &_55 <- _ret ] 
            -{inv _ret.final}-
             [ &_56 <- { _56 with current = _ret.final } ] 
            s2)
      | s2 = next {_55} (fun (_ret:t_Option) ->  [ &_54 <- _ret ] s3)
      | s3 = bb11 ]
    
    | bb11 = s0
      [ s0 = {[@expl:type invariant] inv'2 _56} s1
      | s1 = -{resolve'4 _56}- s2
      | s2 = {[@expl:type invariant] inv a} s3
      | s3 = promoted0__test_filter_map (fun (pr0:t_Option) ->  [ &_73 <- pr0 ] s4)
      | s4 =  [ &_52 <- { _0 = _54; _1 = _73 } ] s5
      | s5 =  [ &left_val'1 <- _52._0 ] s6
      | s6 =  [ &right_val'1 <- _52._1 ] s7
      | s7 = eq {left_val'1} {right_val'1} (fun (_ret:bool) ->  [ &_61 <- _ret ] s8)
      | s8 = bb12 ]
    
    | bb12 = any [ br0 -> {_61 = false} (! bb14) | br1 -> {_61} (! bb13) ] 
    | bb13 = return''0 {_0'0}
    | bb14 = s0
      [ s0 =  [ &kind'1 <- C_Eq ] s1
      | s1 =  [ &_69 <- left_val'1 ] s2
      | s2 =  [ &_71 <- right_val'1 ] s3
      | s3 = {false} any ]
    
    | bb10 = s0
      [ s0 = {[@expl:type invariant] inv a} s1
      | s1 =  [ &kind'0 <- C_Eq ] s2
      | s2 =  [ &_47 <- left_val'0 ] s3
      | s3 =  [ &_49 <- right_val'0 ] s4
      | s4 = {false} any ]
    
    | bb6 = s0
      [ s0 = {[@expl:type invariant] inv a} s1
      | s1 =  [ &kind <- C_Eq ] s2
      | s2 =  [ &_25 <- left_val ] s3
      | s3 =  [ &_27 <- right_val ] s4
      | s4 = {false} any ]
     ]
    )
    [ & _0'0 : () = Any.any_l ()
    | & a : t_FilterMap = Any.any_l ()
    | & _2 : t_Iter = Any.any_l ()
    | & _6 : () = Any.any_l ()
    | & _8 : tuple = Any.any_l ()
    | & _10 : t_Option = Any.any_l ()
    | & _11 : MutBorrow.t t_FilterMap = Any.any_l ()
    | & _12 : MutBorrow.t t_FilterMap = Any.any_l ()
    | & left_val : t_Option = Any.any_l ()
    | & right_val : t_Option = Any.any_l ()
    | & _17 : bool = Any.any_l ()
    | & kind : t_AssertKind = Any.any_l ()
    | & _25 : t_Option = Any.any_l ()
    | & _27 : t_Option = Any.any_l ()
    | & _30 : tuple = Any.any_l ()
    | & _32 : t_Option = Any.any_l ()
    | & _33 : MutBorrow.t t_FilterMap = Any.any_l ()
    | & _34 : MutBorrow.t t_FilterMap = Any.any_l ()
    | & left_val'0 : t_Option = Any.any_l ()
    | & right_val'0 : t_Option = Any.any_l ()
    | & _39 : bool = Any.any_l ()
    | & kind'0 : t_AssertKind = Any.any_l ()
    | & _47 : t_Option = Any.any_l ()
    | & _49 : t_Option = Any.any_l ()
    | & _52 : tuple = Any.any_l ()
    | & _54 : t_Option = Any.any_l ()
    | & _55 : MutBorrow.t t_FilterMap = Any.any_l ()
    | & _56 : MutBorrow.t t_FilterMap = Any.any_l ()
    | & left_val'1 : t_Option = Any.any_l ()
    | & right_val'1 : t_Option = Any.any_l ()
    | & _61 : bool = Any.any_l ()
    | & kind'1 : t_AssertKind = Any.any_l ()
    | & _69 : t_Option = Any.any_l ()
    | & _71 : t_Option = Any.any_l ()
    | & _73 : t_Option = Any.any_l ()
    | & _74 : t_Option = Any.any_l ()
    | & _75 : t_Option = Any.any_l ()
    | & _76 : Slice64.array bool = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
