module M_ghost_map__ghost_map [#"ghost_map.rs" 4 0 4 18]
  let%span sghost_map = "ghost_map.rs" 7 22 7 53
  let%span sghost_map'0 = "ghost_map.rs" 8 25 8 26
  let%span sghost_map'1 = "ghost_map.rs" 8 28 8 30
  let%span sghost_map'2 = "ghost_map.rs" 10 22 10 47
  let%span sghost_map'3 = "ghost_map.rs" 11 22 11 34
  let%span sghost_map'4 = "ghost_map.rs" 13 17 13 19
  let%span sghost_map'5 = "ghost_map.rs" 15 22 15 47
  let%span sghost_map'6 = "ghost_map.rs" 17 45 17 46
  let%span sghost_map'7 = "ghost_map.rs" 17 48 17 50
  let%span sghost_map'8 = "ghost_map.rs" 18 45 18 46
  let%span sghost_map'9 = "ghost_map.rs" 18 48 18 51
  let%span sghost_map'10 = "ghost_map.rs" 20 22 20 43
  let%span sghost_map'11 = "ghost_map.rs" 21 22 21 50
  let%span sghost_map'12 = "ghost_map.rs" 22 22 22 34
  let%span sghost_map'13 = "ghost_map.rs" 23 22 23 48
  let%span sghost_map'14 = "ghost_map.rs" 24 22 24 47
  let%span sghost_map'15 = "ghost_map.rs" 27 17 27 19
  let%span sghost_map'16 = "ghost_map.rs" 28 30 28 31
  let%span sghost_map'17 = "ghost_map.rs" 28 33 28 36
  let%span sghost_map'18 = "ghost_map.rs" 29 30 29 31
  let%span sghost_map'19 = "ghost_map.rs" 29 33 29 35
  let%span sghost_map'20 = "ghost_map.rs" 31 22 31 47
  let%span sghost_map'21 = "ghost_map.rs" 32 22 32 48
  let%span sghost_map'22 = "ghost_map.rs" 37 22 37 42
  let%span sghost_map'23 = "ghost_map.rs" 38 22 38 49
  let%span sghost_map'24 = "ghost_map.rs" 39 22 39 42
  let%span sghost_map'25 = "ghost_map.rs" 40 22 40 43
  let%span sghost_map'26 = "ghost_map.rs" 45 22 45 31
  let%span sghost_map'27 = "ghost_map.rs" 46 22 46 32
  let%span sghost_map'28 = "ghost_map.rs" 47 22 47 32
  let%span sghost_map'29 = "ghost_map.rs" 52 22 52 42
  let%span sghost_map'30 = "ghost_map.rs" 53 22 53 34
  let%span sghost_map'31 = "ghost_map.rs" 54 22 54 34
  let%span sghost_map'32 = "ghost_map.rs" 12 44 12 45
  let%span sghost_map'33 = "ghost_map.rs" 26 54 26 55
  let%span sghost_map'34 = "ghost_map.rs" 34 45 34 46
  let%span sghost_map'35 = "ghost_map.rs" 35 44 35 45
  let%span sghost_map'36 = "ghost_map.rs" 36 45 36 46
  let%span sghost_map'37 = "ghost_map.rs" 42 44 42 45
  let%span sghost_map'38 = "ghost_map.rs" 43 44 43 45
  let%span sghost_map'39 = "ghost_map.rs" 44 44 44 45
  let%span sghost_map'40 = "ghost_map.rs" 49 34 49 35
  let%span sghost_map'41 = "ghost_map.rs" 50 34 50 35
  let%span sghost_map'42 = "ghost_map.rs" 51 34 51 35
  let%span sfmap = "../../../creusot-contracts/src/logic/fmap.rs" 238 14 238 31
  let%span sfmap'0 = "../../../creusot-contracts/src/logic/fmap.rs" 133 8 133 35
  let%span sfmap'1 = "../../../creusot-contracts/src/logic/fmap.rs" 412 14 412 49
  let%span sfmap'2 = "../../../creusot-contracts/src/logic/fmap.rs" 413 14 413 40
  let%span sfmap'3 = "../../../creusot-contracts/src/logic/fmap.rs" 265 14 265 34
  let%span sfmap'4 = "../../../creusot-contracts/src/logic/fmap.rs" 117 8 117 31
  let%span sfmap'5 = "../../../creusot-contracts/src/logic/fmap.rs" 337 14 346 9
  let%span sfmap'6 = "../../../creusot-contracts/src/logic/fmap.rs" 347 14 347 89
  let%span sfmap'7 = "../../../creusot-contracts/src/logic/fmap.rs" 348 14 348 44
  let%span sfmap'8 = "../../../creusot-contracts/src/logic/fmap.rs" 377 14 385 5
  let%span sfmap'9 = "../../../creusot-contracts/src/logic/fmap.rs" 451 14 451 43
  let%span sfmap'10 = "../../../creusot-contracts/src/logic/fmap.rs" 452 14 452 41
  let%span sfmap'11 = "../../../creusot-contracts/src/logic/fmap.rs" 93 8 96 9
  let%span sfmap'12 = "../../../creusot-contracts/src/logic/fmap.rs" 285 14 285 43
  let%span sfmap'13 = "../../../creusot-contracts/src/logic/fmap.rs" 307 14 314 9
  let%span sfmap'14 = "../../../creusot-contracts/src/logic/fmap.rs" 140 8 140 34
  let%span sfmap'15 = "../../../creusot-contracts/src/logic/fmap.rs" 104 8 104 26
  let%span sfmap'16 = "../../../creusot-contracts/src/logic/fmap.rs" 67 14 67 71
  let%span sfmap'17 = "../../../creusot-contracts/src/logic/fmap.rs" 68 14 68 61
  let%span sfmap'18 = "../../../creusot-contracts/src/logic/fmap.rs" 69 14 69 66
  let%span sfmap'19 = "../../../creusot-contracts/src/logic/fmap.rs" 49 14 49 25
  let%span sfmap'20 = "../../../creusot-contracts/src/logic/fmap.rs" 125 8 125 35
  let%span sfmap'21 = "../../../creusot-contracts/src/logic/fmap.rs" 77 14 77 55
  let%span sfmap'22 = "../../../creusot-contracts/src/logic/fmap.rs" 78 14 78 84
  let%span sfmap'23 = "../../../creusot-contracts/src/logic/fmap.rs" 215 14 215 38
  let%span sfmap'24 = "../../../creusot-contracts/src/logic/fmap.rs" 216 14 216 83
  let%span sfmap'25 = "../../../creusot-contracts/src/logic/fmap.rs" 218 8 218 35
  let%span sfmap'26 = "../../../creusot-contracts/src/logic/fmap.rs" 40 14 40 31
  let%span sfmap'27 = "../../../creusot-contracts/src/logic/fmap.rs" 41 14 41 49
  let%span sfmap'28 = "../../../creusot-contracts/src/logic/fmap.rs" 59 14 59 86
  let%span sghost = "../../../creusot-contracts/src/ghost.rs" 77 14 77 31
  let%span sghost'0 = "../../../creusot-contracts/src/ghost.rs" 78 14 78 31
  let%span sghost'1 = "../../../creusot-contracts/src/ghost.rs" 67 14 67 43
  let%span sghost'2 = "../../../creusot-contracts/src/ghost.rs" 162 14 162 26
  let%span sresolve = "../../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span sutil = "../../../creusot-contracts/src/util.rs" 21 14 21 30
  let%span sutil'0 = "../../../creusot-contracts/src/util.rs" 54 11 54 21
  let%span sutil'1 = "../../../creusot-contracts/src/util.rs" 55 10 55 28
  
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_FMap
  
  type t_Option  =
    | C_None
    | C_Some Int32.t
  
  function view (self: t_FMap) : Map.map Int32.t t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'28] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: Int32.t) : t_Option =
    [%#sfmap'15] Map.get (view self) k
  
  function ext_eq (self: t_FMap) (other: t_FMap) : bool =
    [%#sfmap'25] view self = view other
  
  axiom ext_eq_spec: forall self: t_FMap, other: t_FMap. ([%#sfmap'23] ext_eq self other  -> self = other)
  && ([%#sfmap'24] (forall k: Int32.t. get_unsized self k = get_unsized other k)  -> ext_eq self other)
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'19] len self >= 0
  
  constant empty  : t_FMap
  
  axiom empty_spec: ([%#sfmap'26] len empty = 0) && ([%#sfmap'27] view empty = Const.const (C_None))
  
  function is_empty (self: t_FMap) : bool =
    [%#sfmap'14] ext_eq self empty
  
  let rec new (return'  (x: t_FMap))= any
    [ return''0 (result: t_FMap)-> {[%#sfmap] is_empty result} (! return' {result}) ]
  
  
  function contains [@inline:trivial] (self: t_FMap) (k: Int32.t) : bool =
    [%#sfmap'0] get_unsized self k <> C_None
  
  let rec deref_mut (self:MutBorrow.t ( t_FMap)) (return'  (x:MutBorrow.t t_FMap))= any
    [ return''0 (result:MutBorrow.t t_FMap)-> {[%#sghost] result.current = self.current}
      {[%#sghost'0] result.final = self.final}
      (! return' {result}) ]
  
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 Int32.t
  
  function make_sized (self: Int32.t) : Int32.t
  
  axiom make_sized_spec: forall self: Int32.t. [%#sutil] make_sized self = self
  
  function insert (self: t_FMap) (k: Int32.t) (v: Int32.t) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: Int32.t, v: Int32.t. ([%#sfmap'16] view (insert self k v)
  = Map.set (view self) k (C_Some (make_sized v)))
  && ([%#sfmap'17] contains self k  -> len (insert self k v) = len self)
  && ([%#sfmap'18] not contains self k  -> len (insert self k v) = len self + 1)
  
  function get [@inline:trivial] (self: t_FMap) (k: Int32.t) : t_Option'0 =
    [%#sfmap'11] match get_unsized self k with
      | C_None -> C_None'0
      | C_Some x -> C_Some'0 x
      end
  
  let rec insert_ghost (self:MutBorrow.t t_FMap) (key:Int32.t) (value:Int32.t) (return'  (x:t_Option'0))= any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'1] self.final = insert self.current key value}
      {[%#sfmap'2] result = get self.current key}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t t_FMap) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t t_FMap) =
    resolve _0
  
  let rec deref (self: t_FMap) (return'  (x:t_FMap))= any
    [ return''0 (result:t_FMap)-> {[%#sghost'1] self = result} (! return' {result}) ]
  
  
  let rec len_ghost (self:t_FMap) (return'  (x:int))= any
    [ return''0 (result:int)-> {[%#sfmap'3] result = len self} (! return' {result}) ]
  
  
  function unwrap (op: t_Option) : Int32.t
  
  axiom unwrap_spec: forall op: t_Option. ([%#sutil'0] op <> C_None)  -> ([%#sutil'1] C_Some (unwrap op) = op)
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: Int32.t) : Int32.t =
    [%#sfmap'20] unwrap (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: Int32.t) : Int32.t =
    [%#sfmap'4] lookup_unsized self k
  
  let rec promoted10__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'32] (1: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  type t_Option'1  =
    | C_None'1
    | C_Some'1 (MutBorrow.t Int32.t)
  
  let rec get_mut_ghost (self:MutBorrow.t t_FMap) (key:Int32.t) (return'  (x:t_Option'1))= any
    [ return''0 (result:t_Option'1)-> {[%#sfmap'5] if contains self.current key then
        match result with
          | C_None'1 -> false
          | C_Some'1 r -> contains self.final key
          /\ lookup_unsized self.current key = r.current /\ lookup_unsized self.final key = r.final
          end
      else
        result = C_None'1 /\ self.current = self.final
      }
      {[%#sfmap'6] forall k: Int32.t. k <> key  -> get_unsized self.current k = get_unsized self.final k}
      {[%#sfmap'7] len self.current = len self.final}
      (! return' {result}) ]
  
  
  predicate resolve'1 (self: MutBorrow.t Int32.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t Int32.t) =
    resolve'1 _0
  
  let rec v_Some (input:t_Option'1) (ret  (field_0:MutBorrow.t Int32.t))= any
    [ good (field_0:MutBorrow.t Int32.t)-> {C_Some'1 field_0 = input} (! ret {field_0})
    | bad -> {forall field_0: MutBorrow.t Int32.t [C_Some'1 field_0: t_Option'1]. C_Some'1 field_0 <> input}
      (! {false}
      any) ]
  
  
  let rec promoted9__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'33] (1: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  type tuple  =
    { _p0: t_Option'1; _p1: MutBorrow.t t_FMap }
  
  function remove (self: t_FMap) (k: Int32.t) : t_FMap
  
  axiom remove_spec: forall self: t_FMap, k: Int32.t. ([%#sfmap'21] view (remove self k)
  = Map.set (view self) k (C_None))
  && ([%#sfmap'22] len (remove self k) = (if contains self k then len self - 1 else len self))
  
  let rec split_mut_ghost (self:MutBorrow.t t_FMap) (key:Int32.t) (return'  (x:tuple))= any
    [ return''0 (result:tuple)-> {[%#sfmap'8] if contains self.current key then
        (result._p1).current = remove self.current key
        /\ match result._p0 with
          | C_None'1 -> false
          | C_Some'1 r -> lookup_unsized self.current key = r.current
          /\ self.final = insert (result._p1).final key r.final
          end
      else
        result._p0 = C_None'1 /\ result._p1 = self
      }
      (! return' {result}) ]
  
  
  let rec promoted8__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'34] (3: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec remove_ghost (self:MutBorrow.t t_FMap) (key:Int32.t) (return'  (x:t_Option'0))= any
    [ return''0 (result:t_Option'0)-> {[%#sfmap'9] self.final = remove self.current key}
      {[%#sfmap'10] result = get self.current key}
      (! return' {result}) ]
  
  
  let rec promoted7__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'35] (2: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec promoted6__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'36] (2: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec promoted5__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'37] (1: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec contains_ghost (self:t_FMap) (key:Int32.t) (return'  (x:bool))= any
    [ return''0 (result:bool)-> {[%#sfmap'12] result = contains self key} (! return' {result}) ]
  
  
  let rec promoted4__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'38] (2: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec promoted3__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'39] (3: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec promoted2__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'40] (1: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  type t_Option'2  =
    | C_None'2
    | C_Some'2 Int32.t
  
  let rec get_ghost (self:t_FMap) (key:Int32.t) (return'  (x:t_Option'2))= any
    [ return''0 (result:t_Option'2)-> {[%#sfmap'13] if contains self key then
        match result with
          | C_None'2 -> false
          | C_Some'2 r -> lookup_unsized self key = r
          end
      else
        result = C_None'2
      }
      (! return' {result}) ]
  
  
  let rec promoted1__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'41] (2: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec promoted0__ghost_map (return'  (x:Int32.t))= bb0
    [ bb0 = s0 [ s0 =  [ &_0 <- [%#sghost_map'42] (3: Int32.t) ] s1 | s1 = return''0 {_0} ]  ]
     [ & _0: Int32.t = Any.any_l () ]  [ return''0 (result:Int32.t)-> return' {result} ] 
  
  let rec new'0 (x:()) (return'  (x'0: ()))= any
    [ return''0 (result: ())-> {[%#sghost'2] result = x} (! return' {result}) ]
  
  
  meta "compute_max_steps" 1000000
  
  let rec ghost_map[#"ghost_map.rs" 4 0 4 18] (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 = new (fun (_ret: t_FMap) ->  [ &map <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map] forall k: Int32.t. not contains map k} s1
      | s1 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_9 <- _ret ]  [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_9} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_8 <- _ret ] s3)
      | s3 = bb2 ]
    
    | bb2 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_7 <- _ret ]  [ &_8 <- { _8 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_7} {[%#sghost_map'0] (1: Int32.t)} {[%#sghost_map'1] (21: Int32.t)}
          (fun (_ret:t_Option'0) ->  [ &_6 <- _ret ] s2)
      | s2 = bb3 ]
    
    | bb3 = s0 [ s0 = -{resolve'0 _8}- s1 | s1 = deref {map} (fun (_ret:t_FMap) ->  [ &_12 <- _ret ] s2) | s2 = bb4 ] 
    | bb4 = s0 [ s0 = len_ghost {_12} (fun (_ret:int) ->  [ &length1 <- _ret ] s1) | s1 = bb5 ] 
    | bb5 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'2] lookup map (1: Int32.t) = (21: Int32.t)} s1
      | s1 = {[@expl:assertion] [%#sghost_map'3] length1 = 1} s2
      | s2 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_22 <- _ret ]  [ &map <- _ret.final ] s3)
      | s3 = deref_mut {_22} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_21 <- _ret ] s4)
      | s4 = bb6 ]
    
    | bb6 = s0
      [ s0 = promoted10__ghost_map (fun (pr10:Int32.t) ->  [ &_164 <- pr10 ] s1)
      | s1 =  [ &_24 <- _164 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_21.current} {MutBorrow.get_id _21}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_20 <- _ret ]  [ &_21 <- { _21 with current = _ret.final } ] s3)
      | s3 = get_mut_ghost {_20} {_24} (fun (_ret:t_Option'1) ->  [ &_19 <- _ret ] s4)
      | s4 = bb7 ]
    
    | bb7 = any [ br0 -> {_19 = C_None'1} (! bb10) | br1 (x0:MutBorrow.t Int32.t)-> {_19 = C_Some'1 x0} (! bb8) ] 
    | bb10 = s0
      [ s0 = -{match _19 with
          | C_Some'1 x'1 -> resolve'2 x'1
          | _ -> true
          end}-
        s1
      | s1 = -{resolve'0 _21}- s2
      | s2 = bb11 ]
    
    | bb8 = bb9
    | bb9 = s0
      [ s0 = v_Some {_19} (fun (r0:MutBorrow.t Int32.t) ->  [ &x <- r0 ] s1)
      | s1 =  [ &x <- { x with current = ([%#sghost_map'4] (43: Int32.t)) } ] s2
      | s2 = -{resolve'2 x}- s3
      | s3 = -{resolve'0 _21}- s4
      | s4 = bb11 ]
    
    | bb11 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'5] lookup map (1: Int32.t) = (43: Int32.t)} s1
      | s1 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_33 <- _ret ]  [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_33} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_32 <- _ret ] s3)
      | s3 = bb12 ]
    
    | bb12 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {_32.current} {MutBorrow.get_id _32}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_31 <- _ret ]  [ &_32 <- { _32 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_31} {[%#sghost_map'6] (2: Int32.t)} {[%#sghost_map'7] (50: Int32.t)}
          (fun (_ret:t_Option'0) ->  [ &inserted_none <- _ret ] s2)
      | s2 = bb13 ]
    
    | bb13 = s0
      [ s0 = -{resolve'0 _32}- s1
      | s1 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_37 <- _ret ]  [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_37} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_36 <- _ret ] s3)
      | s3 = bb14 ]
    
    | bb14 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_35 <- _ret ]  [ &_36 <- { _36 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_35} {[%#sghost_map'8] (2: Int32.t)} {[%#sghost_map'9] (100: Int32.t)}
          (fun (_ret:t_Option'0) ->  [ &inserted_some <- _ret ] s2)
      | s2 = bb15 ]
    
    | bb15 = s0
      [ s0 = -{resolve'0 _36}- s1 | s1 = deref {map} (fun (_ret:t_FMap) ->  [ &_40 <- _ret ] s2) | s2 = bb16 ]
    
    | bb16 = s0 [ s0 = len_ghost {_40} (fun (_ret:int) ->  [ &length2 <- _ret ] s1) | s1 = bb17 ] 
    | bb17 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'10] inserted_none = C_None'0} s1
      | s1 = {[@expl:assertion] [%#sghost_map'11] inserted_some = C_Some'0 (50: Int32.t)} s2
      | s2 = {[@expl:assertion] [%#sghost_map'12] length2 = 2} s3
      | s3 = {[@expl:assertion] [%#sghost_map'13] lookup map (2: Int32.t) = (100: Int32.t)} s4
      | s4 = {[@expl:assertion] [%#sghost_map'14] lookup map (1: Int32.t) = (43: Int32.t)} s5
      | s5 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_56 <- _ret ]  [ &map <- _ret.final ] s6)
      | s6 = deref_mut {_56} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_55 <- _ret ] s7)
      | s7 = bb18 ]
    
    | bb18 = s0
      [ s0 = promoted9__ghost_map (fun (pr9:Int32.t) ->  [ &_163 <- pr9 ] s1)
      | s1 =  [ &_58 <- _163 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_55.current} {MutBorrow.get_id _55}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_54 <- _ret ]  [ &_55 <- { _55 with current = _ret.final } ] s3)
      | s3 = split_mut_ghost {_54} {_58} (fun (_ret:tuple) ->  [ &_53 <- _ret ] s4)
      | s4 = bb19 ]
    
    | bb19 = any
      [ br0 -> {_53._p0 = C_None'1} (! bb24) | br1 (x0:MutBorrow.t Int32.t)-> {_53._p0 = C_Some'1 x0} (! bb20) ]
    
    | bb24 = s0
      [ s0 = -{match _53 with
          | {_p1 = x'1} -> resolve'0 x'1
          | _ -> true
          end}-
        s1
      | s1 = -{match _53 with
          | {_p0 = C_Some'1 x'1} -> resolve'2 x'1
          | _ -> true
          end}-
        s2
      | s2 = -{resolve'0 _55}- s3
      | s3 = bb25 ]
    
    | bb20 = bb21
    | bb21 = s0
      [ s0 = v_Some {_53._p0} (fun (r0:MutBorrow.t Int32.t) ->  [ &x'0 <- r0 ] s1)
      | s1 =  [ &map2 <- _53._p1 ] s2
      | s2 =  [ &x'0 <- { x'0 with current = ([%#sghost_map'15] (42: Int32.t)) } ] s3
      | s3 = -{resolve'2 x'0}- s4
      | s4 = MutBorrow.borrow_mut <t_FMap> {map2.current}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_64 <- _ret ]  [ &map2 <- { map2 with current = _ret.final } ] s5)
      | s5 = insert_ghost {_64} {[%#sghost_map'16] (2: Int32.t)} {[%#sghost_map'17] (200: Int32.t)}
          (fun (_ret:t_Option'0) ->  [ &_63 <- _ret ] s6)
      | s6 = bb22 ]
    
    | bb22 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap> {map2.current} {MutBorrow.get_id map2}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_66 <- _ret ]  [ &map2 <- { map2 with current = _ret.final } ] s1)
      | s1 = insert_ghost {_66} {[%#sghost_map'18] (1: Int32.t)} {[%#sghost_map'19] (56: Int32.t)}
          (fun (_ret:t_Option'0) ->  [ &_65 <- _ret ] s2)
      | s2 = bb23 ]
    
    | bb23 = s0 [ s0 = -{resolve'0 map2}- s1 | s1 = -{resolve'0 _55}- s2 | s2 = bb25 ] 
    | bb25 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'20] lookup map (1: Int32.t) = (42: Int32.t)} s1
      | s1 = {[@expl:assertion] [%#sghost_map'21] lookup map (2: Int32.t) = (200: Int32.t)} s2
      | s2 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_74 <- _ret ]  [ &map <- _ret.final ] s3)
      | s3 = deref_mut {_74} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_73 <- _ret ] s4)
      | s4 = bb26 ]
    
    | bb26 = s0
      [ s0 = promoted8__ghost_map (fun (pr8:Int32.t) ->  [ &_162 <- pr8 ] s1)
      | s1 =  [ &_76 <- _162 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_73.current} {MutBorrow.get_id _73}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_72 <- _ret ]  [ &_73 <- { _73 with current = _ret.final } ] s3)
      | s3 = remove_ghost {_72} {_76} (fun (_ret:t_Option'0) ->  [ &remove_none1 <- _ret ] s4)
      | s4 = bb27 ]
    
    | bb27 = s0
      [ s0 = -{resolve'0 _73}- s1
      | s1 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_81 <- _ret ]  [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_81} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_80 <- _ret ] s3)
      | s3 = bb28 ]
    
    | bb28 = s0
      [ s0 = promoted7__ghost_map (fun (pr7:Int32.t) ->  [ &_161 <- pr7 ] s1)
      | s1 =  [ &_83 <- _161 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_80.current} {MutBorrow.get_id _80}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_79 <- _ret ]  [ &_80 <- { _80 with current = _ret.final } ] s3)
      | s3 = remove_ghost {_79} {_83} (fun (_ret:t_Option'0) ->  [ &remove_some <- _ret ] s4)
      | s4 = bb29 ]
    
    | bb29 = s0
      [ s0 = -{resolve'0 _80}- s1
      | s1 = MutBorrow.borrow_mut < t_FMap> {map}
          (fun (_ret:MutBorrow.t ( t_FMap)) ->  [ &_88 <- _ret ]  [ &map <- _ret.final ] s2)
      | s2 = deref_mut {_88} (fun (_ret:MutBorrow.t t_FMap) ->  [ &_87 <- _ret ] s3)
      | s3 = bb30 ]
    
    | bb30 = s0
      [ s0 = promoted6__ghost_map (fun (pr6:Int32.t) ->  [ &_160 <- pr6 ] s1)
      | s1 =  [ &_90 <- _160 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap> {_87.current} {MutBorrow.get_id _87}
          (fun (_ret:MutBorrow.t t_FMap) ->  [ &_86 <- _ret ]  [ &_87 <- { _87 with current = _ret.final } ] s3)
      | s3 = remove_ghost {_86} {_90} (fun (_ret:t_Option'0) ->  [ &remove_none2 <- _ret ] s4)
      | s4 = bb31 ]
    
    | bb31 = s0
      [ s0 = -{resolve'0 _87}- s1
      | s1 = {[@expl:assertion] [%#sghost_map'22] remove_none1 = C_None'0} s2
      | s2 = {[@expl:assertion] [%#sghost_map'23] remove_some = C_Some'0 (200: Int32.t)} s3
      | s3 = {[@expl:assertion] [%#sghost_map'24] remove_none2 = C_None'0} s4
      | s4 = {[@expl:assertion] [%#sghost_map'25] get map (2: Int32.t) = C_None'0} s5
      | s5 = deref {map} (fun (_ret:t_FMap) ->  [ &_102 <- _ret ] s6)
      | s6 = bb32 ]
    
    | bb32 = s0
      [ s0 = promoted5__ghost_map (fun (pr5:Int32.t) ->  [ &_159 <- pr5 ] s1)
      | s1 =  [ &_105 <- _159 ] s2
      | s2 = contains_ghost {_102} {_105} (fun (_ret:bool) ->  [ &contains1 <- _ret ] s3)
      | s3 = bb33 ]
    
    | bb33 = s0 [ s0 = deref {map} (fun (_ret:t_FMap) ->  [ &_109 <- _ret ] s1) | s1 = bb34 ] 
    | bb34 = s0
      [ s0 = promoted4__ghost_map (fun (pr4:Int32.t) ->  [ &_158 <- pr4 ] s1)
      | s1 =  [ &_112 <- _158 ] s2
      | s2 = contains_ghost {_109} {_112} (fun (_ret:bool) ->  [ &contains2 <- _ret ] s3)
      | s3 = bb35 ]
    
    | bb35 = s0 [ s0 = deref {map} (fun (_ret:t_FMap) ->  [ &_116 <- _ret ] s1) | s1 = bb36 ] 
    | bb36 = s0
      [ s0 = promoted3__ghost_map (fun (pr3:Int32.t) ->  [ &_157 <- pr3 ] s1)
      | s1 =  [ &_119 <- _157 ] s2
      | s2 = contains_ghost {_116} {_119} (fun (_ret:bool) ->  [ &contains3 <- _ret ] s3)
      | s3 = bb37 ]
    
    | bb37 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'26] contains1} s1
      | s1 = {[@expl:assertion] [%#sghost_map'27] not contains2} s2
      | s2 = {[@expl:assertion] [%#sghost_map'28] not contains3} s3
      | s3 = deref {map} (fun (_ret:t_FMap) ->  [ &_129 <- _ret ] s4)
      | s4 = bb38 ]
    
    | bb38 = s0
      [ s0 = promoted2__ghost_map (fun (pr2:Int32.t) ->  [ &_156 <- pr2 ] s1)
      | s1 =  [ &_132 <- _156 ] s2
      | s2 = get_ghost {_129} {_132} (fun (_ret:t_Option'2) ->  [ &get1 <- _ret ] s3)
      | s3 = bb39 ]
    
    | bb39 = s0 [ s0 = deref {map} (fun (_ret:t_FMap) ->  [ &_136 <- _ret ] s1) | s1 = bb40 ] 
    | bb40 = s0
      [ s0 = promoted1__ghost_map (fun (pr1:Int32.t) ->  [ &_155 <- pr1 ] s1)
      | s1 =  [ &_139 <- _155 ] s2
      | s2 = get_ghost {_136} {_139} (fun (_ret:t_Option'2) ->  [ &get2 <- _ret ] s3)
      | s3 = bb41 ]
    
    | bb41 = s0 [ s0 = deref {map} (fun (_ret:t_FMap) ->  [ &_143 <- _ret ] s1) | s1 = bb42 ] 
    | bb42 = s0
      [ s0 = promoted0__ghost_map (fun (pr0:Int32.t) ->  [ &_154 <- pr0 ] s1)
      | s1 =  [ &_146 <- _154 ] s2
      | s2 = get_ghost {_143} {_146} (fun (_ret:t_Option'2) ->  [ &get3 <- _ret ] s3)
      | s3 = bb43 ]
    
    | bb43 = s0
      [ s0 = {[@expl:assertion] [%#sghost_map'29] get1 = C_Some'2 (42: Int32.t)} s1
      | s1 = {[@expl:assertion] [%#sghost_map'30] get2 = C_None'2} s2
      | s2 = {[@expl:assertion] [%#sghost_map'31] get3 = C_None'2} s3
      | s3 = new'0 {_3} (fun (_ret: ()) ->  [ &_2 <- _ret ] s4)
      | s4 = bb44 ]
    
    | bb44 = return''0 {_0} ]
    )
    [ & _0: () = Any.any_l ()
    | & map:  t_FMap = Any.any_l ()
    | & _2:  () = Any.any_l ()
    | & _3: () = Any.any_l ()
    | & _6: t_Option'0 = Any.any_l ()
    | & _7: MutBorrow.t t_FMap = Any.any_l ()
    | & _8: MutBorrow.t t_FMap = Any.any_l ()
    | & _9: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & length1: int = Any.any_l ()
    | & _12: t_FMap = Any.any_l ()
    | & _19: t_Option'1 = Any.any_l ()
    | & _20: MutBorrow.t t_FMap = Any.any_l ()
    | & _21: MutBorrow.t t_FMap = Any.any_l ()
    | & _22: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _24: Int32.t = Any.any_l ()
    | & x: MutBorrow.t Int32.t = Any.any_l ()
    | & inserted_none: t_Option'0 = Any.any_l ()
    | & _31: MutBorrow.t t_FMap = Any.any_l ()
    | & _32: MutBorrow.t t_FMap = Any.any_l ()
    | & _33: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & inserted_some: t_Option'0 = Any.any_l ()
    | & _35: MutBorrow.t t_FMap = Any.any_l ()
    | & _36: MutBorrow.t t_FMap = Any.any_l ()
    | & _37: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & length2: int = Any.any_l ()
    | & _40: t_FMap = Any.any_l ()
    | & _53: tuple = Any.any_l ()
    | & _54: MutBorrow.t t_FMap = Any.any_l ()
    | & _55: MutBorrow.t t_FMap = Any.any_l ()
    | & _56: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _58: Int32.t = Any.any_l ()
    | & x'0: MutBorrow.t Int32.t = Any.any_l ()
    | & map2: MutBorrow.t t_FMap = Any.any_l ()
    | & _63: t_Option'0 = Any.any_l ()
    | & _64: MutBorrow.t t_FMap = Any.any_l ()
    | & _65: t_Option'0 = Any.any_l ()
    | & _66: MutBorrow.t t_FMap = Any.any_l ()
    | & remove_none1: t_Option'0 = Any.any_l ()
    | & _72: MutBorrow.t t_FMap = Any.any_l ()
    | & _73: MutBorrow.t t_FMap = Any.any_l ()
    | & _74: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _76: Int32.t = Any.any_l ()
    | & remove_some: t_Option'0 = Any.any_l ()
    | & _79: MutBorrow.t t_FMap = Any.any_l ()
    | & _80: MutBorrow.t t_FMap = Any.any_l ()
    | & _81: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _83: Int32.t = Any.any_l ()
    | & remove_none2: t_Option'0 = Any.any_l ()
    | & _86: MutBorrow.t t_FMap = Any.any_l ()
    | & _87: MutBorrow.t t_FMap = Any.any_l ()
    | & _88: MutBorrow.t ( t_FMap) = Any.any_l ()
    | & _90: Int32.t = Any.any_l ()
    | & contains1: bool = Any.any_l ()
    | & _102: t_FMap = Any.any_l ()
    | & _105: Int32.t = Any.any_l ()
    | & contains2: bool = Any.any_l ()
    | & _109: t_FMap = Any.any_l ()
    | & _112: Int32.t = Any.any_l ()
    | & contains3: bool = Any.any_l ()
    | & _116: t_FMap = Any.any_l ()
    | & _119: Int32.t = Any.any_l ()
    | & get1: t_Option'2 = Any.any_l ()
    | & _129: t_FMap = Any.any_l ()
    | & _132: Int32.t = Any.any_l ()
    | & get2: t_Option'2 = Any.any_l ()
    | & _136: t_FMap = Any.any_l ()
    | & _139: Int32.t = Any.any_l ()
    | & get3: t_Option'2 = Any.any_l ()
    | & _143: t_FMap = Any.any_l ()
    | & _146: Int32.t = Any.any_l ()
    | & _154: Int32.t = Any.any_l ()
    | & _155: Int32.t = Any.any_l ()
    | & _156: Int32.t = Any.any_l ()
    | & _157: Int32.t = Any.any_l ()
    | & _158: Int32.t = Any.any_l ()
    | & _159: Int32.t = Any.any_l ()
    | & _160: Int32.t = Any.any_l ()
    | & _161: Int32.t = Any.any_l ()
    | & _162: Int32.t = Any.any_l ()
    | & _163: Int32.t = Any.any_l ()
    | & _164: Int32.t = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
