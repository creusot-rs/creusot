module M_ghost_map
  use creusot.int.Int32
  use map.Map
  use mach.int.Int
  use map.Const
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_FMap_i32_i32
  
  type t_Option_i32 = None | Some Int32.t
  
  function view_FMap_i32_i32 (self: t_FMap_i32_i32) : Map.map Int32.t t_Option_i32
  
  function get_i32 [@inline:trivial] (self: t_FMap_i32_i32) (k: Int32.t) : t_Option_i32 =
    Map.get (view_FMap_i32_i32 self) k
  
  meta "rewrite_def" function get_i32
  
  predicate ext_eq_i32 (self: t_FMap_i32_i32) (other: t_FMap_i32_i32) =
    forall k: Int32.t. get_i32 self k = get_i32 other k
  
  axiom ext_eq_i32_spec: forall self: t_FMap_i32_i32, other: t_FMap_i32_i32. ext_eq_i32 self other = (self = other)
  
  function len_i32 (self: t_FMap_i32_i32) : int
  
  axiom len_i32_spec: forall self: t_FMap_i32_i32. len_i32 self >= 0
  
  constant empty_i32 : t_FMap_i32_i32
  
  axiom empty_i32_spec: len_i32 empty_i32 = 0
  
  axiom empty_i32_spec'0: view_FMap_i32_i32 empty_i32 = Const.const (None)
  
  predicate is_empty_i32 (self: t_FMap_i32_i32) = ext_eq_i32 self empty_i32
  
  let rec new_i32 (return (x: t_FMap_i32_i32)) = any
    [ return (result: t_FMap_i32_i32) -> {is_empty_i32 result} (! return {result}) ]
  
  predicate contains_i32 [@inline:trivial] (self: t_FMap_i32_i32) (k: Int32.t) = get_i32 self k <> None
  
  meta "rewrite_def" predicate contains_i32
  
  let rec deref_mut_Ghost_FMap_i32_i32 (self: MutBorrow.t t_FMap_i32_i32) (return (x: MutBorrow.t t_FMap_i32_i32)) = any
    [ return (result: MutBorrow.t t_FMap_i32_i32) -> {result = self} (! return {result}) ]
  
  function insert_i32 (self: t_FMap_i32_i32) (k: Int32.t) (v: Int32.t) : t_FMap_i32_i32
  
  axiom insert_i32_spec: forall self: t_FMap_i32_i32, k: Int32.t, v: Int32.t. view_FMap_i32_i32 (insert_i32 self k v)
      = Map.set (view_FMap_i32_i32 self) k (Some v)
  
  axiom insert_i32_spec'0: forall self: t_FMap_i32_i32, k: Int32.t, v: Int32.t. len_i32 (insert_i32 self k v)
      = (if contains_i32 self k then len_i32 self else len_i32 self + 1)
  
  let rec insert_ghost_i32 (self: MutBorrow.t t_FMap_i32_i32) (key: Int32.t) (value: Int32.t)
    (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {self.final = insert_i32 self.current key value}
      {result = get_i32 self.current key}
      (! return {result}) ]
  
  predicate resolve_ref_FMap_i32_i32 [@inline:trivial] (_1: MutBorrow.t t_FMap_i32_i32) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMap_i32_i32
  
  let rec deref_Ghost_FMap_i32_i32 (self: t_FMap_i32_i32) (return (x: t_FMap_i32_i32)) = any
    [ return (result: t_FMap_i32_i32) -> {result = self} (! return {result}) ]
  
  let rec len_ghost_i32 (self: t_FMap_i32_i32) (return (x: int)) = any
    [ return (result: int) -> {result = len_i32 self} (! return {result}) ]
  
  predicate index_Mapping_i32_bool [@inline:trivial] (self: Map.map Int32.t bool) (a: Int32.t) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_i32_bool
  
  function such_that_i32 (p: Map.map Int32.t bool) : Int32.t
  
  axiom such_that_i32_spec: forall p: Map.map Int32.t bool. (exists x: Int32.t. index_Mapping_i32_bool p x)
      -> index_Mapping_i32_bool p (such_that_i32 p)
  
  function unwrap_Option_i32 (self: t_Option_i32) : Int32.t = match self with
      | Some x -> x
      | None -> such_that_i32 (fun (__0: Int32.t) -> true)
      end
  
  function lookup_i32 [@inline:trivial] (self: t_FMap_i32_i32) (k: Int32.t) : Int32.t =
    unwrap_Option_i32 (get_i32 self k)
  
  meta "rewrite_def" function lookup_i32
  
  type t_Option_ref_i32 = None'0 | Some'0 (MutBorrow.t Int32.t)
  
  function index_FMap_i32_i32 [@inline:trivial] (self: t_FMap_i32_i32) (key: Int32.t) : Int32.t = lookup_i32 self key
  
  meta "rewrite_def" function index_FMap_i32_i32
  
  let rec get_mut_ghost_i32 (self: MutBorrow.t t_FMap_i32_i32) (key: Int32.t) (return (x: t_Option_ref_i32)) = any
    [ return (result: t_Option_ref_i32) -> {if contains_i32 self.current key then
        match result with
          | None'0 -> false
          | Some'0 r -> contains_i32 self.final key
          /\ index_FMap_i32_i32 self.current key = r.current /\ index_FMap_i32_i32 self.final key = r.final
          end
      else
        result = None'0 /\ self.current = self.final
      }
      {forall k: Int32.t. k <> key -> get_i32 self.current k = get_i32 self.final k}
      {len_i32 self.current = len_i32 self.final}
      (! return {result}) ]
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  let rec elim_Some (_x: t_Option_ref_i32) (return (f0: MutBorrow.t Int32.t)) = any
    [ _k (f0: MutBorrow.t Int32.t) -> {Some'0 f0 = _x} (! return {f0})
    | _chk -> (! {match _x with
        | Some'0 _ -> true
        | _ -> false
        end}
      any) ]
  
  type tup2_ref_i32_ref_FMap_i32_i32 = { f0: MutBorrow.t Int32.t; f1: MutBorrow.t t_FMap_i32_i32 }
  
  function remove_i32 (self: t_FMap_i32_i32) (k: Int32.t) : t_FMap_i32_i32
  
  axiom remove_i32_spec: forall self: t_FMap_i32_i32, k: Int32.t. view_FMap_i32_i32 (remove_i32 self k)
      = Map.set (view_FMap_i32_i32 self) k (None)
  
  axiom remove_i32_spec'0: forall self: t_FMap_i32_i32, k: Int32.t. len_i32 (remove_i32 self k)
      = (if contains_i32 self k then len_i32 self - 1 else len_i32 self)
  
  let rec split_mut_ghost_i32 (self: MutBorrow.t t_FMap_i32_i32) (key: Int32.t)
    (return (x: tup2_ref_i32_ref_FMap_i32_i32)) = {[@expl:split_mut_ghost requires] contains_i32 self.current key}
    any
    [ return (result: tup2_ref_i32_ref_FMap_i32_i32) -> {result.f1.current = remove_i32 self.current key}
      {index_FMap_i32_i32 self.current key = result.f0.current
      /\ self.final = insert_i32 result.f1.final key result.f0.final}
      (! return {result}) ]
  
  let rec remove_ghost_i32 (self: MutBorrow.t t_FMap_i32_i32) (key: Int32.t) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {self.final = remove_i32 self.current key}
      {result = get_i32 self.current key}
      (! return {result}) ]
  
  let rec contains_ghost_i32 (self: t_FMap_i32_i32) (key: Int32.t) (return (x: bool)) = any
    [ return (result: bool) -> {result = contains_i32 self key} (! return {result}) ]
  
  type t_Option_ref_i32'0 = None'1 | Some'1 Int32.t
  
  function map_Option_i32 (self: t_Option_i32) (f: Map.map Int32.t Int32.t) : t_Option_ref_i32'0 = match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  let rec get_ghost_i32 (self: t_FMap_i32_i32) (key: Int32.t) (return (x: t_Option_ref_i32'0)) = any
    [ return (result: t_Option_ref_i32'0) -> {result = map_Option_i32 (get_i32 self key) (fun (v: Int32.t) -> v)}
      (! return {result}) ]
  
  let rec new_unit (x: ()) (return (x'0: ())) = any [ return (result: ()) -> {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ghost_map (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = new_i32 (fun (_ret: t_FMap_i32_i32) -> [ &map <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] forall k: Int32.t. not contains_i32 map k} s1
      | s1 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_10 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_FMap_i32_i32 {_10} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_9 <- _ret ] s3)
      | s3 = bb2 ]
    | bb2 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap_i32_i32> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_8 <- _ret ] [ &_9 <- { _9 with current = _ret.final } ] s1)
      | s1 = insert_ghost_i32 {_8} {(1: Int32.t)} {(21: Int32.t)} (fun (_ret: t_Option_i32) -> [ &_7 <- _ret ] s2)
      | s2 = bb3 ]
    | bb3 = s0
      [ s0 = -{resolve_ref_FMap_i32_i32 _9}- s1
      | s1 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_13 <- _ret ] s2)
      | s2 = bb4 ]
    | bb4 = s0 [ s0 = len_ghost_i32 {_13} (fun (_ret: int) -> [ &length1 <- _ret ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = {[@expl:assertion] lookup_i32 map (1: Int32.t) = (21: Int32.t)} s1
      | s1 = {[@expl:assertion] length1 = 1} s2
      | s2 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_25 <- _ret ] [ &map <- _ret.final ] s3)
      | s3 = deref_mut_Ghost_FMap_i32_i32 {_25} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_24 <- _ret ] s4)
      | s4 = bb6 ]
    | bb6 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_183 <- _const ] s1 ]
      | s1 = [ &_27 <- _183 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap_i32_i32> {_24.current} {MutBorrow.get_id _24}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_23 <- _ret ] [ &_24 <- { _24 with current = _ret.final } ] s3)
      | s3 = get_mut_ghost_i32 {_23} {_27} (fun (_ret: t_Option_ref_i32) -> [ &_22 <- _ret ] s4)
      | s4 = bb7 ]
    | bb7 = any [ br0 -> {_22 = None'0} (! bb10) | br1 (x0: MutBorrow.t Int32.t) -> {_22 = Some'0 x0} (! bb9) ]
    | bb10 = s0
      [ s0 = -{match _22 with
          | Some'0 x'1 -> resolve_ref_i32 x'1
          | _ -> true
          end}-
        s1
      | s1 = -{resolve_ref_FMap_i32_i32 _24}- s2
      | s2 = bb11 ]
    | bb9 = s0
      [ s0 = elim_Some {_22} (fun (r0: MutBorrow.t Int32.t) -> [ &x <- r0 ] s1)
      | s1 = [ &x <- { x with current = (43: Int32.t) } ] s2
      | s2 = -{resolve_ref_i32 x}- s3
      | s3 = -{resolve_ref_FMap_i32_i32 _24}- s4
      | s4 = bb11 ]
    | bb11 = s0
      [ s0 = {[@expl:assertion] lookup_i32 map (1: Int32.t) = (43: Int32.t)} s1
      | s1 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_37 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_FMap_i32_i32 {_37} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_36 <- _ret ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap_i32_i32> {_36.current} {MutBorrow.get_id _36}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_35 <- _ret ] [ &_36 <- { _36 with current = _ret.final } ] s1)
      | s1 = insert_ghost_i32 {_35} {(2: Int32.t)} {(50: Int32.t)}
          (fun (_ret: t_Option_i32) -> [ &inserted_none <- _ret ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = -{resolve_ref_FMap_i32_i32 _36}- s1
      | s1 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_41 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_FMap_i32_i32 {_41} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_40 <- _ret ] s3)
      | s3 = bb14 ]
    | bb14 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap_i32_i32> {_40.current} {MutBorrow.get_id _40}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_39 <- _ret ] [ &_40 <- { _40 with current = _ret.final } ] s1)
      | s1 = insert_ghost_i32 {_39} {(2: Int32.t)} {(100: Int32.t)}
          (fun (_ret: t_Option_i32) -> [ &inserted_some <- _ret ] s2)
      | s2 = bb15 ]
    | bb15 = s0
      [ s0 = -{resolve_ref_FMap_i32_i32 _40}- s1
      | s1 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_44 <- _ret ] s2)
      | s2 = bb16 ]
    | bb16 = s0 [ s0 = len_ghost_i32 {_44} (fun (_ret: int) -> [ &length2 <- _ret ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = {[@expl:assertion] inserted_none = None} s1
      | s1 = {[@expl:assertion] inserted_some = Some (50: Int32.t)} s2
      | s2 = {[@expl:assertion] length2 = 2} s3
      | s3 = {[@expl:assertion] lookup_i32 map (2: Int32.t) = (100: Int32.t)} s4
      | s4 = {[@expl:assertion] lookup_i32 map (1: Int32.t) = (43: Int32.t)} s5
      | s5 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_66 <- _ret ] [ &map <- _ret.final ] s6)
      | s6 = deref_mut_Ghost_FMap_i32_i32 {_66} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_65 <- _ret ] s7)
      | s7 = bb18 ]
    | bb18 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_182 <- _const ] s1 ]
      | s1 = [ &_68 <- _182 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap_i32_i32> {_65.current} {MutBorrow.get_id _65}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_64 <- _ret ] [ &_65 <- { _65 with current = _ret.final } ] s3)
      | s3 = split_mut_ghost_i32 {_64} {_68} (fun (_ret: tup2_ref_i32_ref_FMap_i32_i32) -> [ &_63 <- _ret ] s4)
      | s4 = bb19 ]
    | bb19 = s0
      [ s0 = [ &x'0 <- _63.f0 ] s1
      | s1 = [ &map2 <- _63.f1 ] s2
      | s2 = -{resolve_ref_FMap_i32_i32 _65}- s3
      | s3 = [ &x'0 <- { x'0 with current = (42: Int32.t) } ] s4
      | s4 = -{resolve_ref_i32 x'0}- s5
      | s5 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map2.current}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) ->
            [ &_71 <- _ret ] [ &map2 <- { map2 with current = _ret.final } ] s6)
      | s6 = insert_ghost_i32 {_71} {(2: Int32.t)} {(200: Int32.t)} (fun (_ret: t_Option_i32) -> [ &_70 <- _ret ] s7)
      | s7 = bb20 ]
    | bb20 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap_i32_i32> {map2.current} {MutBorrow.get_id map2}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) ->
            [ &_73 <- _ret ] [ &map2 <- { map2 with current = _ret.final } ] s1)
      | s1 = insert_ghost_i32 {_73} {(1: Int32.t)} {(56: Int32.t)} (fun (_ret: t_Option_i32) -> [ &_72 <- _ret ] s2)
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = -{resolve_ref_FMap_i32_i32 map2}- s1
      | s1 = {[@expl:assertion] lookup_i32 map (1: Int32.t) = (42: Int32.t)} s2
      | s2 = {[@expl:assertion] lookup_i32 map (2: Int32.t) = (200: Int32.t)} s3
      | s3 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_83 <- _ret ] [ &map <- _ret.final ] s4)
      | s4 = deref_mut_Ghost_FMap_i32_i32 {_83} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_82 <- _ret ] s5)
      | s5 = bb22 ]
    | bb22 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (3: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_181 <- _const ] s1 ]
      | s1 = [ &_85 <- _181 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap_i32_i32> {_82.current} {MutBorrow.get_id _82}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_81 <- _ret ] [ &_82 <- { _82 with current = _ret.final } ] s3)
      | s3 = remove_ghost_i32 {_81} {_85} (fun (_ret: t_Option_i32) -> [ &remove_none1 <- _ret ] s4)
      | s4 = bb23 ]
    | bb23 = s0
      [ s0 = -{resolve_ref_FMap_i32_i32 _82}- s1
      | s1 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_90 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_FMap_i32_i32 {_90} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_89 <- _ret ] s3)
      | s3 = bb24 ]
    | bb24 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_180 <- _const ] s1 ]
      | s1 = [ &_92 <- _180 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap_i32_i32> {_89.current} {MutBorrow.get_id _89}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_88 <- _ret ] [ &_89 <- { _89 with current = _ret.final } ] s3)
      | s3 = remove_ghost_i32 {_88} {_92} (fun (_ret: t_Option_i32) -> [ &remove_some <- _ret ] s4)
      | s4 = bb25 ]
    | bb25 = s0
      [ s0 = -{resolve_ref_FMap_i32_i32 _89}- s1
      | s1 = MutBorrow.borrow_mut <t_FMap_i32_i32> {map}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_97 <- _ret ] [ &map <- _ret.final ] s2)
      | s2 = deref_mut_Ghost_FMap_i32_i32 {_97} (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_96 <- _ret ] s3)
      | s3 = bb26 ]
    | bb26 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_179 <- _const ] s1 ]
      | s1 = [ &_99 <- _179 ] s2
      | s2 = MutBorrow.borrow_final <t_FMap_i32_i32> {_96.current} {MutBorrow.get_id _96}
          (fun (_ret: MutBorrow.t t_FMap_i32_i32) -> [ &_95 <- _ret ] [ &_96 <- { _96 with current = _ret.final } ] s3)
      | s3 = remove_ghost_i32 {_95} {_99} (fun (_ret: t_Option_i32) -> [ &remove_none2 <- _ret ] s4)
      | s4 = bb27 ]
    | bb27 = s0
      [ s0 = -{resolve_ref_FMap_i32_i32 _96}- s1
      | s1 = {[@expl:assertion] remove_none1 = None} s2
      | s2 = {[@expl:assertion] remove_some = Some (200: Int32.t)} s3
      | s3 = {[@expl:assertion] remove_none2 = None} s4
      | s4 = {[@expl:assertion] get_i32 map (2: Int32.t) = None} s5
      | s5 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_115 <- _ret ] s6)
      | s6 = bb28 ]
    | bb28 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_178 <- _const ] s1 ]
      | s1 = [ &_118 <- _178 ] s2
      | s2 = contains_ghost_i32 {_115} {_118} (fun (_ret: bool) -> [ &contains1 <- _ret ] s3)
      | s3 = bb29 ]
    | bb29 = s0 [ s0 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_122 <- _ret ] s1) | s1 = bb30 ]
    | bb30 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_177 <- _const ] s1 ]
      | s1 = [ &_125 <- _177 ] s2
      | s2 = contains_ghost_i32 {_122} {_125} (fun (_ret: bool) -> [ &contains2 <- _ret ] s3)
      | s3 = bb31 ]
    | bb31 = s0 [ s0 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_129 <- _ret ] s1) | s1 = bb32 ]
    | bb32 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (3: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_176 <- _const ] s1 ]
      | s1 = [ &_132 <- _176 ] s2
      | s2 = contains_ghost_i32 {_129} {_132} (fun (_ret: bool) -> [ &contains3 <- _ret ] s3)
      | s3 = bb33 ]
    | bb33 = s0
      [ s0 = {[@expl:assertion] contains1} s1
      | s1 = {[@expl:assertion] not contains2} s2
      | s2 = {[@expl:assertion] not contains3} s3
      | s3 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_145 <- _ret ] s4)
      | s4 = bb34 ]
    | bb34 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (1: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_175 <- _const ] s1 ]
      | s1 = [ &_148 <- _175 ] s2
      | s2 = get_ghost_i32 {_145} {_148} (fun (_ret: t_Option_ref_i32'0) -> [ &get1 <- _ret ] s3)
      | s3 = bb35 ]
    | bb35 = s0 [ s0 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_152 <- _ret ] s1) | s1 = bb36 ]
    | bb36 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (2: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_174 <- _const ] s1 ]
      | s1 = [ &_155 <- _174 ] s2
      | s2 = get_ghost_i32 {_152} {_155} (fun (_ret: t_Option_ref_i32'0) -> [ &get2 <- _ret ] s3)
      | s3 = bb37 ]
    | bb37 = s0 [ s0 = deref_Ghost_FMap_i32_i32 {map} (fun (_ret: t_FMap_i32_i32) -> [ &_159 <- _ret ] s1) | s1 = bb38 ]
    | bb38 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_0'0 <- (3: Int32.t) ] s1'0 | s1'0 = _const_ret {_0'0} ] ]
        [ & _0'0: Int32.t = Any.any_l () ] [ _const_ret (_const: Int32.t) -> [ &_173 <- _const ] s1 ]
      | s1 = [ &_162 <- _173 ] s2
      | s2 = get_ghost_i32 {_159} {_162} (fun (_ret: t_Option_ref_i32'0) -> [ &get3 <- _ret ] s3)
      | s3 = bb39 ]
    | bb39 = s0
      [ s0 = {[@expl:assertion] get1 = Some'1 (42: Int32.t)} s1
      | s1 = {[@expl:assertion] get2 = None'1} s2
      | s2 = {[@expl:assertion] get3 = None'1} s3
      | s3 = new_unit {_3} (fun (_ret: ()) -> [ &_2 <- _ret ] s4)
      | s4 = bb40 ]
    | bb40 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & map: t_FMap_i32_i32 = Any.any_l ()
    | & _2: () = Any.any_l ()
    | & _3: () = Any.any_l ()
    | & _7: t_Option_i32 = Any.any_l ()
    | & _8: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _9: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _10: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & length1: int = Any.any_l ()
    | & _13: t_FMap_i32_i32 = Any.any_l ()
    | & _22: t_Option_ref_i32 = Any.any_l ()
    | & _23: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _24: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _25: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _27: Int32.t = Any.any_l ()
    | & x: MutBorrow.t Int32.t = Any.any_l ()
    | & inserted_none: t_Option_i32 = Any.any_l ()
    | & _35: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _36: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _37: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & inserted_some: t_Option_i32 = Any.any_l ()
    | & _39: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _40: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _41: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & length2: int = Any.any_l ()
    | & _44: t_FMap_i32_i32 = Any.any_l ()
    | & x'0: MutBorrow.t Int32.t = Any.any_l ()
    | & map2: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _63: tup2_ref_i32_ref_FMap_i32_i32 = Any.any_l ()
    | & _64: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _65: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _66: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _68: Int32.t = Any.any_l ()
    | & _70: t_Option_i32 = Any.any_l ()
    | & _71: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _72: t_Option_i32 = Any.any_l ()
    | & _73: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & remove_none1: t_Option_i32 = Any.any_l ()
    | & _81: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _82: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _83: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _85: Int32.t = Any.any_l ()
    | & remove_some: t_Option_i32 = Any.any_l ()
    | & _88: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _89: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _90: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _92: Int32.t = Any.any_l ()
    | & remove_none2: t_Option_i32 = Any.any_l ()
    | & _95: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _96: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _97: MutBorrow.t t_FMap_i32_i32 = Any.any_l ()
    | & _99: Int32.t = Any.any_l ()
    | & contains1: bool = Any.any_l ()
    | & _115: t_FMap_i32_i32 = Any.any_l ()
    | & _118: Int32.t = Any.any_l ()
    | & contains2: bool = Any.any_l ()
    | & _122: t_FMap_i32_i32 = Any.any_l ()
    | & _125: Int32.t = Any.any_l ()
    | & contains3: bool = Any.any_l ()
    | & _129: t_FMap_i32_i32 = Any.any_l ()
    | & _132: Int32.t = Any.any_l ()
    | & get1: t_Option_ref_i32'0 = Any.any_l ()
    | & _145: t_FMap_i32_i32 = Any.any_l ()
    | & _148: Int32.t = Any.any_l ()
    | & get2: t_Option_ref_i32'0 = Any.any_l ()
    | & _152: t_FMap_i32_i32 = Any.any_l ()
    | & _155: Int32.t = Any.any_l ()
    | & get3: t_Option_ref_i32'0 = Any.any_l ()
    | & _159: t_FMap_i32_i32 = Any.any_l ()
    | & _162: Int32.t = Any.any_l ()
    | & _173: Int32.t = Any.any_l ()
    | & _174: Int32.t = Any.any_l ()
    | & _175: Int32.t = Any.any_l ()
    | & _176: Int32.t = Any.any_l ()
    | & _177: Int32.t = Any.any_l ()
    | & _178: Int32.t = Any.any_l ()
    | & _179: Int32.t = Any.any_l ()
    | & _180: Int32.t = Any.any_l ()
    | & _181: Int32.t = Any.any_l ()
    | & _182: Int32.t = Any.any_l ()
    | & _183: Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
