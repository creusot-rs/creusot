module M_complicated_identity
  use map.Map
  use mach.int.Int
  use map.Const
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_Ghost_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_Ghost_FMap_K_V
  
  predicate inv_Ghost_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_Ghost_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_Ghost_FMap_K_V
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  let rec new_K (return (x: t_FMap_K_V)) = any
    [ return (result: t_FMap_K_V) -> {inv_Ghost_FMap_K_V result} {is_empty_K result} (! return {result}) ]
  
  let rec into_inner_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_FMap_K_V self}
    any [ return (result: t_FMap_K_V) -> {inv_FMap_K_V result} {result = self} (! return {result}) ]
  
  type t_FMapIter_K_V
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V
  
  let rec into_iter_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMapIter_K_V)) =
    {[@expl:into_iter 'self' type invariant] inv_FMap_K_V self}
    any
    [ return (result: t_FMapIter_K_V) -> {inv_FMapIter_K_V result}
      {view_FMapIter_K_V result = self}
      (! return {result}) ]
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  predicate invariant_ref_FMapIter_K_V [@inline:trivial] (self: MutBorrow.t t_FMapIter_K_V) =
    inv_FMapIter_K_V self.current /\ inv_FMapIter_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMapIter_K_V
  
  predicate inv_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = invariant_ref_FMapIter_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMapIter_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_tup2_K_V f0'0
        end
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0 = k; f1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  function produces_trans_FMapIter_K_V (a: t_FMapIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMapIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMapIter_K_V) : ()
  
  axiom produces_trans_FMapIter_K_V_spec:
    forall a: t_FMapIter_K_V, ab: Seq.seq tup2_K_V, b: t_FMapIter_K_V, bc: Seq.seq tup2_K_V, c: t_FMapIter_K_V. produces_FMapIter_K_V a ab b
      -> produces_FMapIter_K_V b bc c -> produces_FMapIter_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMapIter_K_V (self: t_FMapIter_K_V) : ()
  
  axiom produces_refl_FMapIter_K_V_spec:
    forall self: t_FMapIter_K_V. produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate completed_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) = is_empty_K (view_FMapIter_K_V self.current)
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  let rec next_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:next 'self' type invariant] inv_ref_FMapIter_K_V self}
    any
    [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result}
      {match result with
        | None'0 -> completed_FMapIter_K_V self
        | Some'0 {f0 = k; f1 = v} -> produces_FMapIter_K_V self.current (Seq.singleton { f0 = k; f1 = v }) self.final
        /\ view_FMapIter_K_V self.current = insert_K (view_FMapIter_K_V self.final) k v
        end}
      (! return {result}) ]
  
  predicate resolve_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMapIter_K_V
  
  predicate invariant_Box_tup2_K_V_Global (self: tup2_K_V) = inv_tup2_K_V self
  
  predicate inv_Box_tup2_K_V_Global [@inline:trivial] (_1: tup2_K_V) = invariant_Box_tup2_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_tup2_K_V_Global
  
  predicate invariant_Seq_tup2_K_V [@inline:trivial] (self: Seq.seq tup2_K_V) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_tup2_K_V_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_tup2_K_V
  
  predicate inv_Seq_tup2_K_V [@inline:trivial] (_1: Seq.seq tup2_K_V) = invariant_Seq_tup2_K_V _1
  
  meta "rewrite_def" predicate inv_Seq_tup2_K_V
  
  let rec elim_Some (_x: t_Option_tup2_K_V) (return (f0'0: tup2_K_V)) = any
    [ _k (f0'0: tup2_K_V) -> {Some'0 f0'0 = _x} (! return {f0'0})
    | _chk -> (! {match _x with
        | Some'0 _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: MutBorrow.t t_FMap_K_V) =
    inv_FMap_K_V self.current /\ inv_FMap_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate inv_Option_V (_1: t_Option_V)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_V [inv_Option_V x]. inv_Option_V x
      = match x with
        | None -> true
        | Some f0'0 -> inv_V f0'0
        end
  
  let rec insert_ghost_K (self: MutBorrow.t t_FMap_K_V) (key: t_K) (value: t_V) (return (x: t_Option_V)) =
    {[@expl:insert_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:insert_ghost 'key' type invariant] inv_K key}
    {[@expl:insert_ghost 'value' type invariant] inv_V value}
    any
    [ return (result: t_Option_V) -> {inv_Option_V result}
      {self.final = insert_K self.current key value}
      {result = get_K self.current key}
      (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None -> true
        | Some x0 -> resolve_V x0
        end
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_FMap_K_V (self: t_FMap_K_V) =
    forall k: t_K, v: t_V. get_K self k = Some v -> resolve_K k /\ resolve_V v
  
  predicate resolve_FMap_K_V'0 (_1: t_FMap_K_V)
  
  axiom resolve_axiom'0: forall x: t_FMap_K_V [resolve_FMap_K_V'0 x]. resolve_FMap_K_V'0 x -> resolve_FMap_K_V x
  
  predicate resolve_FMapIter_K_V (self: t_FMapIter_K_V) = resolve_FMap_K_V'0 (view_FMapIter_K_V self)
  
  predicate resolve_FMapIter_K_V'0 (_1: t_FMapIter_K_V)
  
  axiom resolve_axiom'1: forall x: t_FMapIter_K_V [resolve_FMapIter_K_V'0 x]. resolve_FMapIter_K_V'0 x
      -> resolve_FMapIter_K_V x
  
  let rec new_FMap_K_V (x: t_FMap_K_V) (return (x'0: t_FMap_K_V)) = {[@expl:new 'x' type invariant] inv_FMap_K_V x}
    any [ return (result: t_FMap_K_V) -> {inv_Ghost_FMap_K_V result} {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec complicated_identity_K (m: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:complicated_identity 'm' type invariant] inv_Ghost_FMap_K_V m}
    (! bb0
    [ bb0 = s0
      [ s0 = new_K (fun (_x: t_FMap_K_V) -> [ &_6 <- _x ] s1)
      | s1 = into_inner_FMap_K_V {_6} (fun (_x: t_FMap_K_V) -> [ &result <- _x ] s2)
      | s2 = [ &len <- len_K m ] s3
      | s3 = [ &m_snap <- m ] s4
      | s4 = into_inner_FMap_K_V {m} (fun (_x: t_FMap_K_V) -> [ &_15 <- _x ] s5)
      | s5 = into_iter_FMap_K_V {_15} (fun (_x: t_FMapIter_K_V) -> [ &iter <- _x ] s6)
      | s6 = [ &iter_old <- iter ] s7
      | s7 = [ &produced <- Seq.empty: Seq.seq tup2_K_V ] s8
      | s8 = bb9 ]
    | bb9 = bb9invariant
      [ bb9 = {[@expl:loop variant] well_founded_relation_Int variant_old_bb9 (len - Seq.length produced)} bb9invariant
      | bb9invariant = {[@expl:for invariant] inv_Seq_tup2_K_V produced}
        {[@expl:for invariant] inv_FMapIter_K_V iter}
        {[@expl:for invariant] produces_FMapIter_K_V iter_old produced iter}
        {[@expl:loop invariant] forall k'0: t_K, v'0: t_V. (get_K m_snap k'0 = Some v'0)
          = (get_K result k'0 = Some v'0 \/ get_K (view_FMapIter_K_V iter) k'0 = Some v'0)}
        (! [ &variant_old_bb9 <- len - Seq.length produced ] s0)
        [ s0 = {inv_FMapIter_K_V iter}
          MutBorrow.borrow_mut <t_FMapIter_K_V> {iter}
            (fun (_bor: MutBorrow.t t_FMapIter_K_V) ->
              [ &_41 <- _bor ] -{inv_FMapIter_K_V _bor.final}-
              [ &iter <- _bor.final ] s1)
        | s1 = {inv_FMapIter_K_V _41.current}
          MutBorrow.borrow_final <t_FMapIter_K_V> {_41.current} {MutBorrow.get_id _41}
            (fun (_bor: MutBorrow.t t_FMapIter_K_V) ->
              [ &_40 <- _bor ] -{inv_FMapIter_K_V _bor.final}-
              [ &_41 <- { _41 with current = _bor.final } ] s2)
        | s2 = next_FMapIter_K_V {_40} (fun (_x: t_Option_tup2_K_V) -> [ &_39 <- _x ] s3)
        | s3 = {[@expl:type invariant] inv_ref_FMapIter_K_V _41} s4
        | s4 = -{resolve_ref_FMapIter_K_V _41}- s5
        | s5 = any [ br0 -> {_39 = None'0} (! bb14) | br1 (x0: tup2_K_V) -> {_39 = Some'0 x0} (! bb15) ] ]
        [ bb15 = s0
          [ s0 = elim_Some {_39} (fun (r0: tup2_K_V) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &produced <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = [ &k <- __creusot_proc_iter_elem.f0 ] s3
          | s3 = [ &v <- __creusot_proc_iter_elem.f1 ] s4
          | s4 = {inv_FMap_K_V result}
            MutBorrow.borrow_mut <t_FMap_K_V> {result}
              (fun (_bor: MutBorrow.t t_FMap_K_V) ->
                [ &_51 <- _bor ] -{inv_FMap_K_V _bor.final}-
                [ &result <- _bor.final ] s5)
          | s5 = insert_ghost_K {_51} {k} {v} (fun (_x: t_Option_V) -> [ &_50 <- _x ] s6)
          | s6 = {[@expl:type invariant] inv_Option_V _50} s7
          | s7 = -{resolve_Option_V _50}- s8
          | s8 = bb9 ] ] ]
    | bb14 = s0
      [ s0 = {[@expl:type invariant] inv_FMapIter_K_V iter} s1
      | s1 = -{resolve_FMapIter_K_V'0 iter}- s2
      | s2 = {[@expl:assertion] ext_eq_K result m_snap} s3
      | s3 = new_FMap_K_V {result} (fun (_x: t_FMap_K_V) -> [ &_ret <- _x ] s4)
      | s4 = return {_ret} ] ]
    [ & _ret: t_FMap_K_V = Any.any_l ()
    | & m: t_FMap_K_V = m
    | & result: t_FMap_K_V = Any.any_l ()
    | & _6: t_FMap_K_V = Any.any_l ()
    | & len: int = Any.any_l ()
    | & m_snap: t_FMap_K_V = Any.any_l ()
    | & iter: t_FMapIter_K_V = Any.any_l ()
    | & _15: t_FMap_K_V = Any.any_l ()
    | & iter_old: t_FMapIter_K_V = Any.any_l ()
    | & produced: Seq.seq tup2_K_V = Any.any_l ()
    | & _39: t_Option_tup2_K_V = Any.any_l ()
    | & _40: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & _41: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & __creusot_proc_iter_elem: tup2_K_V = Any.any_l ()
    | & k: t_K = Any.any_l ()
    | & v: t_V = Any.any_l ()
    | & _50: t_Option_V = Any.any_l ()
    | & _51: MutBorrow.t t_FMap_K_V = Any.any_l ()
    | & variant_old_bb9: int = Any.any_l () ])
    [ return (result: t_FMap_K_V) -> {[@expl:complicated_identity result type invariant] inv_Ghost_FMap_K_V result}
      {[@expl:complicated_identity ensures] result = m}
      (! return {result}) ]
end
module M_merge_fmaps
  use map.Map
  use mach.int.Int
  use seq.Seq
  use creusot.prelude.MutBorrow
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_V
  
  type tup2_V_V = { f0: t_V; f1: t_V }
  
  type t_Option_V = None | Some t_V
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  type t_K
  
  function view_FMap_K_V (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (view_FMap_K_V self) k
  
  meta "rewrite_def" function get_K
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some x; f1'0 = Some y} -> get_K (merge_K self m f) k
          = Some (index_Mapping_tup2_V_V_V f { f0 = x; f1 = y })
          end
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_Ghost_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_Ghost_FMap_K_V
  
  predicate inv_Ghost_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_Ghost_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_Ghost_FMap_K_V
  
  let rec into_inner_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:into_inner 'self' type invariant] inv_Ghost_FMap_K_V self}
    any [ return (result: t_FMap_K_V) -> {inv_FMap_K_V result} {result = self} (! return {result}) ]
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  type t_FMapIter_K_V
  
  predicate inv_FMapIter_K_V (_1: t_FMapIter_K_V)
  
  function view_FMapIter_K_V (self: t_FMapIter_K_V) : t_FMap_K_V
  
  let rec into_iter_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMapIter_K_V)) =
    {[@expl:into_iter 'self' type invariant] inv_FMap_K_V self}
    any
    [ return (result: t_FMapIter_K_V) -> {inv_FMapIter_K_V result}
      {view_FMapIter_K_V result = self}
      (! return {result}) ]
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  predicate invariant_ref_FMapIter_K_V [@inline:trivial] (self: MutBorrow.t t_FMapIter_K_V) =
    inv_FMapIter_K_V self.current /\ inv_FMapIter_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMapIter_K_V
  
  predicate inv_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = invariant_ref_FMapIter_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMapIter_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0'1 /\ inv_V _1.f1'1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'2 -> inv_tup2_K_V f0'2
        end
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  predicate produces_FMapIter_K_V (self: t_FMapIter_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMapIter_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0'1 <> (Seq.get visited j).f0'1)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0'1 = k; f1'1 = v }
        -> not contains_K (view_FMapIter_K_V o) k /\ get_K (view_FMapIter_K_V self) k = Some v)
    /\ len_K (view_FMapIter_K_V self) = Seq.length visited + len_K (view_FMapIter_K_V o)
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0'1 <> k)
      -> get_K (view_FMapIter_K_V o) k = get_K (view_FMapIter_K_V self) k)
  
  function produces_trans_FMapIter_K_V (a: t_FMapIter_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMapIter_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMapIter_K_V) : ()
  
  axiom produces_trans_FMapIter_K_V_spec:
    forall a: t_FMapIter_K_V, ab: Seq.seq tup2_K_V, b: t_FMapIter_K_V, bc: Seq.seq tup2_K_V, c: t_FMapIter_K_V. produces_FMapIter_K_V a ab b
      -> produces_FMapIter_K_V b bc c -> produces_FMapIter_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMapIter_K_V (self: t_FMapIter_K_V) : ()
  
  axiom produces_refl_FMapIter_K_V_spec:
    forall self: t_FMapIter_K_V. produces_FMapIter_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: view_FMap_K_V empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  predicate completed_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) = is_empty_K (view_FMapIter_K_V self.current)
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. view_FMap_K_V (insert_K self k v)
      = Map.set (view_FMap_K_V self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  let rec next_FMapIter_K_V (self: MutBorrow.t t_FMapIter_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@expl:next 'self' type invariant] inv_ref_FMapIter_K_V self}
    any
    [ return (result: t_Option_tup2_K_V) -> {inv_Option_tup2_K_V result}
      {match result with
        | None'0 -> completed_FMapIter_K_V self
        | Some'0 {f0'1 = k; f1'1 = v} -> produces_FMapIter_K_V self.current (Seq.singleton { f0'1 = k;
                                                                                             f1'1 = v }) self.final
        /\ view_FMapIter_K_V self.current = insert_K (view_FMapIter_K_V self.final) k v
        end}
      (! return {result}) ]
  
  predicate resolve_ref_FMapIter_K_V [@inline:trivial] (_1: MutBorrow.t t_FMapIter_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_FMapIter_K_V
  
  predicate invariant_Box_tup2_K_V_Global (self: tup2_K_V) = inv_tup2_K_V self
  
  predicate inv_Box_tup2_K_V_Global [@inline:trivial] (_1: tup2_K_V) = invariant_Box_tup2_K_V_Global _1
  
  meta "rewrite_def" predicate inv_Box_tup2_K_V_Global
  
  predicate invariant_Seq_tup2_K_V [@inline:trivial] (self: Seq.seq tup2_K_V) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_Box_tup2_K_V_Global (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_tup2_K_V
  
  predicate inv_Seq_tup2_K_V [@inline:trivial] (_1: Seq.seq tup2_K_V) = invariant_Seq_tup2_K_V _1
  
  meta "rewrite_def" predicate inv_Seq_tup2_K_V
  
  let rec elim_Some (_x: t_Option_tup2_K_V) (return (f0'2: tup2_K_V)) = any
    [ _k (f0'2: tup2_K_V) -> {Some'0 f0'2 = _x} (! return {f0'2})
    | _chk -> (! {match _x with
        | Some'0 _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: MutBorrow.t t_FMap_K_V) =
    inv_FMap_K_V self.current /\ inv_FMap_K_V self.final
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate inv_Option_V (_1: t_Option_V)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_V [inv_Option_V x]. inv_Option_V x
      = match x with
        | None -> true
        | Some f0'2 -> inv_V f0'2
        end
  
  let rec insert_ghost_K (self: MutBorrow.t t_FMap_K_V) (key: t_K) (value: t_V) (return (x: t_Option_V)) =
    {[@expl:insert_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    {[@expl:insert_ghost 'key' type invariant] inv_K key}
    {[@expl:insert_ghost 'value' type invariant] inv_V value}
    any
    [ return (result: t_Option_V) -> {inv_Option_V result}
      {self.final = insert_K self.current key value}
      {result = get_K self.current key}
      (! return {result}) ]
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_Option_V (_1: t_Option_V)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_V [resolve_Option_V x]. resolve_Option_V x
      = match x with
        | None -> true
        | Some x0 -> resolve_V x0
        end
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_FMap_K_V (self: t_FMap_K_V) =
    forall k: t_K, v: t_V. get_K self k = Some v -> resolve_K k /\ resolve_V v
  
  predicate resolve_FMap_K_V'0 (_1: t_FMap_K_V)
  
  axiom resolve_axiom'0: forall x: t_FMap_K_V [resolve_FMap_K_V'0 x]. resolve_FMap_K_V'0 x -> resolve_FMap_K_V x
  
  predicate resolve_FMapIter_K_V (self: t_FMapIter_K_V) = resolve_FMap_K_V'0 (view_FMapIter_K_V self)
  
  predicate resolve_FMapIter_K_V'0 (_1: t_FMapIter_K_V)
  
  axiom resolve_axiom'1: forall x: t_FMapIter_K_V [resolve_FMapIter_K_V'0 x]. resolve_FMapIter_K_V'0 x
      -> resolve_FMapIter_K_V x
  
  let rec new_FMap_K_V (x: t_FMap_K_V) (return (x'0: t_FMap_K_V)) = {[@expl:new 'x' type invariant] inv_FMap_K_V x}
    any [ return (result: t_FMap_K_V) -> {inv_Ghost_FMap_K_V result} {result = x} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec merge_fmaps_K (m1: t_FMap_K_V) (m2: t_FMap_K_V) (return (x: t_FMap_K_V)) =
    {[@expl:merge_fmaps 'm1' type invariant] inv_Ghost_FMap_K_V m1}
    {[@expl:merge_fmaps 'm2' type invariant] inv_Ghost_FMap_K_V m2}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &merge <- merge_K m1 m2 (fun (__0: tup2_V_V) -> let {f0 = v1} = __0 in v1) ] s1
      | s1 = into_inner_FMap_K_V {m2} (fun (_x: t_FMap_K_V) -> [ &result <- _x ] s2)
      | s2 = [ &len <- len_K m1 ] s3
      | s3 = into_inner_FMap_K_V {m1} (fun (_x: t_FMap_K_V) -> [ &_18 <- _x ] s4)
      | s4 = into_iter_FMap_K_V {_18} (fun (_x: t_FMapIter_K_V) -> [ &iter <- _x ] s5)
      | s5 = [ &iter_old <- iter ] s6
      | s6 = [ &produced <- Seq.empty: Seq.seq tup2_K_V ] s7
      | s7 = bb8 ]
    | bb8 = bb8invariant
      [ bb8 = {[@expl:loop variant] well_founded_relation_Int variant_old_bb8 (len - Seq.length produced)} bb8invariant
      | bb8invariant = {[@expl:for invariant] inv_Seq_tup2_K_V produced}
        {[@expl:for invariant] inv_FMapIter_K_V iter}
        {[@expl:for invariant] produces_FMapIter_K_V iter_old produced iter}
        {[@expl:loop invariant #0] ext_eq_K merge (merge_K (view_FMapIter_K_V iter) result (fun (__0: tup2_V_V) -> let {f0 = v1} = __0 in v1))}
        {[@expl:loop invariant #1] inv_FMap_K_V result}
        (! [ &variant_old_bb8 <- len - Seq.length produced ] s0)
        [ s0 = {inv_FMapIter_K_V iter}
          MutBorrow.borrow_mut <t_FMapIter_K_V> {iter}
            (fun (_bor: MutBorrow.t t_FMapIter_K_V) ->
              [ &_46 <- _bor ] -{inv_FMapIter_K_V _bor.final}-
              [ &iter <- _bor.final ] s1)
        | s1 = {inv_FMapIter_K_V _46.current}
          MutBorrow.borrow_final <t_FMapIter_K_V> {_46.current} {MutBorrow.get_id _46}
            (fun (_bor: MutBorrow.t t_FMapIter_K_V) ->
              [ &_45 <- _bor ] -{inv_FMapIter_K_V _bor.final}-
              [ &_46 <- { _46 with current = _bor.final } ] s2)
        | s2 = next_FMapIter_K_V {_45} (fun (_x: t_Option_tup2_K_V) -> [ &_44 <- _x ] s3)
        | s3 = {[@expl:type invariant] inv_ref_FMapIter_K_V _46} s4
        | s4 = -{resolve_ref_FMapIter_K_V _46}- s5
        | s5 = any [ br0 -> {_44 = None'0} (! bb13) | br1 (x0: tup2_K_V) -> {_44 = Some'0 x0} (! bb14) ] ]
        [ bb14 = s0
          [ s0 = elim_Some {_44} (fun (r0: tup2_K_V) -> [ &__creusot_proc_iter_elem <- r0 ] s1)
          | s1 = [ &produced <- Seq.(++) produced (Seq.singleton __creusot_proc_iter_elem) ] s2
          | s2 = [ &k <- __creusot_proc_iter_elem.f0'1 ] s3
          | s3 = [ &v <- __creusot_proc_iter_elem.f1'1 ] s4
          | s4 = {inv_FMap_K_V result}
            MutBorrow.borrow_mut <t_FMap_K_V> {result}
              (fun (_bor: MutBorrow.t t_FMap_K_V) ->
                [ &_56 <- _bor ] -{inv_FMap_K_V _bor.final}-
                [ &result <- _bor.final ] s5)
          | s5 = insert_ghost_K {_56} {k} {v} (fun (_x: t_Option_V) -> [ &_55 <- _x ] s6)
          | s6 = {[@expl:type invariant] inv_Option_V _55} s7
          | s7 = -{resolve_Option_V _55}- s8
          | s8 = bb8 ] ] ]
    | bb13 = s0
      [ s0 = {[@expl:type invariant] inv_FMapIter_K_V iter} s1
      | s1 = -{resolve_FMapIter_K_V'0 iter}- s2
      | s2 = {[@expl:assertion] ext_eq_K result merge} s3
      | s3 = new_FMap_K_V {result} (fun (_x: t_FMap_K_V) -> [ &_ret <- _x ] s4)
      | s4 = return {_ret} ] ]
    [ & _ret: t_FMap_K_V = Any.any_l ()
    | & m1: t_FMap_K_V = m1
    | & m2: t_FMap_K_V = m2
    | & merge: t_FMap_K_V = Any.any_l ()
    | & result: t_FMap_K_V = Any.any_l ()
    | & len: int = Any.any_l ()
    | & iter: t_FMapIter_K_V = Any.any_l ()
    | & _18: t_FMap_K_V = Any.any_l ()
    | & iter_old: t_FMapIter_K_V = Any.any_l ()
    | & produced: Seq.seq tup2_K_V = Any.any_l ()
    | & _44: t_Option_tup2_K_V = Any.any_l ()
    | & _45: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & _46: MutBorrow.t t_FMapIter_K_V = Any.any_l ()
    | & __creusot_proc_iter_elem: tup2_K_V = Any.any_l ()
    | & k: t_K = Any.any_l ()
    | & v: t_V = Any.any_l ()
    | & _55: t_Option_V = Any.any_l ()
    | & _56: MutBorrow.t t_FMap_K_V = Any.any_l ()
    | & variant_old_bb8: int = Any.any_l () ])
    [ return (result: t_FMap_K_V) -> {[@expl:merge_fmaps result type invariant] inv_Ghost_FMap_K_V result}
      {[@expl:merge_fmaps ensures] result = merge_K m1 m2 (fun (__0: tup2_V_V) -> let {f0 = v1} = __0 in v1)}
      (! return {result}) ]
end
