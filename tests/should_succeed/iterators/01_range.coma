module M_impl_Iterator_for_Range__produces_refl (* <Range as common::Iterator> *)
  use creusot.int.Int64
  use seq.Seq
  use mach.int.Int
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate produces_Range (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.end' = o.end'
    /\ Int64.le self.start o.start
    /\ (Seq.length visited > 0 -> Int64.le o.start o.end')
    /\ Seq.length visited = Int64.to_int o.start - Int64.to_int self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> Int64.to_int (Seq.get visited i) = Int64.to_int self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Range
  
  function produces_refl_Range (self: t_Range) : ()
  
  goal vc_produces_refl_Range: [@expl:produces_refl ensures] produces_Range self (Seq.empty: Seq.seq Int64.t) self
end
module M_impl_Iterator_for_Range__produces_trans (* <Range as common::Iterator> *)
  use creusot.int.Int64
  use seq.Seq
  use mach.int.Int
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate produces_Range (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.end' = o.end'
    /\ Int64.le self.start o.start
    /\ (Seq.length visited > 0 -> Int64.le o.start o.end')
    /\ Seq.length visited = Int64.to_int o.start - Int64.to_int self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> Int64.to_int (Seq.get visited i) = Int64.to_int self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Range
  
  constant ab : Seq.seq Int64.t
  
  constant b : t_Range
  
  constant bc : Seq.seq Int64.t
  
  constant c : t_Range
  
  function produces_trans_Range (a: t_Range) (ab: Seq.seq Int64.t) (b: t_Range) (bc: Seq.seq Int64.t) (c: t_Range) : ()
  
  goal vc_produces_trans_Range: produces_Range a ab b
    -> produces_Range b bc c -> ([@expl:produces_trans ensures] produces_Range a (Seq.(++) ab bc) c)
end
module M_impl_Iterator_for_Range__next (* <Range as common::Iterator> *)
  use creusot.int.Int64
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use seq.Seq
  use mach.int.Int
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  predicate resolve_ref_Range [@inline:trivial] (_1: MutBorrow.t t_Range) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Range
  
  type t_Option_isize = None | Some Int64.t
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate completed_Range (self: MutBorrow.t t_Range) =
    resolve_ref_Range self /\ Int64.ge self.current.start self.current.end'
  
  predicate produces_Range (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.end' = o.end'
    /\ Int64.le self.start o.start
    /\ (Seq.length visited > 0 -> Int64.le o.start o.end')
    /\ Seq.length visited = Int64.to_int o.start - Int64.to_int self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> Int64.to_int (Seq.get visited i) = Int64.to_int self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_Range (self: MutBorrow.t t_Range) (return (x: t_Option_isize)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- Int64.ge self.current.start self.current.end' ] s1
      | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ] ]
    | bb1 = s0 [ s0 = -{resolve_ref_Range self}- s1 | s1 = [ &_0 <- None ] s2 | s2 = bb3 ]
    | bb2 = s0
      [ s0 = [ &r <- self.current.start ] s1
      | s1 = Int64.add {self.current.start} {(1: Int64.t)}
          (fun (_ret: Int64.t) -> [ &self <- { self with current = { self.current with start = _ret } } ] s2)
      | s2 = -{resolve_ref_Range self}- s3
      | s3 = [ &_0 <- Some r ] s4
      | s4 = bb3 ]
    | bb3 = return {_0} ]
    [ & _0: t_Option_isize = Any.any_l ()
    | & self: MutBorrow.t t_Range = self
    | & _4: bool = Any.any_l ()
    | & r: Int64.t = Any.any_l () ])
    [ return (result: t_Option_isize) -> {[@expl:next ensures] match result with
        | None -> completed_Range self
        | Some v -> produces_Range self.current (Seq.singleton v) self.final
        end}
      (! return {result}) ]
end
module M_impl_Range__into_iter (* Range *)
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter (self: t_Range) (return (x: t_Range)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_0 <- self ] s1 | s1 = return {_0} ] ]
    [ & _0: t_Range = Any.any_l () | & self: t_Range = self ])
    [ return (result: t_Range) -> {[@expl:into_iter ensures] result = self} (! return {result}) ]
end
module M_sum_range
  use creusot.int.Int64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  let rec into_iter (self: t_Range) (return (x: t_Range)) = any
    [ return (result: t_Range) -> {result = self} (! return {result}) ]
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate produces_Range (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.end' = o.end'
    /\ Int64.le self.start o.start
    /\ (Seq.length visited > 0 -> Int64.le o.start o.end')
    /\ Seq.length visited = Int64.to_int o.start - Int64.to_int self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> Int64.to_int (Seq.get visited i) = Int64.to_int self.start + i)
  
  function produces_trans_Range (a: t_Range) (ab: Seq.seq Int64.t) (b: t_Range) (bc: Seq.seq Int64.t) (c: t_Range) : ()
   = ()
  
  axiom produces_trans_Range_spec:
    forall a: t_Range, ab: Seq.seq Int64.t, b: t_Range, bc: Seq.seq Int64.t, c: t_Range. produces_Range a ab b
      -> produces_Range b bc c -> produces_Range a (Seq.(++) ab bc) c
  
  function produces_refl_Range (self: t_Range) : () = ()
  
  axiom produces_refl_Range_spec: forall self: t_Range. produces_Range self (Seq.empty: Seq.seq Int64.t) self
  
  predicate inv_Range [@inline:trivial] (_1: t_Range) = true
  
  meta "rewrite_def" predicate inv_Range
  
  type t_Option_isize = None | Some Int64.t
  
  predicate resolve_ref_Range [@inline:trivial] (_1: MutBorrow.t t_Range) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Range
  
  predicate completed_Range (self: MutBorrow.t t_Range) =
    resolve_ref_Range self /\ Int64.ge self.current.start self.current.end'
  
  let rec next_Range (self: MutBorrow.t t_Range) (return (x: t_Option_isize)) = any
    [ return (result: t_Option_isize) -> {match result with
        | None -> completed_Range self
        | Some v -> produces_Range self.current (Seq.singleton v) self.final
        end}
      (! return {result}) ]
  
  let rec elim_Some (input: t_Option_isize) (ret (f0: Int64.t)) = any
    [ good (f0: Int64.t) -> {Some f0 = input} (! ret {f0})
    | bad -> {forall f0: Int64.t [Some f0: t_Option_isize]. Some f0 <> input} (! {false} any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec sum_range (n: Int64.t) (return (x: Int64.t)) = {[@expl:sum_range requires] Int64.to_int n >= 0}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &i <- (0: Int64.t) ] s1
      | s1 = [ &_8 <- { start = (0: Int64.t); end' = n } ] s2
      | s2 = into_iter {_8} (fun (_ret: t_Range) -> [ &it <- _ret ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = [ &iter_old <- it ] s1 | s1 = bb2 ]
    | bb2 = s0 [ s0 = [ &produced <- Seq.empty: Seq.seq Int64.t ] s1 | s1 = bb4 ]
    | bb4 = bb4
      [ bb4 = {[@expl:loop invariant #0] inv_Range it}
        {[@expl:loop invariant #1] produces_Range iter_old produced it}
        {[@expl:loop invariant #2] Int64.to_int i = Seq.length produced /\ Int64.le i n}
        (! s0)
        [ s0 = bb5 ]
        [ bb5 = s0
          [ s0 = MutBorrow.borrow_mut <t_Range> {it}
              (fun (_ret: MutBorrow.t t_Range) -> [ &_29 <- _ret ] [ &it <- _ret.final ] s1)
          | s1 = next_Range {_29} (fun (_ret: t_Option_isize) -> [ &_28 <- _ret ] s2)
          | s2 = bb6 ]
        | bb6 = any [ br0 -> {_28 = None} (! bb9) | br1 (x0: Int64.t) -> {_28 = Some x0} (! bb10) ]
        | bb10 = s0
          [ s0 = elim_Some {_28} (fun (r0: Int64.t) -> [ &x <- r0 ] s1)
          | s1 = [ &_32 <- Seq.(++) produced (Seq.singleton x) ] s2
          | s2 = bb11 ]
        | bb11 = s0
          [ s0 = [ &produced <- _32 ] s1
          | s1 = Int64.add {i} {(1: Int64.t)} (fun (_ret: Int64.t) -> [ &i <- _ret ] s2)
          | s2 = bb4 ] ] ]
    | bb9 = s0 [ s0 = [ &_0 <- i ] s1 | s1 = return {_0} ] ]
    [ & _0: Int64.t = Any.any_l ()
    | & n: Int64.t = n
    | & i: Int64.t = Any.any_l ()
    | & it: t_Range = Any.any_l ()
    | & _8: t_Range = Any.any_l ()
    | & iter_old: t_Range = Any.any_l ()
    | & produced: Seq.seq Int64.t = Any.any_l ()
    | & _28: t_Option_isize = Any.any_l ()
    | & _29: MutBorrow.t t_Range = Any.any_l ()
    | & x: Int64.t = Any.any_l ()
    | & _32: Seq.seq Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@expl:sum_range ensures] result = n} (! return {result}) ]
end
module M_impl_Iterator_for_Range__produces_trans__refines (* <Range as common::Iterator> *)
  use creusot.int.Int64
  use seq.Seq
  use mach.int.Int
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate produces_Range (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.end' = o.end'
    /\ Int64.le self.start o.start
    /\ (Seq.length visited > 0 -> Int64.le o.start o.end')
    /\ Seq.length visited = Int64.to_int o.start - Int64.to_int self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> Int64.to_int (Seq.get visited i) = Int64.to_int self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Range. forall ab: Seq.seq Int64.t. forall b: t_Range. forall bc: Seq.seq Int64.t. forall c: t_Range. produces_Range a ab b
                /\ produces_Range b bc c
              -> produces_Range a ab b
              /\ produces_Range b bc c
              /\ (forall result: (). produces_Range a (Seq.(++) ab bc) c -> produces_Range a (Seq.(++) ab bc) c)
end
module M_impl_Iterator_for_Range__next__refines (* <Range as common::Iterator> *)
  use creusot.int.Int64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  
  type t_Option_isize = None | Some Int64.t
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  predicate resolve_ref_Range [@inline:trivial] (_1: MutBorrow.t t_Range) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Range
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate completed_Range (self: MutBorrow.t t_Range) =
    resolve_ref_Range self /\ Int64.ge self.current.start self.current.end'
  
  predicate produces_Range (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.end' = o.end'
    /\ Int64.le self.start o.start
    /\ (Seq.length visited > 0 -> Int64.le o.start o.end')
    /\ Seq.length visited = Int64.to_int o.start - Int64.to_int self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> Int64.to_int (Seq.get visited i) = Int64.to_int self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_Range. forall result: t_Option_isize. match result with
            | None -> completed_Range self
            | Some v -> produces_Range self.current (Seq.singleton v) self.final
            end
        -> match result with
          | None -> completed_Range self
          | Some v -> produces_Range self.current (Seq.singleton v) self.final
          end
end
module M_impl_Iterator_for_Range__produces_refl__refines (* <Range as common::Iterator> *)
  use creusot.int.Int64
  use seq.Seq
  use mach.int.Int
  
  type t_Range = { start: Int64.t; end': Int64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate produces_Range (self: t_Range) (visited: Seq.seq Int64.t) (o: t_Range) =
    self.end' = o.end'
    /\ Int64.le self.start o.start
    /\ (Seq.length visited > 0 -> Int64.le o.start o.end')
    /\ Seq.length visited = Int64.to_int o.start - Int64.to_int self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> Int64.to_int (Seq.get visited i) = Int64.to_int self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Range. forall result: (). produces_Range self (Seq.empty: Seq.seq Int64.t) self
        -> produces_Range self (Seq.empty: Seq.seq Int64.t) self
end
