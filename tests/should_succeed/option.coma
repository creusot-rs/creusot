module M_is_some_none
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec is_some_i32 (self_: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ <> None)} (! return {result}) ]
  
  let rec is_none_i32 (self_: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_some_none (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = is_some_i32 {some} (fun (_x: bool) -> [ &_4 <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = any [ br0 -> {_4 = false} (! bb7) | br1 -> {_4} (! bb2) ]
    | bb2 = s0 [ s0 = is_some_i32 {none} (fun (_x: bool) -> [ &_6 <- _x ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_6 = false} (! bb5) | br1 -> {_6} (! bb7) ]
    | bb5 = s0 [ s0 = is_none_i32 {some} (fun (_x: bool) -> [ &_10 <- _x ] s1) | s1 = bb8 ]
    | bb8 = any [ br0 -> {_10 = false} (! bb10) | br1 -> {_10} (! bb14) ]
    | bb10 = s0 [ s0 = is_none_i32 {none} (fun (_x: bool) -> [ &_12 <- _x ] s1) | s1 = bb11 ]
    | bb11 = any [ br0 -> {_12 = false} (! bb14) | br1 -> {_12} (! bb12) ]
    | bb12 = return {_ret}
    | bb14 = {false} any
    | bb7 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _12: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_unwrap
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec unwrap_i32 (self_: t_Option_i32) (return (x: Int32.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  let rec expect_i32 (self_: t_Option_i32) (msg: string) (return (x: Int32.t)) = {[@expl:expect requires] self_ <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  predicate resolve_i32 [@inline:trivial] (_1: Int32.t) = true
  
  meta "rewrite_def" predicate resolve_i32
  
  let rec unwrap_or_i32 (self_: t_Option_i32) (default: Int32.t) (return (x: Int32.t)) = any
    [ return (result: Int32.t) -> {self_ = None -> result = default}
      {self_ = None \/ self_ = Some result /\ resolve_i32 default}
      (! return {result}) ]
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: Int32.t. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    let () = args in result = (0: Int32.t)
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: Int32.t) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: Int32.t. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: Int32.t. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  let rec default_i32 (return (x: Int32.t)) = any
    [ return (result: Int32.t) -> {result = (0: Int32.t)} (! return {result}) ]
  
  let rec unwrap_or_default_i32 (self_: t_Option_i32) (return (x: Int32.t)) = any
    [ return (result: Int32.t) -> {self_ = None -> postcondition_default () () result}
      {self_ = None \/ self_ = Some result}
      (! return {result}) ]
  
  let rec closure0 [@coma:extspec] (self: ()) (return (x: Int32.t)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: ()) = closure0'pre self
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    closure0'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec unwrap_or_else_i32 (self_: t_Option_i32) (f: ()) (return (x: Int32.t)) =
    {[@expl:unwrap_or_else requires] self_ = None -> precondition_closure0 f ()}
    any
    [ return (result: Int32.t) -> {match self_ with
        | None -> postcondition_once_closure0 f () result
        | Some t -> result = t
        end}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (return (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (3: Int32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int32.t = Any.any_l () ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: ()) = closure1'pre self
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    closure1'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec unwrap_or_else_i32'0 (self_: t_Option_i32) (f: ()) (return (x: Int32.t)) =
    {[@expl:unwrap_or_else requires] self_ = None -> precondition_closure1 f ()}
    any
    [ return (result: Int32.t) -> {match self_ with
        | None -> postcondition_once_closure1 f () result
        | Some t -> result = t
        end}
      (! return {result}) ]
  
  let rec unwrap_unchecked_i32 (self_: t_Option_i32) (return (x: Int32.t)) = {[@expl:unwrap_unchecked requires] self_
    <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec unwrap (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = unwrap_i32 {some} (fun (_x: Int32.t) -> [ &_5 <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = [ &_4 <- _5 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ] ]
    | bb2 = s0
      [ s0 = [ &_13 <- "failed" ] s1
      | s1 = expect_i32 {some} {_13} (fun (_x: Int32.t) -> [ &_10 <- _x ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_9 <- _10 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_9 = false} (! bb6) | br1 -> {_9} (! bb5) ] ]
    | bb5 = s0 [ s0 = unwrap_or_i32 {some} {(2: Int32.t)} (fun (_x: Int32.t) -> [ &_17 <- _x ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_16 <- _17 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ] ]
    | bb8 = s0 [ s0 = unwrap_or_i32 {none} {(2: Int32.t)} (fun (_x: Int32.t) -> [ &_22 <- _x ] s1) | s1 = bb10 ]
    | bb10 = s0
      [ s0 = [ &_21 <- _22 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_21 = false} (! bb12) | br1 -> {_21} (! bb11) ] ]
    | bb11 = s0 [ s0 = unwrap_or_default_i32 {some} (fun (_x: Int32.t) -> [ &_27 <- _x ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_26 <- _27 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_26 = false} (! bb15) | br1 -> {_26} (! bb14) ] ]
    | bb14 = s0 [ s0 = unwrap_or_default_i32 {none} (fun (_x: Int32.t) -> [ &_32 <- _x ] s1) | s1 = bb16 ]
    | bb16 = s0
      [ s0 = [ &_31 <- _32 = (0: Int32.t) ] s1 | s1 = any [ br0 -> {_31 = false} (! bb18) | br1 -> {_31} (! bb17) ] ]
    | bb17 = s0
      [ s0 = [ &_39 <- () ] s1
      | s1 = unwrap_or_else_i32 {some} {_39} (fun (_x: Int32.t) -> [ &_37 <- _x ] s2)
      | s2 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_36 <- _37 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_36 = false} (! bb21) | br1 -> {_36} (! bb20) ] ]
    | bb20 = s0
      [ s0 = [ &_45 <- () ] s1
      | s1 = unwrap_or_else_i32'0 {none} {_45} (fun (_x: Int32.t) -> [ &_43 <- _x ] s2)
      | s2 = bb22 ]
    | bb22 = s0
      [ s0 = [ &_42 <- _43 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_42 = false} (! bb24) | br1 -> {_42} (! bb23) ] ]
    | bb23 = s0 [ s0 = unwrap_unchecked_i32 {some} (fun (_x: Int32.t) -> [ &_49 <- _x ] s1) | s1 = bb25 ]
    | bb25 = s0
      [ s0 = [ &_48 <- _49 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_48 = false} (! bb27) | br1 -> {_48} (! bb26) ] ]
    | bb26 = return {_ret}
    | bb27 = {false} any
    | bb24 = {false} any
    | bb21 = {false} any
    | bb18 = {false} any
    | bb15 = {false} any
    | bb12 = {false} any
    | bb9 = {false} any
    | bb6 = {false} any
    | bb3 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _9: bool = Any.any_l ()
    | & _10: Int32.t = Any.any_l ()
    | & _13: string = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: Int32.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: Int32.t = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _32: Int32.t = Any.any_l ()
    | & _36: bool = Any.any_l ()
    | & _37: Int32.t = Any.any_l ()
    | & _39: () = Any.any_l ()
    | & _42: bool = Any.any_l ()
    | & _43: Int32.t = Any.any_l ()
    | & _45: () = Any.any_l ()
    | & _48: bool = Any.any_l ()
    | & _49: Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_map
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec closure0 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: ())) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  type t_Option_unit = None'0 | Some'0 ()
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure0'pre self _0
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: Int32.t) (result: ()) =
    let _0 = args in closure0'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec map_i32 (self_: t_Option_i32) (f: ()) (return (x: t_Option_unit)) = {[@expl:map requires] match self_ with
      | None -> true
      | Some t -> precondition_closure0 f t
      end}
    any
    [ return (result: t_Option_unit) -> {match self_ with
        | None -> result = None'0
        | Some t -> exists r: (). result = Some'0 r /\ postcondition_once_closure0 f t r
        end}
      (! return {result}) ]
  
  function deep_model_unit [@inline:trivial] (self: ()) : () = ()
  
  meta "rewrite_def" function deep_model_unit
  
  function deep_model_Option_unit [@inline:trivial] (self: t_Option_unit) : t_Option_unit = match self with
      | Some'0 t -> Some'0 (deep_model_unit t)
      | None'0 -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_unit
  
  function deep_model_ref_Option_unit [@inline:trivial] (self: t_Option_unit) : t_Option_unit =
    deep_model_Option_unit self
  
  meta "rewrite_def" function deep_model_ref_Option_unit
  
  let rec eq_Option_unit (self_: t_Option_unit) (rhs: t_Option_unit) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_unit self_ = deep_model_ref_Option_unit rhs)}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (3: Int32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int32.t = Any.any_l () ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure1'pre self _0
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let _0 = args in closure1'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec map_i32'0 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) = {[@expl:map requires] match self_ with
      | None -> true
      | Some t -> precondition_closure1 f t
      end}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None
        | Some t -> exists r: Int32.t. result = Some r /\ postcondition_once_closure1 f t r
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'1 | Some'1 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'1 (deep_model_i32 t)
      | None -> None'1
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec closure2 [@coma:extspec] (self: ()) (x: Int32.t) (return (x'0: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_x: Int32.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int32.t = Any.any_l () | & x: Int32.t = x ]
  
  meta "rewrite_def" predicate closure2'pre
  
  meta "rewrite_def" predicate closure2'post'return
  
  predicate precondition_closure2 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in closure2'pre self x
  
  meta "rewrite_def" predicate precondition_closure2
  
  predicate postcondition_once_closure2 [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let x = args in closure2'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure2
  
  let rec map_i32'1 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) = {[@expl:map requires] match self_ with
      | None -> true
      | Some t -> precondition_closure2 f t
      end}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None
        | Some t -> exists r: Int32.t. result = Some r /\ postcondition_once_closure2 f t r
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = map_i32 {none} {_8} (fun (_x: t_Option_unit) -> [ &_6 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None'0 ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_unit = Any.any_l () | & _1: t_Option_unit = Any.any_l () ]
        [ _const_ret (_const: t_Option_unit) -> [ &_32 <- _const ] s1 ]
      | s1 = eq_Option_unit {_6} {_32} (fun (_x: bool) -> [ &_4 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &_17 <- () ] s1 | s1 = map_i32'0 {some} {_17} (fun (_x: t_Option_i32) -> [ &_15 <- _x ] s2) | s2 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (3: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_31 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_15} {_31} (fun (_x: bool) -> [ &_13 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ]
    | bb7 = s0
      [ s0 = [ &_26 <- () ] s1 | s1 = map_i32'1 {some} {_26} (fun (_x: t_Option_i32) -> [ &_24 <- _x ] s2) | s2 = bb9 ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_30 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_24} {_30} (fun (_x: bool) -> [ &_22 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]
    | bb11 = return {_ret}
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_unit = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option_i32 = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option_i32 = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _30: t_Option_i32 = Any.any_l ()
    | & _31: t_Option_i32 = Any.any_l ()
    | & _32: t_Option_unit = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_inspect
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec closure0 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: ())) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure0'pre self _0
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: Int32.t) (result: ()) =
    let _0 = args in closure0'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec inspect_i32 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) =
    {[@expl:inspect requires] match self_ with
      | None -> true
      | Some t -> precondition_closure0 f t
      end}
    any
    [ return (result: t_Option_i32) -> {result = self_}
      {match self_ with
        | None -> true
        | Some t -> postcondition_once_closure0 f t ()
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: ())) = bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure1'pre self _0
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: Int32.t) (result: ()) =
    let _0 = args in closure1'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec inspect_i32'0 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) =
    {[@expl:inspect requires] match self_ with
      | None -> true
      | Some t -> precondition_closure1 f t
      end}
    any
    [ return (result: t_Option_i32) -> {result = self_}
      {match self_ with
        | None -> true
        | Some t -> postcondition_once_closure1 f t ()
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec inspect (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = inspect_i32 {none} {_8} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_22 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_6} {_22} (fun (_x: bool) -> [ &_4 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &_17 <- () ] s1
      | s1 = inspect_i32'0 {some} {_17} (fun (_x: t_Option_i32) -> [ &_15 <- _x ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_21 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_15} {_21} (fun (_x: bool) -> [ &_13 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ]
    | bb7 = return {_ret}
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option_i32 = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _21: t_Option_i32 = Any.any_l ()
    | & _22: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_map_or
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec closure0 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: Int32.t)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure0'pre self _0
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let _0 = args in closure0'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec map_or_i32 (self_: t_Option_i32) (default: Int32.t) (f: ()) (return (x: Int32.t)) =
    {[@expl:map_or requires] match self_ with
      | None -> true
      | Some t -> precondition_closure0 f t
      end}
    any
    [ return (result: Int32.t) -> {match self_ with
        | None -> result = default
        | Some t -> postcondition_once_closure0 f t result
        end}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (3: Int32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int32.t = Any.any_l () ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure1'pre self _0
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let _0 = args in closure1'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec map_or_i32'0 (self_: t_Option_i32) (default: Int32.t) (f: ()) (return (x: Int32.t)) =
    {[@expl:map_or requires] match self_ with
      | None -> true
      | Some t -> precondition_closure1 f t
      end}
    any
    [ return (result: Int32.t) -> {match self_ with
        | None -> result = default
        | Some t -> postcondition_once_closure1 f t result
        end}
      (! return {result}) ]
  
  let rec closure2 [@coma:extspec] (self: ()) (x: Int32.t) (return (x'0: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_x: Int32.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int32.t = Any.any_l () | & x: Int32.t = x ]
  
  meta "rewrite_def" predicate closure2'pre
  
  meta "rewrite_def" predicate closure2'post'return
  
  predicate precondition_closure2 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in closure2'pre self x
  
  meta "rewrite_def" predicate precondition_closure2
  
  predicate postcondition_once_closure2 [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let x = args in closure2'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure2
  
  let rec map_or_i32'1 (self_: t_Option_i32) (default: Int32.t) (f: ()) (return (x: Int32.t)) =
    {[@expl:map_or requires] match self_ with
      | None -> true
      | Some t -> precondition_closure2 f t
      end}
    any
    [ return (result: Int32.t) -> {match self_ with
        | None -> result = default
        | Some t -> postcondition_once_closure2 f t result
        end}
      (! return {result}) ]
  
  let rec closure3 [@coma:extspec] (self: ()) (return (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (2: Int32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int32.t = Any.any_l () ]
  
  meta "rewrite_def" predicate closure3'pre
  
  meta "rewrite_def" predicate closure3'post'return
  
  let rec closure4 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: Int32.t)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure4'pre
  
  meta "rewrite_def" predicate closure4'post'return
  
  predicate precondition_closure3 [@inline:trivial] (self: ()) (args: ()) = closure3'pre self
  
  meta "rewrite_def" predicate precondition_closure3
  
  predicate precondition_closure4 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure4'pre self _0
  
  meta "rewrite_def" predicate precondition_closure4
  
  predicate postcondition_once_closure3 [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    closure3'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure3
  
  predicate postcondition_once_closure4 [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let _0 = args in closure4'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure4
  
  let rec map_or_else_i32 (self_: t_Option_i32) (default: ()) (f: ()) (return (x: Int32.t)) =
    {[@expl:map_or_else requires] match self_ with
      | None -> precondition_closure3 default ()
      | Some t -> precondition_closure4 f t
      end}
    any
    [ return (result: Int32.t) -> {match self_ with
        | None -> postcondition_once_closure3 default () result
        | Some t -> postcondition_once_closure4 f t result
        end}
      (! return {result}) ]
  
  let rec closure5 [@coma:extspec] (self: ()) (return (x: Int32.t)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure5'pre
  
  meta "rewrite_def" predicate closure5'post'return
  
  let rec closure6 [@coma:extspec] (self: ()) (x: Int32.t) (return (x'0: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_x: Int32.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int32.t = Any.any_l () | & x: Int32.t = x ]
  
  meta "rewrite_def" predicate closure6'pre
  
  meta "rewrite_def" predicate closure6'post'return
  
  predicate precondition_closure5 [@inline:trivial] (self: ()) (args: ()) = closure5'pre self
  
  meta "rewrite_def" predicate precondition_closure5
  
  predicate precondition_closure6 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in closure6'pre self x
  
  meta "rewrite_def" predicate precondition_closure6
  
  predicate postcondition_once_closure5 [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    closure5'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure5
  
  predicate postcondition_once_closure6 [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let x = args in closure6'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure6
  
  let rec map_or_else_i32'0 (self_: t_Option_i32) (default: ()) (f: ()) (return (x: Int32.t)) =
    {[@expl:map_or_else requires] match self_ with
      | None -> precondition_closure5 default ()
      | Some t -> precondition_closure6 f t
      end}
    any
    [ return (result: Int32.t) -> {match self_ with
        | None -> postcondition_once_closure5 default () result
        | Some t -> postcondition_once_closure6 f t result
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map_or (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = [ &_7 <- () ] s3
      | s3 = map_or_i32 {none} {(2: Int32.t)} {_7} (fun (_x: Int32.t) -> [ &_5 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0 [ s0 = [ &_4 <- _5 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_4 = false} (! bb3) | br1 -> {_4} (! bb2) ] ]
    | bb2 = s0
      [ s0 = [ &_13 <- () ] s1
      | s1 = map_or_i32'0 {some} {(-1: Int32.t)} {_13} (fun (_x: Int32.t) -> [ &_11 <- _x ] s2)
      | s2 = bb4 ]
    | bb4 = s0
      [ s0 = [ &_10 <- _11 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ] ]
    | bb5 = s0
      [ s0 = [ &_19 <- () ] s1
      | s1 = map_or_i32'1 {some} {(-1: Int32.t)} {_19} (fun (_x: Int32.t) -> [ &_17 <- _x ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_16 <- _17 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb8) ] ]
    | bb8 = s0
      [ s0 = [ &_25 <- () ] s1
      | s1 = [ &_26 <- () ] s2
      | s2 = map_or_else_i32 {none} {_25} {_26} (fun (_x: Int32.t) -> [ &_23 <- _x ] s3)
      | s3 = bb10 ]
    | bb10 = s0
      [ s0 = [ &_22 <- _23 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ] ]
    | bb11 = s0
      [ s0 = [ &_32 <- () ] s1
      | s1 = [ &_33 <- () ] s2
      | s2 = map_or_else_i32'0 {some} {_32} {_33} (fun (_x: Int32.t) -> [ &_30 <- _x ] s3)
      | s3 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_29 <- _30 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_29 = false} (! bb15) | br1 -> {_29} (! bb14) ] ]
    | bb14 = return {_ret}
    | bb15 = {false} any
    | bb12 = {false} any
    | bb9 = {false} any
    | bb6 = {false} any
    | bb3 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _5: Int32.t = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _17: Int32.t = Any.any_l ()
    | & _19: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _23: Int32.t = Any.any_l ()
    | & _25: () = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _29: bool = Any.any_l ()
    | & _30: Int32.t = Any.any_l ()
    | & _32: () = Any.any_l ()
    | & _33: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_ok_or
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  type t_Result_i32_bool = Ok Int32.t | Err bool
  
  predicate resolve_bool [@inline:trivial] (_1: bool) = true
  
  meta "rewrite_def" predicate resolve_bool
  
  let rec ok_or_i32 (self_: t_Option_i32) (err: bool) (return (x: t_Result_i32_bool)) = any
    [ return (result: t_Result_i32_bool) -> {match self_ with
        | None -> result = Err err
        | Some t -> result = Ok t /\ resolve_bool err
        end}
      (! return {result}) ]
  
  let rec closure0 [@coma:extspec] (self: ()) (return (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ] [ & _ret: bool = Any.any_l () ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: ()) = closure0'pre self
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: ()) (result: bool) =
    closure0'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec ok_or_else_i32 (self_: t_Option_i32) (err: ()) (return (x: t_Result_i32_bool)) =
    {[@expl:ok_or_else requires] self_ = None -> precondition_closure0 err ()}
    any
    [ return (result: t_Result_i32_bool) -> {match self_ with
        | None -> exists r: bool. result = Err r /\ postcondition_once_closure0 err () r
        | Some t -> result = Ok t
        end}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (return (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ] ] [ & _ret: bool = Any.any_l () ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: ()) = closure1'pre self
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: ()) (result: bool) =
    closure1'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec ok_or_else_i32'0 (self_: t_Option_i32) (err: ()) (return (x: t_Result_i32_bool)) =
    {[@expl:ok_or_else requires] self_ = None -> precondition_closure1 err ()}
    any
    [ return (result: t_Result_i32_bool) -> {match self_ with
        | None -> exists r: bool. result = Err r /\ postcondition_once_closure1 err () r
        | Some t -> result = Ok t
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ok_or (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = ok_or_i32 {none} {true} (fun (_x: t_Result_i32_bool) -> [ &err <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = {[@expl:assertion] err = Err true} s1
      | s1 = ok_or_i32 {some} {false} (fun (_x: t_Result_i32_bool) -> [ &ok <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = s0
      [ s0 = {[@expl:assertion] ok = Ok (1: Int32.t)} s1
      | s1 = [ &_15 <- () ] s2
      | s2 = ok_or_else_i32 {none} {_15} (fun (_x: t_Result_i32_bool) -> [ &err'0 <- _x ] s3)
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = {[@expl:assertion] err'0 = Err true} s1
      | s1 = [ &_21 <- () ] s2
      | s2 = ok_or_else_i32'0 {some} {_21} (fun (_x: t_Result_i32_bool) -> [ &ok'0 <- _x ] s3)
      | s3 = bb4 ]
    | bb4 = s0 [ s0 = {[@expl:assertion] ok'0 = Ok (1: Int32.t)} s1 | s1 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & err: t_Result_i32_bool = Any.any_l ()
    | & ok: t_Result_i32_bool = Any.any_l ()
    | & err'0: t_Result_i32_bool = Any.any_l ()
    | & _15: () = Any.any_l ()
    | & ok'0: t_Result_i32_bool = Any.any_l ()
    | & _21: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_as_mut
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  type t_Option_ref_i32 = None'0 | Some'0 (MutBorrow.t Int32.t)
  
  let rec as_mut_i32 (self_: MutBorrow.t t_Option_i32) (return (x: t_Option_ref_i32)) = any
    [ return (result: t_Option_ref_i32) -> {self_.current = None -> result = None'0 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t Int32.t. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  predicate resolve_Option_ref_i32 (_1: t_Option_ref_i32)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_ref_i32 [resolve_Option_ref_i32 x]. resolve_Option_ref_i32 x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_ref_i32 x0
        end
  
  let rec is_none_ref_i32 (self_: t_Option_ref_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None'0)} (! return {result}) ]
  
  let rec unwrap_ref_i32 (self_: t_Option_ref_i32) (return (x: MutBorrow.t Int32.t)) = {[@expl:unwrap requires] self_
    <> None'0}
    any [ return (result: MutBorrow.t Int32.t) -> {Some'0 result = self_} (! return {result}) ]
  
  let rec unwrap_i32 (self_: t_Option_i32) (return (x: Int32.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_mut (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_7 <- _bor ] [ &none <- _bor.final ] s3)
      | s3 = as_mut_i32 {_7} (fun (_x: t_Option_ref_i32) -> [ &_6 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = -{resolve_Option_ref_i32 _6}- s1
      | s1 = is_none_ref_i32 {_6} (fun (_x: bool) -> [ &_4 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_11 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = as_mut_i32 {_11} (fun (_x: t_Option_ref_i32) -> [ &_10 <- _x ] s2)
      | s2 = bb5 ]
    | bb5 = s0 [ s0 = unwrap_ref_i32 {_10} (fun (_x: MutBorrow.t Int32.t) -> [ &_9 <- _x ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_9 <- { _9 with current = (2: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 _9}- s2
      | s2 = unwrap_i32 {some} (fun (_x: Int32.t) -> [ &_14 <- _x ] s3)
      | s3 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_13 <- _14 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_13 = false} (! bb9) | br1 -> {_13} (! bb8) ] ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_19 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = as_mut_i32 {_19} (fun (_x: t_Option_ref_i32) -> [ &_18 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = s0 [ s0 = unwrap_ref_i32 {_18} (fun (_x: MutBorrow.t Int32.t) -> [ &_17 <- _x ] s1) | s1 = bb11 ]
    | bb11 = s0
      [ s0 = [ &_17 <- { _17 with current = (1: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 _17}- s2
      | s2 = unwrap_i32 {some} (fun (_x: Int32.t) -> [ &_22 <- _x ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = [ &_21 <- _22 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb14 = {false} any
    | bb9 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_ref_i32 = Any.any_l ()
    | & _7: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _9: MutBorrow.t Int32.t = Any.any_l ()
    | & _10: t_Option_ref_i32 = Any.any_l ()
    | & _11: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _14: Int32.t = Any.any_l ()
    | & _17: MutBorrow.t Int32.t = Any.any_l ()
    | & _18: t_Option_ref_i32 = Any.any_l ()
    | & _19: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_as_ref
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  type t_Option_ref_i32 = None'0 | Some'0 Int32.t
  
  let rec as_ref_i32 (self_: t_Option_i32) (return (x: t_Option_ref_i32)) = any
    [ return (result: t_Option_ref_i32) -> {self_ = None -> result = None'0}
      {self_ = None \/ (exists r: Int32.t. result = Some'0 r /\ self_ = Some r)}
      (! return {result}) ]
  
  let rec is_none_ref_i32 (self_: t_Option_ref_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None'0)} (! return {result}) ]
  
  let rec unwrap_ref_i32 (self_: t_Option_ref_i32) (return (x: Int32.t)) = {[@expl:unwrap requires] self_ <> None'0}
    any [ return (result: Int32.t) -> {Some'0 result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_ref (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = as_ref_i32 {none} (fun (_x: t_Option_ref_i32) -> [ &_6 <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = is_none_ref_i32 {_6} (fun (_x: bool) -> [ &_4 <- _x ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0 [ s0 = as_ref_i32 {some} (fun (_x: t_Option_ref_i32) -> [ &_13 <- _x ] s1) | s1 = bb5 ]
    | bb5 = s0 [ s0 = unwrap_ref_i32 {_13} (fun (_x: Int32.t) -> [ &_12 <- _x ] s1) | s1 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_10 <- _12 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_10 = false} (! bb8) | br1 -> {_10} (! bb7) ] ]
    | bb7 = return {_ret}
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_ref_i32 = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _12: Int32.t = Any.any_l ()
    | & _13: t_Option_ref_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_replace
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec replace_i32 (self_: MutBorrow.t t_Option_i32) (value: Int32.t) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {result = self_.current /\ self_.final = Some value} (! return {result}) ]
  
  let rec is_none_i32 (self_: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec unwrap_i32 (self_: t_Option_i32) (return (x: Int32.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec replace (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_7 <- _bor ] [ &none <- _bor.final ] s3)
      | s3 = replace_i32 {_7} {(2: Int32.t)} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0 [ s0 = is_none_i32 {_6} (fun (_x: bool) -> [ &_4 <- _x ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0 [ s0 = unwrap_i32 {none} (fun (_x: Int32.t) -> [ &_11 <- _x ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = [ &_10 <- _11 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ] ]
    | bb6 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_18 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = replace_i32 {_18} {(2: Int32.t)} (fun (_x: t_Option_i32) -> [ &_17 <- _x ] s2)
      | s2 = bb8 ]
    | bb8 = s0 [ s0 = unwrap_i32 {_17} (fun (_x: Int32.t) -> [ &_16 <- _x ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_15 <- _16 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_15 = false} (! bb11) | br1 -> {_15} (! bb10) ] ]
    | bb10 = s0 [ s0 = unwrap_i32 {some} (fun (_x: Int32.t) -> [ &_22 <- _x ] s1) | s1 = bb12 ]
    | bb12 = s0
      [ s0 = [ &_21 <- _22 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_21 = false} (! bb14) | br1 -> {_21} (! bb13) ] ]
    | bb13 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_29 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = replace_i32 {_29} {(1: Int32.t)} (fun (_x: t_Option_i32) -> [ &_28 <- _x ] s2)
      | s2 = bb15 ]
    | bb15 = s0 [ s0 = unwrap_i32 {_28} (fun (_x: Int32.t) -> [ &_27 <- _x ] s1) | s1 = bb16 ]
    | bb16 = s0
      [ s0 = [ &_26 <- _27 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_26 = false} (! bb18) | br1 -> {_26} (! bb17) ] ]
    | bb17 = s0 [ s0 = unwrap_i32 {some} (fun (_x: Int32.t) -> [ &_33 <- _x ] s1) | s1 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_32 <- _33 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_32 = false} (! bb21) | br1 -> {_32} (! bb20) ] ]
    | bb20 = return {_ret}
    | bb21 = {false} any
    | bb18 = {false} any
    | bb14 = {false} any
    | bb11 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _7: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _11: Int32.t = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _16: Int32.t = Any.any_l ()
    | & _17: t_Option_i32 = Any.any_l ()
    | & _18: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & _22: Int32.t = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: Int32.t = Any.any_l ()
    | & _28: t_Option_i32 = Any.any_l ()
    | & _29: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _33: Int32.t = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_and_or_xor
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  predicate resolve_Option_i32 [@inline:trivial] (_1: t_Option_i32) = true
  
  meta "rewrite_def" predicate resolve_Option_i32
  
  let rec and_i32 (self_: t_Option_i32) (optb: t_Option_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {self_ = None -> result = None /\ resolve_Option_i32 optb}
      {self_ = None \/ result = optb /\ resolve_Option_i32 self_}
      (! return {result}) ]
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec or_i32 (self_: t_Option_i32) (optb: t_Option_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {self_ = None -> result = optb}
      {self_ = None \/ result = self_ /\ resolve_Option_i32 optb}
      (! return {result}) ]
  
  type tup2_Option_i32_Option_i32 = { f0: t_Option_i32; f1: t_Option_i32 }
  
  predicate resolve_i32 [@inline:trivial] (_1: Int32.t) = true
  
  meta "rewrite_def" predicate resolve_i32
  
  let rec xor_i32 (self_: t_Option_i32) (optb: t_Option_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {match { f0 = self_; f1 = optb } with
        | {f0 = None; f1 = None} -> result = None
        | {f0 = Some t1; f1 = Some t2} -> result = None /\ resolve_i32 t1 /\ resolve_i32 t2
        | {f0 = Some t; f1 = None} -> result = Some t
        | {f0 = None; f1 = Some t} -> result = Some t
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec and_or_xor (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = and_i32 {none} {none} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_122 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_6} {_122} (fun (_x: bool) -> [ &_4 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &_17 <- Some (2: Int32.t) ] s1
      | s1 = and_i32 {none} {_17} (fun (_x: t_Option_i32) -> [ &_15 <- _x ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_121 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_15} {_121} (fun (_x: bool) -> [ &_13 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ]
    | bb7 = s0 [ s0 = and_i32 {some} {none} (fun (_x: t_Option_i32) -> [ &_24 <- _x ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_120 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_24} {_120} (fun (_x: bool) -> [ &_22 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_35 <- Some (2: Int32.t) ] s1
      | s1 = and_i32 {some} {_35} (fun (_x: t_Option_i32) -> [ &_33 <- _x ] s2)
      | s2 = bb13 ]
    | bb13 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_119 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_33} {_119} (fun (_x: bool) -> [ &_31 <- _x ] s2)
      | s2 = bb14 ]
    | bb14 = any [ br0 -> {_31 = false} (! bb16) | br1 -> {_31} (! bb15) ]
    | bb15 = s0 [ s0 = or_i32 {none} {none} (fun (_x: t_Option_i32) -> [ &_42 <- _x ] s1) | s1 = bb17 ]
    | bb17 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_118 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_42} {_118} (fun (_x: bool) -> [ &_40 <- _x ] s2)
      | s2 = bb18 ]
    | bb18 = any [ br0 -> {_40 = false} (! bb20) | br1 -> {_40} (! bb19) ]
    | bb19 = s0
      [ s0 = [ &_53 <- Some (2: Int32.t) ] s1
      | s1 = or_i32 {none} {_53} (fun (_x: t_Option_i32) -> [ &_51 <- _x ] s2)
      | s2 = bb21 ]
    | bb21 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_117 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_51} {_117} (fun (_x: bool) -> [ &_49 <- _x ] s2)
      | s2 = bb22 ]
    | bb22 = any [ br0 -> {_49 = false} (! bb24) | br1 -> {_49} (! bb23) ]
    | bb23 = s0 [ s0 = or_i32 {some} {none} (fun (_x: t_Option_i32) -> [ &_60 <- _x ] s1) | s1 = bb25 ]
    | bb25 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_116 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_60} {_116} (fun (_x: bool) -> [ &_58 <- _x ] s2)
      | s2 = bb26 ]
    | bb26 = any [ br0 -> {_58 = false} (! bb28) | br1 -> {_58} (! bb27) ]
    | bb27 = s0
      [ s0 = [ &_71 <- Some (2: Int32.t) ] s1
      | s1 = or_i32 {some} {_71} (fun (_x: t_Option_i32) -> [ &_69 <- _x ] s2)
      | s2 = bb29 ]
    | bb29 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_115 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_69} {_115} (fun (_x: bool) -> [ &_67 <- _x ] s2)
      | s2 = bb30 ]
    | bb30 = any [ br0 -> {_67 = false} (! bb32) | br1 -> {_67} (! bb31) ]
    | bb31 = s0 [ s0 = xor_i32 {none} {none} (fun (_x: t_Option_i32) -> [ &_78 <- _x ] s1) | s1 = bb33 ]
    | bb33 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_114 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_78} {_114} (fun (_x: bool) -> [ &_76 <- _x ] s2)
      | s2 = bb34 ]
    | bb34 = any [ br0 -> {_76 = false} (! bb36) | br1 -> {_76} (! bb35) ]
    | bb35 = s0
      [ s0 = [ &_89 <- Some (2: Int32.t) ] s1
      | s1 = xor_i32 {none} {_89} (fun (_x: t_Option_i32) -> [ &_87 <- _x ] s2)
      | s2 = bb37 ]
    | bb37 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_113 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_87} {_113} (fun (_x: bool) -> [ &_85 <- _x ] s2)
      | s2 = bb38 ]
    | bb38 = any [ br0 -> {_85 = false} (! bb40) | br1 -> {_85} (! bb39) ]
    | bb39 = s0 [ s0 = xor_i32 {some} {none} (fun (_x: t_Option_i32) -> [ &_96 <- _x ] s1) | s1 = bb41 ]
    | bb41 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_112 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_96} {_112} (fun (_x: bool) -> [ &_94 <- _x ] s2)
      | s2 = bb42 ]
    | bb42 = any [ br0 -> {_94 = false} (! bb44) | br1 -> {_94} (! bb43) ]
    | bb43 = s0
      [ s0 = [ &_107 <- Some (2: Int32.t) ] s1
      | s1 = xor_i32 {some} {_107} (fun (_x: t_Option_i32) -> [ &_105 <- _x ] s2)
      | s2 = bb45 ]
    | bb45 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_111 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_105} {_111} (fun (_x: bool) -> [ &_103 <- _x ] s2)
      | s2 = bb46 ]
    | bb46 = any [ br0 -> {_103 = false} (! bb48) | br1 -> {_103} (! bb47) ]
    | bb47 = return {_ret}
    | bb48 = {false} any
    | bb44 = {false} any
    | bb40 = {false} any
    | bb36 = {false} any
    | bb32 = {false} any
    | bb28 = {false} any
    | bb24 = {false} any
    | bb20 = {false} any
    | bb16 = {false} any
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option_i32 = Any.any_l ()
    | & _17: t_Option_i32 = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option_i32 = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _33: t_Option_i32 = Any.any_l ()
    | & _35: t_Option_i32 = Any.any_l ()
    | & _40: bool = Any.any_l ()
    | & _42: t_Option_i32 = Any.any_l ()
    | & _49: bool = Any.any_l ()
    | & _51: t_Option_i32 = Any.any_l ()
    | & _53: t_Option_i32 = Any.any_l ()
    | & _58: bool = Any.any_l ()
    | & _60: t_Option_i32 = Any.any_l ()
    | & _67: bool = Any.any_l ()
    | & _69: t_Option_i32 = Any.any_l ()
    | & _71: t_Option_i32 = Any.any_l ()
    | & _76: bool = Any.any_l ()
    | & _78: t_Option_i32 = Any.any_l ()
    | & _85: bool = Any.any_l ()
    | & _87: t_Option_i32 = Any.any_l ()
    | & _89: t_Option_i32 = Any.any_l ()
    | & _94: bool = Any.any_l ()
    | & _96: t_Option_i32 = Any.any_l ()
    | & _103: bool = Any.any_l ()
    | & _105: t_Option_i32 = Any.any_l ()
    | & _107: t_Option_i32 = Any.any_l ()
    | & _111: t_Option_i32 = Any.any_l ()
    | & _112: t_Option_i32 = Any.any_l ()
    | & _113: t_Option_i32 = Any.any_l ()
    | & _114: t_Option_i32 = Any.any_l ()
    | & _115: t_Option_i32 = Any.any_l ()
    | & _116: t_Option_i32 = Any.any_l ()
    | & _117: t_Option_i32 = Any.any_l ()
    | & _118: t_Option_i32 = Any.any_l ()
    | & _119: t_Option_i32 = Any.any_l ()
    | & _120: t_Option_i32 = Any.any_l ()
    | & _121: t_Option_i32 = Any.any_l ()
    | & _122: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_and_then
  use creusot.int.Int32
  use creusot.prelude.Any
  use mach.int.Int
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec closure0 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: t_Option_i32)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure0'pre self _0
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: Int32.t) (result: t_Option_i32) =
    let _0 = args in closure0'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec and_then_i32 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) =
    {[@expl:and_then requires] match self_ with
      | None -> true
      | Some t -> precondition_closure0 f t
      end}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None
        | Some t -> postcondition_once_closure0 f t result
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec closure1 (self: ()) (x: Int32.t) (return (x'0: t_Option_i32)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_4 <- x = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_4 = false} (! bb2) | br1 -> {_4} (! bb1) ] ]
    | bb1 = s0
      [ s0 = Int32.add {x} {(1: Int32.t)} (fun (_x: Int32.t) -> [ &_6 <- _x ] s1)
      | s1 = [ &res <- Some _6 ] s2
      | s2 = bb3 ]
    | bb2 = s0 [ s0 = [ &res <- None ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &_ret <- res ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_i32 = Any.any_l ()
    | & x: Int32.t = x
    | & res: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: Int32.t = Any.any_l () ])
    [ return (result: t_Option_i32) -> {[@expl:closure ensures] Int32.to_int x = 1
        /\ (exists y: Int32.t. result = Some y /\ Int32.to_int y = Int32.to_int x + 1)
      \/ Int32.to_int x <> 1 /\ result = None}
      (! return {result}) ]
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in true
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: Int32.t) (result: t_Option_i32) =
    let x = args in Int32.to_int x = 1 /\ (exists y: Int32.t. result = Some y /\ Int32.to_int y = Int32.to_int x + 1)
    \/ Int32.to_int x <> 1 /\ result = None
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec and_then_i32'0 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) =
    {[@expl:and_then requires] match self_ with
      | None -> true
      | Some t -> precondition_closure1 f t
      end}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None
        | Some t -> postcondition_once_closure1 f t result
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec and_then (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some1 <- Some (1: Int32.t) ] s2
      | s2 = [ &some2 <- Some (3: Int32.t) ] s3
      | s3 = [ &_9 <- () ] s4
      | s4 = and_then_i32 {none} {_9} (fun (_x: t_Option_i32) -> [ &_7 <- _x ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_34 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_7} {_34} (fun (_x: bool) -> [ &_5 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_5 = false} (! bb4) | br1 -> {_5} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &clos <- () ] s1
      | s1 = and_then_i32'0 {some1} {clos} (fun (_x: t_Option_i32) -> [ &_17 <- _x ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_33 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_17} {_33} (fun (_x: bool) -> [ &_15 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb7) ]
    | bb7 = s0 [ s0 = and_then_i32'0 {some2} {clos} (fun (_x: t_Option_i32) -> [ &_26 <- _x ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_32 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_26} {_32} (fun (_x: bool) -> [ &_24 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = any [ br0 -> {_24 = false} (! bb12) | br1 -> {_24} (! bb11) ]
    | bb11 = return {_ret}
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some1: t_Option_i32 = Any.any_l ()
    | & some2: t_Option_i32 = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: t_Option_i32 = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & clos: () = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _17: t_Option_i32 = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Option_i32 = Any.any_l ()
    | & _32: t_Option_i32 = Any.any_l ()
    | & _33: t_Option_i32 = Any.any_l ()
    | & _34: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_filter
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec closure0 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: bool)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure0'pre self _0
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: Int32.t) (result: bool) =
    let _0 = args in closure0'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  predicate resolve_i32 [@inline:trivial] (_1: Int32.t) = true
  
  meta "rewrite_def" predicate resolve_i32
  
  let rec filter_i32 (self_: t_Option_i32) (predicate': ()) (return (x: t_Option_i32)) =
    {[@expl:filter requires] match self_ with
      | None -> true
      | Some t -> precondition_closure0 predicate' t
      end}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None
        | Some t -> match result with
          | None -> postcondition_once_closure0 predicate' t false /\ resolve_i32 t
          | Some r -> postcondition_once_closure0 predicate' t true /\ r = t
          end
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (x: Int32.t) (return (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- x = (1: Int32.t) ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & x: Int32.t = x ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in closure1'pre self x
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: Int32.t) (result: bool) =
    let x = args in closure1'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec filter_i32'0 (self_: t_Option_i32) (predicate': ()) (return (x: t_Option_i32)) =
    {[@expl:filter requires] match self_ with
      | None -> true
      | Some t -> precondition_closure1 predicate' t
      end}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None
        | Some t -> match result with
          | None -> postcondition_once_closure1 predicate' t false /\ resolve_i32 t
          | Some r -> postcondition_once_closure1 predicate' t true /\ r = t
          end
        end}
      (! return {result}) ]
  
  let rec closure2 [@coma:extspec] (self: ()) (x: Int32.t) (return (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- x = (2: Int32.t) ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & x: Int32.t = x ]
  
  meta "rewrite_def" predicate closure2'pre
  
  meta "rewrite_def" predicate closure2'post'return
  
  predicate precondition_closure2 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in closure2'pre self x
  
  meta "rewrite_def" predicate precondition_closure2
  
  predicate postcondition_once_closure2 [@inline:trivial] (self: ()) (args: Int32.t) (result: bool) =
    let x = args in closure2'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure2
  
  let rec filter_i32'1 (self_: t_Option_i32) (predicate': ()) (return (x: t_Option_i32)) =
    {[@expl:filter requires] match self_ with
      | None -> true
      | Some t -> precondition_closure2 predicate' t
      end}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None
        | Some t -> match result with
          | None -> postcondition_once_closure2 predicate' t false /\ resolve_i32 t
          | Some r -> postcondition_once_closure2 predicate' t true /\ r = t
          end
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec filter (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = filter_i32 {none} {_8} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_32 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_6} {_32} (fun (_x: bool) -> [ &_4 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &_17 <- () ] s1
      | s1 = filter_i32'0 {some} {_17} (fun (_x: t_Option_i32) -> [ &_15 <- _x ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_31 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_15} {_31} (fun (_x: bool) -> [ &_13 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ]
    | bb7 = s0
      [ s0 = [ &_26 <- () ] s1
      | s1 = filter_i32'1 {some} {_26} (fun (_x: t_Option_i32) -> [ &_24 <- _x ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_30 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_24} {_30} (fun (_x: bool) -> [ &_22 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]
    | bb11 = return {_ret}
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option_i32 = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option_i32 = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _30: t_Option_i32 = Any.any_l ()
    | & _31: t_Option_i32 = Any.any_l ()
    | & _32: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_is_some_and
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec closure0 [@coma:extspec] (self: ()) (x: Int32.t) (return (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- x = (1: Int32.t) ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & x: Int32.t = x ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in closure0'pre self x
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: Int32.t) (result: bool) =
    let x = args in closure0'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec is_some_and_i32 (self_: t_Option_i32) (f: ()) (return (x: bool)) =
    {[@expl:is_some_and requires] match self_ with
      | None -> true
      | Some t -> precondition_closure0 f t
      end}
    any
    [ return (result: bool) -> {match self_ with
        | None -> result = false
        | Some t -> postcondition_once_closure0 f t result
        end}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (x: Int32.t) (return (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- x = (1: Int32.t) ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & x: Int32.t = x ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: Int32.t) = let x = args in closure1'pre self x
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: Int32.t) (result: bool) =
    let x = args in closure1'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec is_some_and_i32'0 (self_: t_Option_i32) (f: ()) (return (x: bool)) =
    {[@expl:is_some_and requires] match self_ with
      | None -> true
      | Some t -> precondition_closure1 f t
      end}
    any
    [ return (result: bool) -> {match self_ with
        | None -> result = false
        | Some t -> postcondition_once_closure1 f t result
        end}
      (! return {result}) ]
  
  let rec closure2 [@coma:extspec] (self: ()) (_0: Int32.t) (return (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ] [ & _ret: bool = Any.any_l () ]
  
  meta "rewrite_def" predicate closure2'pre
  
  meta "rewrite_def" predicate closure2'post'return
  
  predicate precondition_closure2 [@inline:trivial] (self: ()) (args: Int32.t) = let _0 = args in closure2'pre self _0
  
  meta "rewrite_def" predicate precondition_closure2
  
  predicate postcondition_once_closure2 [@inline:trivial] (self: ()) (args: Int32.t) (result: bool) =
    let _0 = args in closure2'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure2
  
  let rec is_some_and_i32'1 (self_: t_Option_i32) (f: ()) (return (x: bool)) =
    {[@expl:is_some_and requires] match self_ with
      | None -> true
      | Some t -> precondition_closure2 f t
      end}
    any
    [ return (result: bool) -> {match self_ with
        | None -> result = false
        | Some t -> postcondition_once_closure2 f t result
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec is_some_and (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some1 <- Some (1: Int32.t) ] s2
      | s2 = [ &some2 <- Some (2: Int32.t) ] s3
      | s3 = [ &_7 <- () ] s4
      | s4 = is_some_and_i32 {some1} {_7} (fun (_x: bool) -> [ &_5 <- _x ] s5)
      | s5 = bb1 ]
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ]
    | bb2 = s0
      [ s0 = [ &_12 <- () ] s1 | s1 = is_some_and_i32'0 {some2} {_12} (fun (_x: bool) -> [ &_10 <- _x ] s2) | s2 = bb4 ]
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ]
    | bb5 = {false} any
    | bb6 = s0
      [ s0 = [ &_17 <- () ] s1 | s1 = is_some_and_i32'1 {none} {_17} (fun (_x: bool) -> [ &_15 <- _x ] s2) | s2 = bb7 ]
    | bb7 = any [ br0 -> {_15 = false} (! bb9) | br1 -> {_15} (! bb8) ]
    | bb8 = {false} any
    | bb9 = return {_ret}
    | bb3 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some1: t_Option_i32 = Any.any_l ()
    | & some2: t_Option_i32 = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _17: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_or_else
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec closure0 [@coma:extspec] (self: ()) (return (x: t_Option_i32)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- Some (2: Int32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: t_Option_i32 = Any.any_l () ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: ()) = closure0'pre self
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: ()) (result: t_Option_i32) =
    closure0'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec or_else_i32 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) = {[@expl:or_else requires] self_ = None
    -> precondition_closure0 f ()}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> postcondition_once_closure0 f () result
        | Some t -> result = Some t
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (return (x: t_Option_i32)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- None ] s1 | s1 = return {_ret} ] ] [ & _ret: t_Option_i32 = Any.any_l () ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: ()) = closure1'pre self
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: ()) (result: t_Option_i32) =
    closure1'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec or_else_i32'0 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) = {[@expl:or_else requires] self_
      = None -> precondition_closure1 f ()}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> postcondition_once_closure1 f () result
        | Some t -> result = Some t
        end}
      (! return {result}) ]
  
  let rec closure2 [@coma:extspec] (self: ()) (return (x: t_Option_i32)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure2'pre
  
  meta "rewrite_def" predicate closure2'post'return
  
  predicate precondition_closure2 [@inline:trivial] (self: ()) (args: ()) = closure2'pre self
  
  meta "rewrite_def" predicate precondition_closure2
  
  predicate postcondition_once_closure2 [@inline:trivial] (self: ()) (args: ()) (result: t_Option_i32) =
    closure2'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure2
  
  let rec or_else_i32'1 (self_: t_Option_i32) (f: ()) (return (x: t_Option_i32)) = {[@expl:or_else requires] self_
      = None -> precondition_closure2 f ()}
    any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> postcondition_once_closure2 f () result
        | Some t -> result = Some t
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec or_else (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = or_else_i32 {none} {_8} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (2: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_32 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_6} {_32} (fun (_x: bool) -> [ &_4 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &_17 <- () ] s1
      | s1 = or_else_i32'0 {none} {_17} (fun (_x: t_Option_i32) -> [ &_15 <- _x ] s2)
      | s2 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_31 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_15} {_31} (fun (_x: bool) -> [ &_13 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ]
    | bb7 = s0
      [ s0 = [ &_26 <- () ] s1
      | s1 = or_else_i32'1 {some} {_26} (fun (_x: t_Option_i32) -> [ &_24 <- _x ] s2)
      | s2 = bb9 ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_30 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_24} {_30} (fun (_x: bool) -> [ &_22 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]
    | bb11 = return {_ret}
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option_i32 = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _24: t_Option_i32 = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _30: t_Option_i32 = Any.any_l ()
    | & _31: t_Option_i32 = Any.any_l ()
    | & _32: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_insert
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  predicate resolve_i32 [@inline:trivial] (_1: Int32.t) = true
  
  meta "rewrite_def" predicate resolve_i32
  
  let rec insert_i32 (self_: MutBorrow.t t_Option_i32) (value: Int32.t) (return (x: MutBorrow.t Int32.t)) = any
    [ return (result: MutBorrow.t Int32.t) -> {match self_.current with
        | Some t -> resolve_i32 t
        | None -> true
        end}
      {result.current = value /\ self_.final = Some (result.final)}
      (! return {result}) ]
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec insert (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_4 <- _bor ] [ &none <- _bor.final ] s3)
      | s3 = insert_i32 {_4} {(2: Int32.t)} (fun (_x: MutBorrow.t Int32.t) -> [ &i1 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_6 <- i1.current = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_6 = false} (! bb3) | br1 -> {_6} (! bb2) ] ]
    | bb2 = s0
      [ s0 = [ &i1 <- { i1 with current = (3: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 i1}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (3: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_28 <- _const ] s3 ]
      | s3 = eq_Option_i32 {none} {_28} (fun (_x: bool) -> [ &_10 <- _x ] s4)
      | s4 = bb4 ]
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_16 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = insert_i32 {_16} {(4: Int32.t)} (fun (_x: MutBorrow.t Int32.t) -> [ &i2 <- _x ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_18 <- i2.current = (4: Int32.t) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb8) ] ]
    | bb8 = s0
      [ s0 = [ &i2 <- { i2 with current = (5: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 i2}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (5: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_27 <- _const ] s3 ]
      | s3 = eq_Option_i32 {some} {_27} (fun (_x: bool) -> [ &_22 <- _x ] s4)
      | s4 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]
    | bb11 = return {_ret}
    | bb12 = {false} any
    | bb9 = s0 [ s0 = -{resolve_ref_i32 i2}- s1 | s1 = {false} any ]
    | bb6 = {false} any
    | bb3 = s0 [ s0 = -{resolve_ref_i32 i1}- s1 | s1 = {false} any ] ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & i1: MutBorrow.t Int32.t = Any.any_l ()
    | & _4: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & i2: MutBorrow.t Int32.t = Any.any_l ()
    | & _16: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _27: t_Option_i32 = Any.any_l ()
    | & _28: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_get_or_insert
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  predicate resolve_i32 [@inline:trivial] (_1: Int32.t) = true
  
  meta "rewrite_def" predicate resolve_i32
  
  let rec get_or_insert_i32 (self_: MutBorrow.t t_Option_i32) (value: Int32.t) (return (x: MutBorrow.t Int32.t)) = any
    [ return (result: MutBorrow.t Int32.t) -> {match self_.current with
        | None -> result.current = value /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final) /\ resolve_i32 value
        end}
      (! return {result}) ]
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec closure0 [@coma:extspec] (self: ()) (return (x: Int32.t)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (2: Int32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int32.t = Any.any_l () ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: ()) = closure0'pre self
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    closure0'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec get_or_insert_with_i32 (self_: MutBorrow.t t_Option_i32) (f: ()) (return (x: MutBorrow.t Int32.t)) =
    {[@expl:get_or_insert_with requires] self_.current = None -> precondition_closure0 f ()}
    any
    [ return (result: MutBorrow.t Int32.t) -> {match self_.current with
        | None -> postcondition_once_closure0 f () result.current /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final)
        end}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (return (x: Int32.t)) = bb0 [ bb0 = {false} any ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: ()) = closure1'pre self
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: ()) (result: Int32.t) =
    closure1'post'return self result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec get_or_insert_with_i32'0 (self_: MutBorrow.t t_Option_i32) (f: ()) (return (x: MutBorrow.t Int32.t)) =
    {[@expl:get_or_insert_with requires] self_.current = None -> precondition_closure1 f ()}
    any
    [ return (result: MutBorrow.t Int32.t) -> {match self_.current with
        | None -> postcondition_once_closure1 f () result.current /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final)
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec get_or_insert (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_4 <- _bor ] [ &none <- _bor.final ] s3)
      | s3 = get_or_insert_i32 {_4} {(2: Int32.t)} (fun (_x: MutBorrow.t Int32.t) -> [ &i1 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_6 <- i1.current = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_6 = false} (! bb3) | br1 -> {_6} (! bb2) ] ]
    | bb2 = s0
      [ s0 = [ &i1 <- { i1 with current = (3: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 i1}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (3: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_58 <- _const ] s3 ]
      | s3 = eq_Option_i32 {none} {_58} (fun (_x: bool) -> [ &_10 <- _x ] s4)
      | s4 = bb4 ]
    | bb4 = any [ br0 -> {_10 = false} (! bb6) | br1 -> {_10} (! bb5) ]
    | bb5 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_16 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = get_or_insert_i32 {_16} {(4: Int32.t)} (fun (_x: MutBorrow.t Int32.t) -> [ &i2 <- _x ] s2)
      | s2 = bb7 ]
    | bb7 = s0
      [ s0 = [ &_18 <- i2.current = (1: Int32.t) ] s1
      | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb8) ] ]
    | bb8 = s0
      [ s0 = [ &i2 <- { i2 with current = (5: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 i2}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (5: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_57 <- _const ] s3 ]
      | s3 = eq_Option_i32 {some} {_57} (fun (_x: bool) -> [ &_22 <- _x ] s4)
      | s4 = bb10 ]
    | bb10 = any [ br0 -> {_22 = false} (! bb12) | br1 -> {_22} (! bb11) ]
    | bb11 = s0
      [ s0 = [ &_27 <- None ] s1
      | s1 = [ &none <- _27 ] s2
      | s2 = [ &_28 <- Some (1: Int32.t) ] s3
      | s3 = [ &some <- _28 ] s4
      | s4 = [ &_31 <- () ] s5
      | s5 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_30 <- _bor ] [ &none <- _bor.final ] s6)
      | s6 = get_or_insert_with_i32 {_30} {_31} (fun (_x: MutBorrow.t Int32.t) -> [ &i1'0 <- _x ] s7)
      | s7 = bb13 ]
    | bb13 = s0
      [ s0 = [ &_33 <- i1'0.current = (2: Int32.t) ] s1
      | s1 = any [ br0 -> {_33 = false} (! bb15) | br1 -> {_33} (! bb14) ] ]
    | bb14 = s0
      [ s0 = [ &i1'0 <- { i1'0 with current = (3: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 i1'0}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (3: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_56 <- _const ] s3 ]
      | s3 = eq_Option_i32 {none} {_56} (fun (_x: bool) -> [ &_37 <- _x ] s4)
      | s4 = bb16 ]
    | bb16 = any [ br0 -> {_37 = false} (! bb18) | br1 -> {_37} (! bb17) ]
    | bb17 = s0
      [ s0 = [ &_44 <- () ] s1
      | s1 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_43 <- _bor ] [ &some <- _bor.final ] s2)
      | s2 = get_or_insert_with_i32'0 {_43} {_44} (fun (_x: MutBorrow.t Int32.t) -> [ &i2'0 <- _x ] s3)
      | s3 = bb19 ]
    | bb19 = s0
      [ s0 = [ &_46 <- i2'0.current = (1: Int32.t) ] s1
      | s1 = any [ br0 -> {_46 = false} (! bb21) | br1 -> {_46} (! bb20) ] ]
    | bb20 = s0
      [ s0 = [ &i2'0 <- { i2'0 with current = (5: Int32.t) } ] s1
      | s1 = -{resolve_ref_i32 i2'0}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (5: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_55 <- _const ] s3 ]
      | s3 = eq_Option_i32 {some} {_55} (fun (_x: bool) -> [ &_50 <- _x ] s4)
      | s4 = bb22 ]
    | bb22 = any [ br0 -> {_50 = false} (! bb24) | br1 -> {_50} (! bb23) ]
    | bb23 = return {_ret}
    | bb24 = {false} any
    | bb21 = s0 [ s0 = -{resolve_ref_i32 i2'0}- s1 | s1 = {false} any ]
    | bb18 = {false} any
    | bb15 = s0 [ s0 = -{resolve_ref_i32 i1'0}- s1 | s1 = {false} any ]
    | bb12 = {false} any
    | bb9 = s0 [ s0 = -{resolve_ref_i32 i2}- s1 | s1 = {false} any ]
    | bb6 = {false} any
    | bb3 = s0 [ s0 = -{resolve_ref_i32 i1}- s1 | s1 = {false} any ] ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & i1: MutBorrow.t Int32.t = Any.any_l ()
    | & _4: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & i2: MutBorrow.t Int32.t = Any.any_l ()
    | & _16: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _27: t_Option_i32 = Any.any_l ()
    | & _28: t_Option_i32 = Any.any_l ()
    | & i1'0: MutBorrow.t Int32.t = Any.any_l ()
    | & _30: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _31: () = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & i2'0: MutBorrow.t Int32.t = Any.any_l ()
    | & _43: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _44: () = Any.any_l ()
    | & _46: bool = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & _55: t_Option_i32 = Any.any_l ()
    | & _56: t_Option_i32 = Any.any_l ()
    | & _57: t_Option_i32 = Any.any_l ()
    | & _58: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_take
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  let rec take_i32 (self_: MutBorrow.t t_Option_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {result = self_.current /\ self_.final = None} (! return {result}) ]
  
  let rec is_none_i32 (self_: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec unwrap_i32 (self_: t_Option_i32) (return (x: Int32.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_7 <- _bor ] [ &none <- _bor.final ] s3)
      | s3 = take_i32 {_7} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s4)
      | s4 = bb1 ]
    | bb1 = s0 [ s0 = is_none_i32 {_6} (fun (_x: bool) -> [ &_4 <- _x ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0 [ s0 = is_none_i32 {none} (fun (_x: bool) -> [ &_10 <- _x ] s1) | s1 = bb5 ]
    | bb5 = any [ br0 -> {_10 = false} (! bb7) | br1 -> {_10} (! bb6) ]
    | bb6 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_17 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = take_i32 {_17} (fun (_x: t_Option_i32) -> [ &_16 <- _x ] s2)
      | s2 = bb8 ]
    | bb8 = s0 [ s0 = unwrap_i32 {_16} (fun (_x: Int32.t) -> [ &_15 <- _x ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = [ &_14 <- _15 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_14 = false} (! bb11) | br1 -> {_14} (! bb10) ] ]
    | bb10 = s0 [ s0 = is_none_i32 {some} (fun (_x: bool) -> [ &_20 <- _x ] s1) | s1 = bb12 ]
    | bb12 = any [ br0 -> {_20 = false} (! bb14) | br1 -> {_20} (! bb13) ]
    | bb13 = return {_ret}
    | bb14 = {false} any
    | bb11 = {false} any
    | bb7 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _7: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & _14: bool = Any.any_l ()
    | & _15: Int32.t = Any.any_l ()
    | & _16: t_Option_i32 = Any.any_l ()
    | & _17: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _20: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_take_if
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  let rec closure0 [@coma:extspec] (self: ()) (_0: MutBorrow.t Int32.t) (return (x: bool)) = bb0
    [ bb0 = s0 [ s0 = -{resolve_ref_i32 _0}- s1 | s1 = {false} any ] ] [ & _0: MutBorrow.t Int32.t = _0 ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate inv_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = true
  
  meta "rewrite_def" predicate inv_ref_i32
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) =
    let _0 = args in closure0'pre self _0
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    let _0 = args in closure0'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec take_if_i32 (self_: MutBorrow.t t_Option_i32) (predicate': ()) (return (x: t_Option_i32)) =
    {[@expl:take_if requires] match self_.current with
      | None -> true
      | Some t -> forall b: MutBorrow.t Int32.t. inv_ref_i32 b /\ b.current = t -> precondition_closure0 predicate' b
      end}
    any
    [ return (result: t_Option_i32) -> {match self_.current with
        | None -> result = None /\ self_.final = None
        | Some cur -> exists b: MutBorrow.t Int32.t, res: bool. inv_ref_i32 b
          /\ cur = b.current
          /\ postcondition_once_closure0 predicate' b res
          /\ (if res then
            self_.final = None /\ result = Some (b.final)
          else
            self_.final = Some (b.final) /\ result = None
          )
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'0 | Some'0 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'0 (deep_model_i32 t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec closure1 [@coma:extspec] (self: ()) (x: MutBorrow.t Int32.t) (return (x'0: bool)) = bb0
    [ bb0 = s0 [ s0 = -{resolve_ref_i32 x}- s1 | s1 = [ &_ret <- x.current = (2: Int32.t) ] s2 | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & x: MutBorrow.t Int32.t = x ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) =
    let x = args in closure1'pre self x
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    let x = args in closure1'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec take_if_i32'0 (self_: MutBorrow.t t_Option_i32) (predicate': ()) (return (x: t_Option_i32)) =
    {[@expl:take_if requires] match self_.current with
      | None -> true
      | Some t -> forall b: MutBorrow.t Int32.t. inv_ref_i32 b /\ b.current = t -> precondition_closure1 predicate' b
      end}
    any
    [ return (result: t_Option_i32) -> {match self_.current with
        | None -> result = None /\ self_.final = None
        | Some cur -> exists b: MutBorrow.t Int32.t, res: bool. inv_ref_i32 b
          /\ cur = b.current
          /\ postcondition_once_closure1 predicate' b res
          /\ (if res then
            self_.final = None /\ result = Some (b.final)
          else
            self_.final = Some (b.final) /\ result = None
          )
        end}
      (! return {result}) ]
  
  let rec closure2 [@coma:extspec] (self: ()) (x: MutBorrow.t Int32.t) (return (x'0: bool)) = bb0
    [ bb0 = s0
      [ s0 = [ &res <- x.current = (1: Int32.t) ] s1
      | s1 = [ &x <- { x with current = (3: Int32.t) } ] s2
      | s2 = -{resolve_ref_i32 x}- s3
      | s3 = [ &_ret <- res ] s4
      | s4 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & x: MutBorrow.t Int32.t = x | & res: bool = Any.any_l () ]
  
  meta "rewrite_def" predicate closure2'pre
  
  meta "rewrite_def" predicate closure2'post'return
  
  predicate precondition_closure2 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) =
    let x = args in closure2'pre self x
  
  meta "rewrite_def" predicate precondition_closure2
  
  predicate postcondition_once_closure2 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    let x = args in closure2'post'return self x result
  
  meta "rewrite_def" predicate postcondition_once_closure2
  
  let rec take_if_i32'1 (self_: MutBorrow.t t_Option_i32) (predicate': ()) (return (x: t_Option_i32)) =
    {[@expl:take_if requires] match self_.current with
      | None -> true
      | Some t -> forall b: MutBorrow.t Int32.t. inv_ref_i32 b /\ b.current = t -> precondition_closure2 predicate' b
      end}
    any
    [ return (result: t_Option_i32) -> {match self_.current with
        | None -> result = None /\ self_.final = None
        | Some cur -> exists b: MutBorrow.t Int32.t, res: bool. inv_ref_i32 b
          /\ cur = b.current
          /\ postcondition_once_closure2 predicate' b res
          /\ (if res then
            self_.final = None /\ result = Some (b.final)
          else
            self_.final = Some (b.final) /\ result = None
          )
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take_if (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = [ &_8 <- () ] s3
      | s3 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_7 <- _bor ] [ &none <- _bor.final ] s4)
      | s4 = take_if_i32 {_7} {_8} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_46 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_6} {_46} (fun (_x: bool) -> [ &_4 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_4 = false} (! bb4) | br1 -> {_4} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &_17 <- () ] s1
      | s1 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_16 <- _bor ] [ &some <- _bor.final ] s2)
      | s2 = take_if_i32'0 {_16} {_17} (fun (_x: t_Option_i32) -> [ &_15 <- _x ] s3)
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_45 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_15} {_45} (fun (_x: bool) -> [ &_13 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_13 = false} (! bb8) | br1 -> {_13} (! bb7) ]
    | bb7 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_44 <- _const ] s1 ]
      | s1 = eq_Option_i32 {some} {_44} (fun (_x: bool) -> [ &_22 <- _x ] s2)
      | s2 = bb9 ]
    | bb9 = any [ br0 -> {_22 = false} (! bb11) | br1 -> {_22} (! bb10) ]
    | bb10 = s0
      [ s0 = [ &_32 <- () ] s1
      | s1 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_31 <- _bor ] [ &some <- _bor.final ] s2)
      | s2 = take_if_i32'1 {_31} {_32} (fun (_x: t_Option_i32) -> [ &_30 <- _x ] s3)
      | s3 = bb12 ]
    | bb12 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (3: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_43 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_30} {_43} (fun (_x: bool) -> [ &_28 <- _x ] s2)
      | s2 = bb13 ]
    | bb13 = any [ br0 -> {_28 = false} (! bb15) | br1 -> {_28} (! bb14) ]
    | bb14 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_42 <- _const ] s1 ]
      | s1 = eq_Option_i32 {some} {_42} (fun (_x: bool) -> [ &_37 <- _x ] s2)
      | s2 = bb16 ]
    | bb16 = any [ br0 -> {_37 = false} (! bb18) | br1 -> {_37} (! bb17) ]
    | bb17 = return {_ret}
    | bb18 = {false} any
    | bb15 = {false} any
    | bb11 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _7: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _8: () = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & _15: t_Option_i32 = Any.any_l ()
    | & _16: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _17: () = Any.any_l ()
    | & _22: bool = Any.any_l ()
    | & _28: bool = Any.any_l ()
    | & _30: t_Option_i32 = Any.any_l ()
    | & _31: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _32: () = Any.any_l ()
    | & _37: bool = Any.any_l ()
    | & _42: t_Option_i32 = Any.any_l ()
    | & _43: t_Option_i32 = Any.any_l ()
    | & _44: t_Option_i32 = Any.any_l ()
    | & _45: t_Option_i32 = Any.any_l ()
    | & _46: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_copied_cloned
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  type t_Option_ref_i32 = None'0 | Some'0 Int32.t
  
  let rec as_ref_i32 (self_: t_Option_i32) (return (x: t_Option_ref_i32)) = any
    [ return (result: t_Option_ref_i32) -> {self_ = None -> result = None'0}
      {self_ = None \/ (exists r: Int32.t. result = Some'0 r /\ self_ = Some r)}
      (! return {result}) ]
  
  let rec copied_i32 (self_: t_Option_ref_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {match self_ with
        | None'0 -> result = None
        | Some'0 s -> result = Some s
        end}
      (! return {result}) ]
  
  let rec is_none_i32 (self_: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec unwrap_i32 (self_: t_Option_i32) (return (x: Int32.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  type t_Option_ref_i32'0 = None'1 | Some'1 (MutBorrow.t Int32.t)
  
  let rec as_mut_i32 (self_: MutBorrow.t t_Option_i32) (return (x: t_Option_ref_i32'0)) = any
    [ return (result: t_Option_ref_i32'0) -> {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t Int32.t. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec copied_i32'0 (self_: t_Option_ref_i32'0) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {match self_ with
        | None'1 -> result = None
        | Some'1 s -> result = Some (s.current) /\ s.final = s.current
        end}
      (! return {result}) ]
  
  type tup2_Option_ref_i32_Option_i32 = { f0: t_Option_ref_i32; f1: t_Option_i32 }
  
  predicate postcondition_once_clone [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once_clone
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone [@inline:trivial] (self: ()) (args: Int32.t) (result_state: ()) (result: Int32.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut_clone
  
  function fn_mut_once_clone (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: Int32.t, res: Int32.t. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_clone
  
  function fn_once_clone (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: Int32.t, res: Int32.t. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  let rec clone_i32 (self_: Int32.t) (return (x: Int32.t)) = any
    [ return (result: Int32.t) -> {result = self_} (! return {result}) ]
  
  let rec cloned_i32 (self_: t_Option_ref_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {match { f0 = self_; f1 = result } with
        | {f0 = None'0; f1 = None} -> true
        | {f0 = Some'0 s; f1 = Some r} -> postcondition_clone () s r
        | _ -> false
        end}
      (! return {result}) ]
  
  type tup2_Option_ref_i32_Option_i32'0 = { f0'0: t_Option_ref_i32'0; f1'0: t_Option_i32 }
  
  let rec cloned_i32'0 (self_: t_Option_ref_i32'0) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {match { f0'0 = self_; f1'0 = result } with
        | {f0'0 = None'1; f1'0 = None} -> true
        | {f0'0 = Some'1 s; f1'0 = Some r} -> postcondition_clone () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec copied_cloned (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &some <- Some (1: Int32.t) ] s2
      | s2 = as_ref_i32 {none} (fun (_x: t_Option_ref_i32) -> [ &_7 <- _x ] s3)
      | s3 = bb1 ]
    | bb1 = s0 [ s0 = copied_i32 {_7} (fun (_x: t_Option_i32) -> [ &_6 <- _x ] s1) | s1 = bb2 ]
    | bb2 = s0 [ s0 = is_none_i32 {_6} (fun (_x: bool) -> [ &_4 <- _x ] s1) | s1 = bb3 ]
    | bb3 = any [ br0 -> {_4 = false} (! bb5) | br1 -> {_4} (! bb4) ]
    | bb4 = s0 [ s0 = as_ref_i32 {some} (fun (_x: t_Option_ref_i32) -> [ &_14 <- _x ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = copied_i32 {_14} (fun (_x: t_Option_i32) -> [ &_13 <- _x ] s1) | s1 = bb7 ]
    | bb7 = s0 [ s0 = unwrap_i32 {_13} (fun (_x: Int32.t) -> [ &_12 <- _x ] s1) | s1 = bb8 ]
    | bb8 = s0
      [ s0 = [ &_11 <- _12 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_11 = false} (! bb10) | br1 -> {_11} (! bb9) ] ]
    | bb9 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_22 <- _bor ] [ &none <- _bor.final ] s1)
      | s1 = as_mut_i32 {_22} (fun (_x: t_Option_ref_i32'0) -> [ &_21 <- _x ] s2)
      | s2 = bb11 ]
    | bb11 = s0 [ s0 = copied_i32'0 {_21} (fun (_x: t_Option_i32) -> [ &_20 <- _x ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = is_none_i32 {_20} (fun (_x: bool) -> [ &_18 <- _x ] s1) | s1 = bb13 ]
    | bb13 = any [ br0 -> {_18 = false} (! bb15) | br1 -> {_18} (! bb14) ]
    | bb14 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_29 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = as_mut_i32 {_29} (fun (_x: t_Option_ref_i32'0) -> [ &_28 <- _x ] s2)
      | s2 = bb16 ]
    | bb16 = s0 [ s0 = copied_i32'0 {_28} (fun (_x: t_Option_i32) -> [ &_27 <- _x ] s1) | s1 = bb17 ]
    | bb17 = s0 [ s0 = unwrap_i32 {_27} (fun (_x: Int32.t) -> [ &_26 <- _x ] s1) | s1 = bb18 ]
    | bb18 = s0
      [ s0 = [ &_25 <- _26 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_25 = false} (! bb20) | br1 -> {_25} (! bb19) ] ]
    | bb19 = s0 [ s0 = as_ref_i32 {none} (fun (_x: t_Option_ref_i32) -> [ &_35 <- _x ] s1) | s1 = bb21 ]
    | bb21 = s0 [ s0 = cloned_i32 {_35} (fun (_x: t_Option_i32) -> [ &_34 <- _x ] s1) | s1 = bb22 ]
    | bb22 = s0 [ s0 = is_none_i32 {_34} (fun (_x: bool) -> [ &_32 <- _x ] s1) | s1 = bb23 ]
    | bb23 = any [ br0 -> {_32 = false} (! bb25) | br1 -> {_32} (! bb24) ]
    | bb24 = s0 [ s0 = as_ref_i32 {some} (fun (_x: t_Option_ref_i32) -> [ &_42 <- _x ] s1) | s1 = bb26 ]
    | bb26 = s0 [ s0 = cloned_i32 {_42} (fun (_x: t_Option_i32) -> [ &_41 <- _x ] s1) | s1 = bb27 ]
    | bb27 = s0 [ s0 = unwrap_i32 {_41} (fun (_x: Int32.t) -> [ &_40 <- _x ] s1) | s1 = bb28 ]
    | bb28 = s0
      [ s0 = [ &_39 <- _40 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_39 = false} (! bb30) | br1 -> {_39} (! bb29) ] ]
    | bb29 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {none}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_50 <- _bor ] [ &none <- _bor.final ] s1)
      | s1 = as_mut_i32 {_50} (fun (_x: t_Option_ref_i32'0) -> [ &_49 <- _x ] s2)
      | s2 = bb31 ]
    | bb31 = s0 [ s0 = cloned_i32'0 {_49} (fun (_x: t_Option_i32) -> [ &_48 <- _x ] s1) | s1 = bb32 ]
    | bb32 = s0 [ s0 = is_none_i32 {_48} (fun (_x: bool) -> [ &_46 <- _x ] s1) | s1 = bb33 ]
    | bb33 = any [ br0 -> {_46 = false} (! bb35) | br1 -> {_46} (! bb34) ]
    | bb34 = s0
      [ s0 = MutBorrow.borrow_mut <t_Option_i32> {some}
          (fun (_bor: MutBorrow.t t_Option_i32) -> [ &_57 <- _bor ] [ &some <- _bor.final ] s1)
      | s1 = as_mut_i32 {_57} (fun (_x: t_Option_ref_i32'0) -> [ &_56 <- _x ] s2)
      | s2 = bb36 ]
    | bb36 = s0 [ s0 = cloned_i32'0 {_56} (fun (_x: t_Option_i32) -> [ &_55 <- _x ] s1) | s1 = bb37 ]
    | bb37 = s0 [ s0 = unwrap_i32 {_55} (fun (_x: Int32.t) -> [ &_54 <- _x ] s1) | s1 = bb38 ]
    | bb38 = s0
      [ s0 = [ &_53 <- _54 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_53 = false} (! bb40) | br1 -> {_53} (! bb39) ] ]
    | bb39 = return {_ret}
    | bb40 = {false} any
    | bb35 = {false} any
    | bb30 = {false} any
    | bb25 = {false} any
    | bb20 = {false} any
    | bb15 = {false} any
    | bb10 = {false} any
    | bb5 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_i32 = Any.any_l ()
    | & some: t_Option_i32 = Any.any_l ()
    | & _4: bool = Any.any_l ()
    | & _6: t_Option_i32 = Any.any_l ()
    | & _7: t_Option_ref_i32 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _12: Int32.t = Any.any_l ()
    | & _13: t_Option_i32 = Any.any_l ()
    | & _14: t_Option_ref_i32 = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: t_Option_i32 = Any.any_l ()
    | & _21: t_Option_ref_i32'0 = Any.any_l ()
    | & _22: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: Int32.t = Any.any_l ()
    | & _27: t_Option_i32 = Any.any_l ()
    | & _28: t_Option_ref_i32'0 = Any.any_l ()
    | & _29: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _34: t_Option_i32 = Any.any_l ()
    | & _35: t_Option_ref_i32 = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & _40: Int32.t = Any.any_l ()
    | & _41: t_Option_i32 = Any.any_l ()
    | & _42: t_Option_ref_i32 = Any.any_l ()
    | & _46: bool = Any.any_l ()
    | & _48: t_Option_i32 = Any.any_l ()
    | & _49: t_Option_ref_i32'0 = Any.any_l ()
    | & _50: MutBorrow.t t_Option_i32 = Any.any_l ()
    | & _53: bool = Any.any_l ()
    | & _54: Int32.t = Any.any_l ()
    | & _55: t_Option_i32 = Any.any_l ()
    | & _56: t_Option_ref_i32'0 = Any.any_l ()
    | & _57: MutBorrow.t t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_zip_unzip
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  type t_Option_bool = None'0 | Some'0 bool
  
  type tup2_i32_bool = { f0: Int32.t; f1: bool }
  
  type t_Option_tup2_i32_bool = None'1 | Some'1 tup2_i32_bool
  
  type tup2_Option_i32_Option_bool = { f0'0: t_Option_i32; f1'0: t_Option_bool }
  
  predicate resolve_Option_bool [@inline:trivial] (_1: t_Option_bool) = true
  
  meta "rewrite_def" predicate resolve_Option_bool
  
  predicate resolve_Option_i32 [@inline:trivial] (_1: t_Option_i32) = true
  
  meta "rewrite_def" predicate resolve_Option_i32
  
  let rec zip_i32 (self_: t_Option_i32) (other: t_Option_bool) (return (x: t_Option_tup2_i32_bool)) = any
    [ return (result: t_Option_tup2_i32_bool) -> {match { f0'0 = self_; f1'0 = other } with
        | {f0'0 = None} -> result = None'1 /\ resolve_Option_bool other
        | {f1'0 = None'0} -> result = None'1 /\ resolve_Option_i32 self_
        | {f0'0 = Some t; f1'0 = Some'0 u} -> result = Some'1 { f0 = t; f1 = u }
        end}
      (! return {result}) ]
  
  type tup2_Int_bool = { f0'1: int; f1'1: bool }
  
  type t_Option_tup2_Int_bool = None'2 | Some'2 tup2_Int_bool
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  predicate deep_model_bool [@inline:trivial] (self: bool) = self
  
  meta "rewrite_def" predicate deep_model_bool
  
  function deep_model_tup2_i32_bool [@inline:trivial] (self: tup2_i32_bool) : tup2_Int_bool =
    { f0'1 = deep_model_i32 self.f0; f1'1 = deep_model_bool self.f1 }
  
  meta "rewrite_def" function deep_model_tup2_i32_bool
  
  function deep_model_Option_tup2_i32_bool [@inline:trivial] (self: t_Option_tup2_i32_bool) : t_Option_tup2_Int_bool =
    match self with
      | Some'1 t -> Some'2 (deep_model_tup2_i32_bool t)
      | None'1 -> None'2
      end
  
  meta "rewrite_def" function deep_model_Option_tup2_i32_bool
  
  function deep_model_ref_Option_tup2_i32_bool [@inline:trivial] (self: t_Option_tup2_i32_bool) : t_Option_tup2_Int_bool
   = deep_model_Option_tup2_i32_bool self
  
  meta "rewrite_def" function deep_model_ref_Option_tup2_i32_bool
  
  let rec eq_Option_tup2_i32_bool (self_: t_Option_tup2_i32_bool) (rhs: t_Option_tup2_i32_bool) (return (x: bool)) = any
    [ return (result: bool) -> {result
      = (deep_model_ref_Option_tup2_i32_bool self_ = deep_model_ref_Option_tup2_i32_bool rhs)}
      (! return {result}) ]
  
  let rec unzip_i32 (self_: t_Option_tup2_i32_bool) (return (x: tup2_Option_i32_Option_bool)) = any
    [ return (result: tup2_Option_i32_Option_bool) -> {match self_ with
        | None'1 -> result = { f0'0 = None; f1'0 = None'0 }
        | Some'1 {f0 = t; f1 = u} -> result = { f0'0 = Some t; f1'0 = Some'0 u }
        end}
      (! return {result}) ]
  
  type t_Option_Int = None'3 | Some'3 int
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some t -> Some'3 (deep_model_i32 t)
      | None -> None'3
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  function deep_model_Option_bool [@inline:trivial] (self: t_Option_bool) : t_Option_bool = match self with
      | Some'0 t -> Some'0 (deep_model_bool t)
      | None'0 -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_bool
  
  function deep_model_ref_Option_bool [@inline:trivial] (self: t_Option_bool) : t_Option_bool =
    deep_model_Option_bool self
  
  meta "rewrite_def" function deep_model_ref_Option_bool
  
  let rec eq_Option_bool (self_: t_Option_bool) (rhs: t_Option_bool) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_bool self_ = deep_model_ref_Option_bool rhs)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec zip_unzip (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none_int <- None ] s1
      | s1 = [ &none_bool <- None'0 ] s2
      | s2 = [ &some_int <- Some (1: Int32.t) ] s3
      | s3 = [ &some_bool <- Some'0 true ] s4
      | s4 = zip_i32 {none_int} {none_bool} (fun (_x: t_Option_tup2_i32_bool) -> [ &_8 <- _x ] s5)
      | s5 = bb1 ]
    | bb1 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None'1 ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_tup2_i32_bool = Any.any_l () | & _1: t_Option_tup2_i32_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_tup2_i32_bool) -> [ &_80 <- _const ] s1 ]
      | s1 = eq_Option_tup2_i32_bool {_8} {_80} (fun (_x: bool) -> [ &_6 <- _x ] s2)
      | s2 = bb2 ]
    | bb2 = any [ br0 -> {_6 = false} (! bb4) | br1 -> {_6} (! bb3) ]
    | bb3 = s0
      [ s0 = zip_i32 {none_int} {some_bool} (fun (_x: t_Option_tup2_i32_bool) -> [ &_17 <- _x ] s1) | s1 = bb5 ]
    | bb5 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None'1 ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_tup2_i32_bool = Any.any_l () | & _1: t_Option_tup2_i32_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_tup2_i32_bool) -> [ &_79 <- _const ] s1 ]
      | s1 = eq_Option_tup2_i32_bool {_17} {_79} (fun (_x: bool) -> [ &_15 <- _x ] s2)
      | s2 = bb6 ]
    | bb6 = any [ br0 -> {_15 = false} (! bb8) | br1 -> {_15} (! bb7) ]
    | bb7 = s0
      [ s0 = zip_i32 {some_int} {none_bool} (fun (_x: t_Option_tup2_i32_bool) -> [ &_26 <- _x ] s1) | s1 = bb9 ]
    | bb9 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None'1 ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_tup2_i32_bool = Any.any_l () | & _1: t_Option_tup2_i32_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_tup2_i32_bool) -> [ &_78 <- _const ] s1 ]
      | s1 = eq_Option_tup2_i32_bool {_26} {_78} (fun (_x: bool) -> [ &_24 <- _x ] s2)
      | s2 = bb10 ]
    | bb10 = any [ br0 -> {_24 = false} (! bb12) | br1 -> {_24} (! bb11) ]
    | bb11 = s0
      [ s0 = zip_i32 {some_int} {some_bool} (fun (_x: t_Option_tup2_i32_bool) -> [ &_35 <- _x ] s1) | s1 = bb13 ]
    | bb13 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_2 <- { f0 = (1: Int32.t); f1 = true } ] s1'0
          | s1'0 = [ &_1 <- Some'1 _2 ] s2'0
          | s2'0 = [ &_ret'0 <- _1 ] s3
          | s3 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_tup2_i32_bool = Any.any_l ()
        | & _1: t_Option_tup2_i32_bool = Any.any_l ()
        | & _2: tup2_i32_bool = Any.any_l () ] [ _const_ret (_const: t_Option_tup2_i32_bool) -> [ &_77 <- _const ] s1 ]
      | s1 = eq_Option_tup2_i32_bool {_35} {_77} (fun (_x: bool) -> [ &_33 <- _x ] s2)
      | s2 = bb14 ]
    | bb14 = any [ br0 -> {_33 = false} (! bb16) | br1 -> {_33} (! bb15) ]
    | bb15 = s0
      [ s0 = [ &none_zipped <- None'1 ] s1
      | s1 = [ &_44 <- { f0 = (1: Int32.t); f1 = true } ] s2
      | s2 = [ &some_zipped <- Some'1 _44 ] s3
      | s3 = unzip_i32 {none_zipped} (fun (_x: tup2_Option_i32_Option_bool) -> [ &none_unzip <- _x ] s4)
      | s4 = bb17 ]
    | bb17 = s0
      [ s0 = unzip_i32 {some_zipped} (fun (_x: tup2_Option_i32_Option_bool) -> [ &some_unzip <- _x ] s1) | s1 = bb18 ]
    | bb18 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_76 <- _const ] s1 ]
      | s1 = eq_Option_i32 {none_unzip.f0'0} {_76} (fun (_x: bool) -> [ &_50 <- _x ] s2)
      | s2 = bb19 ]
    | bb19 = any [ br0 -> {_50 = false} (! bb21) | br1 -> {_50} (! bb20) ]
    | bb20 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None'0 ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_bool = Any.any_l () | & _1: t_Option_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_bool) -> [ &_75 <- _const ] s1 ]
      | s1 = eq_Option_bool {none_unzip.f1'0} {_75} (fun (_x: bool) -> [ &_56 <- _x ] s2)
      | s2 = bb22 ]
    | bb22 = any [ br0 -> {_56 = false} (! bb24) | br1 -> {_56} (! bb23) ]
    | bb23 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_74 <- _const ] s1 ]
      | s1 = eq_Option_i32 {some_unzip.f0'0} {_74} (fun (_x: bool) -> [ &_62 <- _x ] s2)
      | s2 = bb25 ]
    | bb25 = any [ br0 -> {_62 = false} (! bb27) | br1 -> {_62} (! bb26) ]
    | bb26 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some'0 true ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_bool = Any.any_l () | & _1: t_Option_bool = Any.any_l () ]
        [ _const_ret (_const: t_Option_bool) -> [ &_73 <- _const ] s1 ]
      | s1 = eq_Option_bool {some_unzip.f1'0} {_73} (fun (_x: bool) -> [ &_68 <- _x ] s2)
      | s2 = bb28 ]
    | bb28 = any [ br0 -> {_68 = false} (! bb30) | br1 -> {_68} (! bb29) ]
    | bb29 = return {_ret}
    | bb30 = {false} any
    | bb27 = {false} any
    | bb24 = {false} any
    | bb21 = {false} any
    | bb16 = {false} any
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none_int: t_Option_i32 = Any.any_l ()
    | & none_bool: t_Option_bool = Any.any_l ()
    | & some_int: t_Option_i32 = Any.any_l ()
    | & some_bool: t_Option_bool = Any.any_l ()
    | & _6: bool = Any.any_l ()
    | & _8: t_Option_tup2_i32_bool = Any.any_l ()
    | & _15: bool = Any.any_l ()
    | & _17: t_Option_tup2_i32_bool = Any.any_l ()
    | & _24: bool = Any.any_l ()
    | & _26: t_Option_tup2_i32_bool = Any.any_l ()
    | & _33: bool = Any.any_l ()
    | & _35: t_Option_tup2_i32_bool = Any.any_l ()
    | & none_zipped: t_Option_tup2_i32_bool = Any.any_l ()
    | & some_zipped: t_Option_tup2_i32_bool = Any.any_l ()
    | & _44: tup2_i32_bool = Any.any_l ()
    | & none_unzip: tup2_Option_i32_Option_bool = Any.any_l ()
    | & some_unzip: tup2_Option_i32_Option_bool = Any.any_l ()
    | & _50: bool = Any.any_l ()
    | & _56: bool = Any.any_l ()
    | & _62: bool = Any.any_l ()
    | & _68: bool = Any.any_l ()
    | & _73: t_Option_bool = Any.any_l ()
    | & _74: t_Option_i32 = Any.any_l ()
    | & _75: t_Option_bool = Any.any_l ()
    | & _76: t_Option_i32 = Any.any_l ()
    | & _77: t_Option_tup2_i32_bool = Any.any_l ()
    | & _78: t_Option_tup2_i32_bool = Any.any_l ()
    | & _79: t_Option_tup2_i32_bool = Any.any_l ()
    | & _80: t_Option_tup2_i32_bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_transpose
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Result_i32_bool = Ok Int32.t | Err bool
  
  type t_Option_Result_i32_bool = None | Some t_Result_i32_bool
  
  type t_Option_i32 = None'0 | Some'0 Int32.t
  
  type t_Result_Option_i32_bool = Ok'0 t_Option_i32 | Err'0 bool
  
  let rec transpose_i32 (self_: t_Option_Result_i32_bool) (return (x: t_Result_Option_i32_bool)) = any
    [ return (result: t_Result_Option_i32_bool) -> {match self_ with
        | None -> result = Ok'0 (None'0)
        | Some (Ok ok) -> result = Ok'0 (Some'0 ok)
        | Some (Err err) -> result = Err'0 err
        end}
      (! return {result}) ]
  
  let rec unwrap_Option_i32 (self_: t_Result_Option_i32_bool) (return (x: t_Option_i32)) =
    {[@expl:unwrap requires] exists t: t_Option_i32. self_ = Ok'0 t}
    any [ return (result: t_Option_i32) -> {Ok'0 result = self_} (! return {result}) ]
  
  type t_Option_Int = None'1 | Some'1 int
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  function deep_model_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = match self with
      | Some'0 t -> Some'1 (deep_model_i32 t)
      | None'0 -> None'1
      end
  
  meta "rewrite_def" function deep_model_Option_i32
  
  function deep_model_ref_Option_i32 [@inline:trivial] (self: t_Option_i32) : t_Option_Int = deep_model_Option_i32 self
  
  meta "rewrite_def" function deep_model_ref_Option_i32
  
  let rec eq_Option_i32 (self_: t_Option_i32) (rhs: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (deep_model_ref_Option_i32 self_ = deep_model_ref_Option_i32 rhs)}
      (! return {result}) ]
  
  let rec unwrap_err_Option_i32 (self_: t_Result_Option_i32_bool) (return (x: bool)) =
    {[@expl:unwrap_err requires] exists e: bool. self_ = Err'0 e}
    any [ return (result: bool) -> {Err'0 result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec transpose (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &none <- None ] s1
      | s1 = [ &_3 <- Ok (1: Int32.t) ] s2
      | s2 = [ &some_ok <- Some _3 ] s3
      | s3 = [ &_5 <- Err true ] s4
      | s4 = [ &some_err <- Some _5 ] s5
      | s5 = transpose_i32 {none} (fun (_x: t_Result_Option_i32_bool) -> [ &_10 <- _x ] s6)
      | s6 = bb1 ]
    | bb1 = s0 [ s0 = unwrap_Option_i32 {_10} (fun (_x: t_Option_i32) -> [ &_9 <- _x ] s1) | s1 = bb2 ]
    | bb2 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0 [ s0'0 = [ &_1 <- None'0 ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_31 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_9} {_31} (fun (_x: bool) -> [ &_7 <- _x ] s2)
      | s2 = bb3 ]
    | bb3 = any [ br0 -> {_7 = false} (! bb5) | br1 -> {_7} (! bb4) ]
    | bb4 = s0 [ s0 = transpose_i32 {some_ok} (fun (_x: t_Result_Option_i32_bool) -> [ &_19 <- _x ] s1) | s1 = bb6 ]
    | bb6 = s0 [ s0 = unwrap_Option_i32 {_19} (fun (_x: t_Option_i32) -> [ &_18 <- _x ] s1) | s1 = bb7 ]
    | bb7 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = [ &_1 <- Some'0 (1: Int32.t) ] s1'0 | s1'0 = [ &_ret'0 <- _1 ] s2'0 | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: t_Option_i32 = Any.any_l () | & _1: t_Option_i32 = Any.any_l () ]
        [ _const_ret (_const: t_Option_i32) -> [ &_30 <- _const ] s1 ]
      | s1 = eq_Option_i32 {_18} {_30} (fun (_x: bool) -> [ &_16 <- _x ] s2)
      | s2 = bb8 ]
    | bb8 = any [ br0 -> {_16 = false} (! bb10) | br1 -> {_16} (! bb9) ]
    | bb9 = s0 [ s0 = transpose_i32 {some_err} (fun (_x: t_Result_Option_i32_bool) -> [ &_27 <- _x ] s1) | s1 = bb11 ]
    | bb11 = s0 [ s0 = unwrap_err_Option_i32 {_27} (fun (_x: bool) -> [ &_26 <- _x ] s1) | s1 = bb12 ]
    | bb12 = s0 [ s0 = [ &_25 <- _26 ] s1 | s1 = any [ br0 -> {_25 = false} (! bb14) | br1 -> {_25} (! bb13) ] ]
    | bb13 = return {_ret}
    | bb14 = {false} any
    | bb10 = {false} any
    | bb5 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & none: t_Option_Result_i32_bool = Any.any_l ()
    | & some_ok: t_Option_Result_i32_bool = Any.any_l ()
    | & _3: t_Result_i32_bool = Any.any_l ()
    | & some_err: t_Option_Result_i32_bool = Any.any_l ()
    | & _5: t_Result_i32_bool = Any.any_l ()
    | & _7: bool = Any.any_l ()
    | & _9: t_Option_i32 = Any.any_l ()
    | & _10: t_Result_Option_i32_bool = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: t_Option_i32 = Any.any_l ()
    | & _19: t_Result_Option_i32_bool = Any.any_l ()
    | & _25: bool = Any.any_l ()
    | & _26: bool = Any.any_l ()
    | & _27: t_Result_Option_i32_bool = Any.any_l ()
    | & _30: t_Option_i32 = Any.any_l ()
    | & _31: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_flatten
  use creusot.int.Int32
  use creusot.prelude.Any
  
  type t_Option_i32 = None | Some Int32.t
  
  type t_Option_Option_i32 = None'0 | Some'0 t_Option_i32
  
  let rec flatten_i32 (self_: t_Option_Option_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {self_ = None'0 -> result = None}
      {self_ = None'0 \/ self_ = Some'0 result}
      (! return {result}) ]
  
  let rec is_none_i32 (self_: t_Option_i32) (return (x: bool)) = any
    [ return (result: bool) -> {result = (self_ = None)} (! return {result}) ]
  
  let rec unwrap_i32 (self_: t_Option_i32) (return (x: Int32.t)) = {[@expl:unwrap requires] self_ <> None}
    any [ return (result: Int32.t) -> {Some result = self_} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec flatten (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &opt <- None'0 ] s1 | s1 = flatten_i32 {opt} (fun (_x: t_Option_i32) -> [ &_5 <- _x ] s2) | s2 = bb1 ]
    | bb1 = s0 [ s0 = is_none_i32 {_5} (fun (_x: bool) -> [ &_3 <- _x ] s1) | s1 = bb2 ]
    | bb2 = any [ br0 -> {_3 = false} (! bb4) | br1 -> {_3} (! bb3) ]
    | bb3 = s0
      [ s0 = [ &_9 <- None ] s1
      | s1 = [ &opt'0 <- Some'0 _9 ] s2
      | s2 = flatten_i32 {opt'0} (fun (_x: t_Option_i32) -> [ &_13 <- _x ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = is_none_i32 {_13} (fun (_x: bool) -> [ &_11 <- _x ] s1) | s1 = bb6 ]
    | bb6 = any [ br0 -> {_11 = false} (! bb8) | br1 -> {_11} (! bb7) ]
    | bb7 = s0
      [ s0 = [ &_17 <- Some (1: Int32.t) ] s1
      | s1 = [ &opt'1 <- Some'0 _17 ] s2
      | s2 = flatten_i32 {opt'1} (fun (_x: t_Option_i32) -> [ &_21 <- _x ] s3)
      | s3 = bb9 ]
    | bb9 = s0 [ s0 = unwrap_i32 {_21} (fun (_x: Int32.t) -> [ &_20 <- _x ] s1) | s1 = bb10 ]
    | bb10 = s0
      [ s0 = [ &_19 <- _20 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_19 = false} (! bb12) | br1 -> {_19} (! bb11) ] ]
    | bb11 = return {_ret}
    | bb12 = {false} any
    | bb8 = {false} any
    | bb4 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & opt: t_Option_Option_i32 = Any.any_l ()
    | & _3: bool = Any.any_l ()
    | & _5: t_Option_i32 = Any.any_l ()
    | & opt'0: t_Option_Option_i32 = Any.any_l ()
    | & _9: t_Option_i32 = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: t_Option_i32 = Any.any_l ()
    | & opt'1: t_Option_Option_i32 = Any.any_l ()
    | & _17: t_Option_i32 = Any.any_l ()
    | & _19: bool = Any.any_l ()
    | & _20: Int32.t = Any.any_l ()
    | & _21: t_Option_i32 = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_resolve
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Option_ref_i32 = None | Some (MutBorrow.t Int32.t)
  
  predicate resolve_ref_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_i32
  
  let rec closure1 [@coma:extspec] (self: ()) (_0: MutBorrow.t Int32.t) (return (x: bool)) = bb0
    [ bb0 = s0 [ s0 = -{resolve_ref_i32 _0}- s1 | s1 = [ &_ret <- true ] s2 | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & _0: MutBorrow.t Int32.t = _0 ]
  
  meta "rewrite_def" predicate closure1'pre
  
  meta "rewrite_def" predicate closure1'post'return
  
  predicate precondition_closure1 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) =
    let _0 = args in closure1'pre self _0
  
  meta "rewrite_def" predicate precondition_closure1
  
  predicate postcondition_once_closure1 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    let _0 = args in closure1'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure1
  
  let rec is_some_and_ref_i32 (self_: t_Option_ref_i32) (f: ()) (return (x: bool)) =
    {[@expl:is_some_and requires] match self_ with
      | None -> true
      | Some t -> precondition_closure1 f t
      end}
    any
    [ return (result: bool) -> {match self_ with
        | None -> result = false
        | Some t -> postcondition_once_closure1 f t result
        end}
      (! return {result}) ]
  
  type t_Option_i32 = None'0 | Some'0 Int32.t
  
  predicate resolve_Option_i32 [@inline:trivial] (_1: t_Option_i32) = true
  
  meta "rewrite_def" predicate resolve_Option_i32
  
  predicate resolve_Option_ref_i32 (_1: t_Option_ref_i32)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_ref_i32 [resolve_Option_ref_i32 x]. resolve_Option_ref_i32 x
      = match x with
        | None -> true
        | Some x0 -> resolve_ref_i32 x0
        end
  
  let rec and_ref_i32 (self_: t_Option_ref_i32) (optb: t_Option_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {self_ = None -> result = None'0 /\ resolve_Option_i32 optb}
      {self_ = None \/ result = optb /\ resolve_Option_ref_i32 self_}
      (! return {result}) ]
  
  let rec or_ref_i32 (self_: t_Option_ref_i32) (optb: t_Option_ref_i32) (return (x: t_Option_ref_i32)) = any
    [ return (result: t_Option_ref_i32) -> {self_ = None -> result = optb}
      {self_ = None \/ result = self_ /\ resolve_Option_ref_i32 optb}
      (! return {result}) ]
  
  let rec closure0 [@coma:extspec] (self: ()) (_0: MutBorrow.t Int32.t) (return (x: bool)) = bb0
    [ bb0 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ] ] [ & _ret: bool = Any.any_l () ]
  
  meta "rewrite_def" predicate closure0'pre
  
  meta "rewrite_def" predicate closure0'post'return
  
  predicate precondition_closure0 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) =
    let _0 = args in closure0'pre self _0
  
  meta "rewrite_def" predicate precondition_closure0
  
  predicate postcondition_once_closure0 [@inline:trivial] (self: ()) (args: MutBorrow.t Int32.t) (result: bool) =
    let _0 = args in closure0'post'return self _0 result
  
  meta "rewrite_def" predicate postcondition_once_closure0
  
  let rec filter_ref_i32 (self_: t_Option_ref_i32) (predicate': ()) (return (x: t_Option_ref_i32)) =
    {[@expl:filter requires] match self_ with
      | None -> true
      | Some t -> precondition_closure0 predicate' t
      end}
    any
    [ return (result: t_Option_ref_i32) -> {match self_ with
        | None -> result = None
        | Some t -> match result with
          | None -> postcondition_once_closure0 predicate' t false /\ resolve_ref_i32 t
          | Some r -> postcondition_once_closure0 predicate' t true /\ r = t
          end
        end}
      (! return {result}) ]
  
  type tup2_Option_ref_i32_Option_ref_i32 = { f0: t_Option_ref_i32; f1: t_Option_ref_i32 }
  
  let rec xor_ref_i32 (self_: t_Option_ref_i32) (optb: t_Option_ref_i32) (return (x: t_Option_ref_i32)) = any
    [ return (result: t_Option_ref_i32) -> {match { f0 = self_; f1 = optb } with
        | {f0 = None; f1 = None} -> result = None
        | {f0 = Some t1; f1 = Some t2} -> result = None /\ resolve_ref_i32 t1 /\ resolve_ref_i32 t2
        | {f0 = Some t; f1 = None} -> result = Some t
        | {f0 = None; f1 = Some t} -> result = Some t
        end}
      (! return {result}) ]
  
  let rec insert_ref_i32 (self_: MutBorrow.t t_Option_ref_i32) (value: MutBorrow.t Int32.t)
    (return (x: MutBorrow.t (MutBorrow.t Int32.t))) = any
    [ return (result: MutBorrow.t (MutBorrow.t Int32.t)) -> {match self_.current with
        | Some t -> resolve_ref_i32 t
        | None -> true
        end}
      {result.current = value /\ self_.final = Some (result.final)}
      (! return {result}) ]
  
  predicate resolve_ref_ref_i32 [@inline:trivial] (_1: MutBorrow.t (MutBorrow.t Int32.t)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_ref_i32
  
  let rec get_or_insert_ref_i32 (self_: MutBorrow.t t_Option_ref_i32) (value: MutBorrow.t Int32.t)
    (return (x: MutBorrow.t (MutBorrow.t Int32.t))) = any
    [ return (result: MutBorrow.t (MutBorrow.t Int32.t)) -> {match self_.current with
        | None -> result.current = value /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final) /\ resolve_ref_i32 value
        end}
      (! return {result}) ]
  
  type tup2_ref_i32_i32 = { f0'0: MutBorrow.t Int32.t; f1'0: Int32.t }
  
  type t_Option_tup2_ref_i32_i32 = None'1 | Some'1 tup2_ref_i32_i32
  
  type tup2_Option_ref_i32_Option_i32 = { f0'1: t_Option_ref_i32; f1'1: t_Option_i32 }
  
  let rec zip_ref_i32 (self_: t_Option_ref_i32) (other: t_Option_i32) (return (x: t_Option_tup2_ref_i32_i32)) = any
    [ return (result: t_Option_tup2_ref_i32_i32) -> {match { f0'1 = self_; f1'1 = other } with
        | {f0'1 = None} -> result = None'1 /\ resolve_Option_i32 other
        | {f1'1 = None'0} -> result = None'1 /\ resolve_Option_ref_i32 self_
        | {f0'1 = Some t; f1'1 = Some'0 u} -> result = Some'1 { f0'0 = t; f1'0 = u }
        end}
      (! return {result}) ]
  
  predicate resolve_tup2_ref_i32_i32 [@inline:trivial] (_1: tup2_ref_i32_i32) = resolve_ref_i32 _1.f0'0
  
  meta "rewrite_def" predicate resolve_tup2_ref_i32_i32
  
  predicate resolve_Option_tup2_ref_i32_i32 (_1: t_Option_tup2_ref_i32_i32)
  
  axiom resolve_axiom'0 [@rewrite]:
    forall x: t_Option_tup2_ref_i32_i32 [resolve_Option_tup2_ref_i32_i32 x]. resolve_Option_tup2_ref_i32_i32 x
      = match x with
        | None'1 -> true
        | Some'1 x0 -> resolve_tup2_ref_i32_i32 x0
        end
  
  let rec copied_i32 (self_: t_Option_ref_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {match self_ with
        | None -> result = None'0
        | Some s -> result = Some'0 (s.current) /\ s.final = s.current
        end}
      (! return {result}) ]
  
  predicate postcondition_once_clone [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once_clone
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone [@inline:trivial] (self: ()) (args: Int32.t) (result_state: ()) (result: Int32.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut_clone
  
  function fn_mut_once_clone (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: Int32.t, res: Int32.t. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone [@inline:trivial] (self: ()) (args: Int32.t) (result: Int32.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_clone
  
  function fn_once_clone (self: ()) (args: Int32.t) (res: Int32.t) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: Int32.t, res: Int32.t. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: Int32.t) (res_state: ()) (res: Int32.t) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: Int32.t, res_state: (), res: Int32.t. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  let rec clone_i32 (self_: Int32.t) (return (x: Int32.t)) = any
    [ return (result: Int32.t) -> {result = self_} (! return {result}) ]
  
  let rec cloned_i32 (self_: t_Option_ref_i32) (return (x: t_Option_i32)) = any
    [ return (result: t_Option_i32) -> {match { f0'1 = self_; f1'1 = result } with
        | {f0'1 = None; f1'1 = None'0} -> true
        | {f0'1 = Some s; f1'1 = Some'0 r} -> postcondition_clone () s.current r /\ s.final = s.current
        | _ -> false
        end}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec resolve (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_3 <- _bor ] [ &x <- _bor.final ] s2)
      | s2 = [ &opt <- Some _3 ] s3
      | s3 = [ &_7 <- () ] s4
      | s4 = is_some_and_ref_i32 {opt} {_7} (fun (_x: bool) -> [ &_5 <- _x ] s5)
      | s5 = bb1 ]
    | bb1 = any [ br0 -> {_5 = false} (! bb3) | br1 -> {_5} (! bb2) ]
    | bb2 = s0
      [ s0 = [ &_10 <- x = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_10 = false} (! bb5) | br1 -> {_10} (! bb4) ] ]
    | bb4 = s0
      [ s0 = [ &x'0 <- (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'0}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_15 <- _bor ] [ &x'0 <- _bor.final ] s2)
      | s2 = [ &opt'0 <- Some _15 ] s3
      | s3 = [ &_18 <- Some'0 (2: Int32.t) ] s4
      | s4 = and_ref_i32 {opt'0} {_18} (fun (_x: t_Option_i32) -> [ &_16 <- _x ] s5)
      | s5 = bb6 ]
    | bb6 = s0
      [ s0 = [ &_20 <- x'0 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_20 = false} (! bb8) | br1 -> {_20} (! bb7) ] ]
    | bb7 = s0
      [ s0 = [ &x'1 <- (1: Int32.t) ] s1
      | s1 = [ &y <- (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'1}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_26 <- _bor ] [ &x'1 <- _bor.final ] s3)
      | s3 = [ &opt'1 <- Some _26 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_29 <- _bor ] [ &y <- _bor.final ] s5)
      | s5 = [ &_28 <- Some _29 ] s6
      | s6 = or_ref_i32 {_28} {opt'1} (fun (_x: t_Option_ref_i32) -> [ &_27 <- _x ] s7)
      | s7 = bb9 ]
    | bb9 = s0
      [ s0 = -{resolve_Option_ref_i32 _27}- s1
      | s1 = [ &_32 <- x'1 = (1: Int32.t) ] s2
      | s2 = any [ br0 -> {_32 = false} (! bb14) | br1 -> {_32} (! bb10) ] ]
    | bb10 = s0
      [ s0 = [ &_34 <- y = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_34 = false} (! bb14) | br1 -> {_34} (! bb11) ] ]
    | bb11 = s0
      [ s0 = [ &x'2 <- (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'2}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_39 <- _bor ] [ &x'2 <- _bor.final ] s2)
      | s2 = [ &opt'2 <- Some _39 ] s3
      | s3 = [ &_42 <- () ] s4
      | s4 = filter_ref_i32 {opt'2} {_42} (fun (_x: t_Option_ref_i32) -> [ &_40 <- _x ] s5)
      | s5 = bb15 ]
    | bb15 = s0
      [ s0 = -{resolve_Option_ref_i32 _40}- s1
      | s1 = [ &_44 <- x'2 = (1: Int32.t) ] s2
      | s2 = any [ br0 -> {_44 = false} (! bb17) | br1 -> {_44} (! bb16) ] ]
    | bb16 = s0
      [ s0 = [ &x'3 <- (1: Int32.t) ] s1
      | s1 = [ &y'0 <- (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'3}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_50 <- _bor ] [ &x'3 <- _bor.final ] s3)
      | s3 = [ &optx <- Some _50 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y'0}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_52 <- _bor ] [ &y'0 <- _bor.final ] s5)
      | s5 = [ &opty <- Some _52 ] s6
      | s6 = xor_ref_i32 {optx} {opty} (fun (_x: t_Option_ref_i32) -> [ &_53 <- _x ] s7)
      | s7 = bb18 ]
    | bb18 = s0
      [ s0 = -{resolve_Option_ref_i32 _53}- s1
      | s1 = [ &_57 <- x'3 = (1: Int32.t) ] s2
      | s2 = any [ br0 -> {_57 = false} (! bb23) | br1 -> {_57} (! bb19) ] ]
    | bb19 = s0
      [ s0 = [ &_59 <- y'0 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_59 = false} (! bb23) | br1 -> {_59} (! bb20) ] ]
    | bb20 = s0
      [ s0 = [ &x'4 <- (1: Int32.t) ] s1
      | s1 = [ &y'1 <- (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'4}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_65 <- _bor ] [ &x'4 <- _bor.final ] s3)
      | s3 = [ &opt'3 <- Some _65 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y'1}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_69 <- _bor ] [ &y'1 <- _bor.final ] s5)
      | s5 = MutBorrow.borrow_mut <t_Option_ref_i32> {opt'3}
          (fun (_bor: MutBorrow.t t_Option_ref_i32) -> [ &_67 <- _bor ] [ &opt'3 <- _bor.final ] s6)
      | s6 = MutBorrow.borrow_final <Int32.t> {_69.current} {MutBorrow.get_id _69}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_68 <- _bor ] [ &_69 <- { _69 with current = _bor.final } ] s7)
      | s7 = insert_ref_i32 {_67} {_68} (fun (_x: MutBorrow.t (MutBorrow.t Int32.t)) -> [ &bor <- _x ] s8)
      | s8 = bb24 ]
    | bb24 = s0
      [ s0 = -{resolve_ref_i32 _69}- s1
      | s1 = [ &bor <- { bor with current = { bor.current with current = (3: Int32.t) } } ] s2
      | s2 = -{resolve_ref_ref_i32 bor}- s3
      | s3 = -{resolve_Option_ref_i32 opt'3}- s4
      | s4 = [ &_71 <- x'4 = (1: Int32.t) ] s5
      | s5 = any [ br0 -> {_71 = false} (! bb29) | br1 -> {_71} (! bb25) ] ]
    | bb25 = s0
      [ s0 = [ &_73 <- y'1 = (3: Int32.t) ] s1 | s1 = any [ br0 -> {_73 = false} (! bb29) | br1 -> {_73} (! bb26) ] ]
    | bb26 = s0
      [ s0 = [ &x'5 <- (1: Int32.t) ] s1
      | s1 = [ &y'2 <- (2: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x'5}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_79 <- _bor ] [ &x'5 <- _bor.final ] s3)
      | s3 = [ &opt'4 <- Some _79 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y'2}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_83 <- _bor ] [ &y'2 <- _bor.final ] s5)
      | s5 = MutBorrow.borrow_mut <t_Option_ref_i32> {opt'4}
          (fun (_bor: MutBorrow.t t_Option_ref_i32) -> [ &_81 <- _bor ] [ &opt'4 <- _bor.final ] s6)
      | s6 = MutBorrow.borrow_final <Int32.t> {_83.current} {MutBorrow.get_id _83}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_82 <- _bor ] [ &_83 <- { _83 with current = _bor.final } ] s7)
      | s7 = get_or_insert_ref_i32 {_81} {_82} (fun (_x: MutBorrow.t (MutBorrow.t Int32.t)) -> [ &bor'0 <- _x ] s8)
      | s8 = bb30 ]
    | bb30 = s0
      [ s0 = -{resolve_ref_i32 _83}- s1
      | s1 = [ &bor'0 <- { bor'0 with current = { bor'0.current with current = (3: Int32.t) } } ] s2
      | s2 = -{resolve_ref_ref_i32 bor'0}- s3
      | s3 = -{resolve_Option_ref_i32 opt'4}- s4
      | s4 = [ &_85 <- x'5 = (3: Int32.t) ] s5
      | s5 = any [ br0 -> {_85 = false} (! bb35) | br1 -> {_85} (! bb31) ] ]
    | bb31 = s0
      [ s0 = [ &_87 <- y'2 = (2: Int32.t) ] s1 | s1 = any [ br0 -> {_87 = false} (! bb35) | br1 -> {_87} (! bb32) ] ]
    | bb32 = s0
      [ s0 = [ &x'6 <- (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'6}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_92 <- _bor ] [ &x'6 <- _bor.final ] s2)
      | s2 = [ &opt'5 <- Some _92 ] s3
      | s3 = [ &_95 <- None'0 ] s4
      | s4 = zip_ref_i32 {opt'5} {_95} (fun (_x: t_Option_tup2_ref_i32_i32) -> [ &_93 <- _x ] s5)
      | s5 = bb36 ]
    | bb36 = s0
      [ s0 = -{resolve_Option_tup2_ref_i32_i32 _93}- s1
      | s1 = [ &_97 <- x'6 = (1: Int32.t) ] s2
      | s2 = any [ br0 -> {_97 = false} (! bb38) | br1 -> {_97} (! bb37) ] ]
    | bb37 = s0
      [ s0 = [ &x'7 <- (1: Int32.t) ] s1
      | s1 = MutBorrow.borrow_mut <Int32.t> {x'7}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_102 <- _bor ] [ &x'7 <- _bor.final ] s2)
      | s2 = [ &opt'6 <- Some _102 ] s3
      | s3 = copied_i32 {opt'6} (fun (_x: t_Option_i32) -> [ &_103 <- _x ] s4)
      | s4 = bb39 ]
    | bb39 = s0
      [ s0 = [ &_106 <- x'7 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_106 = false} (! bb41) | br1 -> {_106} (! bb40) ] ]
    | bb40 = s0
      [ s0 = MutBorrow.borrow_mut <Int32.t> {x'7}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_110 <- _bor ] [ &x'7 <- _bor.final ] s1)
      | s1 = [ &opt'7 <- Some _110 ] s2
      | s2 = cloned_i32 {opt'7} (fun (_x: t_Option_i32) -> [ &_111 <- _x ] s3)
      | s3 = bb42 ]
    | bb42 = s0
      [ s0 = [ &_114 <- x'7 = (1: Int32.t) ] s1 | s1 = any [ br0 -> {_114 = false} (! bb44) | br1 -> {_114} (! bb43) ] ]
    | bb43 = return {_ret}
    | bb44 = {false} any
    | bb41 = {false} any
    | bb38 = {false} any
    | bb35 = {false} any
    | bb29 = {false} any
    | bb23 = {false} any
    | bb17 = {false} any
    | bb14 = {false} any
    | bb8 = {false} any
    | bb5 = {false} any
    | bb3 = {false} any ]
    [ & _ret: () = Any.any_l ()
    | & x: Int32.t = Any.any_l ()
    | & opt: t_Option_ref_i32 = Any.any_l ()
    | & _3: MutBorrow.t Int32.t = Any.any_l ()
    | & _5: bool = Any.any_l ()
    | & _7: () = Any.any_l ()
    | & _10: bool = Any.any_l ()
    | & x'0: Int32.t = Any.any_l ()
    | & opt'0: t_Option_ref_i32 = Any.any_l ()
    | & _15: MutBorrow.t Int32.t = Any.any_l ()
    | & _16: t_Option_i32 = Any.any_l ()
    | & _18: t_Option_i32 = Any.any_l ()
    | & _20: bool = Any.any_l ()
    | & x'1: Int32.t = Any.any_l ()
    | & y: Int32.t = Any.any_l ()
    | & opt'1: t_Option_ref_i32 = Any.any_l ()
    | & _26: MutBorrow.t Int32.t = Any.any_l ()
    | & _27: t_Option_ref_i32 = Any.any_l ()
    | & _28: t_Option_ref_i32 = Any.any_l ()
    | & _29: MutBorrow.t Int32.t = Any.any_l ()
    | & _32: bool = Any.any_l ()
    | & _34: bool = Any.any_l ()
    | & x'2: Int32.t = Any.any_l ()
    | & opt'2: t_Option_ref_i32 = Any.any_l ()
    | & _39: MutBorrow.t Int32.t = Any.any_l ()
    | & _40: t_Option_ref_i32 = Any.any_l ()
    | & _42: () = Any.any_l ()
    | & _44: bool = Any.any_l ()
    | & x'3: Int32.t = Any.any_l ()
    | & y'0: Int32.t = Any.any_l ()
    | & optx: t_Option_ref_i32 = Any.any_l ()
    | & _50: MutBorrow.t Int32.t = Any.any_l ()
    | & opty: t_Option_ref_i32 = Any.any_l ()
    | & _52: MutBorrow.t Int32.t = Any.any_l ()
    | & _53: t_Option_ref_i32 = Any.any_l ()
    | & _57: bool = Any.any_l ()
    | & _59: bool = Any.any_l ()
    | & x'4: Int32.t = Any.any_l ()
    | & y'1: Int32.t = Any.any_l ()
    | & opt'3: t_Option_ref_i32 = Any.any_l ()
    | & _65: MutBorrow.t Int32.t = Any.any_l ()
    | & bor: MutBorrow.t (MutBorrow.t Int32.t) = Any.any_l ()
    | & _67: MutBorrow.t t_Option_ref_i32 = Any.any_l ()
    | & _68: MutBorrow.t Int32.t = Any.any_l ()
    | & _69: MutBorrow.t Int32.t = Any.any_l ()
    | & _71: bool = Any.any_l ()
    | & _73: bool = Any.any_l ()
    | & x'5: Int32.t = Any.any_l ()
    | & y'2: Int32.t = Any.any_l ()
    | & opt'4: t_Option_ref_i32 = Any.any_l ()
    | & _79: MutBorrow.t Int32.t = Any.any_l ()
    | & bor'0: MutBorrow.t (MutBorrow.t Int32.t) = Any.any_l ()
    | & _81: MutBorrow.t t_Option_ref_i32 = Any.any_l ()
    | & _82: MutBorrow.t Int32.t = Any.any_l ()
    | & _83: MutBorrow.t Int32.t = Any.any_l ()
    | & _85: bool = Any.any_l ()
    | & _87: bool = Any.any_l ()
    | & x'6: Int32.t = Any.any_l ()
    | & opt'5: t_Option_ref_i32 = Any.any_l ()
    | & _92: MutBorrow.t Int32.t = Any.any_l ()
    | & _93: t_Option_tup2_ref_i32_i32 = Any.any_l ()
    | & _95: t_Option_i32 = Any.any_l ()
    | & _97: bool = Any.any_l ()
    | & x'7: Int32.t = Any.any_l ()
    | & opt'6: t_Option_ref_i32 = Any.any_l ()
    | & _102: MutBorrow.t Int32.t = Any.any_l ()
    | & _103: t_Option_i32 = Any.any_l ()
    | & _106: bool = Any.any_l ()
    | & opt'7: t_Option_ref_i32 = Any.any_l ()
    | & _110: MutBorrow.t Int32.t = Any.any_l ()
    | & _111: t_Option_i32 = Any.any_l ()
    | & _114: bool = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
