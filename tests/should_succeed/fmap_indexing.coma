module M_fmap_indexing__foo [#"fmap_indexing.rs" 4 0 4 12]
  let%span sfmap_indexing = "fmap_indexing.rs" 5 18 5 42
  let%span sfmap_indexing'0 = "fmap_indexing.rs" 6 10 6 37
  let%span sfmap_indexing'1 = "fmap_indexing.rs" 7 18 7 29
  let%span sfmap_indexing'2 = "fmap_indexing.rs" 8 10 8 38
  let%span sfmap_indexing'3 = "fmap_indexing.rs" 9 18 9 45
  let%span sfmap_indexing'4 = "fmap_indexing.rs" 10 10 10 37
  let%span sfmap_indexing'5 = "fmap_indexing.rs" 11 18 11 45
  let%span sfmap = "../../creusot-contracts/src/logic/fmap.rs" 41 14 41 31
  let%span sfmap'0 = "../../creusot-contracts/src/logic/fmap.rs" 42 14 42 49
  let%span sfmap'1 = "../../creusot-contracts/src/logic/fmap.rs" 68 14 68 71
  let%span sfmap'2 = "../../creusot-contracts/src/logic/fmap.rs" 69 14 69 61
  let%span sfmap'3 = "../../creusot-contracts/src/logic/fmap.rs" 70 14 70 66
  let%span sfmap'4 = "../../creusot-contracts/src/logic/fmap.rs" 300 8 300 24
  let%span sfmap'5 = "../../creusot-contracts/src/logic/fmap.rs" 50 14 50 25
  let%span sfmap'6 = "../../creusot-contracts/src/logic/fmap.rs" 60 14 60 86
  let%span sfmap'7 = "../../creusot-contracts/src/logic/fmap.rs" 134 8 134 35
  let%span sfmap'8 = "../../creusot-contracts/src/logic/fmap.rs" 118 8 118 31
  let%span sfmap'9 = "../../creusot-contracts/src/logic/fmap.rs" 105 8 105 26
  let%span sfmap'10 = "../../creusot-contracts/src/logic/fmap.rs" 126 8 126 42
  let%span sutil = "../../creusot-contracts/src/util.rs" 21 14 21 30
  let%span sutil'0 = "../../creusot-contracts/src/util.rs" 33 11 33 28
  let%span sutil'1 = "../../creusot-contracts/src/util.rs" 34 0 34 21
  let%span soption = "../../creusot-contracts/src/std/option.rs" 751 8 754 9
  let%span smapping = "../../creusot-contracts/src/logic/mapping.rs" 60 8 60 19
  
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap
  
  function len (self: t_FMap) : int
  
  axiom len_spec: forall self: t_FMap. [%#sfmap'5] len self >= 0
  
  type t_Option  =
    | C_None
    | C_Some int
  
  function view (self: t_FMap) : Map.map int t_Option
  
  axiom view_spec: forall self: t_FMap. [%#sfmap'6] forall m1: t_FMap, m2: t_FMap. m1 <> m2  -> view m1 <> view m2
  
  constant empty  : t_FMap
  
  axiom empty_spec: ([%#sfmap] len empty = 0) && ([%#sfmap'0] view empty = Const.const (C_None))
  
  function make_sized (self: int) : int
  
  axiom make_sized_spec: forall self: int. [%#sutil] make_sized self = self
  
  function get_unsized [@inline:trivial] (self: t_FMap) (k: int) : t_Option =
    [%#sfmap'9] Map.get (view self) k
  
  function contains [@inline:trivial] (self: t_FMap) (k: int) : bool =
    [%#sfmap'7] get_unsized self k <> C_None
  
  function insert (self: t_FMap) (k: int) (v: int) : t_FMap
  
  axiom insert_spec: forall self: t_FMap, k: int, v: int. ([%#sfmap'1] view (insert self k v)
  = Map.set (view self) k (C_Some (make_sized v)))
  && ([%#sfmap'2] contains self k  -> len (insert self k v) = len self)
  && ([%#sfmap'3] not contains self k  -> len (insert self k v) = len self + 1)
  
  function index_logic (self: Map.map int bool) (a: int) : bool =
    [%#smapping] Map.get self a
  
  function such_that (p: Map.map int bool) : int
  
  axiom such_that_spec: forall p: Map.map int bool. ([%#sutil'0] exists x: int. index_logic p x)
   -> ([%#sutil'1] index_logic p (such_that p))
  
  function unwrap_logic (self: t_Option) : int =
    [%#soption] match self with
      | C_Some x -> x
      | C_None -> such_that (fun (__0: int) -> true)
      end
  
  function lookup_unsized [@inline:trivial] (self: t_FMap) (k: int) : int =
    [%#sfmap'10] unwrap_logic (get_unsized self k)
  
  function lookup [@inline:trivial] (self: t_FMap) (k: int) : int =
    [%#sfmap'8] lookup_unsized self k
  
  function index_logic'0 [@inline:trivial] (self: t_FMap) (key: int) : int =
    [%#sfmap'4] lookup self key
  
  meta "compute_max_steps" 1000000
  
  let rec foo[#"fmap_indexing.rs" 4 0 4 12] (return'  (x:()))= (! bb0
    [ bb0 = s0 [ s0 =  [ &map <- [%#sfmap_indexing] empty ] s1 | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_3 <- [%#sfmap_indexing'0] insert map 1 3 ] s1 | s1 = bb2 ] 
    | bb2 = s0
      [ s0 =  [ &map <- _3 ] s1
      | s1 = {[@expl:assertion] [%#sfmap_indexing'1] index_logic'0 map 1 = 3} s2
      | s2 =  [ &_7 <- [%#sfmap_indexing'2] insert map 2 42 ] s3
      | s3 = bb3 ]
    
    | bb3 = s0
      [ s0 =  [ &map <- _7 ] s1
      | s1 = {[@expl:assertion] [%#sfmap_indexing'3] index_logic'0 map 1 = 3 /\ index_logic'0 map 2 = 42} s2
      | s2 =  [ &_11 <- [%#sfmap_indexing'4] insert map 1 4 ] s3
      | s3 = bb4 ]
    
    | bb4 = s0
      [ s0 =  [ &map <- _11 ] s1
      | s1 = {[@expl:assertion] [%#sfmap_indexing'5] index_logic'0 map 1 = 4 /\ index_logic'0 map 2 = 42} s2
      | s2 = return''0 {_0} ]
     ]
    )
    [ & _0: () = Any.any_l ()
    | & map: t_FMap = Any.any_l ()
    | & _3: t_FMap = Any.any_l ()
    | & _7: t_FMap = Any.any_l ()
    | & _11: t_FMap = Any.any_l () ]
     [ return''0 (result:())-> (! return' {result}) ] 
end
