module M_foo
  use mach.int.Int
  use map.Map
  use map.Const
  use creusot.prelude.Any
  
  type t_FMap_Int_Int
  
  function len_Int (self: t_FMap_Int_Int) : int
  
  axiom len_Int_spec: forall self: t_FMap_Int_Int. len_Int self >= 0
  
  type t_Option_Int = None | Some int
  
  function view_FMap_Int_Int (self: t_FMap_Int_Int) : Map.map int t_Option_Int
  
  constant empty_Int : t_FMap_Int_Int
  
  axiom empty_Int_spec: len_Int empty_Int = 0
  
  axiom empty_Int_spec'0: view_FMap_Int_Int empty_Int = Const.const (None)
  
  function get_Int [@inline:trivial] (self: t_FMap_Int_Int) (k: int) : t_Option_Int = Map.get (view_FMap_Int_Int self) k
  
  meta "rewrite_def" function get_Int
  
  predicate contains_Int [@inline:trivial] (self: t_FMap_Int_Int) (k: int) = get_Int self k <> None
  
  meta "rewrite_def" predicate contains_Int
  
  function insert_Int (self: t_FMap_Int_Int) (k: int) (v: int) : t_FMap_Int_Int
  
  axiom insert_Int_spec: forall self: t_FMap_Int_Int, k: int, v: int. view_FMap_Int_Int (insert_Int self k v)
      = Map.set (view_FMap_Int_Int self) k (Some v)
  
  axiom insert_Int_spec'0: forall self: t_FMap_Int_Int, k: int, v: int. len_Int (insert_Int self k v)
      = (if contains_Int self k then len_Int self else len_Int self + 1)
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  function unwrap_Option_Int (self: t_Option_Int) : int = match self with
      | Some x -> x
      | None -> such_that_Int (fun (__0: int) -> true)
      end
  
  function lookup_Int [@inline:trivial] (self: t_FMap_Int_Int) (k: int) : int = unwrap_Option_Int (get_Int self k)
  
  meta "rewrite_def" function lookup_Int
  
  function index_FMap_Int_Int [@inline:trivial] (self: t_FMap_Int_Int) (key: int) : int = lookup_Int self key
  
  meta "rewrite_def" function index_FMap_Int_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec foo (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = [ &map <- empty_Int ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_3 <- insert_Int map 1 3 ] s1 | s1 = bb2 ]
    | bb2 = s0
      [ s0 = [ &map <- _3 ] s1
      | s1 = {[@expl:assertion] index_FMap_Int_Int map 1 = 3} s2
      | s2 = [ &_9 <- insert_Int map 2 42 ] s3
      | s3 = bb3 ]
    | bb3 = s0
      [ s0 = [ &map <- _9 ] s1
      | s1 = {[@expl:assertion] index_FMap_Int_Int map 1 = 3 /\ index_FMap_Int_Int map 2 = 42} s2
      | s2 = [ &_15 <- insert_Int map 1 4 ] s3
      | s3 = bb4 ]
    | bb4 = s0
      [ s0 = [ &map <- _15 ] s1
      | s1 = {[@expl:assertion] index_FMap_Int_Int map 1 = 4 /\ index_FMap_Int_Int map 2 = 42} s2
      | s2 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & map: t_FMap_Int_Int = Any.any_l ()
    | & _3: t_FMap_Int_Int = Any.any_l ()
    | & _9: t_FMap_Int_Int = Any.any_l ()
    | & _15: t_FMap_Int_Int = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
