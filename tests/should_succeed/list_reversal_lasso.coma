module M_list_reversal_lasso__qyi13715866738248475091__index [#"list_reversal_lasso.rs" 29 4 29 35] (* <Memory as std::ops::Index<usize>> *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 27 4 27 36
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 28 14 28 44
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 190 16 190 48
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 191 16 191 56
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 129 20 129 37
  let%span smodel = "../../creusot-contracts/src/model.rs" 43 8 43 22
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 [@inline:trivial] (self: t_Vec) : Seq.seq UInt64.t = [%#smodel] view self
  
  meta "rewrite_def" function view'0
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  let rec index (self_: t_Vec) (ix: UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:index requires] [%#svec] in_bounds ix (view'0 self_)}
    any [ return''0 (result: UInt64.t) -> {[%#svec'0] has_value ix (view'0 self_) result} (! return' {result}) ]
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'1] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'2] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'2] index_logic self.t_Memory__0 i
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index'0 [#"list_reversal_lasso.rs" 29 4 29 35] (self: t_Memory) (i: UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:index requires] [%#slist_reversal_lasso] nonnull_ptr self i}
    (! bb0
    [ bb0 = s0 [ s0 = index {self'0.t_Memory__0} {i'0} (fun (_ret: UInt64.t) -> [ &_6 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_5 <- _6 ] s1 | s1 = [ &_0 <- _5 ] s2 | s2 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: t_Memory = self
    | & i'0: UInt64.t = i
    | & _5: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l () ])
    [ return''0 (result: UInt64.t) -> {[@expl:index ensures] [%#slist_reversal_lasso'0] result = index_logic'0 self i}
      (! return' {result}) ]
end
module M_list_reversal_lasso__qyi14823043098042356205__index_mut [#"list_reversal_lasso.rs" 40 4 40 47] (* <Memory as std::ops::IndexMut<usize>> *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 35 4 35 36
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 180 16 180 48
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 181 16 181 56
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 182 16 182 59
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 183 16 183 64
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 184 26 184 55
  let%span svec'4 = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'5 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 124 20 124 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 129 20 129 37
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 134 20 134 88
  let%span smodel = "../../creusot-contracts/src/model.rs" 59 8 59 22
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec'4] Seq.length (view self) <= UInt64.t'int const_MAX
  
  function view'0 [@inline:trivial] (self: MutBorrow.t t_Vec) : Seq.seq UInt64.t = [%#smodel] view self.current
  
  meta "rewrite_def" function view'0
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
      -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere
  
  let rec index_mut (self_: MutBorrow.t t_Vec) (ix: UInt64.t) (return' (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] [%#svec] in_bounds ix (view'0 self_)}
    any
    [ return''0 (result: MutBorrow.t UInt64.t) -> {[%#svec'0] has_value ix (view'0 self_) result.current}
      {[%#svec'1] has_value ix (view self_.final) result.final}
      {[%#svec'2] resolve_elswhere ix (view'0 self_) (view self_.final)}
      {[%#svec'3] Seq.length (view self_.final) = Seq.length (view'0 self_)}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t UInt64.t) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Memory) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Memory) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'4] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'5] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'5] index_logic self.t_Memory__0 i
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_mut'0 [#"list_reversal_lasso.rs" 40 4 40 47] (self: MutBorrow.t t_Memory) (i: UInt64.t)
    (return' (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] [%#slist_reversal_lasso] nonnull_ptr self.current i}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Vec> {(self'0.current).t_Memory__0}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret: MutBorrow.t t_Vec) ->
            [ &_11 <- _ret ] [ &self'0 <- { self'0 with current = { t_Memory__0 = _ret.final } } ] s1)
      | s1 = index_mut {_11} {i'0} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <UInt64.t> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &_9 <- _ret ] [ &_10 <- { _10 with current = _ret.final } ] s1)
      | s1 = MutBorrow.borrow_final <UInt64.t> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &_3 <- _ret ] [ &_9 <- { _9 with current = _ret.final } ] s2)
      | s2 = MutBorrow.borrow_final <UInt64.t> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &_0 <- _ret ] [ &_3 <- { _3 with current = _ret.final } ] s3)
      | s3 = -{resolve'0 _10}- s4
      | s4 = -{resolve'0 _9}- s5
      | s5 = -{resolve'0 _3}- s6
      | s6 = -{resolve'2 self'0}- s7
      | s7 = return''0 {_0} ] ]
    [ & _0: MutBorrow.t UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & i'0: UInt64.t = i
    | & _3: MutBorrow.t UInt64.t = Any.any_l ()
    | & _9: MutBorrow.t UInt64.t = Any.any_l ()
    | & _10: MutBorrow.t UInt64.t = Any.any_l ()
    | & _11: MutBorrow.t t_Vec = Any.any_l () ])
    [ return''0 (result: MutBorrow.t UInt64.t) ->
    {[@expl:index_mut ensures #0] [%#slist_reversal_lasso'0] result.current = index_logic'0 self.current i}
      {[@expl:index_mut ensures #1] [%#slist_reversal_lasso'1] result.final = index_logic'0 self.final i}
      {[@expl:index_mut ensures #2] [%#slist_reversal_lasso'2] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[@expl:index_mut ensures #3] [%#slist_reversal_lasso'3] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_safe [#"list_reversal_lasso.rs" 62 4 62 59] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 63 20 63 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 65 8 65 54
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 68 19 68 23
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 60 4 60 42
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 61 4 61 49
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 13 0 13 19
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 54 12 54 95
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 27 4 27 36
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 28 14 28 44
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 35 4 35 36
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = [%#slist_reversal_lasso'4] (18446744073709551615: UInt64.t)
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'6] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'0] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'14] index_logic self.t_Memory__0 i
  
  predicate mem_is_well_formed [#"list_reversal_lasso.rs" 52 4 52 43] (self: t_Memory) =
    [%#slist_reversal_lasso'5] forall i: UInt64.t. nonnull_ptr self i
      -> index_logic'0 self i = const_NULL \/ nonnull_ptr self (index_logic'0 self i)
  
  let rec index (self: t_Memory) (i: UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:index requires] [%#slist_reversal_lasso'7] nonnull_ptr self i}
    any
    [ return''0 (result: UInt64.t) -> {[%#slist_reversal_lasso'8] result = index_logic'0 self i} (! return' {result}) ]
  
  let rec index_mut (self: MutBorrow.t t_Memory) (i: UInt64.t) (return' (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] [%#slist_reversal_lasso'9] nonnull_ptr self.current i}
    any
    [ return''0 (result: MutBorrow.t UInt64.t) -> {[%#slist_reversal_lasso'10] result.current
      = index_logic'0 self.current i}
      {[%#slist_reversal_lasso'11] result.final = index_logic'0 self.final i}
      {[%#slist_reversal_lasso'12] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'13] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t UInt64.t) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Memory) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Memory) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_safe [#"list_reversal_lasso.rs" 62 4 62 59] (self: MutBorrow.t t_Memory) (l: UInt64.t)
    (return' (x: UInt64.t)) =
    {[@expl:list_reversal_safe requires #0] [%#slist_reversal_lasso'2] mem_is_well_formed self.current}
    {[@expl:list_reversal_safe requires #1] [%#slist_reversal_lasso'3] l = const_NULL \/ nonnull_ptr self.current l}
    (! bb0
    [ bb0 = s0 [ s0 = [ &r <- [%#slist_reversal_lasso] const_NULL ] s1 | s1 = [ &old_1_0 <- self'0 ] s2 | s2 = bb1 ]
    | bb1 = bb1'0
      [ bb1'0 = {[@expl:mut invariant] old_1_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'0] r = const_NULL \/ nonnull_ptr self'0.current r}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'0] l'0 = const_NULL \/ nonnull_ptr self'0.current l'0}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'0] mem_is_well_formed self'0.current}
        (! s0)
        [ s0 = bb2 ]
        [ bb2 = s0
          [ s0 = [ &_13 <- l'0 <> ([%#slist_reversal_lasso'1] const_NULL) ] s1
          | s1 = any [ br0 -> {_13 = false} (! bb6) | br1 -> {_13} (! bb3) ] ]
        | bb3 = s0
          [ s0 = [ &tmp <- l'0 ] s1
          | s1 = index {self'0.current} {l'0} (fun (_ret: UInt64.t) -> [ &_17 <- _ret ] s2)
          | s2 = bb4 ]
        | bb4 = s0
          [ s0 = [ &l'0 <- _17 ] s1
          | s1 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret: MutBorrow.t t_Memory) ->
                [ &_22 <- _ret ] [ &self'0 <- { self'0 with current = _ret.final } ] s2)
          | s2 = index_mut {_22} {tmp} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_21 <- _ret ] s3)
          | s3 = bb5 ]
        | bb5 = s0
          [ s0 = [ &_21 <- { _21 with current = r } ] s1
          | s1 = -{resolve'0 _21}- s2
          | s2 = [ &r <- tmp ] s3
          | s3 = bb1'0 ] ] ]
    | bb6 = s0 [ s0 = -{resolve'2 self'0}- s1 | s1 = [ &_0 <- r ] s2 | s2 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & r: UInt64.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & tmp: UInt64.t = Any.any_l ()
    | & _17: UInt64.t = Any.any_l ()
    | & _21: MutBorrow.t UInt64.t = Any.any_l ()
    | & _22: MutBorrow.t t_Memory = Any.any_l ()
    | & old_1_0: MutBorrow.t t_Memory = Any.any_l () ]) [ return''0 (result: UInt64.t) -> (! return' {result}) ]
end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_list [#"list_reversal_lasso.rs" 95 4 95 82] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 96 20 96 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 97 32 97 33
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 99 8 99 46
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 99 20 99 44
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 103 19 103 23
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 105 28 105 34
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 93 4 93 33
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 94 14 94 47
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 13 0 13 19
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 35 4 35 36
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 88 8 90 9
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = [%#slist_reversal_lasso'7] (18446744073709551615: UInt64.t)
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'15] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'0] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'16] index_logic self.t_Memory__0 i
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    [%#slist_reversal_lasso'8] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  let rec index_mut (self: MutBorrow.t t_Memory) (i: UInt64.t) (return' (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] [%#slist_reversal_lasso'9] nonnull_ptr self.current i}
    any
    [ return''0 (result: MutBorrow.t UInt64.t) -> {[%#slist_reversal_lasso'10] result.current
      = index_logic'0 self.current i}
      {[%#slist_reversal_lasso'11] result.final = index_logic'0 self.final i}
      {[%#slist_reversal_lasso'12] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'13] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
  
  let rec replace (dest: MutBorrow.t UInt64.t) (src: UInt64.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t UInt64.t) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Memory) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Memory) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate list [#"list_reversal_lasso.rs" 87 4 87 54] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'14] list_seg self first s const_NULL 0 (Seq.length s)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_list [#"list_reversal_lasso.rs" 95 4 95 82] (self: MutBorrow.t t_Memory) (l: UInt64.t)
    (s: Seq.seq UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:list_reversal_list requires] [%#slist_reversal_lasso'5] list self.current l s}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &r <- [%#slist_reversal_lasso] const_NULL ] s1
      | s1 = [ &n <- [%#slist_reversal_lasso'0] 0 ] s2
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_2_0 <- self'0 ] s1 | s1 = bb2 ]
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:mut invariant] old_2_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'2] 0 <= n /\ n <= Seq.length s'0}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'1] list_seg self'0.current l'0 s'0 const_NULL n (Seq.length s'0)}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'1] list_seg self'0.current r (Reverse.reverse s'0) const_NULL (Seq.length s'0
        - n) (Seq.length s'0)}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_16 <- l'0 <> ([%#slist_reversal_lasso'3] const_NULL) ] s1
          | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb4) ] ]
        | bb4 = s0
          [ s0 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret: MutBorrow.t t_Memory) ->
                [ &_22 <- _ret ] [ &self'0 <- { self'0 with current = _ret.final } ] s1)
          | s1 = index_mut {_22} {l'0} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_21 <- _ret ] s2)
          | s2 = bb5 ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_20 <- _ret ] [ &_21 <- { _21 with current = _ret.final } ] s1)
          | s1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_26 <- _ret ] [ &r <- _ret.final ] s2)
          | s2 = MutBorrow.borrow_final <UInt64.t> {_26.current} {MutBorrow.get_id _26}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_25 <- _ret ] [ &_26 <- { _26 with current = _ret.final } ] s3)
          | s3 = replace {_25} {l'0} (fun (_ret: UInt64.t) -> [ &_24 <- _ret ] s4)
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve'0 _26}- s1
          | s1 = MutBorrow.borrow_final <UInt64.t> {_20.current} {MutBorrow.get_id _20}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_19 <- _ret ] [ &_20 <- { _20 with current = _ret.final } ] s2)
          | s2 = replace {_19} {_24} (fun (_ret: UInt64.t) -> [ &_18 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve'0 _21}- s1
          | s1 = -{resolve'0 _20}- s2
          | s2 = [ &l'0 <- _18 ] s3
          | s3 = [ &_28 <- [%#slist_reversal_lasso'4] n + 1 ] s4
          | s4 = bb8 ]
        | bb8 = s0 [ s0 = [ &n <- _28 ] s1 | s1 = bb2'0 ] ] ]
    | bb9 = s0 [ s0 = -{resolve'2 self'0}- s1 | s1 = [ &_0 <- r ] s2 | s2 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & s'0: Seq.seq UInt64.t = s
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _19: MutBorrow.t UInt64.t = Any.any_l ()
    | & _20: MutBorrow.t UInt64.t = Any.any_l ()
    | & _21: MutBorrow.t UInt64.t = Any.any_l ()
    | & _22: MutBorrow.t t_Memory = Any.any_l ()
    | & _24: UInt64.t = Any.any_l ()
    | & _25: MutBorrow.t UInt64.t = Any.any_l ()
    | & _26: MutBorrow.t UInt64.t = Any.any_l ()
    | & _28: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ])
    [ return''0 (result: UInt64.t) ->
    {[@expl:list_reversal_list ensures] [%#slist_reversal_lasso'6] list self.final result (Reverse.reverse s)}
      (! return' {result}) ]
end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_loop [#"list_reversal_lasso.rs" 120 4 120 82] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 121 20 121 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 122 32 122 33
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 130 20 130 94
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 129 20 129 77
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 125 20 128 72
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 124 20 124 48
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 132 19 132 23
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 133 28 133 75
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 135 28 135 34
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 138 24 140 52
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 117 15 117 26
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 118 4 118 34
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 119 14 119 89
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 13 0 13 19
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 20 8 20 31
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 35 4 35 36
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'19 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'20 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'21 = "list_reversal_lasso.rs" 112 8 114 9
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 249 8 249 27
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = [%#slist_reversal_lasso'12] (18446744073709551615: UInt64.t)
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'14] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'0] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'15] index_logic self.t_Memory__0 i
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    [%#slist_reversal_lasso'13] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  let rec index_mut (self: MutBorrow.t t_Memory) (i: UInt64.t) (return' (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] [%#slist_reversal_lasso'16] nonnull_ptr self.current i}
    any
    [ return''0 (result: MutBorrow.t UInt64.t) -> {[%#slist_reversal_lasso'17] result.current
      = index_logic'0 self.current i}
      {[%#slist_reversal_lasso'18] result.final = index_logic'0 self.final i}
      {[%#slist_reversal_lasso'19] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'20] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
  
  let rec replace (dest: MutBorrow.t UInt64.t) (src: UInt64.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t UInt64.t) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Memory) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Memory) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  function push_front [@inline:trivial] (self: Seq.seq UInt64.t) (x: UInt64.t) : Seq.seq UInt64.t =
    [%#sseq] Seq.cons x self
  
  meta "rewrite_def" function push_front
  
  predicate loopqy95z [#"list_reversal_lasso.rs" 111 4 111 55] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'21] list_seg self first s (Seq.get s 0) 0 (Seq.length s)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_loop [#"list_reversal_lasso.rs" 120 4 120 82] (self: MutBorrow.t t_Memory) (l: UInt64.t)
    (s: Seq.seq UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:list_reversal_loop requires #0] [%#slist_reversal_lasso'9] Seq.length s > 0}
    {[@expl:list_reversal_loop requires #1] [%#slist_reversal_lasso'10] loopqy95z self.current l s}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &r <- [%#slist_reversal_lasso] const_NULL ] s1
      | s1 = [ &n <- [%#slist_reversal_lasso'0] 0 ] s2
      | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_2_0 <- self'0 ] s1 | s1 = bb2 ]
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:mut invariant] old_2_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'4] 0 <= n /\ n <= Seq.length s'0 + 1}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'3] n = Seq.length s'0 + 1
        -> l'0 = const_NULL
        /\ r = Seq.get s'0 0
        /\ nonnull_ptr self'0.current r
        /\ index_logic'0 self'0.current r = Seq.get s'0 (Seq.length s'0 - 1)
        /\ list_seg self'0.current (Seq.get s'0 (Seq.length s'0
        - 1)) (Reverse.reverse s'0) (Seq.get s'0 0) 0 (Seq.length s'0 - 1)}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'2] n <= Seq.length s'0
        -> list_seg self'0.current l'0 s'0 (Seq.get s'0 0) n (Seq.length s'0)}
        {[@expl:loop invariant #3] [%#slist_reversal_lasso'1] n <= Seq.length s'0
        -> list_seg self'0.current r (Reverse.reverse s'0) const_NULL (Seq.length s'0 - n) (Seq.length s'0)}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_18 <- l'0 <> ([%#slist_reversal_lasso'5] const_NULL) ] s1
          | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb4) ] ]
        | bb4 = s0
          [ s0 = {[@expl:assertion] [%#slist_reversal_lasso'6] n = Seq.length s'0
            -> l'0 = Seq.get (Reverse.reverse s'0) (Seq.length s'0 - 1)}
            s1
          | s1 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret: MutBorrow.t t_Memory) ->
                [ &_26 <- _ret ] [ &self'0 <- { self'0 with current = _ret.final } ] s2)
          | s2 = index_mut {_26} {l'0} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_25 <- _ret ] s3)
          | s3 = bb5 ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_25.current} {MutBorrow.get_id _25}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_24 <- _ret ] [ &_25 <- { _25 with current = _ret.final } ] s1)
          | s1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_30 <- _ret ] [ &r <- _ret.final ] s2)
          | s2 = MutBorrow.borrow_final <UInt64.t> {_30.current} {MutBorrow.get_id _30}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_29 <- _ret ] [ &_30 <- { _30 with current = _ret.final } ] s3)
          | s3 = replace {_29} {l'0} (fun (_ret: UInt64.t) -> [ &_28 <- _ret ] s4)
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve'0 _30}- s1
          | s1 = MutBorrow.borrow_final <UInt64.t> {_24.current} {MutBorrow.get_id _24}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_23 <- _ret ] [ &_24 <- { _24 with current = _ret.final } ] s2)
          | s2 = replace {_23} {_28} (fun (_ret: UInt64.t) -> [ &_22 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve'0 _25}- s1
          | s1 = -{resolve'0 _24}- s2
          | s2 = [ &l'0 <- _22 ] s3
          | s3 = [ &_32 <- [%#slist_reversal_lasso'7] n + 1 ] s4
          | s4 = bb8 ]
        | bb8 = s0 [ s0 = [ &n <- _32 ] s1 | s1 = bb2'0 ] ] ]
    | bb9 = s0
      [ s0 = -{resolve'2 self'0}- s1
      | s1 = {[@expl:assertion] [%#slist_reversal_lasso'8] forall i: int. 0 <= i /\ i < Seq.length s'0
          -> Seq.get (push_front (Reverse.reverse (Seq.([..]) s'0 1 (Seq.length s'0))) (Seq.get s'0 0)) i
          = (if i = 0 then Seq.get s'0 0 else Seq.get (Reverse.reverse s'0) (i - 1))}
        s2
      | s2 = [ &_0 <- r ] s3
      | s3 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & s'0: Seq.seq UInt64.t = s
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & _23: MutBorrow.t UInt64.t = Any.any_l ()
    | & _24: MutBorrow.t UInt64.t = Any.any_l ()
    | & _25: MutBorrow.t UInt64.t = Any.any_l ()
    | & _26: MutBorrow.t t_Memory = Any.any_l ()
    | & _28: UInt64.t = Any.any_l ()
    | & _29: MutBorrow.t UInt64.t = Any.any_l ()
    | & _30: MutBorrow.t UInt64.t = Any.any_l ()
    | & _32: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ])
    [ return''0 (result: UInt64.t) ->
    {[@expl:list_reversal_loop ensures] [%#slist_reversal_lasso'11] loopqy95z self.final result (push_front (Reverse.reverse (Seq.([..]) s 1 (Seq.length s))) (Seq.get s 0))}
      (! return' {result}) ]
end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_lasso [#"list_reversal_lasso.rs" 157 4 162 12] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 163 20 163 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 164 32 164 33
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 178 12 178 82
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 173 20 176 74
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 168 12 168 73
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 166 20 166 58
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 184 19 184 23
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 186 28 186 34
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 155 4 155 40
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 156 14 156 54
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 13 0 13 19
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 35 4 35 36
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 147 12 147 73
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 44 20 44 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = [%#slist_reversal_lasso'9] (18446744073709551615: UInt64.t)
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'17] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'0] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'18] index_logic self.t_Memory__0 i
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    [%#slist_reversal_lasso'10] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  let rec index_mut (self: MutBorrow.t t_Memory) (i: UInt64.t) (return' (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] [%#slist_reversal_lasso'11] nonnull_ptr self.current i}
    any
    [ return''0 (result: MutBorrow.t UInt64.t) -> {[%#slist_reversal_lasso'12] result.current
      = index_logic'0 self.current i}
      {[%#slist_reversal_lasso'13] result.final = index_logic'0 self.final i}
      {[%#slist_reversal_lasso'14] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'15] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
  
  let rec replace (dest: MutBorrow.t UInt64.t) (src: UInt64.t) (return' (x: UInt64.t)) = any
    [ return''0 (result: UInt64.t) -> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  predicate resolve [@inline:trivial] (self: MutBorrow.t UInt64.t) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve
  
  predicate resolve'0 [@inline:trivial] (_0: MutBorrow.t UInt64.t) = resolve _0
  
  meta "rewrite_def" predicate resolve'0
  
  predicate resolve'1 [@inline:trivial] (self: MutBorrow.t t_Memory) = [%#sresolve] self.final = self.current
  
  meta "rewrite_def" predicate resolve'1
  
  predicate resolve'2 [@inline:trivial] (_0: MutBorrow.t t_Memory) = resolve'1 _0
  
  meta "rewrite_def" predicate resolve'2
  
  predicate lasso [#"list_reversal_lasso.rs" 145 4 145 70] (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'16] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
        -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_lasso [#"list_reversal_lasso.rs" 157 4 162 12] (self: MutBorrow.t t_Memory) (l: UInt64.t)
    (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t) (return' (x: UInt64.t)) =
    {[@expl:list_reversal_lasso requires] [%#slist_reversal_lasso'7] lasso self.current l s1 s2}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &r <- [%#slist_reversal_lasso] const_NULL ] s1'1
      | s1'1 = [ &n <- [%#slist_reversal_lasso'0] 0 ] s2'1
      | s2'1 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_2_0 <- self'0 ] s1'1 | s1'1 = bb2 ]
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:mut invariant] old_2_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'4] 0 <= n /\ n <= 2 * Seq.length s1'0 + Seq.length s2'0}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'3] let mid = if Seq.length s2'0 = 0 then
          Seq.get s1'0 (Seq.length s1'0 - 1)
        else
          Seq.get s2'0 0
         in n <= Seq.length s1'0
        -> list_seg self'0.current l'0 s1'0 mid n (Seq.length s1'0)
        /\ list_seg self'0.current mid s2'0 (Seq.get s1'0 (Seq.length s1'0 - 1)) 0 (Seq.length s2'0)
        /\ list_seg self'0.current r (Reverse.reverse s1'0) const_NULL (Seq.length s1'0 - n) (Seq.length s1'0)}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'2] Seq.length s1'0 < n
          /\ n <= Seq.length s1'0 + Seq.length s2'0
        -> list_seg self'0.current l'0 s2'0 (Seq.get s1'0 (Seq.length s1'0 - 1)) (n - Seq.length s1'0) (Seq.length s2'0)
        /\ list_seg self'0.current r (Reverse.reverse s2'0) (Seq.get s1'0 (Seq.length s1'0 - 1)) (Seq.length s1'0
            + Seq.length s2'0
          - n) (Seq.length s2'0)
        /\ list_seg self'0.current (Seq.get s1'0 (Seq.length s1'0
        - 1)) (Reverse.reverse s1'0) const_NULL 0 (Seq.length s1'0)}
        {[@expl:loop invariant #3] [%#slist_reversal_lasso'1] let mid = if Seq.length s2'0 = 0 then
          Seq.get s1'0 (Seq.length s1'0 - 1)
        else
          Seq.get s2'0 (Seq.length s2'0 - 1)
         in Seq.length s1'0 + Seq.length s2'0 < n
        -> list_seg self'0.current l'0 (Reverse.reverse s1'0) const_NULL (n - Seq.length s1'0
          - Seq.length s2'0) (Seq.length s1'0)
        /\ list_seg self'0.current r s1'0 mid (2 * Seq.length s1'0 + Seq.length s2'0 - n) (Seq.length s1'0)
        /\ list_seg self'0.current mid (Reverse.reverse s2'0) (Seq.get s1'0 (Seq.length s1'0 - 1)) 0 (Seq.length s2'0)}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_18 <- l'0 <> ([%#slist_reversal_lasso'5] const_NULL) ] s1'1
          | s1'1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb4) ] ]
        | bb4 = s0
          [ s0 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret: MutBorrow.t t_Memory) ->
                [ &_24 <- _ret ] [ &self'0 <- { self'0 with current = _ret.final } ] s1'1)
          | s1'1 = index_mut {_24} {l'0} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_23 <- _ret ] s2'1)
          | s2'1 = bb5 ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_23.current} {MutBorrow.get_id _23}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_22 <- _ret ] [ &_23 <- { _23 with current = _ret.final } ] s1'1)
          | s1'1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_28 <- _ret ] [ &r <- _ret.final ] s2'1)
          | s2'1 = MutBorrow.borrow_final <UInt64.t> {_28.current} {MutBorrow.get_id _28}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_27 <- _ret ] [ &_28 <- { _28 with current = _ret.final } ] s3)
          | s3 = replace {_27} {l'0} (fun (_ret: UInt64.t) -> [ &_26 <- _ret ] s4)
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve'0 _28}- s1'1
          | s1'1 = MutBorrow.borrow_final <UInt64.t> {_22.current} {MutBorrow.get_id _22}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_21 <- _ret ] [ &_22 <- { _22 with current = _ret.final } ] s2'1)
          | s2'1 = replace {_21} {_26} (fun (_ret: UInt64.t) -> [ &_20 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve'0 _23}- s1'1
          | s1'1 = -{resolve'0 _22}- s2'1
          | s2'1 = [ &l'0 <- _20 ] s3
          | s3 = [ &_30 <- [%#slist_reversal_lasso'6] n + 1 ] s4
          | s4 = bb8 ]
        | bb8 = s0 [ s0 = [ &n <- _30 ] s1'1 | s1'1 = bb2'0 ] ] ]
    | bb9 = s0 [ s0 = -{resolve'2 self'0}- s1'1 | s1'1 = [ &_0 <- r ] s2'1 | s2'1 = return''0 {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & s1'0: Seq.seq UInt64.t = s1
    | & s2'0: Seq.seq UInt64.t = s2
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: UInt64.t = Any.any_l ()
    | & _21: MutBorrow.t UInt64.t = Any.any_l ()
    | & _22: MutBorrow.t UInt64.t = Any.any_l ()
    | & _23: MutBorrow.t UInt64.t = Any.any_l ()
    | & _24: MutBorrow.t t_Memory = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & _27: MutBorrow.t UInt64.t = Any.any_l ()
    | & _28: MutBorrow.t UInt64.t = Any.any_l ()
    | & _30: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ])
    [ return''0 (result: UInt64.t) ->
    {[@expl:list_reversal_lasso ensures] [%#slist_reversal_lasso'8] lasso self.final result s1 (Reverse.reverse s2)}
      (! return' {result}) ]
end
module M_list_reversal_lasso__qyi2644757663130641572__find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 200 12 202 53
  let%span swell_founded = "../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Option = C_None | C_Some int
  
  predicate well_founded_relation (self: int) (other: int) = [%#swell_founded] self >= 0 /\ self > other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq UInt64.t
  
  constant i : int
  
  constant p : int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s'0: Seq.seq UInt64.t) (i'0: int) (p'0: int) : t_Option
  
  goal vc_find_ptr_in_seq: ([%#slist_reversal_lasso'0] 0 <= i /\ i <= Seq.length s)
    -> (if i = Seq.length s then
      [@expl:find_ptr_in_seq ensures] [%#slist_reversal_lasso'1] match C_None with
        | C_None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end
    else
      if UInt64.t'int (Seq.get s i) = p then
        [@expl:find_ptr_in_seq ensures] [%#slist_reversal_lasso'1] match C_Some i with
          | C_None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
          | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
          end
      else
        (([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso'0] 0 <= i + 1 /\ i + 1 <= Seq.length s)
          /\ well_founded_relation ([%#slist_reversal_lasso] Seq.length s - i) ([%#slist_reversal_lasso] Seq.length s
          - (i + 1)))
        /\ (([%#slist_reversal_lasso'1] match find_ptr_in_seq s (i + 1) p with
            | C_None -> forall j: int. i + 1 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
            | C_Some j -> i + 1 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
            end)
        -> ([@expl:find_ptr_in_seq ensures] [%#slist_reversal_lasso'1] match find_ptr_in_seq s (i + 1) p with
          | C_None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
          | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
          end))
    
    )
end
module M_list_reversal_lasso__qyi2644757663130641572__pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 212 14 212 15
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 207 15 207 21
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 208 15 208 60
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 209 15 209 101
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 210 14 210 26
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 211 14 211 20
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 215 12 225 13
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 200 12 202 53
  let%span swell_founded = "../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Option = C_None | C_Some int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'5] 0 <= i
        /\ i <= Seq.length s)
      -> find_ptr_in_seq s i p
      = ([%#slist_reversal_lasso'9] if i = Seq.length s then
        C_None
      else
        if UInt64.t'int (Seq.get s i) = p then C_Some i else find_ptr_in_seq s (i + 1) p
      )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'5] 0 <= i
        /\ i <= Seq.length s)
      -> ([%#slist_reversal_lasso'6] match find_ptr_in_seq s i p with
        | C_None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end)
  
  predicate well_founded_relation (self: int) (other: int) = [%#swell_founded] self >= 0 /\ self > other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq UInt64.t
  
  constant n : int
  
  predicate pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (s'0: Seq.seq UInt64.t) (n'0: int)
  
  goal vc_pigeon: ([%#slist_reversal_lasso'0] 0 <= n)
    -> ([%#slist_reversal_lasso'1] forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
    -> ([%#slist_reversal_lasso'2] forall i: int, j: int. 0 <= i
          /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j)
    -> (if n = 0 then
      ([@expl:pigeon ensures #0] [%#slist_reversal_lasso'3] Seq.length s <= n)
      && ([@expl:pigeon ensures #1] [%#slist_reversal_lasso'4] true)
    else
      ([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso'5] 0 <= 0 /\ 0 <= Seq.length s)
      /\ (([%#slist_reversal_lasso'6] match find_ptr_in_seq s 0 (n - 1) with
          | C_None -> forall j: int. 0 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> n - 1
          | C_Some j -> 0 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = n - 1
          end)
      -> match find_ptr_in_seq s 0 (n - 1) with
        | C_None -> ((([@expl:pigeon requires #0] [%#slist_reversal_lasso'0] 0 <= n - 1)
            && ([@expl:pigeon requires #1] [%#slist_reversal_lasso'1] forall i: int. 0 <= i /\ i < Seq.length s
                -> UInt64.t'int (Seq.get s i) < n - 1)
            && ([@expl:pigeon requires #2] [%#slist_reversal_lasso'2] forall i: int, j: int. 0 <= i
                /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j))
          /\ well_founded_relation ([%#slist_reversal_lasso] n) ([%#slist_reversal_lasso] n - 1))
        /\ (([%#slist_reversal_lasso'3] Seq.length s <= n - 1) && ([%#slist_reversal_lasso'4] pigeon s (n - 1))
        -> ([@expl:pigeon ensures #0] [%#slist_reversal_lasso'3] Seq.length s <= n)
        && ([@expl:pigeon ensures #1] [%#slist_reversal_lasso'4] pigeon s (n - 1)))
        | C_Some i -> ([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso'5] 0 <= i + 1 /\ i + 1 <= Seq.length s)
        /\ (([%#slist_reversal_lasso'6] match find_ptr_in_seq s (i + 1) (n - 1) with
            | C_None -> forall j: int. i + 1 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> n - 1
            | C_Some j -> i + 1 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = n - 1
            end)
        -> match find_ptr_in_seq s (i + 1) (n - 1) with
          | C_None -> ((([@expl:pigeon requires #0] [%#slist_reversal_lasso'0] 0 <= n - 1)
              && ([@expl:pigeon requires #1] [%#slist_reversal_lasso'1] forall i'0: int. 0 <= i'0
                    /\ i'0 < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
                  -> UInt64.t'int (Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) i'0)
                  < n - 1)
              && ([@expl:pigeon requires #2] [%#slist_reversal_lasso'2] forall i'0: int, j: int. 0 <= i'0
                  /\ i'0 < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
                  /\ 0 <= j
                  /\ j < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) /\ i'0 <> j
                -> Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) i'0
                <> Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) j))
            /\ well_founded_relation ([%#slist_reversal_lasso] n) ([%#slist_reversal_lasso] n - 1))
          /\ (([%#slist_reversal_lasso'3] Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
              <= n - 1)
            && ([%#slist_reversal_lasso'4] pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n
            - 1))
          -> ([@expl:pigeon ensures #0] [%#slist_reversal_lasso'3] Seq.length s <= n)
          && ([@expl:pigeon ensures #1] [%#slist_reversal_lasso'4] pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i
          + 1) (Seq.length s))) (n - 1)))
          | C_Some _ -> ([@expl:pigeon ensures #0] [%#slist_reversal_lasso'3] Seq.length s <= n)
          && ([@expl:pigeon ensures #1] [%#slist_reversal_lasso'4] true)
          end)
        end)
    )
end
module M_list_reversal_lasso__qyi2644757663130641572__find_lasso_aux [#"list_reversal_lasso.rs" 238 4 238 95] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 237 14 237 37
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 230 4 230 42
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 231 4 231 55
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 232 4 232 58
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 233 14 236 5
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 207 15 207 21
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 208 15 208 60
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 209 15 209 101
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 210 14 210 26
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 211 14 211 20
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 240 12 252 13
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 54 12 54 95
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 13 0 13 19
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 88 8 90 9
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 147 12 147 73
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'19 = "list_reversal_lasso.rs" 200 12 202 53
  let%span slist_reversal_lasso'20 = "list_reversal_lasso.rs" 212 14 212 15
  let%span slist_reversal_lasso'21 = "list_reversal_lasso.rs" 215 12 225 13
  let%span slist_reversal_lasso'22 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  let%span swell_founded = "../../creusot-contracts/src/logic/well_founded.rs" 43 8 43 33
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  type t_Option = C_None | C_Some (Seq.seq UInt64.t)
  
  type tuple = { _p0: Seq.seq UInt64.t; _p1: t_Option }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'14] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'0] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'22] index_logic self.t_Memory__0 i
  
  constant const_NULL: UInt64.t = [%#slist_reversal_lasso'13] (18446744073709551615: UInt64.t)
  
  predicate mem_is_well_formed [#"list_reversal_lasso.rs" 52 4 52 43] (self: t_Memory) =
    [%#slist_reversal_lasso'12] forall i: UInt64.t. nonnull_ptr self i
      -> index_logic'0 self i = const_NULL \/ nonnull_ptr self (index_logic'0 self i)
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    [%#slist_reversal_lasso'15] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  predicate list [#"list_reversal_lasso.rs" 87 4 87 54] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'16] list_seg self first s const_NULL 0 (Seq.length s)
  
  predicate lasso [#"list_reversal_lasso.rs" 145 4 145 70] (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'17] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
        -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option'0
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'4] 0 <= i
        /\ i <= Seq.length s)
      -> find_ptr_in_seq s i p
      = ([%#slist_reversal_lasso'19] if i = Seq.length s then
        C_None'0
      else
        if UInt64.t'int (Seq.get s i) = p then C_Some'0 i else find_ptr_in_seq s (i + 1) p
      )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'4] 0 <= i
        /\ i <= Seq.length s)
      -> ([%#slist_reversal_lasso'5] match find_ptr_in_seq s i p with
        | C_None'0 -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | C_Some'0 j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end)
  
  predicate pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (s: Seq.seq UInt64.t) (n: int)
  
  axiom pigeon_def: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'6] 0 <= n)
      -> ([%#slist_reversal_lasso'7] forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> ([%#slist_reversal_lasso'8] forall i: int, j: int. 0 <= i
            /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j)
      -> pigeon s n
      = ([%#slist_reversal_lasso'21] if n = 0 then
        true
      else
        match find_ptr_in_seq s 0 (n - 1) with
          | C_None'0 -> pigeon s (n - 1)
          | C_Some'0 i -> match find_ptr_in_seq s (i + 1) (n - 1) with
            | C_None'0 -> pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n - 1)
            | C_Some'0 _ -> true
            end
          end
      )
  
  axiom pigeon_spec: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'6] 0 <= n)
      -> ([%#slist_reversal_lasso'7] forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> ([%#slist_reversal_lasso'8] forall i: int, j: int. 0 <= i
            /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j)
      -> ([%#slist_reversal_lasso'9] Seq.length s <= n)
  
  axiom pigeon_spec'0: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'6] 0 <= n)
      -> ([%#slist_reversal_lasso'7] forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> ([%#slist_reversal_lasso'8] forall i: int, j: int. 0 <= i
            /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j)
      -> ([%#slist_reversal_lasso'10] pigeon s n)
  
  predicate well_founded_relation (self: int) (other: int) = [%#swell_founded] self >= 0 /\ self > other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Memory
  
  constant first : UInt64.t
  
  constant last : UInt64.t
  
  constant s : Seq.seq UInt64.t
  
  function find_lasso_aux [#"list_reversal_lasso.rs" 238 4 238 95] (self'0: t_Memory) (first'0: UInt64.t) (last'0: UInt64.t) (s'0: Seq.seq UInt64.t) : tuple
  
  goal vc_find_lasso_aux: ([%#slist_reversal_lasso'0] mem_is_well_formed self)
    -> ([%#slist_reversal_lasso'1] last = const_NULL \/ nonnull_ptr self last)
    -> ([%#slist_reversal_lasso'2] list_seg self first s last 0 (Seq.length s))
    -> (if last = const_NULL then
      [@expl:find_lasso_aux ensures] [%#slist_reversal_lasso'3] match { _p0 = s; _p1 = C_None } with
        | {_p0 = s'0; _p1 = C_None} -> list self first s'0
        | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
        end
    else
      ([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso'4] 0 <= 0 /\ 0 <= Seq.length s)
      /\ (([%#slist_reversal_lasso'5] match find_ptr_in_seq s 0 (UInt64.t'int last) with
          | C_None'0 -> forall j: int. 0 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> UInt64.t'int last
          | C_Some'0 j -> 0 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = UInt64.t'int last
          end)
      -> match find_ptr_in_seq s 0 (UInt64.t'int last) with
        | C_None'0 -> ([%#svec] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX)
        -> (([@expl:pigeon requires #0] [%#slist_reversal_lasso'6] 0 <= Seq.length (view self.t_Memory__0))
          && ([@expl:pigeon requires #1] [%#slist_reversal_lasso'7] forall i: int. 0 <= i /\ i < Seq.length s
              -> UInt64.t'int (Seq.get s i) < Seq.length (view self.t_Memory__0))
          && ([@expl:pigeon requires #2] [%#slist_reversal_lasso'8] forall i: int, j: int. 0 <= i
              /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j))
        /\ (([%#slist_reversal_lasso'9] Seq.length s <= Seq.length (view self.t_Memory__0))
          && ([%#slist_reversal_lasso'10] pigeon s (Seq.length (view self.t_Memory__0)))
        -> (if pigeon s (Seq.length (view self.t_Memory__0)) then
          ((([@expl:find_lasso_aux requires #0] [%#slist_reversal_lasso'0] mem_is_well_formed self)
              && ([@expl:find_lasso_aux requires #1] [%#slist_reversal_lasso'1] index_logic'0 self last = const_NULL
                \/ nonnull_ptr self (index_logic'0 self last))
              && ([@expl:find_lasso_aux requires #2] [%#slist_reversal_lasso'2] list_seg self first (Seq.snoc s last) (index_logic'0 self last) 0 (Seq.length (Seq.snoc s last))))
            /\ well_founded_relation ([%#slist_reversal_lasso] Seq.length (view self.t_Memory__0)
            - Seq.length s) ([%#slist_reversal_lasso] Seq.length (view self.t_Memory__0)
            - Seq.length (Seq.snoc s last)))
          /\ (([%#slist_reversal_lasso'3] match find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last) with
              | {_p0 = s'0; _p1 = C_None} -> list self first s'0
              | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
              end)
          -> ([@expl:find_lasso_aux ensures] [%#slist_reversal_lasso'3] match find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last) with
            | {_p0 = s'0; _p1 = C_None} -> list self first s'0
            | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
            end))
        else
          [@expl:find_lasso_aux ensures] [%#slist_reversal_lasso'3] match { _p0 = s; _p1 = C_None } with
            | {_p0 = s'0; _p1 = C_None} -> list self first s'0
            | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
            end
        ))
        | C_Some'0 i -> [@expl:find_lasso_aux ensures] [%#slist_reversal_lasso'3] match { _p0 = Seq.([..]) s 0 (i + 1);
                                                                                          _p1 = C_Some (Seq.([..]) s (i
                                                                                          + 1) (Seq.length s)) } with
          | {_p0 = s'0; _p1 = C_None} -> list self first s'0
          | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
          end
        end)
    )
end
module M_list_reversal_lasso__qyi2644757663130641572__find_lasso [#"list_reversal_lasso.rs" 263 4 263 71] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 257 4 257 42
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 258 4 258 57
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 259 14 262 5
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 230 4 230 42
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 231 4 231 55
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 232 4 232 58
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 233 14 236 5
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 265 13 265 67
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 54 12 54 95
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 13 0 13 19
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 88 8 90 9
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 147 12 147 73
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 237 14 237 37
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 240 12 252 13
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 20 8 20 31
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'19 = "list_reversal_lasso.rs" 200 12 202 53
  let%span slist_reversal_lasso'20 = "list_reversal_lasso.rs" 212 14 212 15
  let%span slist_reversal_lasso'21 = "list_reversal_lasso.rs" 207 15 207 21
  let%span slist_reversal_lasso'22 = "list_reversal_lasso.rs" 208 15 208 60
  let%span slist_reversal_lasso'23 = "list_reversal_lasso.rs" 209 15 209 101
  let%span slist_reversal_lasso'24 = "list_reversal_lasso.rs" 210 14 210 26
  let%span slist_reversal_lasso'25 = "list_reversal_lasso.rs" 211 14 211 20
  let%span slist_reversal_lasso'26 = "list_reversal_lasso.rs" 215 12 225 13
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 22 14 22 41
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 58 8 58 32
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull = { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique = { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit = { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner = { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec = { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec = { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory = { t_Memory__0: t_Vec }
  
  type t_Option = C_None | C_Some (Seq.seq UInt64.t)
  
  type tuple = { _p0: Seq.seq UInt64.t; _p1: t_Option }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'9] Seq.length (view self.t_Memory__0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#svec'0] Seq.get (view self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_logic
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'15] index_logic self.t_Memory__0 i
  
  constant const_NULL: UInt64.t = [%#slist_reversal_lasso'8] (18446744073709551615: UInt64.t)
  
  predicate mem_is_well_formed [#"list_reversal_lasso.rs" 52 4 52 43] (self: t_Memory) =
    [%#slist_reversal_lasso'7] forall i: UInt64.t. nonnull_ptr self i
      -> index_logic'0 self i = const_NULL \/ nonnull_ptr self (index_logic'0 self i)
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    [%#slist_reversal_lasso'14] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  predicate list [#"list_reversal_lasso.rs" 87 4 87 54] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'10] list_seg self first s const_NULL 0 (Seq.length s)
  
  predicate lasso [#"list_reversal_lasso.rs" 145 4 145 70] (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'11] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
        -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  type t_Option'0 = C_None'0 | C_Some'0 int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option'0
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'17] 0 <= i
        /\ i <= Seq.length s)
      -> find_ptr_in_seq s i p
      = ([%#slist_reversal_lasso'19] if i = Seq.length s then
        C_None'0
      else
        if UInt64.t'int (Seq.get s i) = p then C_Some'0 i else find_ptr_in_seq s (i + 1) p
      )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'17] 0 <= i
        /\ i <= Seq.length s)
      -> ([%#slist_reversal_lasso'18] match find_ptr_in_seq s i p with
        | C_None'0 -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | C_Some'0 j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end)
  
  predicate pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (s: Seq.seq UInt64.t) (n: int)
  
  axiom pigeon_def: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'21] 0 <= n)
      -> ([%#slist_reversal_lasso'22] forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> ([%#slist_reversal_lasso'23] forall i: int, j: int. 0 <= i
            /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j)
      -> pigeon s n
      = ([%#slist_reversal_lasso'26] if n = 0 then
        true
      else
        match find_ptr_in_seq s 0 (n - 1) with
          | C_None'0 -> pigeon s (n - 1)
          | C_Some'0 i -> match find_ptr_in_seq s (i + 1) (n - 1) with
            | C_None'0 -> pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n - 1)
            | C_Some'0 _ -> true
            end
          end
      )
  
  axiom pigeon_spec: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'21] 0 <= n)
      -> ([%#slist_reversal_lasso'22] forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> ([%#slist_reversal_lasso'23] forall i: int, j: int. 0 <= i
            /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j)
      -> ([%#slist_reversal_lasso'24] Seq.length s <= n)
  
  axiom pigeon_spec'0: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'21] 0 <= n)
      -> ([%#slist_reversal_lasso'22] forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> ([%#slist_reversal_lasso'23] forall i: int, j: int. 0 <= i
            /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j)
      -> ([%#slist_reversal_lasso'25] pigeon s n)
  
  function find_lasso_aux [#"list_reversal_lasso.rs" 238 4 238 95] (self: t_Memory) (first: UInt64.t) (last: UInt64.t) (s: Seq.seq UInt64.t) : tuple
  
  axiom find_lasso_aux_def:
    forall self: t_Memory, first: UInt64.t, last: UInt64.t, s: Seq.seq UInt64.t. ([%#slist_reversal_lasso'2] mem_is_well_formed self)
      -> ([%#slist_reversal_lasso'3] last = const_NULL \/ nonnull_ptr self last)
      -> ([%#slist_reversal_lasso'4] list_seg self first s last 0 (Seq.length s))
      -> find_lasso_aux self first last s
      = ([%#slist_reversal_lasso'13] if last = const_NULL then
        { _p0 = s; _p1 = C_None }
      else
        match find_ptr_in_seq s 0 (UInt64.t'int last) with
          | C_None'0 -> if pigeon s (Seq.length (view self.t_Memory__0)) then
            find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last)
          else
            { _p0 = s; _p1 = C_None }
          
          | C_Some'0 i -> { _p0 = Seq.([..]) s 0 (i + 1); _p1 = C_Some (Seq.([..]) s (i + 1) (Seq.length s)) }
          end
      )
  
  axiom find_lasso_aux_spec:
    forall self: t_Memory, first: UInt64.t, last: UInt64.t, s: Seq.seq UInt64.t. ([%#slist_reversal_lasso'2] mem_is_well_formed self)
      -> ([%#slist_reversal_lasso'3] last = const_NULL \/ nonnull_ptr self last)
      -> ([%#slist_reversal_lasso'4] list_seg self first s last 0 (Seq.length s))
      -> ([%#slist_reversal_lasso'5] match find_lasso_aux self first last s with
        | {_p0 = s'0; _p1 = C_None} -> list self first s'0
        | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
        end)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Memory
  
  constant first : UInt64.t
  
  function find_lasso [#"list_reversal_lasso.rs" 263 4 263 71] (self'0: t_Memory) (first'0: UInt64.t) : tuple
  
  goal vc_find_lasso: ([%#slist_reversal_lasso] mem_is_well_formed self)
    -> ([%#slist_reversal_lasso'0] first = const_NULL \/ nonnull_ptr self first)
    -> (([@expl:find_lasso_aux requires #0] [%#slist_reversal_lasso'2] mem_is_well_formed self)
      && ([@expl:find_lasso_aux requires #1] [%#slist_reversal_lasso'3] first = const_NULL \/ nonnull_ptr self first)
      && ([@expl:find_lasso_aux requires #2] [%#slist_reversal_lasso'4] list_seg self first (Seq.empty: Seq.seq UInt64.t) first 0 (Seq.length (Seq.empty: Seq.seq UInt64.t))))
    /\ (([%#slist_reversal_lasso'5] match find_lasso_aux self first first (Seq.empty: Seq.seq UInt64.t) with
        | {_p0 = s; _p1 = C_None} -> list self first s
        | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
        end)
    -> ([@expl:find_lasso ensures] [%#slist_reversal_lasso'1] match find_lasso_aux self first first (Seq.empty: Seq.seq UInt64.t) with
      | {_p0 = s; _p1 = C_None} -> list self first s
      | {_p0 = s1; _p1 = C_Some s2} -> lasso self first s1 s2
      end))
end
