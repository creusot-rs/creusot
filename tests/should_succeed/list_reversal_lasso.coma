module M_impl_Index_for_Memory__index (* <Memory as std::ops::Index<usize>> *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  predicate in_bounds_usize [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds_usize
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate has_value_usize [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value_usize
  
  let rec index_Vec_usize_Global (self_: t_Vec_usize_Global) (ix: UInt64.t) (return (x: UInt64.t)) =
    {[@expl:index requires] in_bounds_usize ix (view_Vec_usize_Global self_)}
    any [ return (result: UInt64.t) -> {has_value_usize ix (view_Vec_usize_Global self_) result} (! return {result}) ]
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global'0 [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global'0
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global'0 self.f0 i
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_Memory'0 (self: t_Memory) (i: UInt64.t) (return (x: UInt64.t)) =
    {[@expl:index requires] nonnull_ptr self i}
    (! bb0
    [ bb0 = s0 [ s0 = index_Vec_usize_Global {self.f0} {i} (fun (_ret: UInt64.t) -> [ &_10 <- _ret ] s1) | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &_9 <- _10 ] s1 | s1 = [ &_0 <- _9 ] s2 | s2 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: t_Memory = self
    | & i: UInt64.t = i
    | & _9: UInt64.t = Any.any_l ()
    | & _10: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:index ensures] result = index_Memory self i} (! return {result}) ]
end
module M_impl_IndexMut_for_Memory__index_mut (* <Memory as std::ops::IndexMut<usize>> *)
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  predicate in_bounds_usize [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    UInt64.t'int self < Seq.length seq
  
  meta "rewrite_def" predicate in_bounds_usize
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate has_value_usize [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    Seq.get seq (UInt64.t'int self) = out
  
  meta "rewrite_def" predicate has_value_usize
  
  predicate resolve_elswhere_usize [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  
  meta "rewrite_def" predicate resolve_elswhere_usize
  
  let rec index_mut_Vec_usize_Global (self_: MutBorrow.t t_Vec_usize_Global) (ix: UInt64.t)
    (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] in_bounds_usize ix (view_Vec_usize_Global self_.current)}
    any
    [ return (result: MutBorrow.t UInt64.t) -> {has_value_usize ix (view_Vec_usize_Global self_.current) result.current}
      {has_value_usize ix (view_Vec_usize_Global self_.final) result.final}
      {resolve_elswhere_usize ix (view_Vec_usize_Global self_.current) (view_Vec_usize_Global self_.final)}
      {Seq.length (view_Vec_usize_Global self_.final) = Seq.length (view_Vec_usize_Global self_.current)}
      (! return {result}) ]
  
  predicate resolve_ref_usize [@inline:trivial] (_1: MutBorrow.t UInt64.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_usize
  
  predicate resolve_ref_Memory [@inline:trivial] (_1: MutBorrow.t t_Memory) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Memory
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global self.f0 i
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_mut_Memory (self: MutBorrow.t t_Memory) (i: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] nonnull_ptr self.current i}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Vec_usize_Global> {self.current.f0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_ret: MutBorrow.t t_Vec_usize_Global) ->
            [ &_20 <- _ret ] [ &self <- { self with current = { f0 = _ret.final } } ] s1)
      | s1 = index_mut_Vec_usize_Global {_20} {i} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_19 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <UInt64.t> {_19.current} {MutBorrow.get_id _19}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &_18 <- _ret ] [ &_19 <- { _19 with current = _ret.final } ] s1)
      | s1 = MutBorrow.borrow_final <UInt64.t> {_18.current} {MutBorrow.get_id _18}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &_3 <- _ret ] [ &_18 <- { _18 with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_usize _19}- s3
      | s3 = -{resolve_ref_usize _18}- s4
      | s4 = MutBorrow.borrow_final <UInt64.t> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t UInt64.t) -> [ &_0 <- _ret ] [ &_3 <- { _3 with current = _ret.final } ] s5)
      | s5 = -{resolve_ref_usize _3}- s6
      | s6 = -{resolve_ref_Memory self}- s7
      | s7 = return {_0} ] ]
    [ & _0: MutBorrow.t UInt64.t = Any.any_l ()
    | & self: MutBorrow.t t_Memory = self
    | & i: UInt64.t = i
    | & _3: MutBorrow.t UInt64.t = Any.any_l ()
    | & _18: MutBorrow.t UInt64.t = Any.any_l ()
    | & _19: MutBorrow.t UInt64.t = Any.any_l ()
    | & _20: MutBorrow.t t_Vec_usize_Global = Any.any_l () ])
    [ return (result: MutBorrow.t UInt64.t) -> {[@expl:index_mut ensures #0] result.current
      = index_Memory self.current i}
      {[@expl:index_mut ensures #1] result.final = index_Memory self.final i}
      {[@expl:index_mut ensures #2] Seq.length (view_Vec_usize_Global self.current.f0)
      = Seq.length (view_Vec_usize_Global self.final.f0)}
      {[@expl:index_mut ensures #3] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_Memory self.final j = index_Memory self.current j}
      (! return {result}) ]
end
module M_impl_Memory_0__list_reversal_safe (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = (18446744073709551615: UInt64.t)
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global self.f0 i
  
  predicate mem_is_well_formed (self: t_Memory) =
    forall i: UInt64.t. nonnull_ptr self i -> index_Memory self i = const_NULL \/ nonnull_ptr self (index_Memory self i)
  
  let rec index_Memory'0 (self: t_Memory) (i: UInt64.t) (return (x: UInt64.t)) =
    {[@expl:index requires] nonnull_ptr self i}
    any [ return (result: UInt64.t) -> {result = index_Memory self i} (! return {result}) ]
  
  let rec index_mut_Memory (self: MutBorrow.t t_Memory) (i: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] nonnull_ptr self.current i}
    any
    [ return (result: MutBorrow.t UInt64.t) -> {result.current = index_Memory self.current i}
      {result.final = index_Memory self.final i}
      {Seq.length (view_Vec_usize_Global self.current.f0) = Seq.length (view_Vec_usize_Global self.final.f0)}
      {forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_Memory self.final j = index_Memory self.current j}
      (! return {result}) ]
  
  predicate resolve_ref_usize [@inline:trivial] (_1: MutBorrow.t UInt64.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_usize
  
  predicate resolve_ref_Memory [@inline:trivial] (_1: MutBorrow.t t_Memory) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Memory
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_safe (self: MutBorrow.t t_Memory) (l: UInt64.t) (return (x: UInt64.t)) =
    {[@expl:list_reversal_safe requires #0] mem_is_well_formed self.current}
    {[@expl:list_reversal_safe requires #1] l = const_NULL \/ nonnull_ptr self.current l}
    (! bb0
    [ bb0 = s0 [ s0 = [ &r <- const_NULL ] s1 | s1 = [ &old_1_0 <- self ] s2 | s2 = bb1 ]
    | bb1 = bb1
      [ bb1 = {[@expl:mut invariant] old_1_0.final = self.final}
        {[@expl:loop invariant #0] r = const_NULL \/ nonnull_ptr self.current r}
        {[@expl:loop invariant #1] l = const_NULL \/ nonnull_ptr self.current l}
        {[@expl:loop invariant #2] mem_is_well_formed self.current}
        (! s0)
        [ s0 = bb2 ]
        [ bb2 = s0
          [ s0 = [ &_21 <- l <> const_NULL ] s1 | s1 = any [ br0 -> {_21 = false} (! bb6) | br1 -> {_21} (! bb3) ] ]
        | bb3 = s0
          [ s0 = [ &tmp <- l ] s1
          | s1 = index_Memory'0 {self.current} {l} (fun (_ret: UInt64.t) -> [ &_25 <- _ret ] s2)
          | s2 = bb4 ]
        | bb4 = s0
          [ s0 = [ &l <- _25 ] s1
          | s1 = MutBorrow.borrow_mut <t_Memory> {self.current}
              (fun (_ret: MutBorrow.t t_Memory) -> [ &_30 <- _ret ] [ &self <- { self with current = _ret.final } ] s2)
          | s2 = index_mut_Memory {_30} {tmp} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_29 <- _ret ] s3)
          | s3 = bb5 ]
        | bb5 = s0
          [ s0 = [ &_29 <- { _29 with current = r } ] s1
          | s1 = -{resolve_ref_usize _29}- s2
          | s2 = [ &r <- tmp ] s3
          | s3 = bb1 ] ] ]
    | bb6 = s0 [ s0 = -{resolve_ref_Memory self}- s1 | s1 = [ &_0 <- r ] s2 | s2 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: MutBorrow.t t_Memory = self
    | & l: UInt64.t = l
    | & r: UInt64.t = Any.any_l ()
    | & _21: bool = Any.any_l ()
    | & tmp: UInt64.t = Any.any_l ()
    | & _25: UInt64.t = Any.any_l ()
    | & _29: MutBorrow.t UInt64.t = Any.any_l ()
    | & _30: MutBorrow.t t_Memory = Any.any_l ()
    | & old_1_0: MutBorrow.t t_Memory = Any.any_l () ]) [ return (result: UInt64.t) -> (! return {result}) ]
end
module M_impl_Memory_0__list_reversal_list (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = (18446744073709551615: UInt64.t)
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global self.f0 i
  
  predicate list_seg (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_Memory self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  let rec index_mut_Memory (self: MutBorrow.t t_Memory) (i: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] nonnull_ptr self.current i}
    any
    [ return (result: MutBorrow.t UInt64.t) -> {result.current = index_Memory self.current i}
      {result.final = index_Memory self.final i}
      {Seq.length (view_Vec_usize_Global self.current.f0) = Seq.length (view_Vec_usize_Global self.final.f0)}
      {forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_Memory self.final j = index_Memory self.current j}
      (! return {result}) ]
  
  let rec replace_usize (dest: MutBorrow.t UInt64.t) (src: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve_ref_usize [@inline:trivial] (_1: MutBorrow.t UInt64.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_usize
  
  predicate resolve_ref_Memory [@inline:trivial] (_1: MutBorrow.t t_Memory) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Memory
  
  predicate list (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    list_seg self first s const_NULL 0 (Seq.length s)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_list (self: MutBorrow.t t_Memory) (l: UInt64.t) (s: Seq.seq UInt64.t) (return (x: UInt64.t)) =
    {[@expl:list_reversal_list requires] list self.current l s}
    (! bb0
    [ bb0 = s0 [ s0 = [ &r <- const_NULL ] s1 | s1 = [ &n <- 0 ] s2 | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_2_0 <- self ] s1 | s1 = bb2 ]
    | bb2 = bb2
      [ bb2 = {[@expl:mut invariant] old_2_0.final = self.final}
        {[@expl:loop invariant #0] 0 <= n /\ n <= Seq.length s}
        {[@expl:loop invariant #1] list_seg self.current l s const_NULL n (Seq.length s)}
        {[@expl:loop invariant #2] list_seg self.current r (Reverse.reverse s) const_NULL (Seq.length s
        - n) (Seq.length s)}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_31 <- l <> const_NULL ] s1 | s1 = any [ br0 -> {_31 = false} (! bb9) | br1 -> {_31} (! bb4) ] ]
        | bb4 = s0
          [ s0 = MutBorrow.borrow_mut <t_Memory> {self.current}
              (fun (_ret: MutBorrow.t t_Memory) -> [ &_37 <- _ret ] [ &self <- { self with current = _ret.final } ] s1)
          | s1 = index_mut_Memory {_37} {l} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_36 <- _ret ] s2)
          | s2 = bb5 ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_36.current} {MutBorrow.get_id _36}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_35 <- _ret ] [ &_36 <- { _36 with current = _ret.final } ] s1)
          | s1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_41 <- _ret ] [ &r <- _ret.final ] s2)
          | s2 = MutBorrow.borrow_final <UInt64.t> {_41.current} {MutBorrow.get_id _41}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_40 <- _ret ] [ &_41 <- { _41 with current = _ret.final } ] s3)
          | s3 = replace_usize {_40} {l} (fun (_ret: UInt64.t) -> [ &_39 <- _ret ] s4)
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve_ref_usize _41}- s1
          | s1 = MutBorrow.borrow_final <UInt64.t> {_35.current} {MutBorrow.get_id _35}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_34 <- _ret ] [ &_35 <- { _35 with current = _ret.final } ] s2)
          | s2 = replace_usize {_34} {_39} (fun (_ret: UInt64.t) -> [ &_33 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve_ref_usize _36}- s1
          | s1 = -{resolve_ref_usize _35}- s2
          | s2 = [ &l <- _33 ] s3
          | s3 = [ &_43 <- n + 1 ] s4
          | s4 = bb8 ]
        | bb8 = s0 [ s0 = [ &n <- _43 ] s1 | s1 = bb2 ] ] ]
    | bb9 = s0 [ s0 = -{resolve_ref_Memory self}- s1 | s1 = [ &_0 <- r ] s2 | s2 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: MutBorrow.t t_Memory = self
    | & l: UInt64.t = l
    | & s: Seq.seq UInt64.t = s
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & _33: UInt64.t = Any.any_l ()
    | & _34: MutBorrow.t UInt64.t = Any.any_l ()
    | & _35: MutBorrow.t UInt64.t = Any.any_l ()
    | & _36: MutBorrow.t UInt64.t = Any.any_l ()
    | & _37: MutBorrow.t t_Memory = Any.any_l ()
    | & _39: UInt64.t = Any.any_l ()
    | & _40: MutBorrow.t UInt64.t = Any.any_l ()
    | & _41: MutBorrow.t UInt64.t = Any.any_l ()
    | & _43: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:list_reversal_list ensures] list self.final result (Reverse.reverse s)}
      (! return {result}) ]
end
module M_impl_Memory_0__list_reversal_loop (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = (18446744073709551615: UInt64.t)
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global self.f0 i
  
  predicate list_seg (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_Memory self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  let rec index_mut_Memory (self: MutBorrow.t t_Memory) (i: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] nonnull_ptr self.current i}
    any
    [ return (result: MutBorrow.t UInt64.t) -> {result.current = index_Memory self.current i}
      {result.final = index_Memory self.final i}
      {Seq.length (view_Vec_usize_Global self.current.f0) = Seq.length (view_Vec_usize_Global self.final.f0)}
      {forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_Memory self.final j = index_Memory self.current j}
      (! return {result}) ]
  
  let rec replace_usize (dest: MutBorrow.t UInt64.t) (src: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve_ref_usize [@inline:trivial] (_1: MutBorrow.t UInt64.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_usize
  
  predicate resolve_ref_Memory [@inline:trivial] (_1: MutBorrow.t t_Memory) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Memory
  
  function push_front_usize [@inline:trivial] (self: Seq.seq UInt64.t) (x: UInt64.t) : Seq.seq UInt64.t =
    Seq.cons x self
  
  meta "rewrite_def" function push_front_usize
  
  predicate loop_ (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    list_seg self first s (Seq.get s 0) 0 (Seq.length s)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_loop (self: MutBorrow.t t_Memory) (l: UInt64.t) (s: Seq.seq UInt64.t) (return (x: UInt64.t)) =
    {[@expl:list_reversal_loop requires #0] Seq.length s > 0}
    {[@expl:list_reversal_loop requires #1] loop_ self.current l s}
    (! bb0
    [ bb0 = s0 [ s0 = [ &r <- const_NULL ] s1 | s1 = [ &n <- 0 ] s2 | s2 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_2_0 <- self ] s1 | s1 = bb2 ]
    | bb2 = bb2
      [ bb2 = {[@expl:mut invariant] old_2_0.final = self.final}
        {[@expl:loop invariant #0] 0 <= n /\ n <= Seq.length s + 1}
        {[@expl:loop invariant #1] n = Seq.length s + 1
        -> l = const_NULL
        /\ r = Seq.get s 0
        /\ nonnull_ptr self.current r
        /\ index_Memory self.current r = Seq.get s (Seq.length s - 1)
        /\ list_seg self.current (Seq.get s (Seq.length s - 1)) (Reverse.reverse s) (Seq.get s 0) 0 (Seq.length s - 1)}
        {[@expl:loop invariant #2] n <= Seq.length s -> list_seg self.current l s (Seq.get s 0) n (Seq.length s)}
        {[@expl:loop invariant #3] n <= Seq.length s
        -> list_seg self.current r (Reverse.reverse s) const_NULL (Seq.length s - n) (Seq.length s)}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_39 <- l <> const_NULL ] s1 | s1 = any [ br0 -> {_39 = false} (! bb9) | br1 -> {_39} (! bb4) ] ]
        | bb4 = s0
          [ s0 = {[@expl:assertion] n = Seq.length s -> l = Seq.get (Reverse.reverse s) (Seq.length s - 1)} s1
          | s1 = MutBorrow.borrow_mut <t_Memory> {self.current}
              (fun (_ret: MutBorrow.t t_Memory) -> [ &_50 <- _ret ] [ &self <- { self with current = _ret.final } ] s2)
          | s2 = index_mut_Memory {_50} {l} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_49 <- _ret ] s3)
          | s3 = bb5 ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_49.current} {MutBorrow.get_id _49}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_48 <- _ret ] [ &_49 <- { _49 with current = _ret.final } ] s1)
          | s1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_54 <- _ret ] [ &r <- _ret.final ] s2)
          | s2 = MutBorrow.borrow_final <UInt64.t> {_54.current} {MutBorrow.get_id _54}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_53 <- _ret ] [ &_54 <- { _54 with current = _ret.final } ] s3)
          | s3 = replace_usize {_53} {l} (fun (_ret: UInt64.t) -> [ &_52 <- _ret ] s4)
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve_ref_usize _54}- s1
          | s1 = MutBorrow.borrow_final <UInt64.t> {_48.current} {MutBorrow.get_id _48}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_47 <- _ret ] [ &_48 <- { _48 with current = _ret.final } ] s2)
          | s2 = replace_usize {_47} {_52} (fun (_ret: UInt64.t) -> [ &_46 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve_ref_usize _49}- s1
          | s1 = -{resolve_ref_usize _48}- s2
          | s2 = [ &l <- _46 ] s3
          | s3 = [ &_56 <- n + 1 ] s4
          | s4 = bb8 ]
        | bb8 = s0 [ s0 = [ &n <- _56 ] s1 | s1 = bb2 ] ] ]
    | bb9 = s0
      [ s0 = -{resolve_ref_Memory self}- s1
      | s1 = {[@expl:assertion] forall i: int. 0 <= i /\ i < Seq.length s
          -> Seq.get (push_front_usize (Reverse.reverse (Seq.([..]) s 1 (Seq.length s))) (Seq.get s 0)) i
          = (if i = 0 then Seq.get s 0 else Seq.get (Reverse.reverse s) (i - 1))}
        s2
      | s2 = [ &_0 <- r ] s3
      | s3 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: MutBorrow.t t_Memory = self
    | & l: UInt64.t = l
    | & s: Seq.seq UInt64.t = s
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _39: bool = Any.any_l ()
    | & _46: UInt64.t = Any.any_l ()
    | & _47: MutBorrow.t UInt64.t = Any.any_l ()
    | & _48: MutBorrow.t UInt64.t = Any.any_l ()
    | & _49: MutBorrow.t UInt64.t = Any.any_l ()
    | & _50: MutBorrow.t t_Memory = Any.any_l ()
    | & _52: UInt64.t = Any.any_l ()
    | & _53: MutBorrow.t UInt64.t = Any.any_l ()
    | & _54: MutBorrow.t UInt64.t = Any.any_l ()
    | & _56: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ])
    [ return (result: UInt64.t) ->
    {[@expl:list_reversal_loop ensures] loop_ self.final result (push_front_usize (Reverse.reverse (Seq.([..]) s 1 (Seq.length s))) (Seq.get s 0))}
      (! return {result}) ]
end
module M_impl_Memory_0__list_reversal_lasso (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  constant const_NULL: UInt64.t = (18446744073709551615: UInt64.t)
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global self.f0 i
  
  predicate list_seg (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_Memory self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  let rec index_mut_Memory (self: MutBorrow.t t_Memory) (i: UInt64.t) (return (x: MutBorrow.t UInt64.t)) =
    {[@expl:index_mut requires] nonnull_ptr self.current i}
    any
    [ return (result: MutBorrow.t UInt64.t) -> {result.current = index_Memory self.current i}
      {result.final = index_Memory self.final i}
      {Seq.length (view_Vec_usize_Global self.current.f0) = Seq.length (view_Vec_usize_Global self.final.f0)}
      {forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
        -> index_Memory self.final j = index_Memory self.current j}
      (! return {result}) ]
  
  let rec replace_usize (dest: MutBorrow.t UInt64.t) (src: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {dest.final = src} {result = dest.current} (! return {result}) ]
  
  predicate resolve_ref_usize [@inline:trivial] (_1: MutBorrow.t UInt64.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_usize
  
  predicate resolve_ref_Memory [@inline:trivial] (_1: MutBorrow.t t_Memory) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Memory
  
  predicate lasso (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t) =
    let mid = if Seq.length s2 = 0 then Seq.get s1 (Seq.length s1 - 1) else Seq.get s2 0 in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
        -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec list_reversal_lasso (self: MutBorrow.t t_Memory) (l: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t)
    (return (x: UInt64.t)) = {[@expl:list_reversal_lasso requires] lasso self.current l s1 s2}
    (! bb0
    [ bb0 = s0 [ s0 = [ &r <- const_NULL ] s1'0 | s1'0 = [ &n <- 0 ] s2'0 | s2'0 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_2_0 <- self ] s1'0 | s1'0 = bb2 ]
    | bb2 = bb2
      [ bb2 = {[@expl:mut invariant] old_2_0.final = self.final}
        {[@expl:loop invariant #0] 0 <= n /\ n <= 2 * Seq.length s1 + Seq.length s2}
        {[@expl:loop invariant #1] let mid = if Seq.length s2 = 0 then
          Seq.get s1 (Seq.length s1 - 1)
        else
          Seq.get s2 0
         in n <= Seq.length s1
        -> list_seg self.current l s1 mid n (Seq.length s1)
        /\ list_seg self.current mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
        /\ list_seg self.current r (Reverse.reverse s1) const_NULL (Seq.length s1 - n) (Seq.length s1)}
        {[@expl:loop invariant #2] Seq.length s1 < n /\ n <= Seq.length s1 + Seq.length s2
        -> list_seg self.current l s2 (Seq.get s1 (Seq.length s1 - 1)) (n - Seq.length s1) (Seq.length s2)
        /\ list_seg self.current r (Reverse.reverse s2) (Seq.get s1 (Seq.length s1 - 1)) (Seq.length s1 + Seq.length s2
          - n) (Seq.length s2)
        /\ list_seg self.current (Seq.get s1 (Seq.length s1 - 1)) (Reverse.reverse s1) const_NULL 0 (Seq.length s1)}
        {[@expl:loop invariant #3] let mid = if Seq.length s2 = 0 then
          Seq.get s1 (Seq.length s1 - 1)
        else
          Seq.get s2 (Seq.length s2 - 1)
         in Seq.length s1 + Seq.length s2 < n
        -> list_seg self.current l (Reverse.reverse s1) const_NULL (n - Seq.length s1 - Seq.length s2) (Seq.length s1)
        /\ list_seg self.current r s1 mid (2 * Seq.length s1 + Seq.length s2 - n) (Seq.length s1)
        /\ list_seg self.current mid (Reverse.reverse s2) (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)}
        (! s0)
        [ s0 = bb3 ]
        [ bb3 = s0
          [ s0 = [ &_46 <- l <> const_NULL ] s1'0 | s1'0 = any [ br0 -> {_46 = false} (! bb9) | br1 -> {_46} (! bb4) ] ]
        | bb4 = s0
          [ s0 = MutBorrow.borrow_mut <t_Memory> {self.current}
              (fun (_ret: MutBorrow.t t_Memory) ->
                [ &_52 <- _ret ] [ &self <- { self with current = _ret.final } ] s1'0)
          | s1'0 = index_mut_Memory {_52} {l} (fun (_ret: MutBorrow.t UInt64.t) -> [ &_51 <- _ret ] s2'0)
          | s2'0 = bb5 ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_51.current} {MutBorrow.get_id _51}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_50 <- _ret ] [ &_51 <- { _51 with current = _ret.final } ] s1'0)
          | s1'0 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_56 <- _ret ] [ &r <- _ret.final ] s2'0)
          | s2'0 = MutBorrow.borrow_final <UInt64.t> {_56.current} {MutBorrow.get_id _56}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_55 <- _ret ] [ &_56 <- { _56 with current = _ret.final } ] s3)
          | s3 = replace_usize {_55} {l} (fun (_ret: UInt64.t) -> [ &_54 <- _ret ] s4)
          | s4 = bb6 ]
        | bb6 = s0
          [ s0 = -{resolve_ref_usize _56}- s1'0
          | s1'0 = MutBorrow.borrow_final <UInt64.t> {_50.current} {MutBorrow.get_id _50}
              (fun (_ret: MutBorrow.t UInt64.t) -> [ &_49 <- _ret ] [ &_50 <- { _50 with current = _ret.final } ] s2'0)
          | s2'0 = replace_usize {_49} {_54} (fun (_ret: UInt64.t) -> [ &_48 <- _ret ] s3)
          | s3 = bb7 ]
        | bb7 = s0
          [ s0 = -{resolve_ref_usize _51}- s1'0
          | s1'0 = -{resolve_ref_usize _50}- s2'0
          | s2'0 = [ &l <- _48 ] s3
          | s3 = [ &_58 <- n + 1 ] s4
          | s4 = bb8 ]
        | bb8 = s0 [ s0 = [ &n <- _58 ] s1'0 | s1'0 = bb2 ] ] ]
    | bb9 = s0 [ s0 = -{resolve_ref_Memory self}- s1'0 | s1'0 = [ &_0 <- r ] s2'0 | s2'0 = return {_0} ] ]
    [ & _0: UInt64.t = Any.any_l ()
    | & self: MutBorrow.t t_Memory = self
    | & l: UInt64.t = l
    | & s1: Seq.seq UInt64.t = s1
    | & s2: Seq.seq UInt64.t = s2
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _46: bool = Any.any_l ()
    | & _48: UInt64.t = Any.any_l ()
    | & _49: MutBorrow.t UInt64.t = Any.any_l ()
    | & _50: MutBorrow.t UInt64.t = Any.any_l ()
    | & _51: MutBorrow.t UInt64.t = Any.any_l ()
    | & _52: MutBorrow.t t_Memory = Any.any_l ()
    | & _54: UInt64.t = Any.any_l ()
    | & _55: MutBorrow.t UInt64.t = Any.any_l ()
    | & _56: MutBorrow.t UInt64.t = Any.any_l ()
    | & _58: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@expl:list_reversal_lasso ensures] lasso self.final result s1 (Reverse.reverse s2)}
      (! return {result}) ]
end
module M_impl_Memory_0__find_ptr_in_seq (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Option_Int = None | Some int
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq UInt64.t
  
  constant i : int
  
  constant p : int
  
  function find_ptr_in_seq (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option_Int
  
  goal vc_find_ptr_in_seq: 0 <= i /\ i <= Seq.length s
    -> (if i = Seq.length s then
      [@expl:find_ptr_in_seq ensures] match None with
        | None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end
    else
      if UInt64.t'int (Seq.get s i) = p then
        [@expl:find_ptr_in_seq ensures] match Some i with
          | None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
          | Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
          end
      else
        (([@expl:find_ptr_in_seq requires] 0 <= i + 1 /\ i + 1 <= Seq.length s)
          /\ well_founded_relation_Int (Seq.length s - i) (Seq.length s - (i + 1)))
        /\ (match find_ptr_in_seq s (i + 1) p with
            | None -> forall j: int. i + 1 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
            | Some j -> i + 1 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
            end
        -> ([@expl:find_ptr_in_seq ensures] match find_ptr_in_seq s (i + 1) p with
          | None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
          | Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
          end))
    
    )
end
module M_impl_Memory_0__pigeon (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Option_Int = None | Some int
  
  function find_ptr_in_seq (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option_Int
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. 0 <= i /\ i <= Seq.length s
      -> find_ptr_in_seq s i p
      = (if i = Seq.length s then
        None
      else
        if UInt64.t'int (Seq.get s i) = p then Some i else find_ptr_in_seq s (i + 1) p
      )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. 0 <= i /\ i <= Seq.length s
      -> match find_ptr_in_seq s i p with
        | None -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Seq.seq UInt64.t
  
  constant n : int
  
  predicate pigeon (s: Seq.seq UInt64.t) (n: int)
  
  goal vc_pigeon: 0 <= n
    -> (forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
    -> (forall i: int, j: int. 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
        -> Seq.get s i <> Seq.get s j)
    -> (if n = 0 then
      ([@expl:pigeon ensures #0] Seq.length s <= n) && ([@expl:pigeon ensures #1] true)
    else
      ([@expl:find_ptr_in_seq requires] 0 <= 0 /\ 0 <= Seq.length s)
      /\ (match find_ptr_in_seq s 0 (n - 1) with
          | None -> forall j: int. 0 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> n - 1
          | Some j -> 0 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = n - 1
          end
      -> match find_ptr_in_seq s 0 (n - 1) with
        | None -> ((([@expl:pigeon requires #0] 0 <= n - 1)
            && ([@expl:pigeon requires #1] forall i: int. 0 <= i /\ i < Seq.length s
                -> UInt64.t'int (Seq.get s i) < n - 1)
            && ([@expl:pigeon requires #2] forall i: int, j: int. 0 <= i
                /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j))
          /\ well_founded_relation_Int n (n - 1))
        /\ (Seq.length s <= n - 1 && pigeon s (n - 1)
        -> ([@expl:pigeon ensures #0] Seq.length s <= n) && ([@expl:pigeon ensures #1] pigeon s (n - 1)))
        | Some i -> ([@expl:find_ptr_in_seq requires] 0 <= i + 1 /\ i + 1 <= Seq.length s)
        /\ (match find_ptr_in_seq s (i + 1) (n - 1) with
            | None -> forall j: int. i + 1 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> n - 1
            | Some j -> i + 1 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = n - 1
            end
        -> match find_ptr_in_seq s (i + 1) (n - 1) with
          | None -> ((([@expl:pigeon requires #0] 0 <= n - 1)
              && ([@expl:pigeon requires #1] forall i'0: int. 0 <= i'0
                    /\ i'0 < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
                  -> UInt64.t'int (Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) i'0)
                  < n - 1)
              && ([@expl:pigeon requires #2] forall i'0: int, j: int. 0 <= i'0
                  /\ i'0 < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
                  /\ 0 <= j
                  /\ j < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) /\ i'0 <> j
                -> Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) i'0
                <> Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) j))
            /\ well_founded_relation_Int n (n - 1))
          /\ (Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) <= n - 1
            && pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n - 1)
          -> ([@expl:pigeon ensures #0] Seq.length s <= n)
          && ([@expl:pigeon ensures #1] pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n
          - 1)))
          | Some _ -> ([@expl:pigeon ensures #0] Seq.length s <= n) && ([@expl:pigeon ensures #1] true)
          end)
        end)
    )
end
module M_impl_Memory_0__find_lasso_aux (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  type t_Option_Seq_usize = None | Some (Seq.seq UInt64.t)
  
  type tup2_Seq_usize_Option_Seq_usize = { f0'0: Seq.seq UInt64.t; f1'0: t_Option_Seq_usize }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global self.f0 i
  
  constant const_NULL: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate mem_is_well_formed (self: t_Memory) =
    forall i: UInt64.t. nonnull_ptr self i -> index_Memory self i = const_NULL \/ nonnull_ptr self (index_Memory self i)
  
  predicate list_seg (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_Memory self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  predicate list (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    list_seg self first s const_NULL 0 (Seq.length s)
  
  predicate lasso (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t) =
    let mid = if Seq.length s2 = 0 then Seq.get s1 (Seq.length s1 - 1) else Seq.get s2 0 in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
        -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  type t_Option_Int = None'0 | Some'0 int
  
  function find_ptr_in_seq (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option_Int
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. 0 <= i /\ i <= Seq.length s
      -> find_ptr_in_seq s i p
      = (if i = Seq.length s then
        None'0
      else
        if UInt64.t'int (Seq.get s i) = p then Some'0 i else find_ptr_in_seq s (i + 1) p
      )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. 0 <= i /\ i <= Seq.length s
      -> match find_ptr_in_seq s i p with
        | None'0 -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | Some'0 j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end
  
  predicate pigeon (s: Seq.seq UInt64.t) (n: int)
  
  axiom pigeon_def: forall s: Seq.seq UInt64.t, n: int. 0 <= n
      -> (forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> (forall i: int, j: int. 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
          -> Seq.get s i <> Seq.get s j)
      -> pigeon s n
      = (if n = 0 then
        true
      else
        match find_ptr_in_seq s 0 (n - 1) with
          | None'0 -> pigeon s (n - 1)
          | Some'0 i -> match find_ptr_in_seq s (i + 1) (n - 1) with
            | None'0 -> pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n - 1)
            | Some'0 _ -> true
            end
          end
      )
  
  axiom pigeon_spec: forall s: Seq.seq UInt64.t, n: int. 0 <= n
      -> (forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> (forall i: int, j: int. 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
          -> Seq.get s i <> Seq.get s j) -> Seq.length s <= n
  
  axiom pigeon_spec'0: forall s: Seq.seq UInt64.t, n: int. 0 <= n
      -> (forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> (forall i: int, j: int. 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
          -> Seq.get s i <> Seq.get s j) -> pigeon s n
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Memory
  
  constant first : UInt64.t
  
  constant last : UInt64.t
  
  constant s : Seq.seq UInt64.t
  
  function find_lasso_aux (self: t_Memory) (first: UInt64.t) (last: UInt64.t) (s: Seq.seq UInt64.t) : tup2_Seq_usize_Option_Seq_usize
  
  goal vc_find_lasso_aux: mem_is_well_formed self
    -> last = const_NULL \/ nonnull_ptr self last
    -> list_seg self first s last 0 (Seq.length s)
    -> (if last = const_NULL then
      [@expl:find_lasso_aux ensures] match { f0'0 = s; f1'0 = None } with
        | {f0'0 = s'0; f1'0 = None} -> list self first s'0
        | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
        end
    else
      ([@expl:find_ptr_in_seq requires] 0 <= 0 /\ 0 <= Seq.length s)
      /\ (match find_ptr_in_seq s 0 (UInt64.t'int last) with
          | None'0 -> forall j: int. 0 <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> UInt64.t'int last
          | Some'0 j -> 0 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = UInt64.t'int last
          end
      -> match find_ptr_in_seq s 0 (UInt64.t'int last) with
        | None'0 -> Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
        -> (([@expl:pigeon requires #0] 0 <= Seq.length (view_Vec_usize_Global self.f0))
          && ([@expl:pigeon requires #1] forall i: int. 0 <= i /\ i < Seq.length s
              -> UInt64.t'int (Seq.get s i) < Seq.length (view_Vec_usize_Global self.f0))
          && ([@expl:pigeon requires #2] forall i: int, j: int. 0 <= i
              /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j -> Seq.get s i <> Seq.get s j))
        /\ (Seq.length s <= Seq.length (view_Vec_usize_Global self.f0)
          && pigeon s (Seq.length (view_Vec_usize_Global self.f0))
        -> (if pigeon s (Seq.length (view_Vec_usize_Global self.f0)) then
          ((([@expl:find_lasso_aux requires #0] mem_is_well_formed self)
              && ([@expl:find_lasso_aux requires #1] index_Memory self last = const_NULL
                \/ nonnull_ptr self (index_Memory self last))
              && ([@expl:find_lasso_aux requires #2] list_seg self first (Seq.snoc s last) (index_Memory self last) 0 (Seq.length (Seq.snoc s last))))
            /\ well_founded_relation_Int (Seq.length (view_Vec_usize_Global self.f0)
            - Seq.length s) (Seq.length (view_Vec_usize_Global self.f0) - Seq.length (Seq.snoc s last)))
          /\ (match find_lasso_aux self first (index_Memory self last) (Seq.snoc s last) with
              | {f0'0 = s'0; f1'0 = None} -> list self first s'0
              | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
              end
          -> ([@expl:find_lasso_aux ensures] match find_lasso_aux self first (index_Memory self last) (Seq.snoc s last) with
            | {f0'0 = s'0; f1'0 = None} -> list self first s'0
            | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
            end))
        else
          [@expl:find_lasso_aux ensures] match { f0'0 = s; f1'0 = None } with
            | {f0'0 = s'0; f1'0 = None} -> list self first s'0
            | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
            end
        ))
        | Some'0 i -> [@expl:find_lasso_aux ensures] match { f0'0 = Seq.([..]) s 0 (i + 1);
                                                             f1'0 = Some (Seq.([..]) s (i + 1) (Seq.length s)) } with
          | {f0'0 = s'0; f1'0 = None} -> list self first s'0
          | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
          end
        end)
    )
end
module M_impl_Memory_0__find_lasso (* Memory *)
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Vec_usize_Global
  
  type t_Memory = { f0: t_Vec_usize_Global }
  
  type t_Option_Seq_usize = None | Some (Seq.seq UInt64.t)
  
  type tup2_Seq_usize_Option_Seq_usize = { f0'0: Seq.seq UInt64.t; f1'0: t_Option_Seq_usize }
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_usize_Global (self: t_Vec_usize_Global) : Seq.seq UInt64.t
  
  axiom view_Vec_usize_Global_spec: forall self: t_Vec_usize_Global. Seq.length (view_Vec_usize_Global self)
      <= UInt64.t'int const_MAX
  
  predicate nonnull_ptr (self: t_Memory) (i: UInt64.t) =
    Seq.length (view_Vec_usize_Global self.f0) <= UInt64.t'int const_MAX
    /\ UInt64.t'int i < Seq.length (view_Vec_usize_Global self.f0)
  
  function index_Vec_usize_Global [@inline:trivial] (self: t_Vec_usize_Global) (ix: UInt64.t) : UInt64.t =
    Seq.get (view_Vec_usize_Global self) (UInt64.t'int ix)
  
  meta "rewrite_def" function index_Vec_usize_Global
  
  function index_Memory (self: t_Memory) (i: UInt64.t) : UInt64.t = index_Vec_usize_Global self.f0 i
  
  constant const_NULL: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate mem_is_well_formed (self: t_Memory) =
    forall i: UInt64.t. nonnull_ptr self i -> index_Memory self i = const_NULL \/ nonnull_ptr self (index_Memory self i)
  
  predicate list_seg (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int) =
    first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
        -> nonnull_ptr self (Seq.get s i)
        /\ index_Memory self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j -> Seq.get s i <> Seq.get s j)
  
  predicate list (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    list_seg self first s const_NULL 0 (Seq.length s)
  
  predicate lasso (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t) =
    let mid = if Seq.length s2 = 0 then Seq.get s1 (Seq.length s1 - 1) else Seq.get s2 0 in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
        -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  type t_Option_Int = None'0 | Some'0 int
  
  function find_ptr_in_seq (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option_Int
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. 0 <= i /\ i <= Seq.length s
      -> find_ptr_in_seq s i p
      = (if i = Seq.length s then
        None'0
      else
        if UInt64.t'int (Seq.get s i) = p then Some'0 i else find_ptr_in_seq s (i + 1) p
      )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. 0 <= i /\ i <= Seq.length s
      -> match find_ptr_in_seq s i p with
        | None'0 -> forall j: int. i <= j /\ j < Seq.length s -> UInt64.t'int (Seq.get s j) <> p
        | Some'0 j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end
  
  predicate pigeon (s: Seq.seq UInt64.t) (n: int)
  
  axiom pigeon_def: forall s: Seq.seq UInt64.t, n: int. 0 <= n
      -> (forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> (forall i: int, j: int. 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
          -> Seq.get s i <> Seq.get s j)
      -> pigeon s n
      = (if n = 0 then
        true
      else
        match find_ptr_in_seq s 0 (n - 1) with
          | None'0 -> pigeon s (n - 1)
          | Some'0 i -> match find_ptr_in_seq s (i + 1) (n - 1) with
            | None'0 -> pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n - 1)
            | Some'0 _ -> true
            end
          end
      )
  
  axiom pigeon_spec: forall s: Seq.seq UInt64.t, n: int. 0 <= n
      -> (forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> (forall i: int, j: int. 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
          -> Seq.get s i <> Seq.get s j) -> Seq.length s <= n
  
  axiom pigeon_spec'0: forall s: Seq.seq UInt64.t, n: int. 0 <= n
      -> (forall i: int. 0 <= i /\ i < Seq.length s -> UInt64.t'int (Seq.get s i) < n)
      -> (forall i: int, j: int. 0 <= i /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j
          -> Seq.get s i <> Seq.get s j) -> pigeon s n
  
  function find_lasso_aux (self: t_Memory) (first: UInt64.t) (last: UInt64.t) (s: Seq.seq UInt64.t) : tup2_Seq_usize_Option_Seq_usize
  
  axiom find_lasso_aux_def:
    forall self: t_Memory, first: UInt64.t, last: UInt64.t, s: Seq.seq UInt64.t. mem_is_well_formed self
      -> last = const_NULL \/ nonnull_ptr self last
      -> list_seg self first s last 0 (Seq.length s)
      -> find_lasso_aux self first last s
      = (if last = const_NULL then
        { f0'0 = s; f1'0 = None }
      else
        match find_ptr_in_seq s 0 (UInt64.t'int last) with
          | None'0 -> if pigeon s (Seq.length (view_Vec_usize_Global self.f0)) then
            find_lasso_aux self first (index_Memory self last) (Seq.snoc s last)
          else
            { f0'0 = s; f1'0 = None }
          
          | Some'0 i -> { f0'0 = Seq.([..]) s 0 (i + 1); f1'0 = Some (Seq.([..]) s (i + 1) (Seq.length s)) }
          end
      )
  
  axiom find_lasso_aux_spec:
    forall self: t_Memory, first: UInt64.t, last: UInt64.t, s: Seq.seq UInt64.t. mem_is_well_formed self
      -> last = const_NULL \/ nonnull_ptr self last
      -> list_seg self first s last 0 (Seq.length s)
      -> match find_lasso_aux self first last s with
        | {f0'0 = s'0; f1'0 = None} -> list self first s'0
        | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Memory
  
  constant first : UInt64.t
  
  function find_lasso (self: t_Memory) (first: UInt64.t) : tup2_Seq_usize_Option_Seq_usize
  
  goal vc_find_lasso: mem_is_well_formed self
    -> first = const_NULL \/ nonnull_ptr self first
    -> (([@expl:find_lasso_aux requires #0] mem_is_well_formed self)
      && ([@expl:find_lasso_aux requires #1] first = const_NULL \/ nonnull_ptr self first)
      && ([@expl:find_lasso_aux requires #2] list_seg self first (Seq.empty: Seq.seq UInt64.t) first 0 (Seq.length (Seq.empty: Seq.seq UInt64.t))))
    /\ (match find_lasso_aux self first first (Seq.empty: Seq.seq UInt64.t) with
        | {f0'0 = s; f1'0 = None} -> list self first s
        | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
        end
    -> ([@expl:find_lasso ensures] match find_lasso_aux self first first (Seq.empty: Seq.seq UInt64.t) with
      | {f0'0 = s; f1'0 = None} -> list self first s
      | {f0'0 = s1; f1'0 = Some s2} -> lasso self first s1 s2
      end))
end
