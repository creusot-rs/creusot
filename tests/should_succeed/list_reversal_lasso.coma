module M_list_reversal_lasso__qyi13715866738248475091__index [#"list_reversal_lasso.rs" 29 4 29 35] (* <Memory as std::ops::Index<usize>> *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 27 15 27 34
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 28 14 28 44
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 160 27 160 46
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 161 26 161 54
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 108 20 108 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  let%span smodel = "../../creusot-contracts/src/model.rs" 44 8 44 22
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec'1] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  function view'0 (self: t_Vec) : Seq.seq UInt64.t =
    [%#smodel] view self
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  let rec index (self_:t_Vec) (ix:UInt64.t) (return'  (x:UInt64.t))= {[@expl:index requires] [%#svec] in_bounds ix (view'0 self_)}
    any [ return''0 (result:UInt64.t)-> {[%#svec'0] has_value ix (view'0 self_) result} (! return' {result}) ] 
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'1] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'2] index_logic self.t_Memory__0 i
  
  meta "compute_max_steps" 1000000
  
  let rec index'0[#"list_reversal_lasso.rs" 29 4 29 35] (self:t_Memory) (i:UInt64.t) (return'  (x:UInt64.t))= {[@expl:index requires] [%#slist_reversal_lasso] nonnull_ptr self i}
    (! bb0
    [ bb0 = s0 [ s0 = index {self'0.t_Memory__0} {i'0} (fun (_ret:UInt64.t) ->  [ &_6 <- _ret ] s1) | s1 = bb1 ] 
    | bb1 = s0 [ s0 =  [ &_5 <- _6 ] s1 | s1 =  [ &_0 <- _5 ] s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: t_Memory = self
    | & i'0: UInt64.t = i
    | & _5: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:index ensures] [%#slist_reversal_lasso'0] result = index_logic'0 self i}
      (! return' {result}) ]

end
module M_list_reversal_lasso__qyi14823043098042356205__index_mut [#"list_reversal_lasso.rs" 40 4 40 47] (* <Memory as std::ops::IndexMut<usize>> *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 35 15 35 34
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 150 27 150 46
  let%span svec'0 = "../../creusot-contracts/src/std/vec.rs" 151 26 151 54
  let%span svec'1 = "../../creusot-contracts/src/std/vec.rs" 152 26 152 57
  let%span svec'2 = "../../creusot-contracts/src/std/vec.rs" 153 26 153 62
  let%span svec'3 = "../../creusot-contracts/src/std/vec.rs" 154 26 154 55
  let%span svec'4 = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sslice = "../../creusot-contracts/src/std/slice.rs" 108 20 108 37
  let%span sslice'0 = "../../creusot-contracts/src/std/slice.rs" 115 20 115 37
  let%span sslice'1 = "../../creusot-contracts/src/std/slice.rs" 122 20 122 88
  let%span smodel = "../../creusot-contracts/src/model.rs" 62 8 62 22
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  predicate in_bounds [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) =
    [%#sslice] UInt64.t'int self < Seq.length seq
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec'4] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  function view'0 (self: MutBorrow.t t_Vec) : Seq.seq UInt64.t =
    [%#smodel] view self.current
  
  predicate has_value [@inline:trivial] (self: UInt64.t) (seq: Seq.seq UInt64.t) (out: UInt64.t) =
    [%#sslice'0] Seq.get seq (UInt64.t'int self) = out
  
  predicate resolve_elswhere [@inline:trivial] (self: UInt64.t) (old': Seq.seq UInt64.t) (fin: Seq.seq UInt64.t) =
    [%#sslice'1] forall i: int. 0 <= i /\ i <> UInt64.t'int self /\ i < Seq.length old'
     -> Seq.get old' i = Seq.get fin i
  
  let rec index_mut (self_:MutBorrow.t t_Vec) (ix:UInt64.t) (return'  (x:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#svec] in_bounds ix (view'0 self_)}
    any
    [ return''0 (result:MutBorrow.t UInt64.t)-> {[%#svec'0] has_value ix (view'0 self_) result.current}
      {[%#svec'1] has_value ix (view self_.final) result.final}
      {[%#svec'2] resolve_elswhere ix (view'0 self_) (view self_.final)}
      {[%#svec'3] Seq.length (view self_.final) = Seq.length (view'0 self_)}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t UInt64.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t UInt64.t) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_Memory) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Memory) =
    resolve'1 _0
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'4] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'5] index_logic self.t_Memory__0 i
  
  meta "compute_max_steps" 1000000
  
  let rec index_mut'0[#"list_reversal_lasso.rs" 40 4 40 47] (self:MutBorrow.t t_Memory) (i:UInt64.t) (return'  (x:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#slist_reversal_lasso] nonnull_ptr self.current i}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final
          <t_Vec>
          {(self'0.current).t_Memory__0}
          {MutBorrow.inherit_id (MutBorrow.get_id self'0) 1}
          (fun (_ret:MutBorrow.t t_Vec) ->
             [ &_11 <- _ret ] 
             [ &self'0 <- { self'0 with current = { t_Memory__0 = _ret.final } } ] 
            s1)
      | s1 = index_mut {_11} {i'0} (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_10 <- _ret ] s2)
      | s2 = bb1 ]
    
    | bb1 = s0
      [ s0 = MutBorrow.borrow_final <UInt64.t> {_10.current} {MutBorrow.get_id _10}
          (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_9 <- _ret ]  [ &_10 <- { _10 with current = _ret.final } ] s1)
      | s1 = MutBorrow.borrow_final <UInt64.t> {_9.current} {MutBorrow.get_id _9}
          (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_3 <- _ret ]  [ &_9 <- { _9 with current = _ret.final } ] s2)
      | s2 = MutBorrow.borrow_final <UInt64.t> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_0 <- _ret ]  [ &_3 <- { _3 with current = _ret.final } ] s3)
      | s3 = -{resolve'0 _10}- s4
      | s4 = -{resolve'0 _9}- s5
      | s5 = -{resolve'0 _3}- s6
      | s6 = -{resolve'2 self'0}- s7
      | s7 = return''0 {_0} ]
     ]
    )
    [ & _0: MutBorrow.t UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & i'0: UInt64.t = i
    | & _3: MutBorrow.t UInt64.t = Any.any_l ()
    | & _9: MutBorrow.t UInt64.t = Any.any_l ()
    | & _10: MutBorrow.t UInt64.t = Any.any_l ()
    | & _11: MutBorrow.t t_Vec = Any.any_l () ]
    
    [ return''0 (result:MutBorrow.t UInt64.t)-> {[@expl:index_mut ensures #0] [%#slist_reversal_lasso'0] result.current
      = index_logic'0 self.current i}
      {[@expl:index_mut ensures #1] [%#slist_reversal_lasso'1] result.final = index_logic'0 self.final i}
      {[@expl:index_mut ensures #2] [%#slist_reversal_lasso'2] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[@expl:index_mut ensures #3] [%#slist_reversal_lasso'3] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
       -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]

end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_safe [#"list_reversal_lasso.rs" 62 4 62 59] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 63 20 63 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 67 20 67 45
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 66 20 66 52
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 65 20 65 52
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 68 19 68 23
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 60 15 60 40
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 61 15 61 47
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 54 12 54 95
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 13 0 13 15
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 27 15 27 34
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 28 14 28 44
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 35 15 35 34
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'8] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'16] index_logic self.t_Memory__0 i
  
  constant v_NULL: UInt64.t = [%#slist_reversal_lasso'7] (18446744073709551615: UInt64.t)
  
  predicate mem_is_well_formed [#"list_reversal_lasso.rs" 52 4 52 43] (self: t_Memory) =
    [%#slist_reversal_lasso'6] forall i: UInt64.t. nonnull_ptr self i
     -> index_logic'0 self i = v_NULL \/ nonnull_ptr self (index_logic'0 self i)
  
  let rec index (self:t_Memory) (i:UInt64.t) (return'  (x:UInt64.t))= {[@expl:index requires] [%#slist_reversal_lasso'9] nonnull_ptr self i}
    any
    [ return''0 (result:UInt64.t)-> {[%#slist_reversal_lasso'10] result = index_logic'0 self i} (! return' {result}) ]
  
  
  let rec index_mut (self:MutBorrow.t t_Memory) (i:UInt64.t) (return'  (x:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#slist_reversal_lasso'11] nonnull_ptr self.current i}
    any
    [ return''0 (result:MutBorrow.t UInt64.t)-> {[%#slist_reversal_lasso'12] result.current
      = index_logic'0 self.current i}
      {[%#slist_reversal_lasso'13] result.final = index_logic'0 self.final i}
      {[%#slist_reversal_lasso'14] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'15] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
       -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t UInt64.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t UInt64.t) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_Memory) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Memory) =
    resolve'1 _0
  
  meta "compute_max_steps" 1000000
  
  let rec list_reversal_safe[#"list_reversal_lasso.rs" 62 4 62 59] (self:MutBorrow.t t_Memory) (l:UInt64.t) (return'  (x:UInt64.t))= {[@expl:list_reversal_safe requires #0] [%#slist_reversal_lasso'4] mem_is_well_formed self.current}
    {[@expl:list_reversal_safe requires #1] [%#slist_reversal_lasso'5] l = v_NULL \/ nonnull_ptr self.current l}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso] (18446744073709551615: UInt64.t) ] s1
      | s1 =  [ &old_1_0 <- self'0 ] s2
      | s2 = bb1 ]
    
    | bb1 = bb1'0
      [ bb1'0 = {[@expl:mut invariant] old_1_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'2] r = v_NULL \/ nonnull_ptr self'0.current r}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'1] l'0 = v_NULL \/ nonnull_ptr self'0.current l'0}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'0] mem_is_well_formed self'0.current}
        (! s0) [ s0 = bb2 ] 
        [ bb2 = s0
          [ s0 =  [ &_13 <- l'0 <> ([%#slist_reversal_lasso'3] (18446744073709551615: UInt64.t)) ] s1
          | s1 = any [ br0 -> {_13 = false} (! bb6) | br1 -> {_13} (! bb3) ]  ]
        
        | bb3 = s0
          [ s0 =  [ &tmp <- l'0 ] s1
          | s1 = index {self'0.current} {l'0} (fun (_ret:UInt64.t) ->  [ &_17 <- _ret ] s2)
          | s2 = bb4 ]
        
        | bb4 = s0
          [ s0 =  [ &l'0 <- _17 ] s1
          | s1 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret:MutBorrow.t t_Memory) ->
                 [ &_22 <- _ret ] 
                 [ &self'0 <- { self'0 with current = _ret.final } ] 
                s2)
          | s2 = index_mut {_22} {tmp} (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_21 <- _ret ] s3)
          | s3 = bb5 ]
        
        | bb5 = s0
          [ s0 =  [ &_21 <- { _21 with current = r } ] s1
          | s1 = -{resolve'0 _21}- s2
          | s2 =  [ &r <- tmp ] s3
          | s3 = bb1'0 ]
         ]
       ]
    
    | bb6 = s0 [ s0 = -{resolve'2 self'0}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & r: UInt64.t = Any.any_l ()
    | & _13: bool = Any.any_l ()
    | & tmp: UInt64.t = Any.any_l ()
    | & _17: UInt64.t = Any.any_l ()
    | & _21: MutBorrow.t UInt64.t = Any.any_l ()
    | & _22: MutBorrow.t t_Memory = Any.any_l ()
    | & old_1_0: MutBorrow.t t_Memory = Any.any_l () ]
     [ return''0 (result:UInt64.t)-> (! return' {result}) ] 
end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_list [#"list_reversal_lasso.rs" 95 4 95 82] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 96 20 96 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 97 20 97 35
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 101 20 101 76
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 100 20 100 59
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 99 20 99 44
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 103 19 103 23
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 105 16 105 36
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 93 15 93 31
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 94 14 94 47
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 13 0 13 15
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 35 15 35 34
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 89 12 89 53
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  use creusot.int.UInt64
  use creusot.prelude.Opaque
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'16] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'17] index_logic self.t_Memory__0 i
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int)
  
   =
    [%#slist_reversal_lasso'8] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
     -> nonnull_ptr self (Seq.get s i)
    /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  
  constant v_NULL: UInt64.t = [%#slist_reversal_lasso'9] (18446744073709551615: UInt64.t)
  
  let rec index_mut (self:MutBorrow.t t_Memory) (i:UInt64.t) (return'  (x:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#slist_reversal_lasso'10] nonnull_ptr self.current i}
    any
    [ return''0 (result:MutBorrow.t UInt64.t)-> {[%#slist_reversal_lasso'11] result.current
      = index_logic'0 self.current i}
      {[%#slist_reversal_lasso'12] result.final = index_logic'0 self.final i}
      {[%#slist_reversal_lasso'13] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'14] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
       -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
  
  
  let rec replace (dest:MutBorrow.t UInt64.t) (src:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t UInt64.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t UInt64.t) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_Memory) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Memory) =
    resolve'1 _0
  
  predicate list [#"list_reversal_lasso.rs" 87 4 87 54] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'15] list_seg self first s v_NULL 0 (Seq.length s)
  
  meta "compute_max_steps" 1000000
  
  let rec list_reversal_list[#"list_reversal_lasso.rs" 95 4 95 82] (self:MutBorrow.t t_Memory) (l:UInt64.t) (s:Seq.seq UInt64.t) (return'  (x:UInt64.t))= {[@expl:list_reversal_list requires] [%#slist_reversal_lasso'6] list self.current l s}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso] (18446744073709551615: UInt64.t) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso'0] 0 ] s2
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &old_2_0 <- self'0 ] s1 | s1 = bb2 ] 
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:mut invariant] old_2_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'3] 0 <= n /\ n <= Seq.length s'0}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'2] list_seg self'0.current l'0 s'0 v_NULL n (Seq.length s'0)}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'1] list_seg self'0.current r (Reverse.reverse s'0) v_NULL (Seq.length s'0
        - n) (Seq.length s'0)}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 =  [ &_16 <- l'0 <> ([%#slist_reversal_lasso'4] (18446744073709551615: UInt64.t)) ] s1
          | s1 = any [ br0 -> {_16 = false} (! bb9) | br1 -> {_16} (! bb4) ]  ]
        
        | bb4 = s0
          [ s0 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret:MutBorrow.t t_Memory) ->
                 [ &_22 <- _ret ] 
                 [ &self'0 <- { self'0 with current = _ret.final } ] 
                s1)
          | s1 = index_mut {_22} {l'0} (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_21 <- _ret ] s2)
          | s2 = bb5 ]
        
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_21.current} {MutBorrow.get_id _21}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_20 <- _ret ]  [ &_21 <- { _21 with current = _ret.final } ] s1)
          | s1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_26 <- _ret ]  [ &r <- _ret.final ] s2)
          | s2 = MutBorrow.borrow_final <UInt64.t> {_26.current} {MutBorrow.get_id _26}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_25 <- _ret ]  [ &_26 <- { _26 with current = _ret.final } ] s3)
          | s3 = replace {_25} {l'0} (fun (_ret:UInt64.t) ->  [ &_24 <- _ret ] s4)
          | s4 = bb6 ]
        
        | bb6 = s0
          [ s0 = -{resolve'0 _26}- s1
          | s1 = MutBorrow.borrow_final <UInt64.t> {_20.current} {MutBorrow.get_id _20}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_19 <- _ret ]  [ &_20 <- { _20 with current = _ret.final } ] s2)
          | s2 = replace {_19} {_24} (fun (_ret:UInt64.t) ->  [ &_18 <- _ret ] s3)
          | s3 = bb7 ]
        
        | bb7 = s0
          [ s0 = -{resolve'0 _21}- s1
          | s1 = -{resolve'0 _20}- s2
          | s2 =  [ &l'0 <- _18 ] s3
          | s3 =  [ &_28 <- [%#slist_reversal_lasso'5] n + 1 ] s4
          | s4 = bb8 ]
        
        | bb8 = s0 [ s0 =  [ &n <- _28 ] s1 | s1 = bb2'0 ]  ]
       ]
    
    | bb9 = s0 [ s0 = -{resolve'2 self'0}- s1 | s1 =  [ &_0 <- r ] s2 | s2 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & s'0: Seq.seq UInt64.t = s
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _16: bool = Any.any_l ()
    | & _18: UInt64.t = Any.any_l ()
    | & _19: MutBorrow.t UInt64.t = Any.any_l ()
    | & _20: MutBorrow.t UInt64.t = Any.any_l ()
    | & _21: MutBorrow.t UInt64.t = Any.any_l ()
    | & _22: MutBorrow.t t_Memory = Any.any_l ()
    | & _24: UInt64.t = Any.any_l ()
    | & _25: MutBorrow.t UInt64.t = Any.any_l ()
    | & _26: MutBorrow.t UInt64.t = Any.any_l ()
    | & _28: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:list_reversal_list ensures] [%#slist_reversal_lasso'7] list self.final result (Reverse.reverse s)}
      (! return' {result}) ]

end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_loop [#"list_reversal_lasso.rs" 120 4 120 82] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 121 20 121 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 122 20 122 35
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 130 20 130 94
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 129 20 129 77
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 125 20 128 72
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 124 20 124 48
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 132 19 132 23
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 133 28 133 75
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 135 16 135 36
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 138 24 140 52
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 117 15 117 26
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 118 15 118 32
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 119 14 119 89
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 13 0 13 15
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 20 8 20 31
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 35 15 35 34
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'19 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'20 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'21 = "list_reversal_lasso.rs" 113 12 113 53
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 96 8 96 33
  let%span sindex'0 = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  let%span sseq = "../../creusot-contracts/src/logic/seq.rs" 247 8 247 27
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'14] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex'0] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'15] index_logic self.t_Memory__0 i
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int)
  
   =
    [%#slist_reversal_lasso'12] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
     -> nonnull_ptr self (Seq.get s i)
    /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  
  constant v_NULL: UInt64.t = [%#slist_reversal_lasso'13] (18446744073709551615: UInt64.t)
  
  function index_logic'1 [@inline:trivial] (self: Seq.seq UInt64.t) (ix: int) : UInt64.t =
    [%#sindex] Seq.get self ix
  
  let rec index_mut (self:MutBorrow.t t_Memory) (i:UInt64.t) (return'  (x:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#slist_reversal_lasso'16] nonnull_ptr self.current i}
    any
    [ return''0 (result:MutBorrow.t UInt64.t)-> {[%#slist_reversal_lasso'17] result.current
      = index_logic'0 self.current i}
      {[%#slist_reversal_lasso'18] result.final = index_logic'0 self.final i}
      {[%#slist_reversal_lasso'19] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'20] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
       -> index_logic'0 self.final j = index_logic'0 self.current j}
      (! return' {result}) ]
  
  
  let rec replace (dest:MutBorrow.t UInt64.t) (src:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t UInt64.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t UInt64.t) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_Memory) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Memory) =
    resolve'1 _0
  
  function push_front [@inline:trivial] (self: Seq.seq UInt64.t) (x: UInt64.t) : Seq.seq UInt64.t =
    [%#sseq] Seq.cons x self
  
  predicate loopqy95z [#"list_reversal_lasso.rs" 111 4 111 55] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t)
   =
    [%#slist_reversal_lasso'21] list_seg self first s (Seq.get s 0) 0 (Seq.length s)
  
  meta "compute_max_steps" 1000000
  
  let rec list_reversal_loop[#"list_reversal_lasso.rs" 120 4 120 82] (self:MutBorrow.t t_Memory) (l:UInt64.t) (s:Seq.seq UInt64.t) (return'  (x:UInt64.t))= {[@expl:list_reversal_loop requires #0] [%#slist_reversal_lasso'9] Seq.length s
    > 0}
    {[@expl:list_reversal_loop requires #1] [%#slist_reversal_lasso'10] loopqy95z self.current l s}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso] (18446744073709551615: UInt64.t) ] s1
      | s1 =  [ &n <- [%#slist_reversal_lasso'0] 0 ] s2
      | s2 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &old_2_0 <- self'0 ] s1 | s1 = bb2 ] 
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:mut invariant] old_2_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'4] 0 <= n /\ n <= Seq.length s'0 + 1}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'3] n = Seq.length s'0 + 1
         -> l'0 = v_NULL
        /\ r = index_logic'1 s'0 0
        /\ nonnull_ptr self'0.current r
        /\ index_logic'0 self'0.current r = index_logic'1 s'0 (Seq.length s'0 - 1)
        /\ list_seg self'0.current (index_logic'1 s'0 (Seq.length s'0
        - 1)) (Reverse.reverse s'0) (index_logic'1 s'0 0) 0 (Seq.length s'0 - 1)}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'2] n <= Seq.length s'0
         -> list_seg self'0.current l'0 s'0 (index_logic'1 s'0 0) n (Seq.length s'0)}
        {[@expl:loop invariant #3] [%#slist_reversal_lasso'1] n <= Seq.length s'0
         -> list_seg self'0.current r (Reverse.reverse s'0) v_NULL (Seq.length s'0 - n) (Seq.length s'0)}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 =  [ &_18 <- l'0 <> ([%#slist_reversal_lasso'5] (18446744073709551615: UInt64.t)) ] s1
          | s1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb4) ]  ]
        
        | bb4 = s0
          [ s0 = {[@expl:assertion] [%#slist_reversal_lasso'6] n = Seq.length s'0
             -> l'0 = Seq.get (Reverse.reverse s'0) (Seq.length s'0 - 1)}
            s1
          | s1 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret:MutBorrow.t t_Memory) ->
                 [ &_26 <- _ret ] 
                 [ &self'0 <- { self'0 with current = _ret.final } ] 
                s2)
          | s2 = index_mut {_26} {l'0} (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_25 <- _ret ] s3)
          | s3 = bb5 ]
        
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_25.current} {MutBorrow.get_id _25}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_24 <- _ret ]  [ &_25 <- { _25 with current = _ret.final } ] s1)
          | s1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_30 <- _ret ]  [ &r <- _ret.final ] s2)
          | s2 = MutBorrow.borrow_final <UInt64.t> {_30.current} {MutBorrow.get_id _30}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_29 <- _ret ]  [ &_30 <- { _30 with current = _ret.final } ] s3)
          | s3 = replace {_29} {l'0} (fun (_ret:UInt64.t) ->  [ &_28 <- _ret ] s4)
          | s4 = bb6 ]
        
        | bb6 = s0
          [ s0 = -{resolve'0 _30}- s1
          | s1 = MutBorrow.borrow_final <UInt64.t> {_24.current} {MutBorrow.get_id _24}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_23 <- _ret ]  [ &_24 <- { _24 with current = _ret.final } ] s2)
          | s2 = replace {_23} {_28} (fun (_ret:UInt64.t) ->  [ &_22 <- _ret ] s3)
          | s3 = bb7 ]
        
        | bb7 = s0
          [ s0 = -{resolve'0 _25}- s1
          | s1 = -{resolve'0 _24}- s2
          | s2 =  [ &l'0 <- _22 ] s3
          | s3 =  [ &_32 <- [%#slist_reversal_lasso'7] n + 1 ] s4
          | s4 = bb8 ]
        
        | bb8 = s0 [ s0 =  [ &n <- _32 ] s1 | s1 = bb2'0 ]  ]
       ]
    
    | bb9 = s0
      [ s0 = -{resolve'2 self'0}- s1
      | s1 = {[@expl:assertion] [%#slist_reversal_lasso'8] forall i: int. 0 <= i /\ i < Seq.length s'0
         -> Seq.get (push_front (Reverse.reverse (Seq.([..]) s'0 1 (Seq.length s'0))) (index_logic'1 s'0 0)) i
        = (if i = 0 then index_logic'1 s'0 0 else Seq.get (Reverse.reverse s'0) (i - 1))}
        s2
      | s2 =  [ &_0 <- r ] s3
      | s3 = return''0 {_0} ]
     ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & s'0: Seq.seq UInt64.t = s
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _22: UInt64.t = Any.any_l ()
    | & _23: MutBorrow.t UInt64.t = Any.any_l ()
    | & _24: MutBorrow.t UInt64.t = Any.any_l ()
    | & _25: MutBorrow.t UInt64.t = Any.any_l ()
    | & _26: MutBorrow.t t_Memory = Any.any_l ()
    | & _28: UInt64.t = Any.any_l ()
    | & _29: MutBorrow.t UInt64.t = Any.any_l ()
    | & _30: MutBorrow.t UInt64.t = Any.any_l ()
    | & _32: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:list_reversal_loop ensures] [%#slist_reversal_lasso'11] loopqy95z self.final result (push_front (Reverse.reverse (Seq.([..]) s 1 (Seq.length s))) (index_logic'1 s 0))}
      (! return' {result}) ]

end
module M_list_reversal_lasso__qyi2644757663130641572__list_reversal_lasso [#"list_reversal_lasso.rs" 157 4 162 12] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 163 20 163 24
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 164 20 164 35
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 178 12 178 82
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 173 20 176 74
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 168 12 168 73
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 166 20 166 58
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 184 19 184 23
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 186 16 186 36
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 155 15 155 38
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 156 14 156 54
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 13 0 13 15
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 35 15 35 34
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 36 14 36 47
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 37 14 37 47
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 38 14 38 47
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 39 14 39 111
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 147 12 147 73
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 96 8 96 33
  let%span sindex'0 = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  let%span sresolve = "../../creusot-contracts/src/resolve.rs" 49 20 49 34
  let%span smem = "../../creusot-contracts/src/std/mem.rs" 8 22 8 34
  let%span smem'0 = "../../creusot-contracts/src/std/mem.rs" 9 22 9 37
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  use creusot.prelude.Opaque
  use creusot.prelude.MutBorrow
  use seq.Reverse
  use creusot.prelude.Any
  
  function index_logic [@inline:trivial] (self: Seq.seq UInt64.t) (ix: int) : UInt64.t =
    [%#sindex] Seq.get self ix
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'17] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic'0 [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex'0] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'1 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'18] index_logic'0 self.t_Memory__0 i
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int)
  
   =
    [%#slist_reversal_lasso'9] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
     -> nonnull_ptr self (Seq.get s i)
    /\ index_logic'1 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  
  constant v_NULL: UInt64.t = [%#slist_reversal_lasso'10] (18446744073709551615: UInt64.t)
  
  let rec index_mut (self:MutBorrow.t t_Memory) (i:UInt64.t) (return'  (x:MutBorrow.t UInt64.t))= {[@expl:index_mut requires] [%#slist_reversal_lasso'11] nonnull_ptr self.current i}
    any
    [ return''0 (result:MutBorrow.t UInt64.t)-> {[%#slist_reversal_lasso'12] result.current
      = index_logic'1 self.current i}
      {[%#slist_reversal_lasso'13] result.final = index_logic'1 self.final i}
      {[%#slist_reversal_lasso'14] Seq.length (view (self.current).t_Memory__0)
      = Seq.length (view (self.final).t_Memory__0)}
      {[%#slist_reversal_lasso'15] forall j: UInt64.t. nonnull_ptr self.current j /\ i <> j
       -> index_logic'1 self.final j = index_logic'1 self.current j}
      (! return' {result}) ]
  
  
  let rec replace (dest:MutBorrow.t UInt64.t) (src:UInt64.t) (return'  (x:UInt64.t))= any
    [ return''0 (result:UInt64.t)-> {[%#smem] dest.final = src}
      {[%#smem'0] result = dest.current}
      (! return' {result}) ]
  
  
  predicate resolve (self: MutBorrow.t UInt64.t) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'0 (_0: MutBorrow.t UInt64.t) =
    resolve _0
  
  predicate resolve'1 (self: MutBorrow.t t_Memory) =
    [%#sresolve] self.final = self.current
  
  predicate resolve'2 (_0: MutBorrow.t t_Memory) =
    resolve'1 _0
  
  predicate lasso [#"list_reversal_lasso.rs" 145 4 145 70] (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t)
  
   =
    [%#slist_reversal_lasso'16] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
     -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  meta "compute_max_steps" 1000000
  
  let rec list_reversal_lasso[#"list_reversal_lasso.rs" 157 4 162 12] (self:MutBorrow.t t_Memory) (l:UInt64.t) (s1:Seq.seq UInt64.t) (s2:Seq.seq UInt64.t) (return'  (x:UInt64.t))= {[@expl:list_reversal_lasso requires] [%#slist_reversal_lasso'7] lasso self.current l s1 s2}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &r <- [%#slist_reversal_lasso] (18446744073709551615: UInt64.t) ] s1'1
      | s1'1 =  [ &n <- [%#slist_reversal_lasso'0] 0 ] s2'1
      | s2'1 = bb1 ]
    
    | bb1 = s0 [ s0 =  [ &old_2_0 <- self'0 ] s1'1 | s1'1 = bb2 ] 
    | bb2 = bb2'0
      [ bb2'0 = {[@expl:mut invariant] old_2_0.final = self'0.final}
        {[@expl:loop invariant #0] [%#slist_reversal_lasso'4] 0 <= n /\ n <= 2 * Seq.length s1'0 + Seq.length s2'0}
        {[@expl:loop invariant #1] [%#slist_reversal_lasso'3] let mid = if Seq.length s2'0 = 0 then
          index_logic s1'0 (Seq.length s1'0 - 1)
        else
          index_logic s2'0 0
         in n <= Seq.length s1'0
         -> list_seg self'0.current l'0 s1'0 mid n (Seq.length s1'0)
        /\ list_seg self'0.current mid s2'0 (index_logic s1'0 (Seq.length s1'0 - 1)) 0 (Seq.length s2'0)
        /\ list_seg self'0.current r (Reverse.reverse s1'0) v_NULL (Seq.length s1'0 - n) (Seq.length s1'0)}
        {[@expl:loop invariant #2] [%#slist_reversal_lasso'2] Seq.length s1'0 < n
        /\ n <= Seq.length s1'0 + Seq.length s2'0
         -> list_seg self'0.current l'0 s2'0 (index_logic s1'0 (Seq.length s1'0 - 1)) (n
        - Seq.length s1'0) (Seq.length s2'0)
        /\ list_seg self'0.current r (Reverse.reverse s2'0) (index_logic s1'0 (Seq.length s1'0 - 1)) (Seq.length s1'0
        + Seq.length s2'0
        - n) (Seq.length s2'0)
        /\ list_seg self'0.current (index_logic s1'0 (Seq.length s1'0
        - 1)) (Reverse.reverse s1'0) v_NULL 0 (Seq.length s1'0)}
        {[@expl:loop invariant #3] [%#slist_reversal_lasso'1] let mid = if Seq.length s2'0 = 0 then
          index_logic s1'0 (Seq.length s1'0 - 1)
        else
          index_logic s2'0 (Seq.length s2'0 - 1)
         in Seq.length s1'0 + Seq.length s2'0 < n
         -> list_seg self'0.current l'0 (Reverse.reverse s1'0) v_NULL (n - Seq.length s1'0
        - Seq.length s2'0) (Seq.length s1'0)
        /\ list_seg self'0.current r s1'0 mid (2 * Seq.length s1'0 + Seq.length s2'0 - n) (Seq.length s1'0)
        /\ list_seg self'0.current mid (Reverse.reverse s2'0) (index_logic s1'0 (Seq.length s1'0
        - 1)) 0 (Seq.length s2'0)}
        (! s0) [ s0 = bb3 ] 
        [ bb3 = s0
          [ s0 =  [ &_18 <- l'0 <> ([%#slist_reversal_lasso'5] (18446744073709551615: UInt64.t)) ] s1'1
          | s1'1 = any [ br0 -> {_18 = false} (! bb9) | br1 -> {_18} (! bb4) ]  ]
        
        | bb4 = s0
          [ s0 = MutBorrow.borrow_mut <t_Memory> {self'0.current}
              (fun (_ret:MutBorrow.t t_Memory) ->
                 [ &_24 <- _ret ] 
                 [ &self'0 <- { self'0 with current = _ret.final } ] 
                s1'1)
          | s1'1 = index_mut {_24} {l'0} (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_23 <- _ret ] s2'1)
          | s2'1 = bb5 ]
        
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <UInt64.t> {_23.current} {MutBorrow.get_id _23}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_22 <- _ret ]  [ &_23 <- { _23 with current = _ret.final } ] s1'1)
          | s1'1 = MutBorrow.borrow_mut <UInt64.t> {r}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_28 <- _ret ]  [ &r <- _ret.final ] s2'1)
          | s2'1 = MutBorrow.borrow_final <UInt64.t> {_28.current} {MutBorrow.get_id _28}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_27 <- _ret ]  [ &_28 <- { _28 with current = _ret.final } ] s3)
          | s3 = replace {_27} {l'0} (fun (_ret:UInt64.t) ->  [ &_26 <- _ret ] s4)
          | s4 = bb6 ]
        
        | bb6 = s0
          [ s0 = -{resolve'0 _28}- s1'1
          | s1'1 = MutBorrow.borrow_final <UInt64.t> {_22.current} {MutBorrow.get_id _22}
              (fun (_ret:MutBorrow.t UInt64.t) ->  [ &_21 <- _ret ]  [ &_22 <- { _22 with current = _ret.final } ] s2'1)
          | s2'1 = replace {_21} {_26} (fun (_ret:UInt64.t) ->  [ &_20 <- _ret ] s3)
          | s3 = bb7 ]
        
        | bb7 = s0
          [ s0 = -{resolve'0 _23}- s1'1
          | s1'1 = -{resolve'0 _22}- s2'1
          | s2'1 =  [ &l'0 <- _20 ] s3
          | s3 =  [ &_30 <- [%#slist_reversal_lasso'6] n + 1 ] s4
          | s4 = bb8 ]
        
        | bb8 = s0 [ s0 =  [ &n <- _30 ] s1'1 | s1'1 = bb2'0 ]  ]
       ]
    
    | bb9 = s0 [ s0 = -{resolve'2 self'0}- s1'1 | s1'1 =  [ &_0 <- r ] s2'1 | s2'1 = return''0 {_0} ]  ]
    )
    [ & _0: UInt64.t = Any.any_l ()
    | & self'0: MutBorrow.t t_Memory = self
    | & l'0: UInt64.t = l
    | & s1'0: Seq.seq UInt64.t = s1
    | & s2'0: Seq.seq UInt64.t = s2
    | & r: UInt64.t = Any.any_l ()
    | & n: int = Any.any_l ()
    | & _18: bool = Any.any_l ()
    | & _20: UInt64.t = Any.any_l ()
    | & _21: MutBorrow.t UInt64.t = Any.any_l ()
    | & _22: MutBorrow.t UInt64.t = Any.any_l ()
    | & _23: MutBorrow.t UInt64.t = Any.any_l ()
    | & _24: MutBorrow.t t_Memory = Any.any_l ()
    | & _26: UInt64.t = Any.any_l ()
    | & _27: MutBorrow.t UInt64.t = Any.any_l ()
    | & _28: MutBorrow.t UInt64.t = Any.any_l ()
    | & _30: int = Any.any_l ()
    | & old_2_0: MutBorrow.t t_Memory = Any.any_l () ]
    
    [ return''0 (result:UInt64.t)-> {[@expl:list_reversal_lasso ensures] [%#slist_reversal_lasso'8] lasso self.final result s1 (Reverse.reverse s2)}
      (! return' {result}) ]

end
module M_list_reversal_lasso__qyi2644757663130641572__find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 200 12 202 53
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Option  =
    | C_None
    | C_Some int
  
  constant s  : Seq.seq UInt64.t
  
  constant i  : int
  
  constant p  : int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s'0: Seq.seq UInt64.t) (i'0: int) (p'0: int) : t_Option
  
  
  goal vc_find_ptr_in_seq: ([%#slist_reversal_lasso] 0 <= i /\ i <= Seq.length s)
   -> (if i = Seq.length s then
    [%#slist_reversal_lasso'0] match C_None with
      | C_None -> forall j: int. i <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> p
      | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
      end
  else
    if UInt64.t'int (Seq.get s i) = p then
      [%#slist_reversal_lasso'0] match C_Some i with
        | C_None -> forall j: int. i <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> p
        | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end
    else
      (([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso] 0 <= i + 1 /\ i + 1 <= Seq.length s)
      /\ 0 <= ([%#slist_reversal_lasso'1] Seq.length s - i)
      /\ ([%#slist_reversal_lasso'1] Seq.length s - (i + 1)) < ([%#slist_reversal_lasso'1] Seq.length s - i))
      /\ (([%#slist_reversal_lasso'0] match find_ptr_in_seq s (i + 1) p with
        | C_None -> forall j: int. i + 1 <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> p
        | C_Some j -> i + 1 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end)
       -> ([%#slist_reversal_lasso'0] match find_ptr_in_seq s (i + 1) p with
        | C_None -> forall j: int. i <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> p
        | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
        end))
  
  )
end
module M_list_reversal_lasso__qyi2644757663130641572__pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 207 15 207 21
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 208 15 208 60
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 209 15 209 101
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 210 14 210 26
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 211 14 211 20
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 212 14 212 15
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 215 12 225 13
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 200 12 202 53
  
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_Option  =
    | C_None
    | C_Some int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'5] 0 <= i
  /\ i <= Seq.length s)
   -> find_ptr_in_seq s i p
  = ([%#slist_reversal_lasso'9] if i = Seq.length s then
    C_None
  else
    if UInt64.t'int (Seq.get s i) = p then C_Some i else find_ptr_in_seq s (i + 1) p
  )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'5] 0 <= i
  /\ i <= Seq.length s)
   -> ([%#slist_reversal_lasso'6] match find_ptr_in_seq s i p with
    | C_None -> forall j: int. i <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> p
    | C_Some j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
    end)
  
  constant s  : Seq.seq UInt64.t
  
  constant n  : int
  
  predicate pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (s'0: Seq.seq UInt64.t) (n'0: int)
  
  goal vc_pigeon: ([%#slist_reversal_lasso] 0 <= n)
   -> ([%#slist_reversal_lasso'0] forall i: int. 0 <= i /\ i < Seq.length s  -> UInt64.t'int (Seq.get s i) < n)
   -> ([%#slist_reversal_lasso'1] forall i: int, j: int. 0 <= i
  /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
   -> (if n = 0 then
    ([%#slist_reversal_lasso'2] Seq.length s <= n) && ([%#slist_reversal_lasso'3] true)
  else
    ([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso'5] 0 <= 0 /\ 0 <= Seq.length s)
    /\ (([%#slist_reversal_lasso'6] match find_ptr_in_seq s 0 (n - 1) with
      | C_None -> forall j: int. 0 <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> n - 1
      | C_Some j -> 0 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = n - 1
      end)
     -> match find_ptr_in_seq s 0 (n - 1) with
      | C_None -> ((([@expl:pigeon requires #0] [%#slist_reversal_lasso] 0 <= n - 1)
      && ([@expl:pigeon requires #1] [%#slist_reversal_lasso'0] forall i: int. 0 <= i /\ i < Seq.length s
       -> UInt64.t'int (Seq.get s i) < n - 1)
      && ([@expl:pigeon requires #2] [%#slist_reversal_lasso'1] forall i: int, j: int. 0 <= i
      /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j))
      /\ 0 <= ([%#slist_reversal_lasso'4] n) /\ ([%#slist_reversal_lasso'4] n - 1) < ([%#slist_reversal_lasso'4] n))
      /\ (([%#slist_reversal_lasso'2] Seq.length s <= n - 1) && ([%#slist_reversal_lasso'3] pigeon s (n - 1))
       -> ([%#slist_reversal_lasso'2] Seq.length s <= n) && ([%#slist_reversal_lasso'3] pigeon s (n - 1)))
      | C_Some i -> ([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso'5] 0 <= i + 1 /\ i + 1 <= Seq.length s)
      /\ (([%#slist_reversal_lasso'6] match find_ptr_in_seq s (i + 1) (n - 1) with
        | C_None -> forall j: int. i + 1 <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> n - 1
        | C_Some j -> i + 1 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = n - 1
        end)
       -> match find_ptr_in_seq s (i + 1) (n - 1) with
        | C_None -> ((([@expl:pigeon requires #0] [%#slist_reversal_lasso] 0 <= n - 1)
        && ([@expl:pigeon requires #1] [%#slist_reversal_lasso'0] forall i'0: int. 0 <= i'0
        /\ i'0 < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
         -> UInt64.t'int (Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) i'0) < n - 1)
        && ([@expl:pigeon requires #2] [%#slist_reversal_lasso'1] forall i'0: int, j: int. 0 <= i'0
        /\ i'0 < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
        /\ 0 <= j /\ j < Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) /\ i'0 <> j
         -> Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) i'0
        <> Seq.get (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) j))
        /\ 0 <= ([%#slist_reversal_lasso'4] n) /\ ([%#slist_reversal_lasso'4] n - 1) < ([%#slist_reversal_lasso'4] n))
        /\ (([%#slist_reversal_lasso'2] Seq.length (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s)))
        <= n - 1)
        && ([%#slist_reversal_lasso'3] pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n
        - 1))
         -> ([%#slist_reversal_lasso'2] Seq.length s <= n)
        && ([%#slist_reversal_lasso'3] pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n
        - 1)))
        | C_Some _ -> ([%#slist_reversal_lasso'2] Seq.length s <= n) && ([%#slist_reversal_lasso'3] true)
        end)
      end)
  )
end
module M_list_reversal_lasso__qyi2644757663130641572__find_lasso_aux [#"list_reversal_lasso.rs" 238 4 238 95] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 230 15 230 40
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 231 15 231 53
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 232 15 232 56
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 233 14 236 5
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 237 14 237 37
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 207 15 207 21
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 208 15 208 60
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 209 15 209 101
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 210 14 210 26
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 211 14 211 20
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 212 14 212 15
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 240 12 252 13
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 54 12 54 95
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 13 0 13 15
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 89 12 89 53
  let%span slist_reversal_lasso'19 = "list_reversal_lasso.rs" 147 12 147 73
  let%span slist_reversal_lasso'20 = "list_reversal_lasso.rs" 200 12 202 53
  let%span slist_reversal_lasso'21 = "list_reversal_lasso.rs" 215 12 225 13
  let%span slist_reversal_lasso'22 = "list_reversal_lasso.rs" 20 8 20 31
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  type t_Option  =
    | C_None
    | C_Some (Seq.seq UInt64.t)
  
  type tuple  =
    { _p0: Seq.seq UInt64.t; _p1: t_Option }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'16] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'22] index_logic self.t_Memory__0 i
  
  constant v_NULL: UInt64.t = [%#slist_reversal_lasso'15] (18446744073709551615: UInt64.t)
  
  predicate mem_is_well_formed [#"list_reversal_lasso.rs" 52 4 52 43] (self: t_Memory) =
    [%#slist_reversal_lasso'14] forall i: UInt64.t. nonnull_ptr self i
     -> index_logic'0 self i = v_NULL \/ nonnull_ptr self (index_logic'0 self i)
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int)
  
   =
    [%#slist_reversal_lasso'17] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
     -> nonnull_ptr self (Seq.get s i)
    /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  
  predicate list [#"list_reversal_lasso.rs" 87 4 87 54] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'18] list_seg self first s v_NULL 0 (Seq.length s)
  
  predicate lasso [#"list_reversal_lasso.rs" 145 4 145 70] (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t)
  
   =
    [%#slist_reversal_lasso'19] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
     -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option'0
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'4] 0 <= i
  /\ i <= Seq.length s)
   -> find_ptr_in_seq s i p
  = ([%#slist_reversal_lasso'20] if i = Seq.length s then
    C_None'0
  else
    if UInt64.t'int (Seq.get s i) = p then C_Some'0 i else find_ptr_in_seq s (i + 1) p
  )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'4] 0 <= i
  /\ i <= Seq.length s)
   -> ([%#slist_reversal_lasso'5] match find_ptr_in_seq s i p with
    | C_None'0 -> forall j: int. i <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> p
    | C_Some'0 j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
    end)
  
  predicate pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (s: Seq.seq UInt64.t) (n: int)
  
  axiom pigeon_def: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'7] 0 <= n)
   -> ([%#slist_reversal_lasso'8] forall i: int. 0 <= i /\ i < Seq.length s  -> UInt64.t'int (Seq.get s i) < n)
   -> ([%#slist_reversal_lasso'9] forall i: int, j: int. 0 <= i
  /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
   -> pigeon s n
  = ([%#slist_reversal_lasso'21] if n = 0 then
    true
  else
    match find_ptr_in_seq s 0 (n - 1) with
      | C_None'0 -> pigeon s (n - 1)
      | C_Some'0 i -> match find_ptr_in_seq s (i + 1) (n - 1) with
        | C_None'0 -> pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n - 1)
        | C_Some'0 _ -> true
        end
      end
  )
  
  axiom pigeon_spec: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'7] 0 <= n)
   -> ([%#slist_reversal_lasso'8] forall i: int. 0 <= i /\ i < Seq.length s  -> UInt64.t'int (Seq.get s i) < n)
   -> ([%#slist_reversal_lasso'9] forall i: int, j: int. 0 <= i
  /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
   -> ([%#slist_reversal_lasso'10] Seq.length s <= n) && ([%#slist_reversal_lasso'11] pigeon s n)
  
  constant self  : t_Memory
  
  constant first  : UInt64.t
  
  constant last  : UInt64.t
  
  constant s  : Seq.seq UInt64.t
  
  function find_lasso_aux [#"list_reversal_lasso.rs" 238 4 238 95] (self'0: t_Memory) (first'0: UInt64.t) (last'0: UInt64.t) (s'0: Seq.seq UInt64.t) : tuple
  
  
  goal vc_find_lasso_aux: ([%#slist_reversal_lasso] mem_is_well_formed self)
   -> ([%#slist_reversal_lasso'0] last = v_NULL \/ nonnull_ptr self last)
   -> ([%#slist_reversal_lasso'1] list_seg self first s last 0 (Seq.length s))
   -> (if last = v_NULL then
    [%#slist_reversal_lasso'2] match { _p0 = s; _p1 = C_None } with
      | {_p0 = s'0 ; _p1 = C_None} -> list self first s'0
      | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
      end
  else
    ([@expl:find_ptr_in_seq requires] [%#slist_reversal_lasso'4] 0 <= 0 /\ 0 <= Seq.length s)
    /\ (([%#slist_reversal_lasso'5] match find_ptr_in_seq s 0 (UInt64.t'int last) with
      | C_None'0 -> forall j: int. 0 <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> UInt64.t'int last
      | C_Some'0 j -> 0 <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = UInt64.t'int last
      end)
     -> match find_ptr_in_seq s 0 (UInt64.t'int last) with
      | C_None'0 -> ([%#svec] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t))
       -> (([@expl:pigeon requires #0] [%#slist_reversal_lasso'7] 0 <= Seq.length (view self.t_Memory__0))
      && ([@expl:pigeon requires #1] [%#slist_reversal_lasso'8] forall i: int. 0 <= i /\ i < Seq.length s
       -> UInt64.t'int (Seq.get s i) < Seq.length (view self.t_Memory__0))
      && ([@expl:pigeon requires #2] [%#slist_reversal_lasso'9] forall i: int, j: int. 0 <= i
      /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j))
      /\ (([%#slist_reversal_lasso'10] Seq.length s <= Seq.length (view self.t_Memory__0))
      && ([%#slist_reversal_lasso'11] pigeon s (Seq.length (view self.t_Memory__0)))
       -> (if pigeon s (Seq.length (view self.t_Memory__0)) then
        ((([@expl:find_lasso_aux requires #0] [%#slist_reversal_lasso] mem_is_well_formed self)
        && ([@expl:find_lasso_aux requires #1] [%#slist_reversal_lasso'0] index_logic'0 self last = v_NULL
        \/ nonnull_ptr self (index_logic'0 self last))
        && ([@expl:find_lasso_aux requires #2] [%#slist_reversal_lasso'1] list_seg self first (Seq.snoc s last) (index_logic'0 self last) 0 (Seq.length (Seq.snoc s last))))
        /\ 0 <= ([%#slist_reversal_lasso'3] Seq.length (view self.t_Memory__0) - Seq.length s)
        /\ ([%#slist_reversal_lasso'3] Seq.length (view self.t_Memory__0) - Seq.length (Seq.snoc s last))
        < ([%#slist_reversal_lasso'3] Seq.length (view self.t_Memory__0) - Seq.length s))
        /\ (([%#slist_reversal_lasso'2] match find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last) with
          | {_p0 = s'0 ; _p1 = C_None} -> list self first s'0
          | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
          end)
         -> ([%#slist_reversal_lasso'2] match find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last) with
          | {_p0 = s'0 ; _p1 = C_None} -> list self first s'0
          | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
          end))
      else
        [%#slist_reversal_lasso'2] match { _p0 = s; _p1 = C_None } with
          | {_p0 = s'0 ; _p1 = C_None} -> list self first s'0
          | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
          end
      ))
      | C_Some'0 i -> [%#slist_reversal_lasso'2] match { _p0 = Seq.([..]) s 0 (i + 1);
                                                         _p1 = C_Some (Seq.([..]) s (i + 1) (Seq.length s)) } with
        | {_p0 = s'0 ; _p1 = C_None} -> list self first s'0
        | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
        end
      end)
  )
end
module M_list_reversal_lasso__qyi2644757663130641572__find_lasso [#"list_reversal_lasso.rs" 263 4 263 71] (* Memory *)
  let%span slist_reversal_lasso = "list_reversal_lasso.rs" 257 15 257 40
  let%span slist_reversal_lasso'0 = "list_reversal_lasso.rs" 258 15 258 55
  let%span slist_reversal_lasso'1 = "list_reversal_lasso.rs" 259 14 262 5
  let%span slist_reversal_lasso'2 = "list_reversal_lasso.rs" 230 15 230 40
  let%span slist_reversal_lasso'3 = "list_reversal_lasso.rs" 231 15 231 53
  let%span slist_reversal_lasso'4 = "list_reversal_lasso.rs" 232 15 232 56
  let%span slist_reversal_lasso'5 = "list_reversal_lasso.rs" 233 14 236 5
  let%span slist_reversal_lasso'6 = "list_reversal_lasso.rs" 237 14 237 37
  let%span slist_reversal_lasso'7 = "list_reversal_lasso.rs" 265 13 265 65
  let%span slist_reversal_lasso'8 = "list_reversal_lasso.rs" 54 12 54 95
  let%span slist_reversal_lasso'9 = "list_reversal_lasso.rs" 13 0 13 15
  let%span slist_reversal_lasso'10 = "list_reversal_lasso.rs" 48 20 48 70
  let%span slist_reversal_lasso'11 = "list_reversal_lasso.rs" 89 12 89 53
  let%span slist_reversal_lasso'12 = "list_reversal_lasso.rs" 147 12 147 73
  let%span slist_reversal_lasso'13 = "list_reversal_lasso.rs" 240 12 252 13
  let%span slist_reversal_lasso'14 = "list_reversal_lasso.rs" 80 12 82 88
  let%span slist_reversal_lasso'15 = "list_reversal_lasso.rs" 20 8 20 31
  let%span slist_reversal_lasso'16 = "list_reversal_lasso.rs" 192 15 192 37
  let%span slist_reversal_lasso'17 = "list_reversal_lasso.rs" 193 14 196 5
  let%span slist_reversal_lasso'18 = "list_reversal_lasso.rs" 197 14 197 25
  let%span slist_reversal_lasso'19 = "list_reversal_lasso.rs" 200 12 202 53
  let%span slist_reversal_lasso'20 = "list_reversal_lasso.rs" 207 15 207 21
  let%span slist_reversal_lasso'21 = "list_reversal_lasso.rs" 208 15 208 60
  let%span slist_reversal_lasso'22 = "list_reversal_lasso.rs" 209 15 209 101
  let%span slist_reversal_lasso'23 = "list_reversal_lasso.rs" 210 14 210 26
  let%span slist_reversal_lasso'24 = "list_reversal_lasso.rs" 211 14 211 20
  let%span slist_reversal_lasso'25 = "list_reversal_lasso.rs" 212 14 212 15
  let%span slist_reversal_lasso'26 = "list_reversal_lasso.rs" 215 12 225 13
  let%span svec = "../../creusot-contracts/src/std/vec.rs" 21 14 21 41
  let%span sindex = "../../creusot-contracts/src/logic/ops/index.rs" 41 8 41 32
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use seq.Seq
  use mach.int.Int
  
  type t_NonNull  =
    { t_NonNull__pointer: Opaque.ptr }
  
  type t_Unique  =
    { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }
  
  type t_UsizeNoHighBit  =
    { t_UsizeNoHighBit__0: UInt64.t }
  
  type t_RawVecInner  =
    { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }
  
  type t_RawVec  =
    { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }
  
  type t_Vec  =
    { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }
  
  type t_Memory  =
    { t_Memory__0: t_Vec }
  
  type t_Option  =
    | C_None
    | C_Some (Seq.seq UInt64.t)
  
  type tuple  =
    { _p0: Seq.seq UInt64.t; _p1: t_Option }
  
  constant v_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view (self: t_Vec) : Seq.seq UInt64.t
  
  axiom view_spec: forall self: t_Vec. [%#svec] Seq.length (view self) <= UInt64.t'int (v_MAX: UInt64.t)
  
  predicate nonnull_ptr [#"list_reversal_lasso.rs" 47 4 47 44] (self: t_Memory) (i: UInt64.t) =
    [%#slist_reversal_lasso'10] Seq.length (view self.t_Memory__0) <= UInt64.t'int (v_MAX: UInt64.t)
    /\ UInt64.t'int i < Seq.length (view self.t_Memory__0)
  
  function index_logic [@inline:trivial] (self: t_Vec) (ix: UInt64.t) : UInt64.t =
    [%#sindex] Seq.get (view self) (UInt64.t'int ix)
  
  function index_logic'0 [#"list_reversal_lasso.rs" 19 4 19 39] (self: t_Memory) (i: UInt64.t) : UInt64.t =
    [%#slist_reversal_lasso'15] index_logic self.t_Memory__0 i
  
  constant v_NULL: UInt64.t = [%#slist_reversal_lasso'9] (18446744073709551615: UInt64.t)
  
  predicate mem_is_well_formed [#"list_reversal_lasso.rs" 52 4 52 43] (self: t_Memory) =
    [%#slist_reversal_lasso'8] forall i: UInt64.t. nonnull_ptr self i
     -> index_logic'0 self i = v_NULL \/ nonnull_ptr self (index_logic'0 self i)
  
  predicate list_seg [#"list_reversal_lasso.rs" 78 4 78 81] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) (last: UInt64.t) (l: int) (h: int)
  
   =
    [%#slist_reversal_lasso'14] first = (if h = l then last else Seq.get s l)
    /\ (forall i: int. l <= i /\ i < h
     -> nonnull_ptr self (Seq.get s i)
    /\ index_logic'0 self (Seq.get s i) = (if i = h - 1 then last else Seq.get s (i + 1)))
    /\ (forall i: int, j: int. l <= i /\ i < h /\ l <= j /\ j < h /\ i <> j  -> Seq.get s i <> Seq.get s j)
  
  predicate list [#"list_reversal_lasso.rs" 87 4 87 54] (self: t_Memory) (first: UInt64.t) (s: Seq.seq UInt64.t) =
    [%#slist_reversal_lasso'11] list_seg self first s v_NULL 0 (Seq.length s)
  
  predicate lasso [#"list_reversal_lasso.rs" 145 4 145 70] (self: t_Memory) (first: UInt64.t) (s1: Seq.seq UInt64.t) (s2: Seq.seq UInt64.t)
  
   =
    [%#slist_reversal_lasso'12] let mid = if Seq.length s2 = 0 then
      Seq.get s1 (Seq.length s1 - 1)
    else
      Seq.get s2 0
     in Seq.length s1 > 0
    /\ (forall i: int, j: int. 0 <= i /\ i < Seq.length s1 /\ 0 <= j /\ j < Seq.length s2
     -> Seq.get s1 i <> Seq.get s2 j)
    /\ list_seg self first s1 mid 0 (Seq.length s1)
    /\ list_seg self mid s2 (Seq.get s1 (Seq.length s1 - 1)) 0 (Seq.length s2)
  
  type t_Option'0  =
    | C_None'0
    | C_Some'0 int
  
  function find_ptr_in_seq [#"list_reversal_lasso.rs" 198 4 198 66] (s: Seq.seq UInt64.t) (i: int) (p: int) : t_Option'0
  
  axiom find_ptr_in_seq_def: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'16] 0 <= i
  /\ i <= Seq.length s)
   -> find_ptr_in_seq s i p
  = ([%#slist_reversal_lasso'19] if i = Seq.length s then
    C_None'0
  else
    if UInt64.t'int (Seq.get s i) = p then C_Some'0 i else find_ptr_in_seq s (i + 1) p
  )
  
  axiom find_ptr_in_seq_spec: forall s: Seq.seq UInt64.t, i: int, p: int. ([%#slist_reversal_lasso'16] 0 <= i
  /\ i <= Seq.length s)
   -> ([%#slist_reversal_lasso'17] match find_ptr_in_seq s i p with
    | C_None'0 -> forall j: int. i <= j /\ j < Seq.length s  -> UInt64.t'int (Seq.get s j) <> p
    | C_Some'0 j -> i <= j /\ j < Seq.length s /\ UInt64.t'int (Seq.get s j) = p
    end)
  
  predicate pigeon [#"list_reversal_lasso.rs" 213 4 213 42] (s: Seq.seq UInt64.t) (n: int)
  
  axiom pigeon_def: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'20] 0 <= n)
   -> ([%#slist_reversal_lasso'21] forall i: int. 0 <= i /\ i < Seq.length s  -> UInt64.t'int (Seq.get s i) < n)
   -> ([%#slist_reversal_lasso'22] forall i: int, j: int. 0 <= i
  /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
   -> pigeon s n
  = ([%#slist_reversal_lasso'26] if n = 0 then
    true
  else
    match find_ptr_in_seq s 0 (n - 1) with
      | C_None'0 -> pigeon s (n - 1)
      | C_Some'0 i -> match find_ptr_in_seq s (i + 1) (n - 1) with
        | C_None'0 -> pigeon (Seq.(++) (Seq.([..]) s 0 i) (Seq.([..]) s (i + 1) (Seq.length s))) (n - 1)
        | C_Some'0 _ -> true
        end
      end
  )
  
  axiom pigeon_spec: forall s: Seq.seq UInt64.t, n: int. ([%#slist_reversal_lasso'20] 0 <= n)
   -> ([%#slist_reversal_lasso'21] forall i: int. 0 <= i /\ i < Seq.length s  -> UInt64.t'int (Seq.get s i) < n)
   -> ([%#slist_reversal_lasso'22] forall i: int, j: int. 0 <= i
  /\ i < Seq.length s /\ 0 <= j /\ j < Seq.length s /\ i <> j  -> Seq.get s i <> Seq.get s j)
   -> ([%#slist_reversal_lasso'23] Seq.length s <= n) && ([%#slist_reversal_lasso'24] pigeon s n)
  
  function find_lasso_aux [#"list_reversal_lasso.rs" 238 4 238 95] (self: t_Memory) (first: UInt64.t) (last: UInt64.t) (s: Seq.seq UInt64.t) : tuple
  
  
  axiom find_lasso_aux_def: forall self: t_Memory, first: UInt64.t, last: UInt64.t, s: Seq.seq UInt64.t. ([%#slist_reversal_lasso'2] mem_is_well_formed self)
   -> ([%#slist_reversal_lasso'3] last = v_NULL \/ nonnull_ptr self last)
   -> ([%#slist_reversal_lasso'4] list_seg self first s last 0 (Seq.length s))
   -> find_lasso_aux self first last s
  = ([%#slist_reversal_lasso'13] if last = v_NULL then
    { _p0 = s; _p1 = C_None }
  else
    match find_ptr_in_seq s 0 (UInt64.t'int last) with
      | C_None'0 -> if pigeon s (Seq.length (view self.t_Memory__0)) then
        find_lasso_aux self first (index_logic'0 self last) (Seq.snoc s last)
      else
        { _p0 = s; _p1 = C_None }
      
      | C_Some'0 i -> { _p0 = Seq.([..]) s 0 (i + 1); _p1 = C_Some (Seq.([..]) s (i + 1) (Seq.length s)) }
      end
  )
  
  axiom find_lasso_aux_spec: forall self: t_Memory, first: UInt64.t, last: UInt64.t, s: Seq.seq UInt64.t. ([%#slist_reversal_lasso'2] mem_is_well_formed self)
   -> ([%#slist_reversal_lasso'3] last = v_NULL \/ nonnull_ptr self last)
   -> ([%#slist_reversal_lasso'4] list_seg self first s last 0 (Seq.length s))
   -> ([%#slist_reversal_lasso'5] match find_lasso_aux self first last s with
    | {_p0 = s'0 ; _p1 = C_None} -> list self first s'0
    | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
    end)
  
  constant self  : t_Memory
  
  constant first  : UInt64.t
  
  function find_lasso [#"list_reversal_lasso.rs" 263 4 263 71] (self'0: t_Memory) (first'0: UInt64.t) : tuple
  
  goal vc_find_lasso: ([%#slist_reversal_lasso] mem_is_well_formed self)
   -> ([%#slist_reversal_lasso'0] first = v_NULL \/ nonnull_ptr self first)
   -> (([@expl:find_lasso_aux requires #0] [%#slist_reversal_lasso'2] mem_is_well_formed self)
  && ([@expl:find_lasso_aux requires #1] [%#slist_reversal_lasso'3] first = v_NULL \/ nonnull_ptr self first)
  && ([@expl:find_lasso_aux requires #2] [%#slist_reversal_lasso'4] list_seg self first (Seq.empty: Seq.seq UInt64.t) first 0 (Seq.length (Seq.empty: Seq.seq UInt64.t))))
  /\ (([%#slist_reversal_lasso'5] match find_lasso_aux self first first (Seq.empty: Seq.seq UInt64.t) with
    | {_p0 = s ; _p1 = C_None} -> list self first s
    | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
    end)
   -> ([%#slist_reversal_lasso'1] match find_lasso_aux self first first (Seq.empty: Seq.seq UInt64.t) with
    | {_p0 = s ; _p1 = C_None} -> list self first s
    | {_p0 = s1 ; _p1 = C_Some s2} -> lasso self first s1 s2
    end))
end
