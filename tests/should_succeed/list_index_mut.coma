module M_index_mut
  use mach.int.Int
  use creusot.int.UInt32
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_Option_Box_List_Global = None | Some t_List
  with t_List = { f0: UInt32.t; f1: t_Option_Box_List_Global }
  
  function len (self: t_List) : int = let {f0 = _; f1 = ls} = self in 1
    + match ls with
      | Some ls'0 -> len ls'0
      | None -> 0
      end
  
  type t_Option_u32 = None'0 | Some'0 UInt32.t
  
  function get (self: t_List) (ix: int) : t_Option_u32 = let {f0 = i; f1 = ls} = self in if ix > 0 then
      match ls with
        | Some ls'0 -> get ls'0 (ix - 1)
        | None -> None'0
        end
    else
      Some'0 i
  
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  type t_Option_ref_Box_List_Global = None'1 | Some'1 (MutBorrow.t t_List)
  
  let rec as_mut_Box_List_Global (self_: MutBorrow.t t_Option_Box_List_Global)
    (return (x: t_Option_ref_Box_List_Global)) = any
    [ return (result: t_Option_ref_Box_List_Global) -> {self_.current = None -> result = None'1 /\ self_.final = None}
      {self_.current = None
      \/ (exists r: MutBorrow.t t_List. result = Some'1 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final))}
      (! return {result}) ]
  
  let rec unwrap_ref_Box_List_Global (self_: t_Option_ref_Box_List_Global) (return (x: MutBorrow.t t_List)) =
    {[@expl:unwrap requires] self_ <> None'1}
    any [ return (result: MutBorrow.t t_List) -> {Some'1 result = self_} (! return {result}) ]
  
  predicate resolve_ref_List [@inline:trivial] (_1: MutBorrow.t t_List) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_List
  
  predicate resolve_ref_Box_List_Global [@inline:trivial] (_1: MutBorrow.t t_List) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_Box_List_Global
  
  predicate resolve_ref_u32 [@inline:trivial] (_1: MutBorrow.t UInt32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_mut (l: MutBorrow.t t_List) (ix: UInt64.t) (return (x: MutBorrow.t UInt32.t)) =
    {[@expl:index_mut requires] UInt64.t'int ix < len l.current}
    (! bb0
    [ bb0 = s0 [ s0 = [ &old_l <- l ] s1 | s1 = bb1 ]
    | bb1 = s0 [ s0 = [ &old_ix <- ix ] s1 | s1 = bb3 ]
    | bb3 = bb3
      [ bb3 = {[@expl:loop invariant #0] UInt64.le (0: UInt64.t) ix /\ UInt64.t'int ix < len l.current}
        {[@expl:loop invariant #1] get l.current (UInt64.t'int ix) = get old_l.current (UInt64.t'int old_ix)}
        {[@expl:loop invariant #2] get l.final (UInt64.t'int ix) = get old_l.final (UInt64.t'int old_ix)}
        {[@expl:loop invariant #3] len l.final = len l.current -> len old_l.final = len old_l.current}
        {[@expl:loop invariant #4] (forall i: int. 0 <= i /\ i < len l.current /\ i <> UInt64.t'int ix
            -> get l.final i = get l.current i)
        -> (forall i: int. 0 <= i /\ i < len old_l.current /\ i <> UInt64.t'int old_ix
          -> get old_l.final i = get old_l.current i)}
        (! s0)
        [ s0 = bb4 ]
        [ bb4 = s0
          [ s0 = [ &_48 <- UInt64.gt ix (0: UInt64.t) ] s1
          | s1 = any [ br0 -> {_48 = false} (! bb8) | br1 -> {_48} (! bb5) ] ]
        | bb5 = s0
          [ s0 = MutBorrow.borrow_final <t_Option_Box_List_Global> {l.current.f1}
              {MutBorrow.inherit_id (MutBorrow.get_id l) 2}
              (fun (_ret: MutBorrow.t t_Option_Box_List_Global) ->
                [ &_53 <- _ret ] [ &l <- { l with current = { l.current with f1 = _ret.final } } ] s1)
          | s1 = as_mut_Box_List_Global {_53} (fun (_ret: t_Option_ref_Box_List_Global) -> [ &_52 <- _ret ] s2)
          | s2 = bb6 ]
        | bb6 = s0
          [ s0 = unwrap_ref_Box_List_Global {_52} (fun (_ret: MutBorrow.t t_List) -> [ &_51 <- _ret ] s1) | s1 = bb7 ]
        | bb7 = s0
          [ s0 = MutBorrow.borrow_final <t_List> {_51.current} {MutBorrow.get_id _51}
              (fun (_ret: MutBorrow.t t_List) -> [ &_50 <- _ret ] [ &_51 <- { _51 with current = _ret.final } ] s1)
          | s1 = -{resolve_ref_List l}- s2
          | s2 = [ &l <- _50 ] s3
          | s3 = -{resolve_ref_Box_List_Global _51}- s4
          | s4 = UInt64.sub {ix} {(1: UInt64.t)} (fun (_ret: UInt64.t) -> [ &ix <- _ret ] s5)
          | s5 = bb3 ] ] ]
    | bb8 = s0
      [ s0 = MutBorrow.borrow_final <UInt32.t> {l.current.f0} {MutBorrow.inherit_id (MutBorrow.get_id l) 1}
          (fun (_ret: MutBorrow.t UInt32.t) ->
            [ &_55 <- _ret ] [ &l <- { l with current = { l.current with f0 = _ret.final } } ] s1)
      | s1 = MutBorrow.borrow_final <UInt32.t> {_55.current} {MutBorrow.get_id _55}
          (fun (_ret: MutBorrow.t UInt32.t) -> [ &_3 <- _ret ] [ &_55 <- { _55 with current = _ret.final } ] s2)
      | s2 = -{resolve_ref_u32 _55}- s3
      | s3 = MutBorrow.borrow_final <UInt32.t> {_3.current} {MutBorrow.get_id _3}
          (fun (_ret: MutBorrow.t UInt32.t) -> [ &_0 <- _ret ] [ &_3 <- { _3 with current = _ret.final } ] s4)
      | s4 = -{resolve_ref_u32 _3}- s5
      | s5 = -{resolve_ref_List l}- s6
      | s6 = return {_0} ] ]
    [ & _0: MutBorrow.t UInt32.t = Any.any_l ()
    | & l: MutBorrow.t t_List = l
    | & ix: UInt64.t = ix
    | & _3: MutBorrow.t UInt32.t = Any.any_l ()
    | & old_l: MutBorrow.t t_List = Any.any_l ()
    | & old_ix: UInt64.t = Any.any_l ()
    | & _48: bool = Any.any_l ()
    | & _50: MutBorrow.t t_List = Any.any_l ()
    | & _51: MutBorrow.t t_List = Any.any_l ()
    | & _52: t_Option_ref_Box_List_Global = Any.any_l ()
    | & _53: MutBorrow.t t_Option_Box_List_Global = Any.any_l ()
    | & _55: MutBorrow.t UInt32.t = Any.any_l () ])
    [ return (result: MutBorrow.t UInt32.t) -> {[@expl:index_mut ensures #0] Some'0 (result.current)
      = get l.current (UInt64.t'int ix)}
      {[@expl:index_mut ensures #1] Some'0 (result.final) = get l.final (UInt64.t'int ix)}
      {[@expl:index_mut ensures #2] len l.final = len l.current}
      {[@expl:index_mut ensures #3] forall i: int. 0 <= i /\ i < len l.current /\ i <> UInt64.t'int ix
        -> get l.current i = get l.final i}
      (! return {result}) ]
end
module M_write
  use creusot.prelude.MutBorrow
  use creusot.int.UInt32
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_Option_Box_List_Global = None | Some t_List
  with t_List = { f0: UInt32.t; f1: t_Option_Box_List_Global }
  
  function len (self: t_List) : int = let {f0 = _; f1 = ls} = self in 1
    + match ls with
      | Some ls'0 -> len ls'0
      | None -> 0
      end
  
  type t_Option_u32 = None'0 | Some'0 UInt32.t
  
  function get (self: t_List) (ix: int) : t_Option_u32 = let {f0 = i; f1 = ls} = self in if ix > 0 then
      match ls with
        | Some ls'0 -> get ls'0 (ix - 1)
        | None -> None'0
        end
    else
      Some'0 i
  
  
  let rec index_mut (l: MutBorrow.t t_List) (ix: UInt64.t) (return (x: MutBorrow.t UInt32.t)) =
    {[@expl:index_mut requires] UInt64.t'int ix < len l.current}
    any
    [ return (result: MutBorrow.t UInt32.t) -> {Some'0 (result.current) = get l.current (UInt64.t'int ix)}
      {Some'0 (result.final) = get l.final (UInt64.t'int ix)}
      {len l.final = len l.current}
      {forall i: int. 0 <= i /\ i < len l.current /\ i <> UInt64.t'int ix -> get l.current i = get l.final i}
      (! return {result}) ]
  
  predicate resolve_ref_u32 [@inline:trivial] (_1: MutBorrow.t UInt32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_u32
  
  predicate resolve_ref_List [@inline:trivial] (_1: MutBorrow.t t_List) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_List
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec write (l: MutBorrow.t t_List) (ix: UInt64.t) (v: UInt32.t) (return (x: ())) =
    {[@expl:write requires] UInt64.t'int ix < len l.current}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_List> {l.current} {MutBorrow.get_id l}
          (fun (_ret: MutBorrow.t t_List) -> [ &_18 <- _ret ] [ &l <- { l with current = _ret.final } ] s1)
      | s1 = index_mut {_18} {ix} (fun (_ret: MutBorrow.t UInt32.t) -> [ &_17 <- _ret ] s2)
      | s2 = bb1 ]
    | bb1 = s0
      [ s0 = [ &_17 <- { _17 with current = v } ] s1
      | s1 = -{resolve_ref_u32 _17}- s2
      | s2 = -{resolve_ref_List l}- s3
      | s3 = return {_0} ] ]
    [ & _0: () = Any.any_l ()
    | & l: MutBorrow.t t_List = l
    | & ix: UInt64.t = ix
    | & v: UInt32.t = v
    | & _17: MutBorrow.t UInt32.t = Any.any_l ()
    | & _18: MutBorrow.t t_List = Any.any_l () ])
    [ return (result: ()) -> {[@expl:write ensures #0] Some'0 v = get l.final (UInt64.t'int ix)}
      {[@expl:write ensures #1] len l.final = len l.current}
      {[@expl:write ensures #2] forall i: int. 0 <= i /\ i < len l.current /\ i <> UInt64.t'int ix
        -> get l.current i = get l.final i}
      (! return {result}) ]
end
module M_f
  use creusot.int.UInt32
  use creusot.prelude.MutBorrow
  use creusot.int.UInt64
  use mach.int.Int
  use creusot.prelude.Any
  
  type t_List = { f0: UInt32.t; f1: t_Option_Box_List_Global }
  with t_Option_Box_List_Global = None | Some t_List
  
  function len (self: t_List) : int = let {f0 = _; f1 = ls} = self in 1
    + match ls with
      | Some ls'0 -> len ls'0
      | None -> 0
      end
  
  type t_Option_u32 = None'0 | Some'0 UInt32.t
  
  function get (self: t_List) (ix: int) : t_Option_u32 = let {f0 = i; f1 = ls} = self in if ix > 0 then
      match ls with
        | Some ls'0 -> get ls'0 (ix - 1)
        | None -> None'0
        end
    else
      Some'0 i
  
  
  let rec write (l: MutBorrow.t t_List) (ix: UInt64.t) (v: UInt32.t) (return (x: ())) =
    {[@expl:write requires] UInt64.t'int ix < len l.current}
    any
    [ return (result: ()) -> {Some'0 v = get l.final (UInt64.t'int ix)}
      {len l.final = len l.current}
      {forall i: int. 0 <= i /\ i < len l.current /\ i <> UInt64.t'int ix -> get l.current i = get l.final i}
      (! return {result}) ]
  
  predicate resolve_ref_List [@inline:trivial] (_1: MutBorrow.t t_List) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_ref_List
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (return (x: ())) = (! bb0
    [ bb0 = s0 [ s0 = [ &_5 <- None ] s1 | s1 = [ &_4 <- { f0 = (10: UInt32.t); f1 = _5 } ] s2 | s2 = bb2 ]
    | bb2 = s0 [ s0 = [ &_2 <- Some _4 ] s1 | s1 = bb3 ]
    | bb3 = s0 [ s0 = [ &l <- { f0 = (1: UInt32.t); f1 = _2 } ] s1 | s1 = bb4 ]
    | bb4 = s0
      [ s0 = MutBorrow.borrow_mut <t_List> {l}
          (fun (_ret: MutBorrow.t t_List) -> [ &_8 <- _ret ] [ &l <- _ret.final ] s1)
      | s1 = MutBorrow.borrow_final <t_List> {_8.current} {MutBorrow.get_id _8}
          (fun (_ret: MutBorrow.t t_List) -> [ &_7 <- _ret ] [ &_8 <- { _8 with current = _ret.final } ] s2)
      | s2 = write {_7} {(0: UInt64.t)} {(2: UInt32.t)} (fun (_ret: ()) -> [ &_6 <- _ret ] s3)
      | s3 = bb5 ]
    | bb5 = s0 [ s0 = -{resolve_ref_List _8}- s1 | s1 = bb6 ]
    | bb6 = return {_0} ]
    [ & _0: () = Any.any_l ()
    | & l: t_List = Any.any_l ()
    | & _2: t_Option_Box_List_Global = Any.any_l ()
    | & _4: t_List = Any.any_l ()
    | & _5: t_Option_Box_List_Global = Any.any_l ()
    | & _6: () = Any.any_l ()
    | & _7: MutBorrow.t t_List = Any.any_l ()
    | & _8: MutBorrow.t t_List = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
