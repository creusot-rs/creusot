module M_f
  use creusot.int.Int32
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use mach.int.Int
  
  type closure0 = { c0: bool; c1: MutBorrow.t Int32.t; c2: MutBorrow.t Int32.t }
  
  predicate resolve_refmut_i32 [@inline:trivial] (_1: MutBorrow.t Int32.t) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_i32
  
  predicate resolve_Box_refmut_i32_Global [@inline:trivial] (_1: MutBorrow.t Int32.t) = resolve_refmut_i32 _1
  
  meta "rewrite_def" predicate resolve_Box_refmut_i32_Global
  
  predicate resolve_Box_Box_refmut_i32_Global_Global [@inline:trivial] (_1: MutBorrow.t Int32.t) =
    resolve_Box_refmut_i32_Global _1
  
  meta "rewrite_def" predicate resolve_Box_Box_refmut_i32_Global_Global
  
  let rec closure0 (self: closure0) (return (x: ())) = {[@expl:closure requires] Int32.to_int self.c2.current = 1
    /\ Int32.to_int self.c1.current = 1}
    (! bb0
    [ bb0 = any [ br0 -> {self.c0 = false} (! bb3) | br1 -> {self.c0} (! bb1) ]
    | bb1 = s0
      [ s0 = -{match self with
          | {c1 = x} -> resolve_Box_Box_refmut_i32_Global_Global x
          | _ -> true
          end}-
        s1
      | s1 = {[@expl:assertion] Int32.to_int self.c1.final = 1} s2
      | s2 = [ &bx2 <- self.c2 ] s3
      | s3 = Int32.add {bx2.current} {(1: Int32.t)} (fun (_x: Int32.t) -> [ &bx2 <- { bx2 with current = _x } ] s4)
      | s4 = -{resolve_refmut_i32 bx2}- s5
      | s5 = {[@expl:assertion] Int32.to_int bx2.final = 2} s6
      | s6 = return {_ret} ]
    | bb3 = s0
      [ s0 = -{match self with
          | {c2 = x} -> resolve_Box_refmut_i32_Global x
          | _ -> true
          end}-
        s1
      | s1 = {[@expl:assertion] Int32.to_int self.c2.final = 1} s2
      | s2 = [ &by2 <- self.c1 ] s3
      | s3 = Int32.add {by2.current} {(1: Int32.t)} (fun (_x: Int32.t) -> [ &by2 <- { by2 with current = _x } ] s4)
      | s4 = -{resolve_refmut_i32 by2}- s5
      | s5 = {[@expl:assertion] Int32.to_int by2.final = 2} s6
      | s6 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: closure0 = self
    | & bx2: MutBorrow.t Int32.t = Any.any_l ()
    | & by2: MutBorrow.t Int32.t = Any.any_l () ])
    [ return (result: ()) -> {[@expl:closure ensures] Int32.to_int self.c2.final + Int32.to_int self.c1.final = 3}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec f (c: bool) (return (x: ())) = (! bb0
    [ bb0 = s0
      [ s0 = [ &x <- (1: Int32.t) ] s1
      | s1 = [ &y <- (1: Int32.t) ] s2
      | s2 = MutBorrow.borrow_mut <Int32.t> {x}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_5 <- _bor ] [ &x <- _bor.final ] s3)
      | s3 = [ &bx <- _5 ] s4
      | s4 = MutBorrow.borrow_mut <Int32.t> {y}
          (fun (_bor: MutBorrow.t Int32.t) -> [ &_8 <- _bor ] [ &y <- _bor.final ] s5)
      | s5 = [ &by' <- _8 ] s6
      | s6 = [ &f'0 <- { c0 = c; c1 = by'; c2 = bx } ] s7
      | s7 = closure0 {f'0} (fun (_x: ()) -> [ &_10 <- _x ] s8)
      | s8 = {[@expl:assertion] Int32.to_int x + Int32.to_int y = 3} s9
      | s9 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & c: bool = c
    | & x: Int32.t = Any.any_l ()
    | & y: Int32.t = Any.any_l ()
    | & bx: MutBorrow.t Int32.t = Any.any_l ()
    | & _5: MutBorrow.t Int32.t = Any.any_l ()
    | & by': MutBorrow.t Int32.t = Any.any_l ()
    | & _8: MutBorrow.t Int32.t = Any.any_l ()
    | & f'0: closure0 = Any.any_l ()
    | & _10: () = Any.any_l ()
    | & _12: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
