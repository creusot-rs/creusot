module M_cell__permcell__impl_PermCell_T_2__take (* cell::permcell::PermCell<T> *)
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@stop_split] [@expl:default requires] precondition_default () ()}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:default ensures] postcondition_once_default () () result}
      (! return {result}) ]
  
  type t_PermCell_T
  
  type t_Perm_PermCell_T
  
  function ward_PermCell_T (self: t_Perm_PermCell_T) : t_PermCell_T
  
  function val_PermCell_T (self: t_Perm_PermCell_T) : t_T
  
  function view_Perm_PermCell_T [@inline:trivial] (self: t_Perm_PermCell_T) : t_T = val_PermCell_T self
  
  meta "rewrite_def" function view_Perm_PermCell_T
  
  function fin_Ghost_refmut_Perm_PermCell_T [@inline:trivial] (self: MutBorrow.t t_Perm_PermCell_T) : t_Perm_PermCell_T
   = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_Perm_PermCell_T
  
  let rec replace_T (self: t_PermCell_T) (perm: MutBorrow.t t_Perm_PermCell_T) (val': t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:replace_T requires] ([@stop_split] [@expl:replace 'val' type invariant] inv_T val')
    /\ ([@stop_split] [@expl:replace requires] self = ward_PermCell_T perm.current)}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:replace_T ensures] ([@stop_split] [@expl:replace result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:replace ensures #0] val' = view_Perm_PermCell_T (fin_Ghost_refmut_Perm_PermCell_T perm))
      /\ ([@stop_split] [@expl:replace ensures #1] result = view_Perm_PermCell_T perm.current)
      /\ ([@stop_split] [@expl:replace ensures #2] self = ward_PermCell_T (fin_Ghost_refmut_Perm_PermCell_T perm))}
      (! return {result}) ]
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut_default () args () res]. postcondition_mut_default () args () res
      -> (let () = args in inv_T res)
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_default () args res]. postcondition_default () args res
      -> (let () = args in inv_T res)
  
  function fn_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take_T (self: t_PermCell_T) (perm: MutBorrow.t t_Perm_PermCell_T) (return (x: t_T)) =
    {[@stop_split] [@expl:take requires] self = ward_PermCell_T perm.current}
    (! bb0
    [ bb0 = s0
      [ s0 = default_T (fun (_x: t_T) -> [ &_15 <- _x ] s1)
      | s1 = replace_T {self} {perm} {_15} (fun (_x: t_T) -> [ &_ret <- _x ] s2)
      | s2 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l ()
    | & self: t_PermCell_T = self
    | & perm: MutBorrow.t t_Perm_PermCell_T = perm
    | & _15: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:take_T ensures] ([@stop_split] [@expl:take result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:take ensures #0] self = ward_PermCell_T (fin_Ghost_refmut_Perm_PermCell_T perm))
      /\ ([@stop_split] [@expl:take ensures #1] result = view_Perm_PermCell_T perm.current)
      /\ ([@stop_split] [@expl:take ensures #2] postcondition_default () () (view_Perm_PermCell_T (fin_Ghost_refmut_Perm_PermCell_T perm)))}
      (! return {result}) ]
end
module M_ghost__fn_ghost__impl_Clone_for_FnGhostWrapper_F__clone (* <ghost::fn_ghost::FnGhostWrapper<F> as std::clone::Clone> *)
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate invariant_ref_F [@inline:trivial] (self: t_F) = inv_F self
  
  meta "rewrite_def" predicate invariant_ref_F
  
  predicate inv_ref_F [@inline:trivial] (_1: t_F) = invariant_ref_F _1
  
  meta "rewrite_def" predicate inv_ref_F
  
  predicate precondition_clone (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition_clone () args]. (let self_ = args in inv_ref_F self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef:
    forall args: t_F, res: t_F [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_F res)
  
  let rec clone_F (self_: t_F) (return (x: t_F)) = {[@stop_split] [@expl:clone requires] precondition_clone () self_}
    any
    [ return (result: t_F) -> {[@stop_split] [@expl:clone ensures] postcondition_once_clone () self_ result}
      (! return {result}) ]
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_ref_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) = inv_FnGhostWrapper_F self
  
  meta "rewrite_def" predicate invariant_ref_FnGhostWrapper_F
  
  predicate inv_ref_FnGhostWrapper_F [@inline:trivial] (_1: t_FnGhostWrapper_F) = invariant_ref_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_ref_FnGhostWrapper_F
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_F, res: t_F [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_F res)
  
  function fn_mut_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1:
    forall args: t_F, res: t_F [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_F res)
  
  function fn_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_FnGhostWrapper_F (self: t_FnGhostWrapper_F) (return (x: t_FnGhostWrapper_F)) =
    {[@stop_split] [@expl:clone 'self' type invariant] inv_ref_FnGhostWrapper_F self}
    (! bb0
    [ bb0 = s0
      [ s0 = clone_F {self.f0} (fun (_x: t_F) -> [ &_4 <- _x ] s1)
      | s1 = [ &_ret <- { f0 = _4 } ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_FnGhostWrapper_F = Any.any_l () | & self: t_FnGhostWrapper_F = self | & _4: t_F = Any.any_l () ])
    [ return (result: t_FnGhostWrapper_F) ->
    {[@stop_split] [@expl:clone_FnGhostWrapper_F ensures] ([@stop_split] [@expl:clone result type invariant] inv_FnGhostWrapper_F result)
      /\ ([@stop_split] [@expl:clone ensures] postcondition_clone () self.f0 result.f0)}
      (! return {result}) ]
end
module M_ghost__fn_ghost__impl_FnGhostWrapper_F__new (* ghost::fn_ghost::FnGhostWrapper<F> *)
  use creusot.prelude.Any
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec __new_F (f: t_F) (return (x: t_FnGhostWrapper_F)) = {[@stop_split] [@expl:__new 'f' type invariant] inv_F f}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { f0 = f } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_FnGhostWrapper_F = Any.any_l () | & f: t_F = f ])
    [ return (result: t_FnGhostWrapper_F) ->
    {[@stop_split] [@expl:__new_F ensures] ([@stop_split] [@expl:__new result type invariant] inv_FnGhostWrapper_F result)
      /\ ([@stop_split] [@expl:__new ensures] result.f0 = f)}
      (! return {result}) ]
end
module M_ghost__invariant__impl_Clone_for_Namespace__clone (* <ghost::invariant::Namespace as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Namespace (self: t_Namespace) (return (x: t_Namespace)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Namespace = Any.any_l () | & self: t_Namespace = self ])
    [ return (result: t_Namespace) -> {[@stop_split] [@expl:clone ensures] result = self} (! return {result}) ]
end
module M_ghost__invariant__impl_NonAtomicInvariantExt_for_Ghost_ref_NonAtomicInvariant_T__open (* <ghost::Ghost<&'a ghost::invariant::NonAtomicInvariant<T>> as ghost::invariant::NonAtomicInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Set
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_NonAtomicInvariant_T
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  predicate inv_F (_1: t_F)
  
  predicate contains_Namespace [@inline:trivial] (self: Set.set t_Namespace) (e: t_Namespace) = Set.mem e self
  
  meta "rewrite_def" predicate contains_Namespace
  
  function namespaces (self: t_Tokens) : Set.set t_Namespace
  
  predicate contains (self: t_Tokens) (namespace: t_Namespace) = contains_Namespace (namespaces self) namespace
  
  function namespace_T (self: t_NonAtomicInvariant_T) : t_Namespace
  
  type t_T
  
  type t_Public
  
  predicate protocol_T (self: t_T) (data: t_Public)
  
  function public_T (self: t_NonAtomicInvariant_T) : t_Public
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate invariant_Ghost_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_refmut_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_T
  
  predicate inv_Ghost_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_Ghost_refmut_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_T
  
  predicate precondition_F (self: t_F) (args: MutBorrow.t t_T)
  
  predicate postcondition_once_F (self: t_F) (args: MutBorrow.t t_T) (result: t_A)
  
  function fin_Ghost_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) : t_T = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_T
  
  predicate inv_A (_1: t_A)
  
  let rec open_T (this: t_NonAtomicInvariant_T) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@stop_split] [@expl:open_T requires] ([@stop_split] [@expl:open 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:open requires #0] contains tokens (namespace_T this))
    /\ ([@stop_split] [@expl:open requires #1] forall t: MutBorrow.t t_T. protocol_T t.current (public_T this)
        /\ inv_Ghost_refmut_T t
      -> precondition_F f t
      /\ (forall res: t_A. postcondition_once_F f t res -> protocol_T (fin_Ghost_refmut_T t) (public_T this)))}
    any
    [ return (result: t_A) ->
    {[@stop_split] [@expl:open_T ensures] ([@stop_split] [@expl:open result type invariant] inv_A result)
      /\ ([@stop_split] [@expl:open ensures] exists t: MutBorrow.t t_T. inv_Ghost_refmut_T t
        /\ protocol_T t.current (public_T this) /\ postcondition_once_F f t result)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open_Ghost_ref_NonAtomicInvariant_T (self: t_NonAtomicInvariant_T) (tokens: t_Tokens) (f: t_F)
    (return (x: t_A)) =
    {[@stop_split] [@expl:open_Ghost_ref_NonAtomicInvariant_T requires] ([@stop_split] [@expl:open 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:open requires #0] contains tokens (namespace_T self))
    /\ ([@stop_split] [@expl:open requires #1] forall t: MutBorrow.t t_T. protocol_T t.current (public_T self)
        /\ inv_Ghost_refmut_T t
      -> precondition_F f t
      /\ (forall res: t_A. postcondition_once_F f t res -> protocol_T (fin_Ghost_refmut_T t) (public_T self)))}
    (! bb0
    [ bb0 = s0 [ s0 = open_T {self} {tokens} {f} (fun (_x: t_A) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_A = Any.any_l () | & self: t_NonAtomicInvariant_T = self | & tokens: t_Tokens = tokens | & f: t_F = f ])
    [ return (result: t_A) ->
    {[@stop_split] [@expl:open_Ghost_ref_NonAtomicInvariant_T ensures] ([@stop_split] [@expl:open result type invariant] inv_A result)
      /\ ([@stop_split] [@expl:open ensures] exists t: MutBorrow.t t_T. protocol_T t.current (public_T self)
        /\ postcondition_once_F f t result)}
      (! return {result}) ]
end
module M_ghost__invariant__impl_NonAtomicInvariantExt_for_Ghost_ref_T__open (* <ghost::Ghost<&'a T> as ghost::invariant::NonAtomicInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Ghost_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_T
  
  predicate inv_Ghost_ref_T [@inline:trivial] (_1: t_T) = invariant_Ghost_ref_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_T
  
  predicate invariant_ref_Ghost_ref_T [@inline:trivial] (self: t_T) = inv_Ghost_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_ref_T
  
  predicate inv_ref_Ghost_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_Ghost_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_ref_T
  
  predicate invariant_ref_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_T
  
  predicate inv_ref_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_T
  
  let rec deref_Ghost_ref_T (self: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:deref 'self' type invariant] inv_ref_Ghost_ref_T self}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:deref_Ghost_ref_T ensures] ([@stop_split] [@expl:deref result type invariant] inv_ref_ref_T result)
      /\ ([@stop_split] [@expl:deref ensures] result = self)}
      (! return {result}) ]
  
  type t_Target
  
  predicate precondition_deref (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_deref () args]. (let self_ = args in false)
      -> precondition_deref () args
  
  predicate inv_Target (_1: t_Target)
  
  predicate invariant_ref_Target [@inline:trivial] (self: t_Target) = inv_Target self
  
  meta "rewrite_def" predicate invariant_ref_Target
  
  predicate inv_ref_Target [@inline:trivial] (_1: t_Target) = invariant_ref_Target _1
  
  meta "rewrite_def" predicate inv_ref_Target
  
  predicate postcondition_once_deref (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_Target [postcondition_once_deref () args res]. postcondition_once_deref () args res
      -> (let self_ = args in inv_ref_Target res)
  
  let rec deref_T (self_: t_T) (return (x: t_Target)) =
    {[@stop_split] [@expl:deref requires] precondition_deref () self_}
    any
    [ return (result: t_Target) -> {[@stop_split] [@expl:deref ensures] postcondition_once_deref () self_ result}
      (! return {result}) ]
  
  predicate invariant_Ghost_ref_Target [@inline:trivial] (self: t_Target) = inv_ref_Target self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_Target
  
  predicate inv_Ghost_ref_Target [@inline:trivial] (_1: t_Target) = invariant_Ghost_ref_Target _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_Target
  
  let rec new_ref_Target (x: t_Target) (return (x'0: t_Target)) =
    {[@stop_split] [@expl:new 'x' type invariant] inv_ref_Target x}
    any
    [ return (result: t_Target) ->
    {[@stop_split] [@expl:new_ref_Target ensures] ([@stop_split] [@expl:new result type invariant] inv_Ghost_ref_Target result)
      /\ ([@stop_split] [@expl:new ensures] result = x)}
      (! return {result}) ]
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  type tup3_Ghost_ref_Target_Ghost_Tokens_F = { f0: t_Target; f1: t_Tokens; f2: t_F }
  
  predicate precondition_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F)
  
  axiom precondition_fndef'0:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F [precondition_open () args]. (let {f0 = self; f1 = tokens; f2 = f} = args in false)
      -> precondition_open () args
  
  predicate inv_A (_1: t_A)
  
  predicate postcondition_once_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A [postcondition_once_open () args res]. postcondition_once_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  let rec open_Ghost_ref_Target (self: t_Target) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@stop_split] [@expl:open requires] precondition_open () { f0 = self; f1 = tokens; f2 = f }}
    any
    [ return (result: t_A) -> {[@stop_split] [@expl:open ensures] postcondition_once_open () { f0 = self;
                                                                                               f1 = tokens;
                                                                                               f2 = f } result}
      (! return {result}) ]
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_deref [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_deref
  
  predicate postcondition_mut_deref (self: ()) (args: t_T) (result_state: ()) (result: t_Target)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_Target [postcondition_mut_deref () args () res]. postcondition_mut_deref () args () res
      -> (let self_ = args in inv_ref_Target res)
  
  function fn_mut_once_deref (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_mut_once_deref_spec: forall self: (), args: t_T, res: t_Target. postcondition_once_deref self args res
      = (exists res_state: (). postcondition_mut_deref self args res_state res /\ resolve_deref res_state)
  
  predicate hist_inv_deref [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_deref
  
  function hist_inv_trans_deref (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_deref_spec: forall self: (), b: (), c: (). hist_inv_deref self b
      -> hist_inv_deref b c -> hist_inv_deref self c
  
  function hist_inv_refl_deref (self: ()) : ()
  
  axiom hist_inv_refl_deref_spec: forall self: (). hist_inv_deref self self
  
  function postcondition_mut_hist_inv_deref (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom postcondition_mut_hist_inv_deref_spec:
    forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut_deref self args res_state res
      -> hist_inv_deref self res_state
  
  function fn_hist_inv_deref (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_deref_spec: forall self: (), res_state: (). hist_inv_deref self res_state = (self = res_state)
  
  predicate postcondition_deref (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef'2:
    forall args: t_T, res: t_Target [postcondition_deref () args res]. postcondition_deref () args res
      -> (let self_ = args in inv_ref_Target res)
  
  function fn_once_deref (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_once_deref_spec: forall self: (), args: t_T, res: t_Target. postcondition_once_deref self args res
      = (postcondition_deref self args res /\ resolve_deref self)
  
  function fn_mut_deref (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom fn_mut_deref_spec:
    forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut_deref self args res_state res
      = (postcondition_deref self args res /\ self = res_state)
  
  function new_ref_Target'0 (x: t_Target) : t_Target
  
  axiom new_ref_Target_spec: forall x: t_Target. new_ref_Target'0 x = x
  
  predicate resolve_open [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_open
  
  predicate postcondition_mut_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'3:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A [postcondition_mut_open () args () res]. postcondition_mut_open () args () res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_mut_once_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_mut_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (exists res_state: (). postcondition_mut_open self args res_state res /\ resolve_open res_state)
  
  predicate hist_inv_open [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_open
  
  function hist_inv_trans_open (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_open_spec: forall self: (), b: (), c: (). hist_inv_open self b
      -> hist_inv_open b c -> hist_inv_open self c
  
  function hist_inv_refl_open (self: ()) : ()
  
  axiom hist_inv_refl_open_spec: forall self: (). hist_inv_open self self
  
  function postcondition_mut_hist_inv_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      -> hist_inv_open self res_state
  
  function fn_hist_inv_open (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_open_spec: forall self: (), res_state: (). hist_inv_open self res_state = (self = res_state)
  
  predicate postcondition_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef'4:
    forall args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A [postcondition_open () args res]. postcondition_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_once_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (postcondition_open self args res /\ resolve_open self)
  
  function fn_mut_open (self: ()) (args: tup3_Ghost_ref_Target_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_open_spec:
    forall self: (), args: tup3_Ghost_ref_Target_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      = (postcondition_open self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open_Ghost_ref_T (self: t_T) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@stop_split] [@expl:open_Ghost_ref_T requires] ([@stop_split] [@expl:open 'self' type invariant] inv_Ghost_ref_T self)
    /\ ([@stop_split] [@expl:open 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:open requires #0] precondition_deref () self)
    /\ ([@stop_split] [@expl:open requires #1] forall this: t_Target. postcondition_deref () self this
      -> precondition_open () { f0 = new_ref_Target'0 this; f1 = tokens; f2 = f })}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_20 <- self ] s1
      | s1 = deref_Ghost_ref_T {_20} (fun (_x: t_T) -> [ &_18 <- _x ] s2)
      | s2 = deref_T {_18} (fun (_x: t_Target) -> [ &_16 <- _x ] s3)
      | s3 = new_ref_Target {_16} (fun (_x: t_Target) -> [ &this <- _x ] s4)
      | s4 = open_Ghost_ref_Target {this} {tokens} {f} (fun (_x: t_A) -> [ &_ret <- _x ] s5)
      | s5 = return {_ret} ] ]
    [ & _ret: t_A = Any.any_l ()
    | & self: t_T = self
    | & tokens: t_Tokens = tokens
    | & f: t_F = f
    | & this: t_Target = Any.any_l ()
    | & _16: t_Target = Any.any_l ()
    | & _18: t_T = Any.any_l ()
    | & _20: t_T = Any.any_l () ])
    [ return (result: t_A) ->
    {[@stop_split] [@expl:open_Ghost_ref_T ensures] ([@stop_split] [@expl:open result type invariant] inv_A result)
      /\ ([@stop_split] [@expl:open ensures] exists this: t_Target. postcondition_deref () self this
        /\ postcondition_open () { f0 = new_ref_Target'0 this; f1 = tokens; f2 = f } result)}
      (! return {result}) ]
end
module M_ghost__invariant__impl_NonAtomicInvariantExt_for_ref_Ghost_L__open (* <&'a ghost::Ghost<L> as ghost::invariant::NonAtomicInvariantExt<'a>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_L
  
  predicate inv_L (_1: t_L)
  
  predicate invariant_Ghost_L [@inline:trivial] (self: t_L) = inv_L self
  
  meta "rewrite_def" predicate invariant_Ghost_L
  
  predicate inv_Ghost_L [@inline:trivial] (_1: t_L) = invariant_Ghost_L _1
  
  meta "rewrite_def" predicate inv_Ghost_L
  
  predicate invariant_ref_Ghost_L [@inline:trivial] (self: t_L) = inv_Ghost_L self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_L
  
  predicate inv_ref_Ghost_L [@inline:trivial] (_1: t_L) = invariant_ref_Ghost_L _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_L
  
  predicate invariant_ref_L [@inline:trivial] (self: t_L) = inv_L self
  
  meta "rewrite_def" predicate invariant_ref_L
  
  predicate inv_ref_L [@inline:trivial] (_1: t_L) = invariant_ref_L _1
  
  meta "rewrite_def" predicate inv_ref_L
  
  predicate invariant_Ghost_ref_L [@inline:trivial] (self: t_L) = inv_ref_L self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_L
  
  predicate inv_Ghost_ref_L [@inline:trivial] (_1: t_L) = invariant_Ghost_ref_L _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_L
  
  let rec borrow_L (self: t_L) (return (x: t_L)) =
    {[@stop_split] [@expl:borrow 'self' type invariant] inv_ref_Ghost_L self}
    any
    [ return (result: t_L) ->
    {[@stop_split] [@expl:borrow_L ensures] ([@stop_split] [@expl:borrow result type invariant] inv_Ghost_ref_L result)
      /\ ([@stop_split] [@expl:borrow ensures] result = self)}
      (! return {result}) ]
  
  type t_Tokens
  
  type t_F
  
  type t_A
  
  type tup3_Ghost_ref_L_Ghost_Tokens_F = { f0: t_L; f1: t_Tokens; f2: t_F }
  
  predicate precondition_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F)
  
  axiom precondition_fndef:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F [precondition_open () args]. (let {f0 = self; f1 = tokens; f2 = f} = args in false)
      -> precondition_open () args
  
  predicate inv_A (_1: t_A)
  
  predicate postcondition_once_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A [postcondition_once_open () args res]. postcondition_once_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  let rec open_Ghost_ref_L (self: t_L) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@stop_split] [@expl:open requires] precondition_open () { f0 = self; f1 = tokens; f2 = f }}
    any
    [ return (result: t_A) -> {[@stop_split] [@expl:open ensures] postcondition_once_open () { f0 = self;
                                                                                               f1 = tokens;
                                                                                               f2 = f } result}
      (! return {result}) ]
  
  predicate inv_F (_1: t_F)
  
  function new_ref_L (x: t_L) : t_L
  
  axiom new_ref_L_spec: forall x: t_L. new_ref_L x = x
  
  predicate resolve_open [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_open
  
  predicate postcondition_mut_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (result_state: ()) (result: t_A)
  
  axiom postcondition_fndef'0:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A [postcondition_mut_open () args () res]. postcondition_mut_open () args () res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_mut_once_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_mut_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (exists res_state: (). postcondition_mut_open self args res_state res /\ resolve_open res_state)
  
  predicate hist_inv_open [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_open
  
  function hist_inv_trans_open (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_open_spec: forall self: (), b: (), c: (). hist_inv_open self b
      -> hist_inv_open b c -> hist_inv_open self c
  
  function hist_inv_refl_open (self: ()) : ()
  
  axiom hist_inv_refl_open_spec: forall self: (). hist_inv_open self self
  
  function postcondition_mut_hist_inv_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom postcondition_mut_hist_inv_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      -> hist_inv_open self res_state
  
  function fn_hist_inv_open (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_open_spec: forall self: (), res_state: (). hist_inv_open self res_state = (self = res_state)
  
  predicate postcondition_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (result: t_A)
  
  axiom postcondition_fndef'1:
    forall args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A [postcondition_open () args res]. postcondition_open () args res
      -> (let {f0 = self; f1 = tokens; f2 = f} = args in inv_A res)
  
  function fn_once_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res: t_A) : ()
  
  axiom fn_once_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res: t_A. postcondition_once_open self args res
      = (postcondition_open self args res /\ resolve_open self)
  
  function fn_mut_open (self: ()) (args: tup3_Ghost_ref_L_Ghost_Tokens_F) (res_state: ()) (res: t_A) : ()
  
  axiom fn_mut_open_spec:
    forall self: (), args: tup3_Ghost_ref_L_Ghost_Tokens_F, res_state: (), res: t_A. postcondition_mut_open self args res_state res
      = (postcondition_open self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec open_ref_Ghost_L (self: t_L) (tokens: t_Tokens) (f: t_F) (return (x: t_A)) =
    {[@stop_split] [@expl:open_ref_Ghost_L requires] ([@stop_split] [@expl:open 'self' type invariant] inv_ref_Ghost_L self)
    /\ ([@stop_split] [@expl:open 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:open requires] precondition_open () { f0 = new_ref_L self; f1 = tokens; f2 = f })}
    (! bb0
    [ bb0 = s0
      [ s0 = borrow_L {self} (fun (_x: t_L) -> [ &_12 <- _x ] s1)
      | s1 = open_Ghost_ref_L {_12} {tokens} {f} (fun (_x: t_A) -> [ &_ret <- _x ] s2)
      | s2 = return {_ret} ] ]
    [ & _ret: t_A = Any.any_l ()
    | & self: t_L = self
    | & tokens: t_Tokens = tokens
    | & f: t_F = f
    | & _12: t_L = Any.any_l () ])
    [ return (result: t_A) ->
    {[@stop_split] [@expl:open_ref_Ghost_L ensures] ([@stop_split] [@expl:open result type invariant] inv_A result)
      /\ ([@stop_split] [@expl:open ensures] postcondition_open () { f0 = new_ref_L self; f1 = tokens; f2 = f } result)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_From_for_Fragment_R__from (* <ghost::resource::auth::Fragment<R> as std::convert::From<ghost::resource::m::Resource<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_R
  
  type t_View_AuthViewRel_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_Fragment_R (value: t_Resource_View_AuthViewRel_R) (return (x: t_Fragment_R)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { f0 = value } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Fragment_R = Any.any_l () | & value: t_Resource_View_AuthViewRel_R = value ])
    [ return (result: t_Fragment_R) -> {[@stop_split] [@expl:from ensures] view_Fragment_R result
      = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R value)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Authority_R__alloc (* ghost::resource::auth::Authority<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use map.Map
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function new_auth_AuthViewRel_R [@inline:trivial] (auth: t_R) : t_View_AuthViewRel_R =
    new_AuthViewRel_R (Some auth) unit_R
  
  meta "rewrite_def" function new_auth_AuthViewRel_R
  
  type t_Resource_View_AuthViewRel_R
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  let rec alloc_View_AuthViewRel_R (r: t_View_AuthViewRel_R) (return (x: t_Resource_View_AuthViewRel_R)) = any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:alloc ensures] view_Resource_View_AuthViewRel_R result = r}
      (! return {result}) ]
  
  let rec into_inner_Resource_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R)
    (return (x: t_Resource_View_AuthViewRel_R)) = any
    [ return (result: t_Resource_View_AuthViewRel_R) -> {[@stop_split] [@expl:into_inner ensures] result = self}
      (! return {result}) ]
  
  type t_Authority_R = { f0: t_Resource_View_AuthViewRel_R }
  
  predicate invariant_Authority_R (self: t_Authority_R) =
    auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0) <> None
  
  predicate inv_Authority_R (_1: t_Authority_R)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_R [inv_Authority_R x]. inv_Authority_R x = invariant_Authority_R x
  
  predicate invariant_Ghost_Authority_R [@inline:trivial] (self: t_Authority_R) = inv_Authority_R self
  
  meta "rewrite_def" predicate invariant_Ghost_Authority_R
  
  predicate inv_Ghost_Authority_R [@inline:trivial] (_1: t_Authority_R) = invariant_Ghost_Authority_R _1
  
  meta "rewrite_def" predicate inv_Ghost_Authority_R
  
  let rec new_Authority_R (x: t_Authority_R) (return (x'0: t_Authority_R)) =
    {[@stop_split] [@expl:new 'x' type invariant] inv_Authority_R x}
    any
    [ return (result: t_Authority_R) ->
    {[@stop_split] [@expl:new_Authority_R ensures] ([@stop_split] [@expl:new result type invariant] inv_Ghost_Authority_R result)
      /\ ([@stop_split] [@expl:new ensures] result = x)}
      (! return {result}) ]
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function view_Authority_R (self: t_Authority_R) : t_R =
    unwrap_Option_R (auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec alloc_R (return (x: t_Authority_R)) = (! bb0
    [ bb0 = s0
      [ s0 = alloc_View_AuthViewRel_R {new_auth_AuthViewRel_R unit_R}
          (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_4 <- _x ] s1)
      | s1 = into_inner_Resource_View_AuthViewRel_R {_4} (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_3 <- _x ] s2)
      | s2 = [ &_2 <- { f0 = _3 } ] s3
      | s3 = new_Authority_R {_2} (fun (_x: t_Authority_R) -> [ &_ret <- _x ] s4)
      | s4 = return {_ret} ] ]
    [ & _ret: t_Authority_R = Any.any_l ()
    | & _2: t_Authority_R = Any.any_l ()
    | & _3: t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _4: t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: t_Authority_R) ->
    {[@stop_split] [@expl:alloc_R ensures] ([@stop_split] [@expl:alloc result type invariant] inv_Ghost_Authority_R result)
      /\ ([@stop_split] [@expl:alloc ensures] view_Authority_R result = unit_R)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Authority_R__from_resource (* ghost::resource::auth::Authority<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use map.Map
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Authority_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  predicate invariant_Authority_R (self: t_Authority_R) =
    auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0) <> None
  
  predicate inv_Authority_R (_1: t_Authority_R)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_R [inv_Authority_R x]. inv_Authority_R x = invariant_Authority_R x
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function view_Authority_R (self: t_Authority_R) : t_R =
    unwrap_Option_R (auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0))
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  function id_R (self: t_Authority_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_resource_R (r: t_Resource_View_AuthViewRel_R) (return (x: t_Authority_R)) =
    {[@stop_split] [@expl:from_resource requires] auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R r) <> None}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { f0 = r } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Authority_R = Any.any_l () | & r: t_Resource_View_AuthViewRel_R = r ])
    [ return (result: t_Authority_R) ->
    {[@stop_split] [@expl:from_resource_R ensures] ([@stop_split] [@expl:from_resource result type invariant] inv_Authority_R result)
      /\ ([@stop_split] [@expl:from_resource ensures #0] view_Authority_R result
        = unwrap_Option_R (auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R r)))
      /\ ([@stop_split] [@expl:from_resource ensures #1] id_R result = id_View_AuthViewRel_R r)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Authority_R__update (* ghost::resource::auth::Authority<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_View_AuthViewRel_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Authority_R = { f0: t_Resource_View_AuthViewRel_R }
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  function view_Authority_R (self: t_Authority_R) : t_R =
    unwrap_Option_R (auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0))
  
  type t_Fragment_R = { f0'0: t_Resource_View_AuthViewRel_R }
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0'0)
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  type t_Option_View_AuthViewRel_R = None'0 | Some'0 t_View_AuthViewRel_R
  
  type tup2_Option_R_Option_R = { f0'1: t_Option_R; f1'1: t_Option_R }
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some f -> match { f0'1 = auth_AuthViewRel_R self; f1'1 = auth_AuthViewRel_R other } with
        | {f0'1 = None; f1'1 = a} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | {f0'1 = a; f1'1 = None} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | _ -> None'0
        end
      | None -> None'0
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  constant unit_View_AuthViewRel_R : t_View_AuthViewRel_R
  
  axiom unit_View_AuthViewRel_R_spec:
    forall x: t_View_AuthViewRel_R [op_View_AuthViewRel_R x unit_View_AuthViewRel_R]. op_View_AuthViewRel_R x unit_View_AuthViewRel_R
      = Some'0 x
  
  let rec take_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R)
    (return (x: t_Resource_View_AuthViewRel_R)) = any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:take_View_AuthViewRel_R ensures] ([@stop_split] [@expl:take ensures #0] id_View_AuthViewRel_R self.final
          = id_View_AuthViewRel_R self.current
        /\ id_View_AuthViewRel_R result = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:take ensures #1] view_Resource_View_AuthViewRel_R self.final = unit_View_AuthViewRel_R)
      /\ ([@stop_split] [@expl:take ensures #2] view_Resource_View_AuthViewRel_R result
      = view_Resource_View_AuthViewRel_R self.current)}
      (! return {result}) ]
  
  let rec join_in_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R)
    (other: t_Resource_View_AuthViewRel_R) (return (x: ())) =
    {[@stop_split] [@expl:join_in requires] id_View_AuthViewRel_R self.current = id_View_AuthViewRel_R other}
    any
    [ return (result: ()) ->
    {[@stop_split] [@expl:join_in_View_AuthViewRel_R ensures] ([@stop_split] [@expl:join_in ensures #0] id_View_AuthViewRel_R self.final
        = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:join_in ensures #1] Some'0 (view_Resource_View_AuthViewRel_R self.final)
      = op_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.current) (view_Resource_View_AuthViewRel_R other))}
      (! return {result}) ]
  
  function new_frag_AuthViewRel_R [@inline:trivial] (frag: t_R) : t_View_AuthViewRel_R = new_AuthViewRel_R (None) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_R
  
  function factor_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (factor: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match factor_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R factor) with
      | Some f -> match { f0'1 = auth_AuthViewRel_R self; f1'1 = auth_AuthViewRel_R factor } with
        | {f0'1 = Some a; f1'1 = None} -> Some'0 (new_AuthViewRel_R (Some a) f)
        | {f0'1 = a1; f1'1 = a2} -> if a1 = a2 then Some'0 (new_frag_AuthViewRel_R f) else None'0
        end
      | None -> None'0
      end
  
  axiom factor_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, factor: t_View_AuthViewRel_R. match factor_View_AuthViewRel_R self factor with
        | Some'0 c -> op_View_AuthViewRel_R factor c = Some'0 self
        | None'0 -> forall c: t_View_AuthViewRel_R. op_View_AuthViewRel_R factor c <> Some'0 self
        end
  
  predicate incl_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    factor_View_AuthViewRel_R other self <> None'0
  
  function incl_transitive_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) : ()
  
  axiom incl_transitive_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R. incl_View_AuthViewRel_R a b
      -> incl_View_AuthViewRel_R b c -> incl_View_AuthViewRel_R a c
  
  function associative_some_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (ab: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_some_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, ab: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = Some'0 ab -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = op_View_AuthViewRel_R ab c
  
  function associative_none_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_none_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = None'0 -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = None'0
  
  function incl_op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) (comb: t_View_AuthViewRel_R) : ()
  
  axiom incl_op_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R, comb: t_View_AuthViewRel_R. op_View_AuthViewRel_R self other
        = Some'0 comb -> incl_View_AuthViewRel_R self comb
  
  let rec weaken_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R) (target: t_View_AuthViewRel_R)
    (return (x: ())) =
    {[@stop_split] [@expl:weaken requires] incl_View_AuthViewRel_R target (view_Resource_View_AuthViewRel_R self.current)}
    any
    [ return (result: ()) ->
    {[@stop_split] [@expl:weaken_View_AuthViewRel_R ensures] ([@stop_split] [@expl:weaken ensures #0] id_View_AuthViewRel_R self.final
        = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:weaken ensures #1] view_Resource_View_AuthViewRel_R self.final = target)}
      (! return {result}) ]
  
  type t_U
  
  type t_AuthUpdate_U = { f0'2: t_U }
  
  predicate inv_U (_1: t_U)
  
  predicate inv_AuthUpdate_U (_1: t_AuthUpdate_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_AuthUpdate_U [inv_AuthUpdate_U x]. inv_AuthUpdate_U x = inv_U x.f0'2
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  predicate premise_AuthUpdate_U [@inline:trivial] (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0'2 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_AuthUpdate_U
  
  type tup2_R_R = { f0'3: t_R; f1'3: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  function update_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (_3: ()) : t_View_AuthViewRel_R
  
  axiom update_AuthUpdate_U_spec:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> auth_AuthViewRel_R (update_AuthUpdate_U self from _3)
      = Some ((update_U self.f0'2 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f0'3)
  
  axiom update_AuthUpdate_U_spec'0:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> frag_AuthViewRel_R (update_AuthUpdate_U self from _3)
      = (update_U self.f0'2 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f1'3
  
  let rec update_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R) (upd: t_AuthUpdate_U)
    (return (x: ())) =
    {[@stop_split] [@expl:update_View_AuthViewRel_R requires] ([@stop_split] [@expl:update 'upd' type invariant] inv_AuthUpdate_U upd)
    /\ ([@stop_split] [@expl:update requires] premise_AuthUpdate_U upd (view_Resource_View_AuthViewRel_R self.current))}
    any
    [ return (result: ()) ->
    {[@stop_split] [@expl:update_View_AuthViewRel_R ensures] ([@stop_split] [@expl:update ensures #0] id_View_AuthViewRel_R self.final
        = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:update ensures #1] view_Resource_View_AuthViewRel_R self.final
      = update_AuthUpdate_U upd (view_Resource_View_AuthViewRel_R self.current) result)}
      (! return {result}) ]
  
  type tup2_View_AuthViewRel_R_View_AuthViewRel_R = { f0'4: t_View_AuthViewRel_R; f1'4: t_View_AuthViewRel_R }
  
  predicate eq_View_AuthViewRel_R [@inline:trivial] (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    auth_AuthViewRel_R self = auth_AuthViewRel_R other /\ frag_AuthViewRel_R self = frag_AuthViewRel_R other
  
  meta "rewrite_def" predicate eq_View_AuthViewRel_R
  
  axiom eq_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R. eq_View_AuthViewRel_R self other = (self = other)
  
  predicate incl_eq_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    eq_View_AuthViewRel_R self other \/ incl_View_AuthViewRel_R self other
  
  predicate incl_eq_op_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (x: t_View_AuthViewRel_R) =
    match op_View_AuthViewRel_R a b with
      | None'0 -> false
      | Some'0 ab -> incl_eq_View_AuthViewRel_R ab x
      end
  
  let rec split_off_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R) (r: t_View_AuthViewRel_R)
    (s: t_View_AuthViewRel_R) (return (x: t_Resource_View_AuthViewRel_R)) =
    {[@stop_split] [@expl:split_off requires] incl_eq_op_View_AuthViewRel_R r s (view_Resource_View_AuthViewRel_R self.current)}
    any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:split_off_View_AuthViewRel_R ensures] ([@stop_split] [@expl:split_off ensures #0] id_View_AuthViewRel_R self.final
          = id_View_AuthViewRel_R self.current
        /\ id_View_AuthViewRel_R result = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:split_off ensures #1] view_Resource_View_AuthViewRel_R self.final = s)
      /\ ([@stop_split] [@expl:split_off ensures #2] view_Resource_View_AuthViewRel_R result = r)}
      (! return {result}) ]
  
  predicate invariant_Authority_R (self: t_Authority_R) =
    auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0) <> None
  
  predicate inv_Authority_R (_1: t_Authority_R)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Authority_R [inv_Authority_R x]. inv_Authority_R x = invariant_Authority_R x
  
  predicate invariant_refmut_Authority_R [@inline:trivial] (self: MutBorrow.t t_Authority_R) =
    inv_Authority_R self.current /\ inv_Authority_R self.final
  
  meta "rewrite_def" predicate invariant_refmut_Authority_R
  
  predicate inv_refmut_Authority_R [@inline:trivial] (_1: MutBorrow.t t_Authority_R) = invariant_refmut_Authority_R _1
  
  meta "rewrite_def" predicate inv_refmut_Authority_R
  
  predicate resolve_refmut_Authority_R [@inline:trivial] (_1: MutBorrow.t t_Authority_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Authority_R
  
  predicate resolve_Resource_View_AuthViewRel_R (_1: t_Resource_View_AuthViewRel_R)
  
  predicate resolve_refmut_Fragment_R [@inline:trivial] (_1: MutBorrow.t t_Fragment_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Fragment_R
  
  function id_R (self: t_Authority_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  function id_R'0 (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec update_R (self: MutBorrow.t t_Authority_R) (frag: MutBorrow.t t_Fragment_R) (upd: t_U) (return (x: ())) =
    {[@stop_split] [@expl:update_R requires] ([@stop_split] [@expl:update 'self' type invariant] inv_refmut_Authority_R self)
    /\ ([@stop_split] [@expl:update 'upd' type invariant] inv_U upd)
    /\ ([@stop_split] [@expl:update requires #0] id_R self.current = id_R'0 frag.current)
    /\ ([@stop_split] [@expl:update requires #1] premise_U upd (view_Authority_R self.current) (view_Fragment_R frag.current))}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &from <- new_AuthViewRel_R (Some (view_Authority_R self.current)) (view_Fragment_R frag.current) ] s1
      | s1 = MutBorrow.borrow_mut <t_Resource_View_AuthViewRel_R> {frag.current.f0'0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_29 <- _bor ] [ &frag <- { frag with current = { f0'0 = _bor.final } } ] s2)
      | s2 = take_View_AuthViewRel_R {_29} (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_28 <- _x ] s3)
      | s3 = MutBorrow.borrow_mut <t_Resource_View_AuthViewRel_R> {self.current.f0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_27 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s4)
      | s4 = join_in_View_AuthViewRel_R {_27} {_28} (fun (_x: ()) -> [ &_26 <- _x ] s5)
      | s5 = MutBorrow.borrow_mut <t_Resource_View_AuthViewRel_R> {self.current.f0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_31 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s6)
      | s6 = weaken_View_AuthViewRel_R {_31} {from} (fun (_x: ()) -> [ &_30 <- _x ] s7)
      | s7 = [ &_35 <- { f0'2 = upd } ] s8
      | s8 = MutBorrow.borrow_mut <t_Resource_View_AuthViewRel_R> {self.current.f0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_34 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s9)
      | s9 = update_View_AuthViewRel_R {_34} {_35} (fun (_x: ()) -> [ &_33 <- _x ] s10)
      | s10 =
        [ &rs <- { f0'4 = new_frag_AuthViewRel_R (frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.current.f0));
                   f1'4 = new_AuthViewRel_R (auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.current.f0)) unit_R } ]
        s11
      | s11 = MutBorrow.borrow_final <t_Resource_View_AuthViewRel_R> {self.current.f0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_41 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s12)
      | s12 = split_off_View_AuthViewRel_R {_41} {rs.f0'4} {rs.f1'4}
          (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_40 <- _x ] s13)
      | s13 = s14 [ _ck -> (! {[@expl:type invariant] inv_refmut_Authority_R self} any) ]
      | s14 = -{resolve_refmut_Authority_R self}- s15
      | s15 = -{resolve_Resource_View_AuthViewRel_R frag.current.f0'0}- s16
      | s16 = [ &frag <- { frag with current = { f0'0 = _40 } } ] s17
      | s17 = -{resolve_refmut_Fragment_R frag}- s18
      | s18 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Authority_R = self
    | & frag: MutBorrow.t t_Fragment_R = frag
    | & upd: t_U = upd
    | & from: t_View_AuthViewRel_R = Any.any_l ()
    | & _26: () = Any.any_l ()
    | & _27: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _28: t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _29: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _30: () = Any.any_l ()
    | & _31: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _33: () = Any.any_l ()
    | & _34: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _35: t_AuthUpdate_U = Any.any_l ()
    | & rs: tup2_View_AuthViewRel_R_View_AuthViewRel_R = Any.any_l ()
    | & _40: t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _41: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:update_R ensures] ([@stop_split] [@expl:update ensures #0] id_R self.current
        = id_R self.final)
      /\ ([@stop_split] [@expl:update ensures #1] id_R'0 frag.current = id_R'0 frag.final)
      /\ ([@stop_split] [@expl:update ensures #2] incl_R (view_Fragment_R frag.current) (view_Authority_R self.current))
      /\ ([@stop_split] [@expl:update ensures #3] { f0'3 = view_Authority_R self.final;
                                                    f1'3 = view_Fragment_R frag.final }
      = update_U upd (view_Authority_R self.current) (view_Fragment_R frag.current))}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Authority_R__frag_lemma (* ghost::resource::auth::Authority<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use map.Map
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_Authority_R = { f0'0: t_Resource_View_AuthViewRel_R }
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  type t_View_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None | Some t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None'0 | Some'0 t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'0 c -> op_R factor c = Some'0 self
        | None'0 -> forall c: t_R. op_R factor c <> Some'0 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'0
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'0 ab
      -> op_R b c = Some'0 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'0
      -> op_R b c = Some'0 bc -> op_R a bc = None'0
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'0 comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some'0 (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some'0 x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some'0 a'0 -> incl_R f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None'0) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  type tup2_Option_R_Option_R = { f0'1: t_Option_R; f1'1: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some'0 f -> match { f0'1 = auth_AuthViewRel_R self; f1'1 = auth_AuthViewRel_R other } with
        | {f0'1 = None'0; f1'1 = a} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | {f0'1 = a; f1'1 = None'0} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  function new_frag_AuthViewRel_R [@inline:trivial] (frag: t_R) : t_View_AuthViewRel_R = new_AuthViewRel_R (None'0) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_R
  
  function factor_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (factor: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match factor_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R factor) with
      | Some'0 f -> match { f0'1 = auth_AuthViewRel_R self; f1'1 = auth_AuthViewRel_R factor } with
        | {f0'1 = Some'0 a; f1'1 = None'0} -> Some (new_AuthViewRel_R (Some'0 a) f)
        | {f0'1 = a1; f1'1 = a2} -> if a1 = a2 then Some (new_frag_AuthViewRel_R f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, factor: t_View_AuthViewRel_R. match factor_View_AuthViewRel_R self factor with
        | Some c -> op_View_AuthViewRel_R factor c = Some self
        | None -> forall c: t_View_AuthViewRel_R. op_View_AuthViewRel_R factor c <> Some self
        end
  
  predicate incl_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    factor_View_AuthViewRel_R other self <> None
  
  function incl_transitive_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) : ()
  
  axiom incl_transitive_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R. incl_View_AuthViewRel_R a b
      -> incl_View_AuthViewRel_R b c -> incl_View_AuthViewRel_R a c
  
  function associative_some_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (ab: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_some_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, ab: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = Some ab -> op_View_AuthViewRel_R b c = Some bc -> op_View_AuthViewRel_R a bc = op_View_AuthViewRel_R ab c
  
  function associative_none_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_none_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = None -> op_View_AuthViewRel_R b c = Some bc -> op_View_AuthViewRel_R a bc = None
  
  function incl_op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) (comb: t_View_AuthViewRel_R) : ()
  
  axiom incl_op_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R, comb: t_View_AuthViewRel_R. op_View_AuthViewRel_R self other
        = Some comb -> incl_View_AuthViewRel_R self comb
  
  predicate eq_View_AuthViewRel_R [@inline:trivial] (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    auth_AuthViewRel_R self = auth_AuthViewRel_R other /\ frag_AuthViewRel_R self = frag_AuthViewRel_R other
  
  meta "rewrite_def" predicate eq_View_AuthViewRel_R
  
  axiom eq_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R. eq_View_AuthViewRel_R self other = (self = other)
  
  predicate incl_eq_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    eq_View_AuthViewRel_R self other \/ incl_View_AuthViewRel_R self other
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  let rec join_shared_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) (other: t_Resource_View_AuthViewRel_R)
    (return (x: t_Resource_View_AuthViewRel_R)) = {[@stop_split] [@expl:join_shared requires] id_View_AuthViewRel_R self
    = id_View_AuthViewRel_R other}
    any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:join_shared_View_AuthViewRel_R ensures] ([@stop_split] [@expl:join_shared ensures #0] id_View_AuthViewRel_R result
        = id_View_AuthViewRel_R self)
      /\ ([@stop_split] [@expl:join_shared ensures #1] incl_eq_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R self) (view_Resource_View_AuthViewRel_R result)
      /\ incl_eq_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R other) (view_Resource_View_AuthViewRel_R result))}
      (! return {result}) ]
  
  predicate invariant_Authority_R (self: t_Authority_R) =
    auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0'0) <> None'0
  
  predicate inv_Authority_R (_1: t_Authority_R)
  
  axiom inv_axiom [@rewrite]: forall x: t_Authority_R [inv_Authority_R x]. inv_Authority_R x = invariant_Authority_R x
  
  predicate invariant_ref_Authority_R [@inline:trivial] (self: t_Authority_R) = inv_Authority_R self
  
  meta "rewrite_def" predicate invariant_ref_Authority_R
  
  predicate inv_ref_Authority_R [@inline:trivial] (_1: t_Authority_R) = invariant_ref_Authority_R _1
  
  meta "rewrite_def" predicate inv_ref_Authority_R
  
  function id_R (self: t_Authority_R) : t_Id = id_View_AuthViewRel_R self.f0'0
  
  function id_R'0 (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some'0 x -> x
      | None'0 -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function view_Authority_R (self: t_Authority_R) : t_R =
    unwrap_Option_R (auth_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0'0))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec frag_lemma_R (self: t_Authority_R) (frag: t_Fragment_R) (return (x: ())) =
    {[@stop_split] [@expl:frag_lemma_R requires] ([@stop_split] [@expl:frag_lemma 'self' type invariant] inv_ref_Authority_R self)
    /\ ([@stop_split] [@expl:frag_lemma requires] id_R self = id_R'0 frag)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_12 <- frag.f0 ] s1
      | s1 = join_shared_View_AuthViewRel_R {self.f0'0} {_12}
          (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_9 <- _x ] s2)
      | s2 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: t_Authority_R = self
    | & frag: t_Fragment_R = frag
    | & _9: t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _12: t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:frag_lemma ensures] incl_R (view_Fragment_R frag) (view_Authority_R self)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__new_unit (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Id
  
  type t_Resource_View_AuthViewRel_R
  
  type t_View_AuthViewRel_R
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None | Some t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None'0 | Some'0 t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'0 c -> op_R factor c = Some'0 self
        | None'0 -> forall c: t_R. op_R factor c <> Some'0 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'0
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'0 ab
      -> op_R b c = Some'0 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'0
      -> op_R b c = Some'0 bc -> op_R a bc = None'0
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'0 comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some'0 (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some'0 x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some'0 a'0 -> incl_R f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None'0) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  type tup2_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some'0 f -> match { f0 = auth_AuthViewRel_R self; f1 = auth_AuthViewRel_R other } with
        | {f0 = None'0; f1 = a} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | {f0 = a; f1 = None'0} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  constant unit_View_AuthViewRel_R : t_View_AuthViewRel_R
  
  axiom unit_View_AuthViewRel_R_spec:
    forall x: t_View_AuthViewRel_R [op_View_AuthViewRel_R x unit_View_AuthViewRel_R]. op_View_AuthViewRel_R x unit_View_AuthViewRel_R
      = Some x
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  let rec new_unit_View_AuthViewRel_R (id: t_Id) (return (x: t_Resource_View_AuthViewRel_R)) = any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:new_unit ensures] view_Resource_View_AuthViewRel_R result = unit_View_AuthViewRel_R
      /\ id_View_AuthViewRel_R result = id}
      (! return {result}) ]
  
  type t_Fragment_R = { f0'0: t_Resource_View_AuthViewRel_R }
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0'0)
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_unit_R (id: t_Id) (return (x: t_Fragment_R)) = (! bb0
    [ bb0 = s0
      [ s0 = new_unit_View_AuthViewRel_R {id} (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_4 <- _x ] s1)
      | s1 = [ &_ret <- { f0'0 = _4 } ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Fragment_R = Any.any_l () | & id: t_Id = id | & _4: t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: t_Fragment_R) -> {[@stop_split] [@expl:new_unit ensures] view_Fragment_R result = unit_R
      /\ id_R result = id}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__core (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_View_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None | Some t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None'0 | Some'0 t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'0 c -> op_R factor c = Some'0 self
        | None'0 -> forall c: t_R. op_R factor c <> Some'0 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'0
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'0 ab
      -> op_R b c = Some'0 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'0
      -> op_R b c = Some'0 bc -> op_R a bc = None'0
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'0 comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some'0 (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some'0 x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some'0 a'0 -> incl_R f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None'0) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some'0 f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None'0; f1'0 = a} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | {f0'0 = a; f1'0 = None'0} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  function new_frag_AuthViewRel_R [@inline:trivial] (frag: t_R) : t_View_AuthViewRel_R = new_AuthViewRel_R (None'0) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_R
  
  function core_View_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R =
    Some (new_frag_AuthViewRel_R (core_total_R (frag_AuthViewRel_R self)))
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  let rec core_View_AuthViewRel_R'0 (self: t_Resource_View_AuthViewRel_R) (return (x: t_Resource_View_AuthViewRel_R)) =
    {[@stop_split] [@expl:core requires] core_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R self) <> None}
    any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:core_View_AuthViewRel_R ensures] ([@stop_split] [@expl:core ensures #0] id_View_AuthViewRel_R result
        = id_View_AuthViewRel_R self)
      /\ ([@stop_split] [@expl:core ensures #1] Some (view_Resource_View_AuthViewRel_R result)
      = core_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R self))}
      (! return {result}) ]
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec core_R'0 (self: t_Fragment_R) (return (x: t_Fragment_R)) = (! bb0
    [ bb0 = s0
      [ s0 = core_View_AuthViewRel_R'0 {self.f0} (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_6 <- _x ] s1)
      | s1 = [ &_ret <- { f0 = _6 } ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Fragment_R = Any.any_l ()
    | & self: t_Fragment_R = self
    | & _6: t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: t_Fragment_R) ->
    {[@stop_split] [@expl:core_R ensures] ([@stop_split] [@expl:core ensures #0] id_R result = id_R self)
      /\ ([@stop_split] [@expl:core ensures #1] view_Fragment_R result = core_total_R (view_Fragment_R self))}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__split (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function new_frag_AuthViewRel_R [@inline:trivial] (frag: t_R) : t_View_AuthViewRel_R = new_AuthViewRel_R (None) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_R
  
  type tup2_Resource_View_AuthViewRel_R_Resource_View_AuthViewRel_R = {
    f0'0: t_Resource_View_AuthViewRel_R;
    f1'0: t_Resource_View_AuthViewRel_R }
  
  type t_Option_View_AuthViewRel_R = None'0 | Some'0 t_View_AuthViewRel_R
  
  type tup2_Option_R_Option_R = { f0'1: t_Option_R; f1'1: t_Option_R }
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some f -> match { f0'1 = auth_AuthViewRel_R self; f1'1 = auth_AuthViewRel_R other } with
        | {f0'1 = None; f1'1 = a} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | {f0'1 = a; f1'1 = None} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | _ -> None'0
        end
      | None -> None'0
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  function factor_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (factor: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match factor_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R factor) with
      | Some f -> match { f0'1 = auth_AuthViewRel_R self; f1'1 = auth_AuthViewRel_R factor } with
        | {f0'1 = Some a; f1'1 = None} -> Some'0 (new_AuthViewRel_R (Some a) f)
        | {f0'1 = a1; f1'1 = a2} -> if a1 = a2 then Some'0 (new_frag_AuthViewRel_R f) else None'0
        end
      | None -> None'0
      end
  
  axiom factor_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, factor: t_View_AuthViewRel_R. match factor_View_AuthViewRel_R self factor with
        | Some'0 c -> op_View_AuthViewRel_R factor c = Some'0 self
        | None'0 -> forall c: t_View_AuthViewRel_R. op_View_AuthViewRel_R factor c <> Some'0 self
        end
  
  predicate incl_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    factor_View_AuthViewRel_R other self <> None'0
  
  function incl_transitive_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) : ()
  
  axiom incl_transitive_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R. incl_View_AuthViewRel_R a b
      -> incl_View_AuthViewRel_R b c -> incl_View_AuthViewRel_R a c
  
  function associative_some_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (ab: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_some_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, ab: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = Some'0 ab -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = op_View_AuthViewRel_R ab c
  
  function associative_none_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_none_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = None'0 -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = None'0
  
  function incl_op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) (comb: t_View_AuthViewRel_R) : ()
  
  axiom incl_op_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R, comb: t_View_AuthViewRel_R. op_View_AuthViewRel_R self other
        = Some'0 comb -> incl_View_AuthViewRel_R self comb
  
  predicate eq_View_AuthViewRel_R [@inline:trivial] (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    auth_AuthViewRel_R self = auth_AuthViewRel_R other /\ frag_AuthViewRel_R self = frag_AuthViewRel_R other
  
  meta "rewrite_def" predicate eq_View_AuthViewRel_R
  
  axiom eq_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R. eq_View_AuthViewRel_R self other = (self = other)
  
  predicate incl_eq_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    eq_View_AuthViewRel_R self other \/ incl_View_AuthViewRel_R self other
  
  predicate incl_eq_op_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (x: t_View_AuthViewRel_R) =
    match op_View_AuthViewRel_R a b with
      | None'0 -> false
      | Some'0 ab -> incl_eq_View_AuthViewRel_R ab x
      end
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  let rec split_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) (a: t_View_AuthViewRel_R)
    (b: t_View_AuthViewRel_R) (return (x: tup2_Resource_View_AuthViewRel_R_Resource_View_AuthViewRel_R)) =
    {[@stop_split] [@expl:split requires] incl_eq_op_View_AuthViewRel_R a b (view_Resource_View_AuthViewRel_R self)}
    any
    [ return (result: tup2_Resource_View_AuthViewRel_R_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:split_View_AuthViewRel_R ensures] ([@stop_split] [@expl:split ensures #0] id_View_AuthViewRel_R result.f0'0
          = id_View_AuthViewRel_R self
        /\ id_View_AuthViewRel_R result.f1'0 = id_View_AuthViewRel_R self)
      /\ ([@stop_split] [@expl:split ensures #1] view_Resource_View_AuthViewRel_R result.f0'0 = a)
      /\ ([@stop_split] [@expl:split ensures #2] view_Resource_View_AuthViewRel_R result.f1'0 = b)}
      (! return {result}) ]
  
  type tup2_Fragment_R_Fragment_R = { f0'2: t_Fragment_R; f1'2: t_Fragment_R }
  
  predicate eq_R (self: t_R) (other: t_R)
  
  axiom eq_R_spec: forall self: t_R, other: t_R. eq_R self other = (self = other)
  
  predicate incl_eq_R (self: t_R) (other: t_R) = eq_R self other \/ incl_R self other
  
  predicate incl_eq_op_R (a: t_R) (b: t_R) (x: t_R) =
    match op_R a b with
      | None -> false
      | Some ab -> incl_eq_R ab x
      end
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec split_R (self: t_Fragment_R) (a: t_R) (b: t_R) (return (x: tup2_Fragment_R_Fragment_R)) =
    {[@stop_split] [@expl:split requires] incl_eq_op_R a b (view_Fragment_R self)}
    (! bb0
    [ bb0 = s0
      [ s0 = split_View_AuthViewRel_R {self.f0} {new_frag_AuthViewRel_R a} {new_frag_AuthViewRel_R b}
          (fun (_x: tup2_Resource_View_AuthViewRel_R_Resource_View_AuthViewRel_R) -> [ &_16 <- _x ] s1)
      | s1 = [ &r1 <- _16.f0'0 ] s2
      | s2 = [ &r2 <- _16.f1'0 ] s3
      | s3 = [ &_24 <- { f0 = r1 } ] s4
      | s4 = [ &_26 <- { f0 = r2 } ] s5
      | s5 = [ &_ret <- { f0'2 = _24; f1'2 = _26 } ] s6
      | s6 = return {_ret} ] ]
    [ & _ret: tup2_Fragment_R_Fragment_R = Any.any_l ()
    | & self: t_Fragment_R = self
    | & a: t_R = a
    | & b: t_R = b
    | & r1: t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & r2: t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _16: tup2_Resource_View_AuthViewRel_R_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _24: t_Fragment_R = Any.any_l ()
    | & _26: t_Fragment_R = Any.any_l () ])
    [ return (result: tup2_Fragment_R_Fragment_R) ->
    {[@stop_split] [@expl:split_R ensures] ([@stop_split] [@expl:split ensures #0] id_R result.f0'2 = id_R self
        /\ id_R result.f1'2 = id_R self)
      /\ ([@stop_split] [@expl:split ensures #1] view_Fragment_R result.f0'2 = a)
      /\ ([@stop_split] [@expl:split ensures #2] view_Fragment_R result.f1'2 = b)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__split_off (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function new_frag_AuthViewRel_R [@inline:trivial] (frag: t_R) : t_View_AuthViewRel_R = new_AuthViewRel_R (None) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None'0 | Some'0 t_View_AuthViewRel_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None; f1'0 = a} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | {f0'0 = a; f1'0 = None} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | _ -> None'0
        end
      | None -> None'0
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  function factor_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (factor: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match factor_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R factor) with
      | Some f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R factor } with
        | {f0'0 = Some a; f1'0 = None} -> Some'0 (new_AuthViewRel_R (Some a) f)
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then Some'0 (new_frag_AuthViewRel_R f) else None'0
        end
      | None -> None'0
      end
  
  axiom factor_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, factor: t_View_AuthViewRel_R. match factor_View_AuthViewRel_R self factor with
        | Some'0 c -> op_View_AuthViewRel_R factor c = Some'0 self
        | None'0 -> forall c: t_View_AuthViewRel_R. op_View_AuthViewRel_R factor c <> Some'0 self
        end
  
  predicate incl_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    factor_View_AuthViewRel_R other self <> None'0
  
  function incl_transitive_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) : ()
  
  axiom incl_transitive_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R. incl_View_AuthViewRel_R a b
      -> incl_View_AuthViewRel_R b c -> incl_View_AuthViewRel_R a c
  
  function associative_some_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (ab: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_some_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, ab: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = Some'0 ab -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = op_View_AuthViewRel_R ab c
  
  function associative_none_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_none_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = None'0 -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = None'0
  
  function incl_op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) (comb: t_View_AuthViewRel_R) : ()
  
  axiom incl_op_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R, comb: t_View_AuthViewRel_R. op_View_AuthViewRel_R self other
        = Some'0 comb -> incl_View_AuthViewRel_R self comb
  
  predicate eq_View_AuthViewRel_R [@inline:trivial] (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    auth_AuthViewRel_R self = auth_AuthViewRel_R other /\ frag_AuthViewRel_R self = frag_AuthViewRel_R other
  
  meta "rewrite_def" predicate eq_View_AuthViewRel_R
  
  axiom eq_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R. eq_View_AuthViewRel_R self other = (self = other)
  
  predicate incl_eq_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    eq_View_AuthViewRel_R self other \/ incl_View_AuthViewRel_R self other
  
  predicate incl_eq_op_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (x: t_View_AuthViewRel_R) =
    match op_View_AuthViewRel_R a b with
      | None'0 -> false
      | Some'0 ab -> incl_eq_View_AuthViewRel_R ab x
      end
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  let rec split_off_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R) (r: t_View_AuthViewRel_R)
    (s: t_View_AuthViewRel_R) (return (x: t_Resource_View_AuthViewRel_R)) =
    {[@stop_split] [@expl:split_off requires] incl_eq_op_View_AuthViewRel_R r s (view_Resource_View_AuthViewRel_R self.current)}
    any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:split_off_View_AuthViewRel_R ensures] ([@stop_split] [@expl:split_off ensures #0] id_View_AuthViewRel_R self.final
          = id_View_AuthViewRel_R self.current
        /\ id_View_AuthViewRel_R result = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:split_off ensures #1] view_Resource_View_AuthViewRel_R self.final = s)
      /\ ([@stop_split] [@expl:split_off ensures #2] view_Resource_View_AuthViewRel_R result = r)}
      (! return {result}) ]
  
  predicate resolve_refmut_Fragment_R [@inline:trivial] (_1: MutBorrow.t t_Fragment_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Fragment_R
  
  predicate eq_R (self: t_R) (other: t_R)
  
  axiom eq_R_spec: forall self: t_R, other: t_R. eq_R self other = (self = other)
  
  predicate incl_eq_R (self: t_R) (other: t_R) = eq_R self other \/ incl_R self other
  
  predicate incl_eq_op_R (a: t_R) (b: t_R) (x: t_R) =
    match op_R a b with
      | None -> false
      | Some ab -> incl_eq_R ab x
      end
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec split_off_R (self: MutBorrow.t t_Fragment_R) (r: t_R) (s: t_R) (return (x: t_Fragment_R)) =
    {[@stop_split] [@expl:split_off requires] incl_eq_op_R r s (view_Fragment_R self.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource_View_AuthViewRel_R> {self.current.f0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_16 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = split_off_View_AuthViewRel_R {_16} {new_frag_AuthViewRel_R r} {new_frag_AuthViewRel_R s}
          (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_15 <- _x ] s2)
      | s2 = -{resolve_refmut_Fragment_R self}- s3
      | s3 = [ &_ret <- { f0 = _15 } ] s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_Fragment_R = Any.any_l ()
    | & self: MutBorrow.t t_Fragment_R = self
    | & r: t_R = r
    | & s: t_R = s
    | & _15: t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _16: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: t_Fragment_R) ->
    {[@stop_split] [@expl:split_off_R ensures] ([@stop_split] [@expl:split_off ensures #0] id_R self.final
          = id_R self.current
        /\ id_R result = id_R self.current)
      /\ ([@stop_split] [@expl:split_off ensures #1] view_Fragment_R self.final = s)
      /\ ([@stop_split] [@expl:split_off ensures #2] view_Fragment_R result = r)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__join (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  type t_View_AuthViewRel_R
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None | Some t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None'0 | Some'0 t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'0 c -> op_R factor c = Some'0 self
        | None'0 -> forall c: t_R. op_R factor c <> Some'0 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'0
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'0 ab
      -> op_R b c = Some'0 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'0
      -> op_R b c = Some'0 bc -> op_R a bc = None'0
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'0 comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some'0 (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some'0 x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some'0 a'0 -> incl_R f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None'0) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some'0 f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None'0; f1'0 = a} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | {f0'0 = a; f1'0 = None'0} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  let rec join_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) (other: t_Resource_View_AuthViewRel_R)
    (return (x: t_Resource_View_AuthViewRel_R)) = {[@stop_split] [@expl:join requires] id_View_AuthViewRel_R self
    = id_View_AuthViewRel_R other}
    any
    [ return (result: t_Resource_View_AuthViewRel_R) ->
    {[@stop_split] [@expl:join_View_AuthViewRel_R ensures] ([@stop_split] [@expl:join ensures #0] id_View_AuthViewRel_R result
        = id_View_AuthViewRel_R self)
      /\ ([@stop_split] [@expl:join ensures #1] Some (view_Resource_View_AuthViewRel_R result)
      = op_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R self) (view_Resource_View_AuthViewRel_R other))}
      (! return {result}) ]
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec join_R (self: t_Fragment_R) (other: t_Fragment_R) (return (x: t_Fragment_R)) =
    {[@stop_split] [@expl:join requires] id_R self = id_R other}
    (! bb0
    [ bb0 = s0
      [ s0 = join_View_AuthViewRel_R {self.f0} {other.f0} (fun (_x: t_Resource_View_AuthViewRel_R) -> [ &_11 <- _x ] s1)
      | s1 = [ &_ret <- { f0 = _11 } ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Fragment_R = Any.any_l ()
    | & self: t_Fragment_R = self
    | & other: t_Fragment_R = other
    | & _11: t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: t_Fragment_R) ->
    {[@stop_split] [@expl:join_R ensures] ([@stop_split] [@expl:join ensures #0] id_R result = id_R self)
      /\ ([@stop_split] [@expl:join ensures #1] Some'0 (view_Fragment_R result)
      = op_R (view_Fragment_R self) (view_Fragment_R other))}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__join_in (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  type t_View_AuthViewRel_R
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None | Some t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None'0 | Some'0 t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'0 c -> op_R factor c = Some'0 self
        | None'0 -> forall c: t_R. op_R factor c <> Some'0 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'0
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'0 ab
      -> op_R b c = Some'0 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'0
      -> op_R b c = Some'0 bc -> op_R a bc = None'0
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'0 comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some'0 (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some'0 x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some'0 a'0 -> incl_R f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None'0) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some'0 f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None'0; f1'0 = a} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | {f0'0 = a; f1'0 = None'0} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  let rec join_in_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R)
    (other: t_Resource_View_AuthViewRel_R) (return (x: ())) =
    {[@stop_split] [@expl:join_in requires] id_View_AuthViewRel_R self.current = id_View_AuthViewRel_R other}
    any
    [ return (result: ()) ->
    {[@stop_split] [@expl:join_in_View_AuthViewRel_R ensures] ([@stop_split] [@expl:join_in ensures #0] id_View_AuthViewRel_R self.final
        = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:join_in ensures #1] Some (view_Resource_View_AuthViewRel_R self.final)
      = op_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.current) (view_Resource_View_AuthViewRel_R other))}
      (! return {result}) ]
  
  predicate resolve_refmut_Fragment_R [@inline:trivial] (_1: MutBorrow.t t_Fragment_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Fragment_R
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec join_in_R (self: MutBorrow.t t_Fragment_R) (other: t_Fragment_R) (return (x: ())) =
    {[@stop_split] [@expl:join_in requires] id_R self.current = id_R other}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource_View_AuthViewRel_R> {self.current.f0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_11 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = join_in_View_AuthViewRel_R {_11} {other.f0} (fun (_x: ()) -> [ &_ret <- _x ] s2)
      | s2 = -{resolve_refmut_Fragment_R self}- s3
      | s3 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Fragment_R = self
    | & other: t_Fragment_R = other
    | & _11: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:join_in_R ensures] ([@stop_split] [@expl:join_in ensures #0] id_R self.final
        = id_R self.current)
      /\ ([@stop_split] [@expl:join_in ensures #1] Some'0 (view_Fragment_R self.final)
      = op_R (view_Fragment_R self.current) (view_Fragment_R other))}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__weaken (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function new_frag_AuthViewRel_R [@inline:trivial] (frag: t_R) : t_View_AuthViewRel_R = new_AuthViewRel_R (None) frag
  
  meta "rewrite_def" function new_frag_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None'0 | Some'0 t_View_AuthViewRel_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None; f1'0 = a} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | {f0'0 = a; f1'0 = None} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | _ -> None'0
        end
      | None -> None'0
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  function factor_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (factor: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match factor_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R factor) with
      | Some f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R factor } with
        | {f0'0 = Some a; f1'0 = None} -> Some'0 (new_AuthViewRel_R (Some a) f)
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then Some'0 (new_frag_AuthViewRel_R f) else None'0
        end
      | None -> None'0
      end
  
  axiom factor_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, factor: t_View_AuthViewRel_R. match factor_View_AuthViewRel_R self factor with
        | Some'0 c -> op_View_AuthViewRel_R factor c = Some'0 self
        | None'0 -> forall c: t_View_AuthViewRel_R. op_View_AuthViewRel_R factor c <> Some'0 self
        end
  
  predicate incl_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) =
    factor_View_AuthViewRel_R other self <> None'0
  
  function incl_transitive_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) : ()
  
  axiom incl_transitive_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R. incl_View_AuthViewRel_R a b
      -> incl_View_AuthViewRel_R b c -> incl_View_AuthViewRel_R a c
  
  function associative_some_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (ab: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_some_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, ab: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = Some'0 ab -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = op_View_AuthViewRel_R ab c
  
  function associative_none_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) (c: t_View_AuthViewRel_R) (bc: t_View_AuthViewRel_R) : ()
  
  axiom associative_none_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R, c: t_View_AuthViewRel_R, bc: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b
        = None'0 -> op_View_AuthViewRel_R b c = Some'0 bc -> op_View_AuthViewRel_R a bc = None'0
  
  function incl_op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) (comb: t_View_AuthViewRel_R) : ()
  
  axiom incl_op_View_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R, other: t_View_AuthViewRel_R, comb: t_View_AuthViewRel_R. op_View_AuthViewRel_R self other
        = Some'0 comb -> incl_View_AuthViewRel_R self comb
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  let rec weaken_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R) (target: t_View_AuthViewRel_R)
    (return (x: ())) =
    {[@stop_split] [@expl:weaken requires] incl_View_AuthViewRel_R target (view_Resource_View_AuthViewRel_R self.current)}
    any
    [ return (result: ()) ->
    {[@stop_split] [@expl:weaken_View_AuthViewRel_R ensures] ([@stop_split] [@expl:weaken ensures #0] id_View_AuthViewRel_R self.final
        = id_View_AuthViewRel_R self.current)
      /\ ([@stop_split] [@expl:weaken ensures #1] view_Resource_View_AuthViewRel_R self.final = target)}
      (! return {result}) ]
  
  predicate resolve_refmut_Fragment_R [@inline:trivial] (_1: MutBorrow.t t_Fragment_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Fragment_R
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec weaken_R (self: MutBorrow.t t_Fragment_R) (target: t_R) (return (x: ())) =
    {[@stop_split] [@expl:weaken requires] incl_R target (view_Fragment_R self.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_Resource_View_AuthViewRel_R> {self.current.f0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_12 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s1)
      | s1 = weaken_View_AuthViewRel_R {_12} {new_frag_AuthViewRel_R target} (fun (_x: ()) -> [ &_11 <- _x ] s2)
      | s2 = -{resolve_refmut_Fragment_R self}- s3
      | s3 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Fragment_R = self
    | & target: t_R = target
    | & _11: () = Any.any_l ()
    | & _12: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:weaken_R ensures] ([@stop_split] [@expl:weaken ensures #0] id_R self.final
        = id_R self.current)
      /\ ([@stop_split] [@expl:weaken ensures #1] view_Fragment_R self.final = target)}
      (! return {result}) ]
end
module M_ghost__resource__auth__impl_Fragment_R__valid_op_lemma (* ghost::resource::auth::Fragment<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Resource_View_AuthViewRel_R
  
  type t_Fragment_R = { f0: t_Resource_View_AuthViewRel_R }
  
  type t_Id
  
  function id_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_Id
  
  type t_View_AuthViewRel_R
  
  type t_Option_View_AuthViewRel_R = None | Some t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None'0 | Some'0 t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'0 c -> op_R factor c = Some'0 self
        | None'0 -> forall c: t_R. op_R factor c <> Some'0 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'0
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'0 ab
      -> op_R b c = Some'0 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'0
      -> op_R b c = Some'0 bc -> op_R a bc = None'0
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'0 comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some'0 (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some'0 x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some'0 a'0 -> incl_R f a'0
      | None'0 -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None'0) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some'0 f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None'0; f1'0 = a} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | {f0'0 = a; f1'0 = None'0} -> if rel_AuthViewRel_R a f then Some (new_AuthViewRel_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  function val_View_AuthViewRel_R (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
  
  function view_Resource_View_AuthViewRel_R [@inline:trivial] (self: t_Resource_View_AuthViewRel_R) : t_View_AuthViewRel_R
   = val_View_AuthViewRel_R self
  
  meta "rewrite_def" function view_Resource_View_AuthViewRel_R
  
  let rec valid_op_lemma_View_AuthViewRel_R (self: MutBorrow.t t_Resource_View_AuthViewRel_R)
    (other: t_Resource_View_AuthViewRel_R) (return (x: ())) =
    {[@stop_split] [@expl:valid_op_lemma requires] id_View_AuthViewRel_R self.current = id_View_AuthViewRel_R other}
    any
    [ return (result: ()) ->
    {[@stop_split] [@expl:valid_op_lemma_View_AuthViewRel_R ensures] ([@stop_split] [@expl:valid_op_lemma ensures #0] self.final
        = self.current)
      /\ ([@stop_split] [@expl:valid_op_lemma ensures #1] op_View_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.current) (view_Resource_View_AuthViewRel_R other)
      <> None)}
      (! return {result}) ]
  
  predicate resolve_refmut_Fragment_R [@inline:trivial] (_1: MutBorrow.t t_Fragment_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Fragment_R
  
  function id_R (self: t_Fragment_R) : t_Id = id_View_AuthViewRel_R self.f0
  
  function view_Fragment_R (self: t_Fragment_R) : t_R = frag_AuthViewRel_R (view_Resource_View_AuthViewRel_R self.f0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec valid_op_lemma_R (self: MutBorrow.t t_Fragment_R) (other: t_Fragment_R) (return (x: ())) =
    {[@stop_split] [@expl:valid_op_lemma requires] id_R self.current = id_R other}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_14 <- other.f0 ] s1
      | s1 = MutBorrow.borrow_final <t_Resource_View_AuthViewRel_R> {self.current.f0}
          {MutBorrow.inherit_id (MutBorrow.get_id self) 0}
          (fun (_bor: MutBorrow.t t_Resource_View_AuthViewRel_R) ->
            [ &_12 <- _bor ] [ &self <- { self with current = { f0 = _bor.final } } ] s2)
      | s2 = valid_op_lemma_View_AuthViewRel_R {_12} {_14} (fun (_x: ()) -> [ &_11 <- _x ] s3)
      | s3 = -{resolve_refmut_Fragment_R self}- s4
      | s4 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Fragment_R = self
    | & other: t_Fragment_R = other
    | & _11: () = Any.any_l ()
    | & _12: MutBorrow.t t_Resource_View_AuthViewRel_R = Any.any_l ()
    | & _14: t_Resource_View_AuthViewRel_R = Any.any_l () ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:valid_op_lemma_R ensures] ([@stop_split] [@expl:valid_op_lemma ensures #0] self.final
        = self.current)
      /\ ([@stop_split] [@expl:valid_op_lemma ensures #1] op_R (view_Fragment_R self.current) (view_Fragment_R other)
      <> None'0)}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__split_off (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Resource_R
  
  let rec dummy_R (return (x: t_Resource_R)) = any [ return (result: t_Resource_R) -> (! return {result}) ]
  
  let rec replace_Resource_R (dest: MutBorrow.t t_Resource_R) (src: t_Resource_R) (return (x: t_Resource_R)) = any
    [ return (result: t_Resource_R) ->
    {[@stop_split] [@expl:replace_Resource_R ensures] ([@stop_split] [@expl:replace ensures #0] dest.final = src)
      /\ ([@stop_split] [@expl:replace ensures #1] result = dest.current)}
      (! return {result}) ]
  
  type t_R
  
  type tup2_Resource_R_Resource_R = { f0: t_Resource_R; f1: t_Resource_R }
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate eq_R (self: t_R) (other: t_R)
  
  axiom eq_R_spec: forall self: t_R, other: t_R. eq_R self other = (self = other)
  
  predicate incl_eq_R (self: t_R) (other: t_R) = eq_R self other \/ incl_R self other
  
  predicate incl_eq_op_R (a: t_R) (b: t_R) (x: t_R) =
    match op_R a b with
      | None -> false
      | Some ab -> incl_eq_R ab x
      end
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  let rec split_R (self: t_Resource_R) (a: t_R) (b: t_R) (return (x: tup2_Resource_R_Resource_R)) =
    {[@stop_split] [@expl:split requires] incl_eq_op_R a b (view_Resource_R self)}
    any
    [ return (result: tup2_Resource_R_Resource_R) ->
    {[@stop_split] [@expl:split_R ensures] ([@stop_split] [@expl:split ensures #0] id_R result.f0 = id_R self
        /\ id_R result.f1 = id_R self)
      /\ ([@stop_split] [@expl:split ensures #1] view_Resource_R result.f0 = a)
      /\ ([@stop_split] [@expl:split ensures #2] view_Resource_R result.f1 = b)}
      (! return {result}) ]
  
  predicate resolve_refmut_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Resource_R
  
  predicate resolve_Resource_R (_1: t_Resource_R)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec split_off_R (self: MutBorrow.t t_Resource_R) (r: t_R) (s: t_R) (return (x: t_Resource_R)) =
    {[@stop_split] [@expl:split_off requires] incl_eq_op_R r s (view_Resource_R self.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = dummy_R (fun (_x: t_Resource_R) -> [ &_17 <- _x ] s1)
      | s1 = MutBorrow.borrow_mut <t_Resource_R> {self.current}
          (fun (_bor: MutBorrow.t t_Resource_R) -> [ &_16 <- _bor ] [ &self <- { self with current = _bor.final } ] s2)
      | s2 = replace_Resource_R {_16} {_17} (fun (_x: t_Resource_R) -> [ &this <- _x ] s3)
      | s3 = split_R {this} {r} {s} (fun (_x: tup2_Resource_R_Resource_R) -> [ &_20 <- _x ] s4)
      | s4 = [ &r'0 <- _20.f0 ] s5
      | s5 = [ &this'0 <- _20.f1 ] s6
      | s6 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Resource_R) -> [ &_25 <- _bor ] [ &self <- { self with current = _bor.final } ] s7)
      | s7 = replace_Resource_R {_25} {this'0} (fun (_x: t_Resource_R) -> [ &_24 <- _x ] s8)
      | s8 = -{resolve_refmut_Resource_R self}- s9
      | s9 = -{resolve_Resource_R _24}- s10
      | s10 = [ &_ret <- r'0 ] s11
      | s11 = return {_ret} ] ]
    [ & _ret: t_Resource_R = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & r: t_R = r
    | & s: t_R = s
    | & this: t_Resource_R = Any.any_l ()
    | & _16: MutBorrow.t t_Resource_R = Any.any_l ()
    | & _17: t_Resource_R = Any.any_l ()
    | & r'0: t_Resource_R = Any.any_l ()
    | & this'0: t_Resource_R = Any.any_l ()
    | & _20: tup2_Resource_R_Resource_R = Any.any_l ()
    | & _24: t_Resource_R = Any.any_l ()
    | & _25: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: t_Resource_R) ->
    {[@stop_split] [@expl:split_off_R ensures] ([@stop_split] [@expl:split_off ensures #0] id_R self.final
          = id_R self.current
        /\ id_R result = id_R self.current)
      /\ ([@stop_split] [@expl:split_off ensures #1] view_Resource_R self.final = s)
      /\ ([@stop_split] [@expl:split_off ensures #2] view_Resource_R result = r)}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__join_in (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Resource_R
  
  let rec dummy_R (return (x: t_Resource_R)) = any [ return (result: t_Resource_R) -> (! return {result}) ]
  
  let rec replace_Resource_R (dest: MutBorrow.t t_Resource_R) (src: t_Resource_R) (return (x: t_Resource_R)) = any
    [ return (result: t_Resource_R) ->
    {[@stop_split] [@expl:replace_Resource_R ensures] ([@stop_split] [@expl:replace ensures #0] dest.final = src)
      /\ ([@stop_split] [@expl:replace ensures #1] result = dest.current)}
      (! return {result}) ]
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  type t_R
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  let rec join_R (self: t_Resource_R) (other: t_Resource_R) (return (x: t_Resource_R)) =
    {[@stop_split] [@expl:join requires] id_R self = id_R other}
    any
    [ return (result: t_Resource_R) ->
    {[@stop_split] [@expl:join_R ensures] ([@stop_split] [@expl:join ensures #0] id_R result = id_R self)
      /\ ([@stop_split] [@expl:join ensures #1] Some (view_Resource_R result)
      = op_R (view_Resource_R self) (view_Resource_R other))}
      (! return {result}) ]
  
  predicate resolve_refmut_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Resource_R
  
  predicate resolve_Resource_R (_1: t_Resource_R)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec join_in_R (self: MutBorrow.t t_Resource_R) (other: t_Resource_R) (return (x: ())) =
    {[@stop_split] [@expl:join_in requires] id_R self.current = id_R other}
    (! bb0
    [ bb0 = s0
      [ s0 = dummy_R (fun (_x: t_Resource_R) -> [ &_13 <- _x ] s1)
      | s1 = MutBorrow.borrow_mut <t_Resource_R> {self.current}
          (fun (_bor: MutBorrow.t t_Resource_R) -> [ &_12 <- _bor ] [ &self <- { self with current = _bor.final } ] s2)
      | s2 = replace_Resource_R {_12} {_13} (fun (_x: t_Resource_R) -> [ &this <- _x ] s3)
      | s3 = join_R {this} {other} (fun (_x: t_Resource_R) -> [ &this'0 <- _x ] s4)
      | s4 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Resource_R) -> [ &_18 <- _bor ] [ &self <- { self with current = _bor.final } ] s5)
      | s5 = replace_Resource_R {_18} {this'0} (fun (_x: t_Resource_R) -> [ &_17 <- _x ] s6)
      | s6 = -{resolve_refmut_Resource_R self}- s7
      | s7 = -{resolve_Resource_R _17}- s8
      | s8 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & other: t_Resource_R = other
    | & this: t_Resource_R = Any.any_l ()
    | & _12: MutBorrow.t t_Resource_R = Any.any_l ()
    | & _13: t_Resource_R = Any.any_l ()
    | & this'0: t_Resource_R = Any.any_l ()
    | & _17: t_Resource_R = Any.any_l ()
    | & _18: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:join_in_R ensures] ([@stop_split] [@expl:join_in ensures #0] id_R self.final
        = id_R self.current)
      /\ ([@stop_split] [@expl:join_in ensures #1] Some (view_Resource_R self.final)
      = op_R (view_Resource_R self.current) (view_Resource_R other))}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__weaken (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  type t_Resource_R
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  predicate eq_R (self: t_R) (other: t_R)
  
  axiom eq_R_spec: forall self: t_R, other: t_R. eq_R self other = (self = other)
  
  predicate incl_eq_R (self: t_R) (other: t_R) = eq_R self other \/ incl_R self other
  
  predicate incl_eq_op_R (a: t_R) (b: t_R) (x: t_R) =
    match op_R a b with
      | None -> false
      | Some ab -> incl_eq_R ab x
      end
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  let rec split_off_R (self: MutBorrow.t t_Resource_R) (r: t_R) (s: t_R) (return (x: t_Resource_R)) =
    {[@stop_split] [@expl:split_off requires] incl_eq_op_R r s (view_Resource_R self.current)}
    any
    [ return (result: t_Resource_R) ->
    {[@stop_split] [@expl:split_off_R ensures] ([@stop_split] [@expl:split_off ensures #0] id_R self.final
          = id_R self.current
        /\ id_R result = id_R self.current)
      /\ ([@stop_split] [@expl:split_off ensures #1] view_Resource_R self.final = s)
      /\ ([@stop_split] [@expl:split_off ensures #2] view_Resource_R result = r)}
      (! return {result}) ]
  
  predicate resolve_Resource_R (_1: t_Resource_R)
  
  predicate resolve_refmut_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Resource_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec weaken_R (self: MutBorrow.t t_Resource_R) (target: t_R) (return (x: ())) =
    {[@stop_split] [@expl:weaken requires] incl_R target (view_Resource_R self.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &f <- unwrap_Option_R (factor_R (view_Resource_R self.current) target) ] s1
      | s1 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Resource_R) -> [ &_16 <- _bor ] [ &self <- { self with current = _bor.final } ] s2)
      | s2 = split_off_R {_16} {f} {target} (fun (_x: t_Resource_R) -> [ &_15 <- _x ] s3)
      | s3 = -{resolve_Resource_R _15}- s4
      | s4 = -{resolve_refmut_Resource_R self}- s5
      | s5 = return {_ret} ] ]
    [ & _ret: () = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & target: t_R = target
    | & f: t_R = Any.any_l ()
    | & _15: t_Resource_R = Any.any_l ()
    | & _16: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:weaken_R ensures] ([@stop_split] [@expl:weaken ensures #0] id_R self.final
        = id_R self.current)
      /\ ([@stop_split] [@expl:weaken ensures #1] view_Resource_R self.final = target)}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R__update (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use set.Set
  use map.Map
  use creusot.prelude.Any
  
  type t_U
  
  predicate inv_U (_1: t_U)
  
  predicate resolve_U (_1: t_U)
  
  type t_Resource_R
  
  type t_R
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  predicate contains_R [@inline:trivial] (self: Set.set t_R) (e: t_R) = Set.mem e self
  
  meta "rewrite_def" predicate contains_R
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function frame_preserving_U (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R, frame: t_R. premise_U self from
      -> op_R from frame <> None -> op_R (update_U self from (frame_preserving_U self from frame)) frame <> None
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  let rec update_raw_R (self: MutBorrow.t t_Resource_R) (target_s: Set.set t_R) (return (x: t_R)) =
    {[@stop_split] [@expl:update_raw requires] forall f: t_Option_R. op_Option_R (Some (view_Resource_R self.current)) f
        <> None'0 -> (exists x: t_R. contains_R target_s x /\ op_Option_R (Some x) f <> None'0)}
    any
    [ return (result: t_R) ->
    {[@stop_split] [@expl:update_raw_R ensures] ([@stop_split] [@expl:update_raw ensures #0] id_R self.final
        = id_R self.current)
      /\ ([@stop_split] [@expl:update_raw ensures #1] contains_R target_s result)
      /\ ([@stop_split] [@expl:update_raw ensures #2] view_Resource_R self.final = result)}
      (! return {result}) ]
  
  predicate resolve_refmut_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Resource_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec update_R (self: MutBorrow.t t_Resource_R) (upd: t_U) (return (x: t_Choice)) =
    {[@stop_split] [@expl:update_R requires] ([@stop_split] [@expl:update 'upd' type invariant] inv_U upd)
    /\ ([@stop_split] [@expl:update requires] premise_U upd (view_Resource_R self.current))}
    (! bb0
    [ bb0 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_U upd} any) ]
      | s1 = -{resolve_U upd}- s2
      | s2 = [ &v <- view_Resource_R self.current ] s3
      | s3 = [ &target_s <- fun (r'0: t_R) -> exists ch: t_Choice. update_U upd v ch = r'0 ] s4
      | s4 = {[@expl:assertion] contains_R target_s (update_U upd v (such_that_Choice (fun (__0: t_Choice) -> true)))}
        s5
      | s5 = {[@expl:assertion] forall f: t_R. op_R v f <> None
          -> (exists ch: t_Choice. op_R (update_U upd v ch) f <> None)}
        s6
      | s6 = [ &_27 <- () ] s7
      | s7 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Resource_R) -> [ &_30 <- _bor ] [ &self <- { self with current = _bor.final } ] s8)
      | s8 = update_raw_R {_30} {target_s} (fun (_x: t_R) -> [ &r <- _x ] s9)
      | s9 = -{resolve_refmut_Resource_R self}- s10
      | s10 = [ &_ret <- such_that_Choice (fun (ch: t_Choice) -> update_U upd v ch = r) ] s11
      | s11 = return {_ret} ] ]
    [ & _ret: t_Choice = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & upd: t_U = upd
    | & v: t_R = Any.any_l ()
    | & target_s: Set.set t_R = Any.any_l ()
    | & _27: () = Any.any_l ()
    | & r: t_R = Any.any_l ()
    | & _30: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: t_Choice) ->
    {[@stop_split] [@expl:update_R ensures] ([@stop_split] [@expl:update ensures #0] id_R self.final
        = id_R self.current)
      /\ ([@stop_split] [@expl:update ensures #1] view_Resource_R self.final
      = update_U upd (view_Resource_R self.current) result)}
      (! return {result}) ]
end
module M_ghost__resource__m__impl_Resource_R_0__take (* ghost::resource::m::Resource<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_Resource_R
  
  type t_R
  
  function val_R (self: t_Resource_R) : t_R
  
  function view_Resource_R [@inline:trivial] (self: t_Resource_R) : t_R = val_R self
  
  meta "rewrite_def" function view_Resource_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate eq_R (self: t_R) (other: t_R)
  
  axiom eq_R_spec: forall self: t_R, other: t_R. eq_R self other = (self = other)
  
  predicate incl_eq_R (self: t_R) (other: t_R) = eq_R self other \/ incl_R self other
  
  predicate incl_eq_op_R (a: t_R) (b: t_R) (x: t_R) =
    match op_R a b with
      | None -> false
      | Some ab -> incl_eq_R ab x
      end
  
  type t_Id
  
  function id_R (self: t_Resource_R) : t_Id
  
  let rec split_off_R (self: MutBorrow.t t_Resource_R) (r: t_R) (s: t_R) (return (x: t_Resource_R)) =
    {[@stop_split] [@expl:split_off requires] incl_eq_op_R r s (view_Resource_R self.current)}
    any
    [ return (result: t_Resource_R) ->
    {[@stop_split] [@expl:split_off_R ensures] ([@stop_split] [@expl:split_off ensures #0] id_R self.final
          = id_R self.current
        /\ id_R result = id_R self.current)
      /\ ([@stop_split] [@expl:split_off ensures #1] view_Resource_R self.final = s)
      /\ ([@stop_split] [@expl:split_off ensures #2] view_Resource_R result = r)}
      (! return {result}) ]
  
  predicate resolve_refmut_Resource_R [@inline:trivial] (_1: MutBorrow.t t_Resource_R) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Resource_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec take_R (self: MutBorrow.t t_Resource_R) (return (x: t_Resource_R)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &r <- view_Resource_R self.current ] s1
      | s1 = MutBorrow.borrow_final <t_Resource_R> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_Resource_R) -> [ &_11 <- _bor ] [ &self <- { self with current = _bor.final } ] s2)
      | s2 = split_off_R {_11} {r} {unit_R} (fun (_x: t_Resource_R) -> [ &_ret <- _x ] s3)
      | s3 = -{resolve_refmut_Resource_R self}- s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_Resource_R = Any.any_l ()
    | & self: MutBorrow.t t_Resource_R = self
    | & r: t_R = Any.any_l ()
    | & _11: MutBorrow.t t_Resource_R = Any.any_l () ])
    [ return (result: t_Resource_R) ->
    {[@stop_split] [@expl:take_R ensures] ([@stop_split] [@expl:take ensures #0] id_R self.final = id_R self.current
        /\ id_R result = id_R self.current)
      /\ ([@stop_split] [@expl:take ensures #1] view_Resource_R self.final = unit_R)
      /\ ([@stop_split] [@expl:take ensures #2] view_Resource_R result = view_Resource_R self.current)}
      (! return {result}) ]
end
module M_ghost__impl_Clone_for_Ghost_T__clone (* <ghost::Ghost<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Ghost_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_Ghost_T
  
  predicate inv_Ghost_T [@inline:trivial] (_1: t_T) = invariant_Ghost_T _1
  
  meta "rewrite_def" predicate inv_Ghost_T
  
  predicate invariant_ref_Ghost_T [@inline:trivial] (self: t_T) = inv_Ghost_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_T
  
  predicate inv_ref_Ghost_T [@inline:trivial] (_1: t_T) = invariant_ref_Ghost_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  let rec deref_Ghost_T (self: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:deref 'self' type invariant] inv_ref_Ghost_T self}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:deref_Ghost_T ensures] ([@stop_split] [@expl:deref result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:deref ensures] result = self)}
      (! return {result}) ]
  
  let rec new_T (x: t_T) (return (x'0: t_T)) = {[@stop_split] [@expl:new 'x' type invariant] inv_T x}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:new_T ensures] ([@stop_split] [@expl:new result type invariant] inv_Ghost_T result)
      /\ ([@stop_split] [@expl:new ensures] result = x)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Ghost_T (self: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:clone 'self' type invariant] inv_ref_Ghost_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = deref_Ghost_T {self} (fun (_x: t_T) -> [ &_5 <- _x ] s1)
      | s1 = new_T {_5} (fun (_x: t_T) -> [ &_ret <- _x ] s2)
      | s2 = return {_ret} ] ] [ & _ret: t_T = Any.any_l () | & self: t_T = self | & _5: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:clone_Ghost_T ensures] ([@stop_split] [@expl:clone result type invariant] inv_Ghost_T result)
      /\ ([@stop_split] [@expl:clone ensures] result = self)}
      (! return {result}) ]
end
module M_invariant__impl_Clone_for_Subset_T__clone (* <invariant::Subset<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Subset_T
  
  type t_T
  
  predicate invariant_T (self: t_T)
  
  function inner_T (self: t_Subset_T) : t_T
  
  axiom inner_T_spec: forall self: t_Subset_T. invariant_T (inner_T self)
  
  function inner_inj_T (self: t_Subset_T) (other: t_Subset_T) : ()
  
  axiom inner_inj_T_spec: forall self: t_Subset_T, other: t_Subset_T. inner_T self = inner_T other -> self = other
  
  predicate inv_T (_1: t_T)
  
  axiom inv_axiom: forall x: t_T [inv_T x]. inv_T x -> invariant_T x
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  let rec deref_Subset_T (self: t_Subset_T) (return (x: t_T)) = any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:deref_Subset_T ensures] ([@stop_split] [@expl:deref result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:deref ensures] result = inner_T self)}
      (! return {result}) ]
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@stop_split] [@expl:clone requires] precondition_clone () self_}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:clone ensures] postcondition_once_clone () self_ result}
      (! return {result}) ]
  
  function new_T (x: t_T) : t_Subset_T
  
  axiom new_T_spec: forall x: t_T. invariant_T x -> inner_T (new_T x) = x
  
  let rec new_T'0 (x: t_T) (return (x'0: t_Subset_T)) = {[@stop_split] [@expl:new 'x' type invariant] inv_T x}
    any [ return (result: t_Subset_T) -> {[@stop_split] [@expl:new ensures] result = new_T x} (! return {result}) ]
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Subset_T (self: t_Subset_T) (return (x: t_Subset_T)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_4 <- () ] s1
      | s1 = deref_Subset_T {self} (fun (_x: t_T) -> [ &_8 <- _x ] s2)
      | s2 = clone_T {_8} (fun (_x: t_T) -> [ &_6 <- _x ] s3)
      | s3 = new_T'0 {_6} (fun (_x: t_Subset_T) -> [ &_ret <- _x ] s4)
      | s4 = return {_ret} ] ]
    [ & _ret: t_Subset_T = Any.any_l ()
    | & self: t_Subset_T = self
    | & _4: () = Any.any_l ()
    | & _6: t_T = Any.any_l ()
    | & _8: t_T = Any.any_l () ])
    [ return (result: t_Subset_T) ->
    {[@stop_split] [@expl:clone ensures] postcondition_clone () (inner_T self) (inner_T result)}
      (! return {result}) ]
end
module M_logic__fmap__impl_FMap_K_V__ext_eq (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function to_mapping_inj_K (self: t_FMap_K_V) (other: t_FMap_K_V) : () = ()
  
  axiom to_mapping_inj_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. to_mapping_K self = to_mapping_K other
      -> self = other
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant other : t_FMap_K_V
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V)
  
  goal vc_ext_eq_K: [@stop_split] [@expl:ext_eq ensures] (forall k: t_K. get_K self k = get_K other k) = (self = other)
end
module M_logic__fmap__impl_FMap_K_V__filter (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate index_Mapping_tup2_K_V_bool [@inline:trivial] (self: Map.map tup2_K_V bool) (a: tup2_K_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_K_V_bool
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None -> None
          | Some v -> index_Mapping_tup2_K_V_Option_V f { f0 = k; f1 = v }
          end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant p : Map.map tup2_K_V bool
  
  function filter_K (self: t_FMap_K_V) (p: Map.map tup2_K_V bool) : t_FMap_K_V
  
  goal vc_filter_K: (forall __0: tup2_K_V. let {f0 = k; f1 = v} = __0 in true)
    /\ (([@stop_split] [@expl:filter_map ensures] forall k: t_K [get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0 = k'0; f1 = v} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k'0;
                                                                                                                                                                                     f1 = v } then
          Some v
        else
          None
        )) k]. get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0 = k'0; f1 = v} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k'0;
                                                                                                                                   f1 = v } then
            Some v
          else
            None
          )) k
        = match get_K self k with
          | None -> None
          | Some v -> index_Mapping_tup2_K_V_Option_V (fun (__0: tup2_K_V) -> let {f0 = k'0; f1 = v'0} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k'0;
                                                                                                                                                   f1 = v'0 } then
            Some v'0
          else
            None
          ) { f0 = k; f1 = v }
          end)
    -> (let result = filter_map_K self (fun (__0: tup2_K_V) -> let {f0 = k; f1 = v} = __0 in if index_Mapping_tup2_K_V_bool p { f0 = k;
                                                                                                                                f1 = v } then
      Some v
    else
      None
    ) in [@stop_split] [@expl:filter ensures] forall k: t_K [get_K result k]. get_K result k
      = match get_K self k with
        | None -> None
        | Some v -> if index_Mapping_tup2_K_V_bool p { f0 = k; f1 = v } then Some v else None
        end))
end
module M_logic__fmap__impl_FMap_K_V_0__contains_ghost (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_ref_V = None | Some t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_V f0
        end
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_V) : t_Option_ref_V = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  let rec get_ghost_K (self: t_FMap_K_V) (key: t_K) (return (x: t_Option_ref_V)) =
    {[@stop_split] [@expl:get_ghost_K requires] ([@stop_split] [@expl:get_ghost 'self' type invariant] inv_ref_FMap_K_V self)
    /\ ([@stop_split] [@expl:get_ghost 'key' type invariant] inv_ref_K key)}
    any
    [ return (result: t_Option_ref_V) ->
    {[@stop_split] [@expl:get_ghost_K ensures] ([@stop_split] [@expl:get_ghost result type invariant] inv_Option_ref_V result)
      /\ ([@stop_split] [@expl:get_ghost ensures] result = map_Option_V (get_K self key) (fun (v: t_V) -> v))}
      (! return {result}) ]
  
  predicate invariant_ref_Option_ref_V [@inline:trivial] (self: t_Option_ref_V) = inv_Option_ref_V self
  
  meta "rewrite_def" predicate invariant_ref_Option_ref_V
  
  predicate inv_ref_Option_ref_V [@inline:trivial] (_1: t_Option_ref_V) = invariant_ref_Option_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_Option_ref_V
  
  let rec is_some_ref_V (self_: t_Option_ref_V) (return (x: bool)) =
    {[@stop_split] [@expl:is_some 'self_' type invariant] inv_ref_Option_ref_V self_}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:is_some ensures] result = (self_ <> None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec contains_ghost_K (self: t_FMap_K_V) (key: t_K) (return (x: bool)) =
    {[@stop_split] [@expl:contains_ghost_K requires] ([@stop_split] [@expl:contains_ghost 'self' type invariant] inv_ref_FMap_K_V self)
    /\ ([@stop_split] [@expl:contains_ghost 'key' type invariant] inv_ref_K key)}
    (! bb0
    [ bb0 = s0
      [ s0 = get_ghost_K {self} {key} (fun (_x: t_Option_ref_V) -> [ &_7 <- _x ] s1)
      | s1 = is_some_ref_V {_7} (fun (_x: bool) -> [ &_ret <- _x ] s2)
      | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self: t_FMap_K_V = self
    | & key: t_K = key
    | & _7: t_Option_ref_V = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:contains_ghost ensures] result = contains_K self key}
      (! return {result}) ]
end
module M_logic__fmap__impl_Index_for_FMap_K_V__index (* <logic::fmap::FMap<K, V> as std::ops::Index<&'a K>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.Any
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_ref_V = None | Some t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate inv_Option_ref_V (_1: t_Option_ref_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_V [inv_Option_ref_V x]. inv_Option_ref_V x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_V f0
        end
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_V) : t_Option_ref_V = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  let rec get_ghost_K (self: t_FMap_K_V) (key: t_K) (return (x: t_Option_ref_V)) =
    {[@stop_split] [@expl:get_ghost_K requires] ([@stop_split] [@expl:get_ghost 'self' type invariant] inv_ref_FMap_K_V self)
    /\ ([@stop_split] [@expl:get_ghost 'key' type invariant] inv_ref_K key)}
    any
    [ return (result: t_Option_ref_V) ->
    {[@stop_split] [@expl:get_ghost_K ensures] ([@stop_split] [@expl:get_ghost result type invariant] inv_Option_ref_V result)
      /\ ([@stop_split] [@expl:get_ghost ensures] result = map_Option_V (get_K self key) (fun (v: t_V) -> v))}
      (! return {result}) ]
  
  let rec unwrap_ref_V (self_: t_Option_ref_V) (return (x: t_V)) =
    {[@stop_split] [@expl:unwrap_ref_V requires] ([@stop_split] [@expl:unwrap 'self_' type invariant] inv_Option_ref_V self_)
    /\ ([@stop_split] [@expl:unwrap requires] self_ <> None)}
    any
    [ return (result: t_V) ->
    {[@stop_split] [@expl:unwrap_ref_V ensures] ([@stop_split] [@expl:unwrap result type invariant] inv_ref_V result)
      /\ ([@stop_split] [@expl:unwrap ensures] Some result = self_)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_FMap_K_V'0 (self: t_FMap_K_V) (key: t_K) (return (x: t_V)) =
    {[@stop_split] [@expl:index_FMap_K_V requires] ([@stop_split] [@expl:index 'self' type invariant] inv_ref_FMap_K_V self)
    /\ ([@stop_split] [@expl:index 'key' type invariant] inv_ref_K key)
    /\ ([@stop_split] [@expl:index requires] contains_K self key)}
    (! bb0
    [ bb0 = s0
      [ s0 = get_ghost_K {self} {key} (fun (_x: t_Option_ref_V) -> [ &_10 <- _x ] s1)
      | s1 = unwrap_ref_V {_10} (fun (_x: t_V) -> [ &_9 <- _x ] s2)
      | s2 = [ &_ret <- _9 ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_V = Any.any_l ()
    | & self: t_FMap_K_V = self
    | & key: t_K = key
    | & _9: t_V = Any.any_l ()
    | & _10: t_Option_ref_V = Any.any_l () ])
    [ return (result: t_V) ->
    {[@stop_split] [@expl:index_FMap_K_V ensures] ([@stop_split] [@expl:index result type invariant] inv_ref_V result)
      /\ ([@stop_split] [@expl:index ensures] Some'0 result = get_K self key)}
      (! return {result}) ]
end
module M_logic__fmap__impl_Iterator_for_FMap_K_V__next (* <logic::fmap::FMap<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use map.Const
  use creusot.prelude.Any
  use seq.Seq
  use int.Int
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  predicate invariant_refmut_FMap_K_V [@inline:trivial] (self: MutBorrow.t t_FMap_K_V) =
    inv_FMap_K_V self.current /\ inv_FMap_K_V self.final
  
  meta "rewrite_def" predicate invariant_refmut_FMap_K_V
  
  predicate inv_refmut_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = invariant_refmut_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_refmut_FMap_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_tup2_K_V f0'0
        end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: to_mapping_K empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. to_mapping_K (insert_K self k v)
      = Map.set (to_mapping_K self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  let rec remove_one_ghost_K (self: MutBorrow.t t_FMap_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@stop_split] [@expl:remove_one_ghost 'self' type invariant] inv_refmut_FMap_K_V self}
    any
    [ return (result: t_Option_tup2_K_V) ->
    {[@stop_split] [@expl:remove_one_ghost_K ensures] ([@stop_split] [@expl:remove_one_ghost result type invariant] inv_Option_tup2_K_V result)
      /\ ([@stop_split] [@expl:remove_one_ghost ensures] match result with
        | None'0 -> self.current = self.final /\ is_empty_K self.current
        | Some'0 {f0 = k; f1 = v} -> self.current = insert_K self.final k v /\ not contains_K self.final k
        end)}
      (! return {result}) ]
  
  predicate resolve_refmut_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_FMap_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  predicate produces_FMap_K_V (self: t_FMap_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMap_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0 = k; f1 = v }
        -> not contains_K o k /\ get_K self k = Some v)
    /\ len_K self = Seq.length visited + len_K o
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K o k = get_K self k)
  
  function produces_trans_FMap_K_V (a: t_FMap_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMap_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMap_K_V) : ()
   = let ac = Seq.(++) ab bc in ()
  
  axiom produces_trans_FMap_K_V_spec:
    forall a: t_FMap_K_V, ab: Seq.seq tup2_K_V, b: t_FMap_K_V, bc: Seq.seq tup2_K_V, c: t_FMap_K_V. produces_FMap_K_V a ab b
      -> produces_FMap_K_V b bc c -> produces_FMap_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMap_K_V (self: t_FMap_K_V) : () = ()
  
  axiom produces_refl_FMap_K_V_spec: forall self: t_FMap_K_V. produces_FMap_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate completed_FMap_K_V (self: MutBorrow.t t_FMap_K_V) = is_empty_K self.current
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_FMap_K_V (self: MutBorrow.t t_FMap_K_V) (return (x: t_Option_tup2_K_V)) =
    {[@stop_split] [@expl:next 'self' type invariant] inv_refmut_FMap_K_V self}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <t_FMap_K_V> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t t_FMap_K_V) ->
            [ &_4 <- _bor ] -{inv_FMap_K_V _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
        [ _ck -> (! {[@expl:type invariant] inv_FMap_K_V self.current} any) ]
      | s1 = remove_one_ghost_K {_4} (fun (_x: t_Option_tup2_K_V) -> [ &_ret <- _x ] s2)
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_FMap_K_V self} any) ]
      | s3 = -{resolve_refmut_FMap_K_V self}- s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_Option_tup2_K_V = Any.any_l ()
    | & self: MutBorrow.t t_FMap_K_V = self
    | & _4: MutBorrow.t t_FMap_K_V = Any.any_l () ])
    [ return (result: t_Option_tup2_K_V) ->
    {[@stop_split] [@expl:next_FMap_K_V ensures] ([@stop_split] [@expl:next result type invariant] inv_Option_tup2_K_V result)
      /\ ([@stop_split] [@expl:next ensures] match result with
        | None'0 -> completed_FMap_K_V self
        | Some'0 {f0 = k; f1 = v} -> produces_FMap_K_V self.current (Seq.singleton { f0 = k; f1 = v }) self.final
        /\ self.current = insert_K self.final k v
        end)}
      (! return {result}) ]
end
module M_logic__fmap__impl_IteratorSpec_for_FMap_K_V__produces_refl (* <logic::fmap::FMap<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMap_K_V (self: t_FMap_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMap_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K o k /\ get_K self k = Some'0 v)
    /\ len_K self = Seq.length visited + len_K o
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K o k = get_K self k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  function produces_refl_FMap_K_V (self: t_FMap_K_V) : ()
  
  goal vc_produces_refl_FMap_K_V:
    [@stop_split] [@expl:produces_refl ensures] produces_FMap_K_V self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_logic__fmap__impl_IteratorSpec_for_FMap_K_V__produces_trans (* <logic::fmap::FMap<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMap_K_V (self: t_FMap_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMap_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K o k /\ get_K self k = Some'0 v)
    /\ len_K self = Seq.length visited + len_K o
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K o k = get_K self k)
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMap_K_V
  
  constant ab : Seq.seq tup2_K_V
  
  constant b : t_FMap_K_V
  
  constant bc : Seq.seq tup2_K_V
  
  constant c : t_FMap_K_V
  
  function produces_trans_FMap_K_V (a: t_FMap_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMap_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMap_K_V) : ()
  
  goal vc_produces_trans_FMap_K_V: produces_FMap_K_V a ab b
    -> produces_FMap_K_V b bc c
    -> (let ac = Seq.(++) ab bc in (forall x: tup2_K_V. contains_tup2_K_V ab x -> contains_tup2_K_V ac x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get ac (i + Seq.length ab) = Seq.get bc i)
    && (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length ac -> (Seq.get ac i).f0 <> k)
        -> (forall i: int. 0 <= i /\ i < Seq.length ab -> (Seq.get ab i).f0 <> k)
        /\ (forall i: int. 0 <= i /\ i < Seq.length bc -> (Seq.get bc i).f0 <> k)
        /\ get_K a k = get_K b k /\ get_K b k = get_K c k)
    && ([@stop_split] [@expl:produces_trans ensures] produces_FMap_K_V a (Seq.(++) ab bc) c))
end
module M_logic__fmap__impl_IntoIterator_for_ref_FMap_K_V__into_iter (* <&'a logic::fmap::FMap<K, V> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use creusot.prelude.Any
  use int.Int
  
  type t_FMap_K_V
  
  type t_FMap_ref_K_ref_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  type t_Option_ref_V = None'0 | Some'0 t_V
  
  function to_mapping_ref_K (self: t_FMap_ref_K_ref_V) : Map.map t_K t_Option_ref_V
  
  function get_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_Option_ref_V =
    Map.get (to_mapping_ref_K self) k
  
  meta "rewrite_def" function get_ref_K
  
  predicate contains_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) = get_ref_K self k <> None'0
  
  meta "rewrite_def" predicate contains_ref_K
  
  predicate invariant_ref_K [@inline:trivial] (self: t_K) = inv_K self
  
  meta "rewrite_def" predicate invariant_ref_K
  
  predicate inv_ref_K [@inline:trivial] (_1: t_K) = invariant_ref_K _1
  
  meta "rewrite_def" predicate inv_ref_K
  
  predicate invariant_ref_V [@inline:trivial] (self: t_V) = inv_V self
  
  meta "rewrite_def" predicate invariant_ref_V
  
  predicate inv_ref_V [@inline:trivial] (_1: t_V) = invariant_ref_V _1
  
  meta "rewrite_def" predicate inv_ref_V
  
  predicate index_Mapping_ref_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_ref_V_bool
  
  function such_that_ref_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_ref_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_ref_V_bool p x)
      -> index_Mapping_ref_V_bool p (such_that_ref_V p)
  
  function unwrap_Option_ref_V (self: t_Option_ref_V) : t_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_ref_V (fun (__0: t_V) -> true)
      end
  
  function lookup_ref_K [@inline:trivial] (self: t_FMap_ref_K_ref_V) (k: t_K) : t_V =
    unwrap_Option_ref_V (get_ref_K self k)
  
  meta "rewrite_def" function lookup_ref_K
  
  function index_FMap_ref_K_ref_V [@inline:trivial] (self: t_FMap_ref_K_ref_V) (key: t_K) : t_V = lookup_ref_K self key
  
  meta "rewrite_def" function index_FMap_ref_K_ref_V
  
  predicate invariant_FMap_ref_K_ref_V [@inline:trivial] (self: t_FMap_ref_K_ref_V) =
    forall k: t_K. contains_ref_K self k -> inv_ref_K k /\ inv_ref_V (index_FMap_ref_K_ref_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_ref_K_ref_V
  
  predicate inv_FMap_ref_K_ref_V (_1: t_FMap_ref_K_ref_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_FMap_ref_K_ref_V [inv_FMap_ref_K_ref_V x]. inv_FMap_ref_K_ref_V x
      = invariant_FMap_ref_K_ref_V x
  
  function len_ref_K (self: t_FMap_ref_K_ref_V) : int
  
  axiom len_ref_K_spec: forall self: t_FMap_ref_K_ref_V. len_ref_K self >= 0
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  let rec as_ref_ghost_K (self: t_FMap_K_V) (return (x: t_FMap_ref_K_ref_V)) =
    {[@stop_split] [@expl:as_ref_ghost 'self' type invariant] inv_ref_FMap_K_V self}
    any
    [ return (result: t_FMap_ref_K_ref_V) ->
    {[@stop_split] [@expl:as_ref_ghost_K ensures] ([@stop_split] [@expl:as_ref_ghost result type invariant] inv_FMap_ref_K_ref_V result)
      /\ ([@stop_split] [@expl:as_ref_ghost ensures #0] len_ref_K result = len_K self)
      /\ ([@stop_split] [@expl:as_ref_ghost ensures #1] forall k: t_K, v: t_V. (get_K self k = Some v)
        = (get_ref_K result k = Some'0 v))}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter_ref_FMap_K_V (self: t_FMap_K_V) (return (x: t_FMap_ref_K_ref_V)) =
    {[@stop_split] [@expl:into_iter 'self' type invariant] inv_ref_FMap_K_V self}
    (! bb0
    [ bb0 = s0
      [ s0 = as_ref_ghost_K {self} (fun (_x: t_FMap_ref_K_ref_V) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_FMap_ref_K_ref_V = Any.any_l () | & self: t_FMap_K_V = self ])
    [ return (result: t_FMap_ref_K_ref_V) ->
    {[@stop_split] [@expl:into_iter_ref_FMap_K_V ensures] ([@stop_split] [@expl:into_iter result type invariant] inv_FMap_ref_K_ref_V result)
      /\ ([@stop_split] [@expl:into_iter ensures #0] len_ref_K result = len_K self)
      /\ ([@stop_split] [@expl:into_iter ensures #1] forall k: t_K, v: t_V. (get_K self k = Some v)
        = (get_ref_K result k = Some'0 v))}
      (! return {result}) ]
end
module M_logic__fset__impl_FSet_T__ext_eq (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant other : Fset.fset t_T
  
  predicate ext_eq_T (self: Fset.fset t_T) (other: Fset.fset t_T)
  
  goal vc_ext_eq_T: [@stop_split] [@expl:ext_eq ensures] (forall e: t_T. contains_T self e = contains_T other e)
    = (self = other)
end
module M_logic__fset__impl_FSet_T__singleton (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function insert_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.add e self
  
  meta "rewrite_def" function insert_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  function singleton_T (x: t_T) : Fset.fset t_T
  
  goal vc_singleton_T:
    [@stop_split] [@expl:singleton ensures] forall y: t_T. contains_T (insert_T (Fset.empty: Fset.fset t_T) x) y
      = (x = y)
end
module M_logic__fset__impl_FSet_T__unions (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  use int.Int
  
  type t_T
  
  type t_U
  
  predicate contains_U [@inline:trivial] (self: Fset.fset t_U) (e: t_U) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_U
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant f : Map.map t_T (Fset.fset t_U)
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  goal vc_unions_T: if Fset.cardinal self = 0 then
      [@stop_split] [@expl:unions ensures] forall y: t_U. contains_U (Fset.empty: Fset.fset t_U) y
        = (exists x: t_T. contains_T self x /\ contains_U (Map.get f x) y)
    else
      let x = Fset.pick self in ([@expl:variant decreases] well_founded_relation_Int (Fset.cardinal self) (Fset.cardinal (remove_T self x)))
      /\ (([@stop_split] [@expl:unions ensures] forall y: t_U. contains_U (unions_T (remove_T self x) f) y
          = (exists x'0: t_T. contains_T (remove_T self x) x'0 /\ contains_U (Map.get f x'0) y))
      -> ([@stop_split] [@expl:unions ensures] forall y: t_U. contains_U (Fset.union (Map.get f x) (unions_T (remove_T self x) f)) y
        = (exists x'0: t_T. contains_T self x'0 /\ contains_U (Map.get f x'0) y)))

end
module M_logic__fset__impl_FSet_T__cons (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T self x /\ contains_Seq_T (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset t_T
  
  constant ss : Fset.fset (Seq.seq t_T)
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  goal vc_cons_T: (forall x: t_T, xs: Seq.seq t_T. tail_T (push_front_T xs x) = xs)
    && (forall xs: Seq.seq t_T. 0 < Seq.length xs -> push_front_T (tail_T xs) (Seq.get xs 0) = xs)
    && (([@stop_split] [@expl:unions ensures] forall y: Seq.seq t_T. contains_Seq_T (unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))) y
        = (exists x: t_T. contains_T s x
          /\ contains_Seq_T (Map.get (fun (x'0: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x'0)) x) y))
    -> ([@stop_split] [@expl:cons ensures] forall xs: Seq.seq t_T. contains_Seq_T (unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs'0: Seq.seq t_T) -> push_front_T xs'0 x))) xs
      = (0 < Seq.length xs /\ contains_T s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))))
end
module M_logic__fset__impl_FSet_T__concat (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset (Seq.seq t_T)
  
  constant t : Fset.fset (Seq.seq t_T)
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
  
  goal vc_concat_T:
    ([@stop_split] [@expl:unions ensures] forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))) y
        = (exists x: Seq.seq t_T. contains_Seq_T s x
          /\ contains_Seq_T (Map.get (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs)) x) y))
    -> ([@stop_split] [@expl:concat ensures] forall xs: Seq.seq t_T. contains_Seq_T (unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))) xs
      = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs))
end
module M_logic__fset__impl_FSet_T__replicate (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  goal vc_replicate_T: n >= 0
    -> (if n = 0 then
      (forall xs: Seq.seq t_T. Seq.length xs = 0 -> xs = (Seq.empty: Seq.seq t_T))
      && (([@stop_split] [@expl:singleton ensures] forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) y
          = ((Seq.empty: Seq.seq t_T) = y))
      -> ([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x))))
    else
      (forall xs: Seq.seq t_T, i: int. 0 < i /\ i < Seq.length xs -> Seq.get xs i = Seq.get (tail_T xs) (i - 1))
      && (([@stop_split] [@expl:replicate requires] n - 1 >= 0)
        /\ ([@expl:variant decreases] well_founded_relation_Int n (n - 1)))
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self (n - 1)) xs
          = (Seq.length xs = n - 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:cons ensures] forall xs: Seq.seq t_T. contains_Seq_T (cons_T self (replicate_T self (n
            - 1))) xs
          = (0 < Seq.length xs
          /\ contains_T'0 self (Seq.get xs 0) /\ contains_Seq_T (replicate_T self (n - 1)) (tail_T xs)))
      -> ([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (cons_T self (replicate_T self (n
          - 1))) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x))))
    )
end
module M_logic__fset__impl_FSet_T__replicate_up_to (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_T self n
      = (if n = 0 then singleton_Seq_T (Seq.empty: Seq.seq t_T) else cons_T self (replicate_T self (n - 1)))
  
  axiom replicate_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  function replicate_up_to_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  goal vc_replicate_up_to_T: n >= 0
    -> (if n = 0 then
      (forall xs: Seq.seq t_T. Seq.length xs = 0 -> xs = (Seq.empty: Seq.seq t_T))
      && (([@stop_split] [@expl:singleton ensures] forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) y
          = ((Seq.empty: Seq.seq t_T) = y))
      -> ([@stop_split] [@expl:replicate_up_to ensures] forall xs: Seq.seq t_T. contains_Seq_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x))))
    else
      (([@stop_split] [@expl:replicate_up_to requires] n - 1 >= 0)
        /\ ([@expl:variant decreases] well_founded_relation_Int n (n - 1)))
      /\ (([@stop_split] [@expl:replicate_up_to ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_up_to_T self (n
            - 1)) xs
          = (Seq.length xs <= n - 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:replicate requires] n >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
          = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:replicate_up_to ensures] forall xs: Seq.seq t_T. contains_Seq_T (Fset.union (replicate_up_to_T self (n
          - 1)) (replicate_T self n)) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))))
    )
end
module M_logic__fset__impl_FSet_T__unions_union (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  predicate contains_U [@inline:trivial] (self: Fset.fset t_U) (e: t_U) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_U
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) : Fset.fset t_U
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset t_U
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset t_U). forall y: t_U. contains_U (unions_T self f) y
        = (exists x: t_T. contains_T self x /\ contains_U (Map.get f x) y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant other : Fset.fset t_T
  
  constant f : Map.map t_T (Fset.fset t_U)
  
  constant g : Map.map t_T (Fset.fset t_U)
  
  function unions_union_T (self: Fset.fset t_T) (other: Fset.fset t_T) (f: Map.map t_T (Fset.fset t_U)) (g: Map.map t_T (Fset.fset t_U)) : ()
  
  goal vc_unions_union_T:
    [@stop_split] [@expl:unions_union_T ensures] ([@stop_split] [@expl:unions_union ensures #0] unions_T (Fset.union self other) f
      = Fset.union (unions_T self f) (unions_T other f))
    /\ ([@stop_split] [@expl:unions_union ensures #1] unions_T self (fun (x: t_T) -> Fset.union (Map.get f x) (Map.get g x))
    = Fset.union (unions_T self f) (unions_T self g))
end
module M_logic__fset__impl_FSet_T__map_union (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use map.Map
  
  type t_T
  
  type t_U
  
  function map_T (self: Fset.fset t_T) (f: Map.map t_T t_U) : Fset.fset t_U = Fset.map f self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant other : Fset.fset t_T
  
  constant f : Map.map t_T t_U
  
  function map_union_T (self: Fset.fset t_T) (other: Fset.fset t_T) (f: Map.map t_T t_U) : ()
  
  goal vc_map_union_T: [@stop_split] [@expl:map_union ensures] map_T (Fset.union self other) f
    = Fset.union (map_T self f) (map_T other f)
end
module M_logic__fset__impl_FSet_T__concat_union (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s1 : Fset.fset (Seq.seq t_T)
  
  constant s2 : Fset.fset (Seq.seq t_T)
  
  constant t : Fset.fset (Seq.seq t_T)
  
  function concat_union_T (s1: Fset.fset (Seq.seq t_T)) (s2: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_concat_union_T:
    [@stop_split] [@expl:concat_union_T ensures] ([@stop_split] [@expl:concat_union ensures #0] concat_T (Fset.union s1 s2) t
      = Fset.union (concat_T s1 t) (concat_T s2 t))
    /\ ([@stop_split] [@expl:concat_union ensures #1] concat_T t (Fset.union s1 s2)
    = Fset.union (concat_T t s1) (concat_T t s2))
end
module M_logic__fset__impl_FSet_T__cons_concat (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant t : Fset.fset (Seq.seq t_T)
  
  constant u : Fset.fset (Seq.seq t_T)
  
  function cons_concat_T (self: Fset.fset t_T) (t: Fset.fset (Seq.seq t_T)) (u: Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_cons_concat_T: (forall x: t_T, xs: Seq.seq t_T, ys: Seq.seq t_T. Seq.(++) (push_front_T xs x) ys
        = push_front_T (Seq.(++) xs ys) x)
    && (forall x: t_T, ys: Seq.seq t_T. tail_T (push_front_T ys x) = ys)
    && (forall ys: Seq.seq t_T. 0 < Seq.length ys -> ys = push_front_T (tail_T ys) (Seq.get ys 0))
    && ([@stop_split] [@expl:cons_concat ensures] concat_T (cons_T self t) u = cons_T self (concat_T t u))
end
module M_logic__fset__impl_FSet_T__concat_replicate (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_T self n
      = (if n = 0 then singleton_Seq_T (Seq.empty: Seq.seq t_T) else cons_T self (replicate_T self (n - 1)))
  
  axiom replicate_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty_T (s: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom concat_empty_T_spec: forall s: Fset.fset (Seq.seq t_T). concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) s
      = s
  
  axiom concat_empty_T_spec'0: forall s: Fset.fset (Seq.seq t_T). concat_T s (singleton_Seq_T (Seq.empty: Seq.seq t_T))
      = s
  
  function cons_concat_T (self: Fset.fset t_T) (t: Fset.fset (Seq.seq t_T)) (u: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom cons_concat_T_spec:
    forall self: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat_T (cons_T self t) u
      = cons_T self (concat_T t u)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  constant m : int
  
  function concat_replicate_T (self: Fset.fset t_T) (n: int) (m: int) : ()
  
  goal vc_concat_replicate_T: 0 <= n /\ 0 <= m
    -> (if n = 0 then
      ([@stop_split] [@expl:replicate requires] m >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self m) xs
          = (Seq.length xs = m /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:concat_empty ensures] ([@stop_split] [@expl:concat_empty ensures #0] concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) (replicate_T self m)
          = replicate_T self m)
        /\ ([@stop_split] [@expl:concat_empty ensures #1] concat_T (replicate_T self m) (singleton_Seq_T (Seq.empty: Seq.seq t_T))
        = replicate_T self m))
      -> (let _ = concat_empty_T (replicate_T self m) in [@stop_split] [@expl:concat_replicate ensures] replicate_T self (n
        + m)
      = concat_T (replicate_T self n) (replicate_T self m)))
    else
      ([@stop_split] [@expl:replicate requires] n - 1 >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self (n - 1)) xs
          = (Seq.length xs = n - 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:replicate requires] m >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self m) xs
          = (Seq.length xs = m /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:cons_concat ensures] concat_T (cons_T self (replicate_T self (n
          - 1))) (replicate_T self m)
        = cons_T self (concat_T (replicate_T self (n - 1)) (replicate_T self m)))
      -> (let _ = cons_concat_T self (replicate_T self (n
      - 1)) (replicate_T self m) in (([@stop_split] [@expl:concat_replicate requires] 0 <= n - 1 /\ 0 <= m)
        /\ ([@expl:variant decreases] well_founded_relation_Int n (n - 1)))
      /\ (([@stop_split] [@expl:concat_replicate ensures] replicate_T self (n - 1 + m)
        = concat_T (replicate_T self (n - 1)) (replicate_T self m))
      -> (let _ = concat_replicate_T self (n
      - 1) m in [@stop_split] [@expl:concat_replicate ensures] replicate_T self (n + m)
      = concat_T (replicate_T self n) (replicate_T self m))))))
    )
end
module M_logic__fset__impl_FSet_T__concat_empty (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use map.Map
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Fset.fset (Seq.seq t_T)
  
  function concat_empty_T (s: Fset.fset (Seq.seq t_T)) : ()
  
  goal vc_concat_empty_T: (forall xs: Seq.seq t_T. Seq.(++) xs (Seq.empty: Seq.seq t_T) = xs)
    && (forall xs: Seq.seq t_T. Seq.(++) (Seq.empty: Seq.seq t_T) xs = xs)
    && ([@stop_split] [@expl:concat_empty_T ensures] ([@stop_split] [@expl:concat_empty ensures #0] concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) s
      = s)
    /\ ([@stop_split] [@expl:concat_empty ensures #1] concat_T s (singleton_Seq_T (Seq.empty: Seq.seq t_T)) = s))
end
module M_logic__fset__impl_FSet_T__concat_replicate_up_to (* logic::fset::FSet<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  predicate contains_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_Seq_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate contains_T'0 [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T'0
  
  function insert_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.add e self
  
  meta "rewrite_def" function insert_Seq_T
  
  function singleton_Seq_T (x: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    insert_Seq_T (Fset.empty: Fset.fset (Seq.seq t_T)) x
  
  axiom singleton_Seq_T_spec: forall x: Seq.seq t_T. forall y: Seq.seq t_T. contains_Seq_T (singleton_Seq_T x) y
        = (x = y)
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  function remove_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) : Fset.fset t_T = Fset.remove e self
  
  meta "rewrite_def" function remove_T
  
  function unions_T (self: Fset.fset t_T) (f: Map.map t_T (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_T_def: forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). unions_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_T (remove_T self x) f)
      )
  
  axiom unions_T_spec:
    forall self: Fset.fset t_T, f: Map.map t_T (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_T self f) y
        = (exists x: t_T. contains_T'0 self x /\ contains_Seq_T (Map.get f x) y)
  
  function map_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Seq.seq t_T)) : Fset.fset (Seq.seq t_T)
   = Fset.map f self
  
  function push_front_T [@inline:trivial] (self: Seq.seq t_T) (x: t_T) : Seq.seq t_T = Seq.cons x self
  
  meta "rewrite_def" function push_front_T
  
  function cons_T (s: Fset.fset t_T) (ss: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_T s (fun (x: t_T) -> map_Seq_T ss (fun (xs: Seq.seq t_T) -> push_front_T xs x))
  
  axiom cons_T_spec:
    forall s: Fset.fset t_T, ss: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (cons_T s ss) xs
        = (0 < Seq.length xs /\ contains_T'0 s (Seq.get xs 0) /\ contains_Seq_T ss (tail_T xs))
  
  function replicate_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_T self n
      = (if n = 0 then singleton_Seq_T (Seq.empty: Seq.seq t_T) else cons_T self (replicate_T self (n - 1)))
  
  axiom replicate_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
        = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  function replicate_up_to_T (self: Fset.fset t_T) (n: int) : Fset.fset (Seq.seq t_T)
  
  axiom replicate_up_to_T_def: forall self: Fset.fset t_T, n: int. n >= 0
      -> replicate_up_to_T self n
      = (if n = 0 then
        singleton_Seq_T (Seq.empty: Seq.seq t_T)
      else
        Fset.union (replicate_up_to_T self (n - 1)) (replicate_T self n)
      )
  
  axiom replicate_up_to_T_spec: forall self: Fset.fset t_T, n: int. n >= 0
      -> (forall xs: Seq.seq t_T. contains_Seq_T (replicate_up_to_T self n) xs
        = (Seq.length xs <= n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
  
  function remove_Seq_T [@inline:trivial] (self: Fset.fset (Seq.seq t_T)) (e: Seq.seq t_T) : Fset.fset (Seq.seq t_T) =
    Fset.remove e self
  
  meta "rewrite_def" function remove_Seq_T
  
  function unions_Seq_T (self: Fset.fset (Seq.seq t_T)) (f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T))) : Fset.fset (Seq.seq t_T)
  
  axiom unions_Seq_T_def:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). unions_Seq_T self f
      = (if Fset.cardinal self = 0 then
        Fset.empty: Fset.fset (Seq.seq t_T)
      else
        let x = Fset.pick self in Fset.union (Map.get f x) (unions_Seq_T (remove_Seq_T self x) f)
      )
  
  axiom unions_Seq_T_spec:
    forall self: Fset.fset (Seq.seq t_T), f: Map.map (Seq.seq t_T) (Fset.fset (Seq.seq t_T)). forall y: Seq.seq t_T. contains_Seq_T (unions_Seq_T self f) y
        = (exists x: Seq.seq t_T. contains_Seq_T self x /\ contains_Seq_T (Map.get f x) y)
  
  function concat_T (s: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : Fset.fset (Seq.seq t_T) =
    unions_Seq_T s (fun (ys: Seq.seq t_T) -> map_Seq_T t (fun (zs: Seq.seq t_T) -> Seq.(++) ys zs))
  
  axiom concat_T_spec:
    forall s: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). forall xs: Seq.seq t_T. contains_Seq_T (concat_T s t) xs
        = (exists ys: Seq.seq t_T, zs: Seq.seq t_T. contains_Seq_T s ys /\ contains_Seq_T t zs /\ xs = Seq.(++) ys zs)
  
  function concat_empty_T (s: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom concat_empty_T_spec: forall s: Fset.fset (Seq.seq t_T). concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) s
      = s
  
  axiom concat_empty_T_spec'0: forall s: Fset.fset (Seq.seq t_T). concat_T s (singleton_Seq_T (Seq.empty: Seq.seq t_T))
      = s
  
  function concat_union_T (s1: Fset.fset (Seq.seq t_T)) (s2: Fset.fset (Seq.seq t_T)) (t: Fset.fset (Seq.seq t_T)) : ()
   = ()
  
  axiom concat_union_T_spec:
    forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat_T (Fset.union s1 s2) t
      = Fset.union (concat_T s1 t) (concat_T s2 t)
  
  axiom concat_union_T_spec'0:
    forall s1: Fset.fset (Seq.seq t_T), s2: Fset.fset (Seq.seq t_T), t: Fset.fset (Seq.seq t_T). concat_T t (Fset.union s1 s2)
      = Fset.union (concat_T t s1) (concat_T t s2)
  
  function cons_concat_T (self: Fset.fset t_T) (t: Fset.fset (Seq.seq t_T)) (u: Fset.fset (Seq.seq t_T)) : () = ()
  
  axiom cons_concat_T_spec:
    forall self: Fset.fset t_T, t: Fset.fset (Seq.seq t_T), u: Fset.fset (Seq.seq t_T). concat_T (cons_T self t) u
      = cons_T self (concat_T t u)
  
  function concat_replicate_T (self: Fset.fset t_T) (n: int) (m: int) : ()
  
  axiom concat_replicate_T_def: forall self: Fset.fset t_T, n: int, m: int. 0 <= n /\ 0 <= m
      -> concat_replicate_T self n m
      = (if n = 0 then
        let _ = concat_empty_T (replicate_T self m) in ()
      else
        let _ = cons_concat_T self (replicate_T self (n - 1)) (replicate_T self m) in let _ = concat_replicate_T self (n
        - 1) m in ()
      )
  
  axiom concat_replicate_T_spec: forall self: Fset.fset t_T, n: int, m: int. 0 <= n /\ 0 <= m
      -> replicate_T self (n + m) = concat_T (replicate_T self n) (replicate_T self m)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Fset.fset t_T
  
  constant n : int
  
  constant m : int
  
  function concat_replicate_up_to_T (self: Fset.fset t_T) (n: int) (m: int) : ()
  
  goal vc_concat_replicate_up_to_T: 0 <= n /\ n < m
    -> (if n + 1 = m then
      ([@stop_split] [@expl:replicate requires] n + 1 >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self (n + 1)) xs
          = (Seq.length xs = n + 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:concat_empty ensures] ([@stop_split] [@expl:concat_empty ensures #0] concat_T (singleton_Seq_T (Seq.empty: Seq.seq t_T)) (replicate_T self (n
            + 1))
          = replicate_T self (n + 1))
        /\ ([@stop_split] [@expl:concat_empty ensures #1] concat_T (replicate_T self (n
          + 1)) (singleton_Seq_T (Seq.empty: Seq.seq t_T))
        = replicate_T self (n + 1)))
      -> (let _ = concat_empty_T (replicate_T self (n
      + 1)) in [@stop_split] [@expl:concat_replicate_up_to ensures] replicate_up_to_T self m
      = Fset.union (replicate_up_to_T self n) (concat_T (replicate_T self (n + 1)) (replicate_up_to_T self (m - n
      - 1)))))
    else
      ([@stop_split] [@expl:replicate requires] n >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self n) xs
          = (Seq.length xs = n /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:replicate requires] m - 1 >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self (m - 1)) xs
          = (Seq.length xs = m - 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:replicate requires] m - n - 1 >= 0)
      /\ (([@stop_split] [@expl:replicate ensures] forall xs: Seq.seq t_T. contains_Seq_T (replicate_T self (m - n
            - 1)) xs
          = (Seq.length xs = m - n - 1 /\ (forall x: t_T. contains_T xs x -> contains_T'0 self x)))
      -> ([@stop_split] [@expl:concat_union ensures] ([@stop_split] [@expl:concat_union ensures #0] concat_T (Fset.union (replicate_T self n) (replicate_T self (m
            - 1))) (replicate_T self (m - n - 1))
          = Fset.union (concat_T (replicate_T self n) (replicate_T self (m - n - 1))) (concat_T (replicate_T self (m
          - 1)) (replicate_T self (m - n - 1))))
        /\ ([@stop_split] [@expl:concat_union ensures #1] concat_T (replicate_T self (m - n
          - 1)) (Fset.union (replicate_T self n) (replicate_T self (m - 1)))
        = Fset.union (concat_T (replicate_T self (m - n - 1)) (replicate_T self n)) (concat_T (replicate_T self (m - n
        - 1)) (replicate_T self (m - 1)))))
      -> (let _ = concat_union_T (replicate_T self n) (replicate_T self (m - 1)) (replicate_T self (m - n
      - 1)) in ([@stop_split] [@expl:concat_replicate requires] 0 <= n /\ 0 <= m - n - 1)
      /\ (([@stop_split] [@expl:concat_replicate ensures] replicate_T self (n + (m - n - 1))
        = concat_T (replicate_T self n) (replicate_T self (m - n - 1)))
      -> (let _ = concat_replicate_T self n (m - n - 1) in (([@stop_split] [@expl:concat_replicate_up_to requires] 0
            <= n
          /\ n < m - 1)
        /\ ([@expl:variant decreases] well_founded_relation_Int m (m - 1)))
      /\ (([@stop_split] [@expl:concat_replicate_up_to ensures] replicate_up_to_T self (m - 1)
        = Fset.union (replicate_up_to_T self n) (concat_T (replicate_T self (n + 1)) (replicate_up_to_T self (m - 1 - n
        - 1))))
      -> (let _ = concat_replicate_up_to_T self n (m
      - 1) in [@stop_split] [@expl:concat_replicate_up_to ensures] replicate_up_to_T self m
      = Fset.union (replicate_up_to_T self n) (concat_T (replicate_T self (n + 1)) (replicate_up_to_T self (m - n
      - 1)))))))))))
    )
end
module M_logic__id__impl_Clone_for_Id__clone (* <logic::id::Id as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Id (self: t_Id) (return (x: t_Id)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Id = Any.any_l () | & self: t_Id = self ])
    [ return (result: t_Id) -> {[@stop_split] [@expl:clone ensures] result = self} (! return {result}) ]
end
module M_logic__id__impl_PartialEq_for_Id__ne (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Id
  
  let rec eq_Id (self: t_Id) (other: t_Id) (return (x: bool)) = any
    [ return (result: bool) -> {[@stop_split] [@expl:eq ensures] result = (self = other)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ne_Id (self: t_Id) (other: t_Id) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = eq_Id {self} {other} (fun (_x: bool) -> [ &_6 <- _x ] s1)
      | s1 = [ &_ret <- not _6 ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self: t_Id = self | & other: t_Id = other | & _6: bool = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:ne ensures] result <> (self = other)} (! return {result}) ]
end
module M_logic__int__impl_Clone_for_Int__clone (* <logic::int::Int as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Int (self: int) (return (x: int)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self ] s1 | s1 = return {_ret} ] ] [ & _ret: int = Any.any_l () | & self: int = self ])
    [ return (result: int) -> {[@stop_split] [@expl:clone ensures] result = self} (! return {result}) ]
end
module M_logic__int__impl_InhabitedInvariant_for_NatInner__inhabits (* <logic::int::NatInner as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_NatInner = { f0: int }
  
  predicate invariant_NatInner (self: t_NatInner) = self.f0 >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function inhabits_NatInner : t_NatInner
  
  goal vc_inhabits_NatInner: [@stop_split] [@expl:inhabits ensures] invariant_NatInner { f0 = 0 }
end
module M_logic__int__impl_Nat__to_int (* logic::int::Nat *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Subset_NatInner
  
  type t_Nat = { f0: t_Subset_NatInner }
  
  type t_NatInner = { f0'0: int }
  
  predicate invariant_NatInner (self: t_NatInner) = self.f0'0 >= 0
  
  function inner_NatInner (self: t_Subset_NatInner) : t_NatInner
  
  axiom inner_NatInner_spec: forall self: t_Subset_NatInner. invariant_NatInner (inner_NatInner self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  function to_int (self: t_Nat) : int
  
  goal vc_to_int: ([@stop_split] [@expl:inner ensures] invariant_NatInner (inner_NatInner self.f0))
    -> ([@stop_split] [@expl:to_int ensures] (inner_NatInner self.f0).f0'0 >= 0)
end
module M_logic__int__impl_Nat__new (* logic::int::Nat *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Subset_NatInner
  
  type t_Nat = { f0: t_Subset_NatInner }
  
  type t_NatInner = { f0'0: int }
  
  predicate invariant_NatInner (self: t_NatInner) = self.f0'0 >= 0
  
  function inner_NatInner (self: t_Subset_NatInner) : t_NatInner
  
  axiom inner_NatInner_spec: forall self: t_Subset_NatInner. invariant_NatInner (inner_NatInner self)
  
  function to_int (self: t_Nat) : int = (inner_NatInner self.f0).f0'0
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function new_NatInner (x: t_NatInner) : t_Subset_NatInner
  
  axiom new_NatInner_spec: forall x: t_NatInner. invariant_NatInner x -> inner_NatInner (new_NatInner x) = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n : int
  
  function new (n: int) : t_Nat
  
  goal vc_new: n >= 0
    -> ([@stop_split] [@expl:new_logic requires] invariant_NatInner { f0'0 = n })
    /\ (([@stop_split] [@expl:new_logic ensures] inner_NatInner (new_NatInner { f0'0 = n }) = { f0'0 = n })
    -> ([@stop_split] [@expl:new ensures] to_int { f0 = new_NatInner { f0'0 = n } } = n))
end
module M_logic__int__impl_Nat__ext_eq (* logic::int::Nat *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Subset_NatInner
  
  type t_Nat = { f0: t_Subset_NatInner }
  
  type t_NatInner = { f0'0: int }
  
  predicate invariant_NatInner (self: t_NatInner) = self.f0'0 >= 0
  
  function inner_NatInner (self: t_Subset_NatInner) : t_NatInner
  
  axiom inner_NatInner_spec: forall self: t_Subset_NatInner. invariant_NatInner (inner_NatInner self)
  
  function inner_inj_NatInner (self: t_Subset_NatInner) (other: t_Subset_NatInner) : ()
  
  axiom inner_inj_NatInner_spec: forall self: t_Subset_NatInner, other: t_Subset_NatInner. inner_NatInner self
        = inner_NatInner other -> self = other
  
  function to_int (self: t_Nat) : int = (inner_NatInner self.f0).f0'0
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  constant other : t_Nat
  
  predicate ext_eq (self: t_Nat) (other: t_Nat)
  
  goal vc_ext_eq: ([@stop_split] [@expl:to_int ensures] to_int self >= 0)
    -> ([@stop_split] [@expl:to_int ensures] to_int other >= 0)
    -> ([@stop_split] [@expl:ext_eq ensures] (to_int self = to_int other) = (self = other))
end
module M_logic__int__impl_AddLogic_for_Nat__add (* <logic::int::Nat as logic::ops::arithmetic::AddLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Subset_NatInner
  
  type t_Nat = { f0: t_Subset_NatInner }
  
  type t_NatInner = { f0'0: int }
  
  predicate invariant_NatInner (self: t_NatInner) = self.f0'0 >= 0
  
  function inner_NatInner (self: t_Subset_NatInner) : t_NatInner
  
  axiom inner_NatInner_spec: forall self: t_Subset_NatInner. invariant_NatInner (inner_NatInner self)
  
  function to_int (self: t_Nat) : int = (inner_NatInner self.f0).f0'0
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function new_NatInner (x: t_NatInner) : t_Subset_NatInner
  
  axiom new_NatInner_spec: forall x: t_NatInner. invariant_NatInner x -> inner_NatInner (new_NatInner x) = x
  
  function new (n: int) : t_Nat = { f0 = new_NatInner { f0'0 = n } }
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  constant other : t_Nat
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  goal vc_add_Nat: ([@stop_split] [@expl:to_int ensures] to_int self >= 0)
    -> ([@stop_split] [@expl:to_int ensures] to_int other >= 0)
    -> ([@stop_split] [@expl:new requires] to_int self + to_int other >= 0)
    /\ (([@stop_split] [@expl:new ensures] to_int (new (to_int self + to_int other)) = to_int self + to_int other)
    -> ([@stop_split] [@expl:add ensures] to_int (new (to_int self + to_int other)) = to_int self + to_int other))
end
module M_logic__int__impl_MulLogic_for_Nat__mul (* <logic::int::Nat as logic::ops::arithmetic::MulLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Subset_NatInner
  
  type t_Nat = { f0: t_Subset_NatInner }
  
  type t_NatInner = { f0'0: int }
  
  predicate invariant_NatInner (self: t_NatInner) = self.f0'0 >= 0
  
  function inner_NatInner (self: t_Subset_NatInner) : t_NatInner
  
  axiom inner_NatInner_spec: forall self: t_Subset_NatInner. invariant_NatInner (inner_NatInner self)
  
  function to_int (self: t_Nat) : int = (inner_NatInner self.f0).f0'0
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function new_NatInner (x: t_NatInner) : t_Subset_NatInner
  
  axiom new_NatInner_spec: forall x: t_NatInner. invariant_NatInner x -> inner_NatInner (new_NatInner x) = x
  
  function new (n: int) : t_Nat = { f0 = new_NatInner { f0'0 = n } }
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  constant other : t_Nat
  
  function mul_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  goal vc_mul_Nat: ([@stop_split] [@expl:to_int ensures] to_int self >= 0)
    -> ([@stop_split] [@expl:to_int ensures] to_int other >= 0)
    -> ([@stop_split] [@expl:new requires] to_int self * to_int other >= 0)
    /\ (([@stop_split] [@expl:new ensures] to_int (new (to_int self * to_int other)) = to_int self * to_int other)
    -> ([@stop_split] [@expl:mul ensures] to_int (new (to_int self * to_int other)) = to_int self * to_int other))
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_le_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate le_log_ref_T (self: t_T) (other: t_T) = le_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_le_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_le_log_ref_T: [@stop_split] [@expl:cmp_le_log ensures] le_log_ref_T x y = (cmp_log_ref_T x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_lt_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate lt_log_ref_T (self: t_T) (other: t_T) = lt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_lt_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_lt_log_ref_T: [@stop_split] [@expl:cmp_lt_log ensures] lt_log_ref_T x y = (cmp_log_ref_T x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_ge_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate ge_log_ref_T (self: t_T) (other: t_T) = ge_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_ge_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_ge_log_ref_T: [@stop_split] [@expl:cmp_ge_log ensures] ge_log_ref_T x y = (cmp_log_ref_T x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_gt_log (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate gt_log_ref_T (self: t_T) (other: t_T) = gt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function cmp_gt_log_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_cmp_gt_log_ref_T: [@stop_split] [@expl:cmp_gt_log ensures] gt_log_ref_T x y = (cmp_log_ref_T x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__refl (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  function refl_ref_T (x: t_T) : ()
  
  goal vc_refl_ref_T: [@stop_split] [@expl:refl ensures] cmp_log_ref_T x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_ref_T__trans (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  constant z : t_T
  
  constant o : t_Ordering
  
  function trans_ref_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  goal vc_trans_ref_T: cmp_log_ref_T x y = o
    -> cmp_log_ref_T y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_ref_T x z = o)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym1 (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function antisym1_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_antisym1_ref_T: cmp_log_ref_T x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_ref_T y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym2 (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function antisym2_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_antisym2_ref_T: cmp_log_ref_T x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_ref_T y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__eq_cmp (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_T
  
  constant y : t_T
  
  function eq_cmp_ref_T (x: t_T) (y: t_T) : ()
  
  goal vc_eq_cmp_ref_T: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_ref_T x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_le_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_le_log_Int: [@stop_split] [@expl:cmp_le_log ensures] (x <= y) = (cmp_log_Int x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_lt_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_lt_log_Int: [@stop_split] [@expl:cmp_lt_log ensures] (x < y) = (cmp_log_Int x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_ge_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_ge_log_Int: [@stop_split] [@expl:cmp_ge_log ensures] (x >= y) = (cmp_log_Int x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_gt_log (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  goal vc_cmp_gt_log_Int: [@stop_split] [@expl:cmp_gt_log ensures] (x > y) = (cmp_log_Int x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__refl (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  function refl_Int (x: int) : ()
  
  goal vc_refl_Int: [@stop_split] [@expl:refl ensures] cmp_log_Int x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_Int__trans (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  constant z : int
  
  constant o : t_Ordering
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  goal vc_trans_Int: cmp_log_Int x y = o
    -> cmp_log_Int y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_Int x z = o)
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym1 (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function antisym1_Int (x: int) (y: int) : ()
  
  goal vc_antisym1_Int: cmp_log_Int x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_Int y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym2 (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function antisym2_Int (x: int) (y: int) : ()
  
  goal vc_antisym2_Int: cmp_log_Int x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_Int y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__eq_cmp (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : int
  
  constant y : int
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  goal vc_eq_cmp_Int: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_Int x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_le_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_le_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_le_log_u8: [@stop_split] [@expl:cmp_le_log ensures] UInt8.le x y = (cmp_log_u8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_lt_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_lt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_lt_log_u8: [@stop_split] [@expl:cmp_lt_log ensures] UInt8.lt x y = (cmp_log_u8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_ge_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_ge_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_ge_log_u8: [@stop_split] [@expl:cmp_ge_log ensures] UInt8.ge x y = (cmp_log_u8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_gt_log (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function cmp_gt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_cmp_gt_log_u8: [@stop_split] [@expl:cmp_gt_log ensures] UInt8.gt x y = (cmp_log_u8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__refl (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  function refl_u8 (x: UInt8.t) : ()
  
  goal vc_refl_u8: [@stop_split] [@expl:refl ensures] cmp_log_u8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u8__trans (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  constant z : UInt8.t
  
  constant o : t_Ordering
  
  function trans_u8 (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  goal vc_trans_u8: cmp_log_u8 x y = o -> cmp_log_u8 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_u8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym1 (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function antisym1_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_antisym1_u8: cmp_log_u8 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_u8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym2 (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function antisym2_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_antisym2_u8: cmp_log_u8 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_u8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__eq_cmp (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt8.t
  
  constant y : UInt8.t
  
  function eq_cmp_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  goal vc_eq_cmp_u8: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_u8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_le_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_le_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_le_log_u16: [@stop_split] [@expl:cmp_le_log ensures] UInt16.le x y = (cmp_log_u16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_lt_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_lt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_lt_log_u16: [@stop_split] [@expl:cmp_lt_log ensures] UInt16.lt x y = (cmp_log_u16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_ge_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_ge_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_ge_log_u16: [@stop_split] [@expl:cmp_ge_log ensures] UInt16.ge x y = (cmp_log_u16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_gt_log (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function cmp_gt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_cmp_gt_log_u16: [@stop_split] [@expl:cmp_gt_log ensures] UInt16.gt x y = (cmp_log_u16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__refl (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  function refl_u16 (x: UInt16.t) : ()
  
  goal vc_refl_u16: [@stop_split] [@expl:refl ensures] cmp_log_u16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u16__trans (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  constant z : UInt16.t
  
  constant o : t_Ordering
  
  function trans_u16 (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  goal vc_trans_u16: cmp_log_u16 x y = o
    -> cmp_log_u16 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_u16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym1 (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function antisym1_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_antisym1_u16: cmp_log_u16 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_u16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym2 (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function antisym2_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_antisym2_u16: cmp_log_u16 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_u16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__eq_cmp (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt16.t
  
  constant y : UInt16.t
  
  function eq_cmp_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  goal vc_eq_cmp_u16: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_u16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_le_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_le_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_le_log_u32: [@stop_split] [@expl:cmp_le_log ensures] UInt32.le x y = (cmp_log_u32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_lt_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_lt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_lt_log_u32: [@stop_split] [@expl:cmp_lt_log ensures] UInt32.lt x y = (cmp_log_u32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_ge_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_ge_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_ge_log_u32: [@stop_split] [@expl:cmp_ge_log ensures] UInt32.ge x y = (cmp_log_u32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_gt_log (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function cmp_gt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_cmp_gt_log_u32: [@stop_split] [@expl:cmp_gt_log ensures] UInt32.gt x y = (cmp_log_u32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__refl (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  function refl_u32 (x: UInt32.t) : ()
  
  goal vc_refl_u32: [@stop_split] [@expl:refl ensures] cmp_log_u32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u32__trans (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  constant z : UInt32.t
  
  constant o : t_Ordering
  
  function trans_u32 (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  goal vc_trans_u32: cmp_log_u32 x y = o
    -> cmp_log_u32 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_u32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym1 (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function antisym1_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_antisym1_u32: cmp_log_u32 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_u32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym2 (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function antisym2_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_antisym2_u32: cmp_log_u32 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_u32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__eq_cmp (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt32.t
  
  constant y : UInt32.t
  
  function eq_cmp_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  goal vc_eq_cmp_u32: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_u32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_le_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_le_log_u64: [@stop_split] [@expl:cmp_le_log ensures] UInt64.le x y = (cmp_log_u64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_lt_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_lt_log_u64: [@stop_split] [@expl:cmp_lt_log ensures] UInt64.lt x y = (cmp_log_u64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_ge_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_ge_log_u64: [@stop_split] [@expl:cmp_ge_log ensures] UInt64.ge x y = (cmp_log_u64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_gt_log (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_gt_log_u64: [@stop_split] [@expl:cmp_gt_log ensures] UInt64.gt x y = (cmp_log_u64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__refl (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  function refl_u64 (x: UInt64.t) : ()
  
  goal vc_refl_u64: [@stop_split] [@expl:refl ensures] cmp_log_u64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u64__trans (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  constant z : UInt64.t
  
  constant o : t_Ordering
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  goal vc_trans_u64: cmp_log_u64 x y = o
    -> cmp_log_u64 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_u64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym1 (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym1_u64: cmp_log_u64 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_u64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym2 (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym2_u64: cmp_log_u64 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_u64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__eq_cmp (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_eq_cmp_u64: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_u64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_le_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_le_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_le_log_u128: [@stop_split] [@expl:cmp_le_log ensures] UInt128.le x y = (cmp_log_u128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_lt_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_lt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_lt_log_u128: [@stop_split] [@expl:cmp_lt_log ensures] UInt128.lt x y = (cmp_log_u128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_ge_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_ge_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_ge_log_u128: [@stop_split] [@expl:cmp_ge_log ensures] UInt128.ge x y = (cmp_log_u128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_gt_log (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function cmp_gt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_cmp_gt_log_u128: [@stop_split] [@expl:cmp_gt_log ensures] UInt128.gt x y = (cmp_log_u128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__refl (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  function refl_u128 (x: UInt128.t) : ()
  
  goal vc_refl_u128: [@stop_split] [@expl:refl ensures] cmp_log_u128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u128__trans (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  constant z : UInt128.t
  
  constant o : t_Ordering
  
  function trans_u128 (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  goal vc_trans_u128: cmp_log_u128 x y = o
    -> cmp_log_u128 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_u128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym1 (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function antisym1_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_antisym1_u128: cmp_log_u128 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_u128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym2 (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function antisym2_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_antisym2_u128: cmp_log_u128 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_u128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__eq_cmp (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt128.t
  
  constant y : UInt128.t
  
  function eq_cmp_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  goal vc_eq_cmp_u128: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_u128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_le_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_le_log_usize: [@stop_split] [@expl:cmp_le_log ensures] UInt64.le x y = (cmp_log_usize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_lt_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_lt_log_usize: [@stop_split] [@expl:cmp_lt_log ensures] UInt64.lt x y = (cmp_log_usize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_ge_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_ge_log_usize: [@stop_split] [@expl:cmp_ge_log ensures] UInt64.ge x y = (cmp_log_usize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_gt_log (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_cmp_gt_log_usize: [@stop_split] [@expl:cmp_gt_log ensures] UInt64.gt x y = (cmp_log_usize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__refl (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  function refl_usize (x: UInt64.t) : ()
  
  goal vc_refl_usize: [@stop_split] [@expl:refl ensures] cmp_log_usize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_usize__trans (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  constant z : UInt64.t
  
  constant o : t_Ordering
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  goal vc_trans_usize: cmp_log_usize x y = o
    -> cmp_log_usize y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_usize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym1 (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym1_usize: cmp_log_usize x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_usize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym2 (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_antisym2_usize: cmp_log_usize x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_usize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__eq_cmp (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : UInt64.t
  
  constant y : UInt64.t
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  goal vc_eq_cmp_usize: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_usize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_le_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_le_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_le_log_i8: [@stop_split] [@expl:cmp_le_log ensures] Int8.le x y = (cmp_log_i8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_lt_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_lt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_lt_log_i8: [@stop_split] [@expl:cmp_lt_log ensures] Int8.lt x y = (cmp_log_i8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_ge_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_ge_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_ge_log_i8: [@stop_split] [@expl:cmp_ge_log ensures] Int8.ge x y = (cmp_log_i8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_gt_log (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function cmp_gt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_cmp_gt_log_i8: [@stop_split] [@expl:cmp_gt_log ensures] Int8.gt x y = (cmp_log_i8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__refl (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  function refl_i8 (x: Int8.t) : ()
  
  goal vc_refl_i8: [@stop_split] [@expl:refl ensures] cmp_log_i8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i8__trans (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  constant z : Int8.t
  
  constant o : t_Ordering
  
  function trans_i8 (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  goal vc_trans_i8: cmp_log_i8 x y = o -> cmp_log_i8 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_i8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym1 (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function antisym1_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_antisym1_i8: cmp_log_i8 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_i8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym2 (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function antisym2_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_antisym2_i8: cmp_log_i8 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_i8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__eq_cmp (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int8.t
  
  constant y : Int8.t
  
  function eq_cmp_i8 (x: Int8.t) (y: Int8.t) : ()
  
  goal vc_eq_cmp_i8: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_i8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_le_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_le_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_le_log_i16: [@stop_split] [@expl:cmp_le_log ensures] Int16.le x y = (cmp_log_i16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_lt_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_lt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_lt_log_i16: [@stop_split] [@expl:cmp_lt_log ensures] Int16.lt x y = (cmp_log_i16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_ge_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_ge_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_ge_log_i16: [@stop_split] [@expl:cmp_ge_log ensures] Int16.ge x y = (cmp_log_i16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_gt_log (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function cmp_gt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_cmp_gt_log_i16: [@stop_split] [@expl:cmp_gt_log ensures] Int16.gt x y = (cmp_log_i16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__refl (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  function refl_i16 (x: Int16.t) : ()
  
  goal vc_refl_i16: [@stop_split] [@expl:refl ensures] cmp_log_i16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i16__trans (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  constant z : Int16.t
  
  constant o : t_Ordering
  
  function trans_i16 (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  goal vc_trans_i16: cmp_log_i16 x y = o
    -> cmp_log_i16 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_i16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym1 (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function antisym1_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_antisym1_i16: cmp_log_i16 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_i16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym2 (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function antisym2_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_antisym2_i16: cmp_log_i16 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_i16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__eq_cmp (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int16.t
  
  constant y : Int16.t
  
  function eq_cmp_i16 (x: Int16.t) (y: Int16.t) : ()
  
  goal vc_eq_cmp_i16: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_i16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_le_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_le_log_i32: [@stop_split] [@expl:cmp_le_log ensures] Int32.le x y = (cmp_log_i32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_lt_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_lt_log_i32: [@stop_split] [@expl:cmp_lt_log ensures] Int32.lt x y = (cmp_log_i32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_ge_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_ge_log_i32: [@stop_split] [@expl:cmp_ge_log ensures] Int32.ge x y = (cmp_log_i32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_gt_log (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_cmp_gt_log_i32: [@stop_split] [@expl:cmp_gt_log ensures] Int32.gt x y = (cmp_log_i32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__refl (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  function refl_i32 (x: Int32.t) : ()
  
  goal vc_refl_i32: [@stop_split] [@expl:refl ensures] cmp_log_i32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i32__trans (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  constant z : Int32.t
  
  constant o : t_Ordering
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  goal vc_trans_i32: cmp_log_i32 x y = o
    -> cmp_log_i32 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_i32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym1 (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_antisym1_i32: cmp_log_i32 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_i32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym2 (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_antisym2_i32: cmp_log_i32 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_i32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__eq_cmp (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int32.t
  
  constant y : Int32.t
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  goal vc_eq_cmp_i32: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_i32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_le_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_le_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_le_log_i64: [@stop_split] [@expl:cmp_le_log ensures] Int64.le x y = (cmp_log_i64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_lt_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_lt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_lt_log_i64: [@stop_split] [@expl:cmp_lt_log ensures] Int64.lt x y = (cmp_log_i64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_ge_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_ge_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_ge_log_i64: [@stop_split] [@expl:cmp_ge_log ensures] Int64.ge x y = (cmp_log_i64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_gt_log (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_gt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_gt_log_i64: [@stop_split] [@expl:cmp_gt_log ensures] Int64.gt x y = (cmp_log_i64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__refl (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  function refl_i64 (x: Int64.t) : ()
  
  goal vc_refl_i64: [@stop_split] [@expl:refl ensures] cmp_log_i64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i64__trans (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  constant z : Int64.t
  
  constant o : t_Ordering
  
  function trans_i64 (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  goal vc_trans_i64: cmp_log_i64 x y = o
    -> cmp_log_i64 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_i64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym1 (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym1_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym1_i64: cmp_log_i64 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_i64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym2 (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym2_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym2_i64: cmp_log_i64 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_i64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__eq_cmp (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function eq_cmp_i64 (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_eq_cmp_i64: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_i64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_le_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_le_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_le_log_i128: [@stop_split] [@expl:cmp_le_log ensures] Int128.le x y = (cmp_log_i128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_lt_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_lt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_lt_log_i128: [@stop_split] [@expl:cmp_lt_log ensures] Int128.lt x y = (cmp_log_i128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_ge_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_ge_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_ge_log_i128: [@stop_split] [@expl:cmp_ge_log ensures] Int128.ge x y = (cmp_log_i128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_gt_log (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function cmp_gt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_cmp_gt_log_i128: [@stop_split] [@expl:cmp_gt_log ensures] Int128.gt x y = (cmp_log_i128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__refl (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  function refl_i128 (x: Int128.t) : ()
  
  goal vc_refl_i128: [@stop_split] [@expl:refl ensures] cmp_log_i128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i128__trans (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  constant z : Int128.t
  
  constant o : t_Ordering
  
  function trans_i128 (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  goal vc_trans_i128: cmp_log_i128 x y = o
    -> cmp_log_i128 y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_i128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym1 (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function antisym1_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_antisym1_i128: cmp_log_i128 x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_i128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym2 (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function antisym2_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_antisym2_i128: cmp_log_i128 x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_i128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__eq_cmp (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int128.t
  
  constant y : Int128.t
  
  function eq_cmp_i128 (x: Int128.t) (y: Int128.t) : ()
  
  goal vc_eq_cmp_i128: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_i128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_le_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_le_log_isize: [@stop_split] [@expl:cmp_le_log ensures] Int64.le x y = (cmp_log_isize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_lt_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_lt_log_isize: [@stop_split] [@expl:cmp_lt_log ensures] Int64.lt x y = (cmp_log_isize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_ge_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_ge_log_isize: [@stop_split] [@expl:cmp_ge_log ensures] Int64.ge x y = (cmp_log_isize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_gt_log (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_cmp_gt_log_isize: [@stop_split] [@expl:cmp_gt_log ensures] Int64.gt x y = (cmp_log_isize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__refl (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  function refl_isize (x: Int64.t) : ()
  
  goal vc_refl_isize: [@stop_split] [@expl:refl ensures] cmp_log_isize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_isize__trans (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  constant z : Int64.t
  
  constant o : t_Ordering
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  goal vc_trans_isize: cmp_log_isize x y = o
    -> cmp_log_isize y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_isize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym1 (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym1_isize: cmp_log_isize x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_isize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym2 (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_antisym2_isize: cmp_log_isize x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_isize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__eq_cmp (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Int64.t
  
  constant y : Int64.t
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  goal vc_eq_cmp_isize: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_isize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_le_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_le_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_le_log_char: [@stop_split] [@expl:cmp_le_log ensures] Char.le x y = (cmp_log_char x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_lt_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_lt_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_lt_log_char: [@stop_split] [@expl:cmp_lt_log ensures] Char.lt x y = (cmp_log_char x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_ge_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_ge_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_ge_log_char: [@stop_split] [@expl:cmp_ge_log ensures] Char.ge x y = (cmp_log_char x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_gt_log (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function cmp_gt_log_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_cmp_gt_log_char: [@stop_split] [@expl:cmp_gt_log ensures] Char.gt x y = (cmp_log_char x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__refl (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  function refl_char (x: Char.t) : ()
  
  goal vc_refl_char: [@stop_split] [@expl:refl ensures] cmp_log_char x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_char__trans (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  constant z : Char.t
  
  constant o : t_Ordering
  
  function trans_char (x: Char.t) (y: Char.t) (z: Char.t) (o: t_Ordering) : ()
  
  goal vc_trans_char: cmp_log_char x y = o
    -> cmp_log_char y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_char x z = o)
end
module M_logic__ord__impl_OrdLogic_for_char__antisym1 (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function antisym1_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_antisym1_char: cmp_log_char x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_char y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__antisym2 (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function antisym2_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_antisym2_char: cmp_log_char x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_char y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__eq_cmp (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Char.t
  
  constant y : Char.t
  
  function eq_cmp_char (x: Char.t) (y: Char.t) : ()
  
  goal vc_eq_cmp_char: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_char x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_le_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_le_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_le_log_bool: [@stop_split] [@expl:cmp_le_log ensures] Bool.le x y = (cmp_log_bool x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_lt_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_lt_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_lt_log_bool: [@stop_split] [@expl:cmp_lt_log ensures] Bool.lt x y = (cmp_log_bool x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_ge_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_ge_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_ge_log_bool: [@stop_split] [@expl:cmp_ge_log ensures] Bool.ge x y = (cmp_log_bool x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_gt_log (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function cmp_gt_log_bool (x: bool) (y: bool) : ()
  
  goal vc_cmp_gt_log_bool: [@stop_split] [@expl:cmp_gt_log ensures] Bool.gt x y = (cmp_log_bool x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__refl (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  function refl_bool (x: bool) : ()
  
  goal vc_refl_bool: [@stop_split] [@expl:refl ensures] cmp_log_bool x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_bool__trans (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  constant z : bool
  
  constant o : t_Ordering
  
  function trans_bool (x: bool) (y: bool) (z: bool) (o: t_Ordering) : ()
  
  goal vc_trans_bool: cmp_log_bool x y = o
    -> cmp_log_bool y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_bool x z = o)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym1 (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function antisym1_bool (x: bool) (y: bool) : ()
  
  goal vc_antisym1_bool: cmp_log_bool x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_bool y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym2 (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function antisym2_bool (x: bool) (y: bool) : ()
  
  goal vc_antisym2_bool: cmp_log_bool x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_bool y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__eq_cmp (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : bool
  
  constant y : bool
  
  function eq_cmp_bool (x: bool) (y: bool) : ()
  
  goal vc_eq_cmp_bool: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_bool x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_le_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate le_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ le_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_le_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_le_log_tup2_A_B: [@stop_split] [@expl:cmp_le_log ensures] le_log_tup2_A_B x y
    = (cmp_log_tup2_A_B x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_lt_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate lt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ lt_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_lt_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_lt_log_tup2_A_B: [@stop_split] [@expl:cmp_lt_log ensures] lt_log_tup2_A_B x y
    = (cmp_log_tup2_A_B x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_ge_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate ge_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ ge_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_ge_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_ge_log_tup2_A_B: [@stop_split] [@expl:cmp_ge_log ensures] ge_log_tup2_A_B x y
    = (cmp_log_tup2_A_B x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_gt_log (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate gt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ gt_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function cmp_gt_log_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_cmp_gt_log_tup2_A_B: [@stop_split] [@expl:cmp_gt_log ensures] gt_log_tup2_A_B x y
    = (cmp_log_tup2_A_B x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__refl (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  function refl_tup2_A_B (x: tup2_A_B) : ()
  
  goal vc_refl_tup2_A_B: [@stop_split] [@expl:refl ensures] cmp_log_tup2_A_B x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__trans (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  constant z : tup2_A_B
  
  constant o : t_Ordering
  
  function trans_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) (z: tup2_A_B) (o: t_Ordering) : ()
  
  goal vc_trans_tup2_A_B: cmp_log_tup2_A_B x y = o
    -> cmp_log_tup2_A_B y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_tup2_A_B x z = o)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym1 (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function antisym1_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_antisym1_tup2_A_B: cmp_log_tup2_A_B x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_tup2_A_B y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym2 (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function antisym2_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_antisym2_tup2_A_B: cmp_log_tup2_A_B x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_tup2_A_B y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__eq_cmp (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : tup2_A_B
  
  constant y : tup2_A_B
  
  function eq_cmp_tup2_A_B (x: tup2_A_B) (y: tup2_A_B) : ()
  
  goal vc_eq_cmp_tup2_A_B: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_tup2_A_B x y = Equal)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__factor (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag_T
  
  constant factor : t_Ag_T
  
  function factor_Ag_T (self: t_Ag_T) (factor: t_Ag_T) : t_Option_Ag_T
  
  goal vc_factor_Ag_T: [@stop_split] [@expl:factor ensures] match op_Ag_T self factor with
      | Some c -> op_Ag_T factor c = Some self
      | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
      end
end
module M_logic__ra__agree__impl_RA_for_Ag_T__commutative (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Ag_T
  
  constant b : t_Ag_T
  
  function commutative_Ag_T (a: t_Ag_T) (b: t_Ag_T) : ()
  
  goal vc_commutative_Ag_T: [@stop_split] [@expl:commutative ensures] op_Ag_T a b = op_Ag_T b a
end
module M_logic__ra__agree__impl_RA_for_Ag_T__associative (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function and_then_Option_Ag_T (self: t_Option_Ag_T) (f: Map.map t_Ag_T t_Option_Ag_T) : t_Option_Ag_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Ag_T
  
  constant b : t_Ag_T
  
  constant c : t_Ag_T
  
  function associative_Ag_T (a: t_Ag_T) (b: t_Ag_T) (c: t_Ag_T) : ()
  
  goal vc_associative_Ag_T:
    [@stop_split] [@expl:associative ensures] and_then_Option_Ag_T (op_Ag_T a b) (fun (ab: t_Ag_T) -> op_Ag_T ab c)
    = and_then_Option_Ag_T (op_Ag_T b c) (fun (bc: t_Ag_T) -> op_Ag_T a bc)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core_idemp (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  predicate index_Mapping_Ag_T_bool [@inline:trivial] (self: Map.map t_Ag_T bool) (a: t_Ag_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Ag_T_bool
  
  function such_that_Ag_T (p: Map.map t_Ag_T bool) : t_Ag_T
  
  axiom such_that_Ag_T_spec: forall p: Map.map t_Ag_T bool. (exists x: t_Ag_T. index_Mapping_Ag_T_bool p x)
      -> index_Mapping_Ag_T_bool p (such_that_Ag_T p)
  
  function unwrap_Option_Ag_T (self: t_Option_Ag_T) : t_Ag_T = match self with
      | Some x -> x
      | None -> such_that_Ag_T (fun (__0: t_Ag_T) -> true)
      end
  
  function core_Ag_T (self: t_Ag_T) : t_Option_Ag_T = Some self
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag_T
  
  function core_idemp_Ag_T (self: t_Ag_T) : ()
  
  goal vc_core_idemp_Ag_T:
    [@stop_split] [@expl:core_idemp_Ag_T ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_Ag_T (core_Ag_T self) in op_Ag_T c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_Ag_T (unwrap_Option_Ag_T (core_Ag_T self)) self = Some self)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core_is_maximal_idemp (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  function core_Ag_T (self: t_Ag_T) : t_Option_Ag_T = Some self
  
  function factor_Ag_T (self: t_Ag_T) (factor: t_Ag_T) : t_Option_Ag_T = op_Ag_T self factor
  
  axiom factor_Ag_T_spec: forall self: t_Ag_T, factor: t_Ag_T. match factor_Ag_T self factor with
        | Some c -> op_Ag_T factor c = Some self
        | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
        end
  
  predicate incl_Ag_T (self: t_Ag_T) (other: t_Ag_T) = factor_Ag_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Ag_T
  
  constant i : t_Ag_T
  
  function core_is_maximal_idemp_Ag_T (self: t_Ag_T) (i: t_Ag_T) : ()
  
  goal vc_core_is_maximal_idemp_Ag_T: op_Ag_T i i = Some i
    -> op_Ag_T i self = Some self
    -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Ag_T self with
      | Some c -> incl_Ag_T i c
      | None -> false
      end)
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_mono (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant f1 : t_T
  
  constant f2 : t_T
  
  function rel_mono_AuthViewRel_T (a: t_Option_T) (f1: t_T) (f2: t_T) : ()
  
  goal vc_rel_mono_AuthViewRel_T: rel_AuthViewRel_T a f1
    -> incl_T f2 f1 -> ([@stop_split] [@expl:rel_mono ensures] rel_AuthViewRel_T a f2)
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_none (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant f : t_T
  
  function rel_none_AuthViewRel_T (a: t_Option_T) (f: t_T) : ()
  
  goal vc_rel_none_AuthViewRel_T: [@stop_split] [@expl:rel_none ensures] rel_AuthViewRel_T (None) f
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_unit (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  function core_T (self: t_T) : t_Option_T
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. core_T self = Some (core_total_T self)
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some x
  
  constant unit_core_T : ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T : ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  function rel_unit_AuthViewRel_T (a: t_Option_T) : ()
  
  goal vc_rel_unit_AuthViewRel_T: [@stop_split] [@expl:rel_unit ensures] rel_AuthViewRel_T a unit_T
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__update (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate_U = { f0: t_U }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  predicate premise_AuthUpdate_U [@inline:trivial] (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_AuthUpdate_U
  
  type tup2_R_R = { f0'0: t_R; f1'0: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0'1: t_Option_R; f1'1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'1 = self;
                                                                                            f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option_R. premise_U self from_auth from_frag
      -> op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
      -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_U self from_auth from_frag in op_Option_R (Some to_frag) frame
      = Some'0 (Some to_auth))
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_AuthUpdate_U
  
  constant from : t_View_AuthViewRel_R
  
  constant _3 : ()
  
  function update_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (_3: ()) : t_View_AuthViewRel_R
  
  goal vc_update_AuthUpdate_U: premise_AuthUpdate_U self from
    -> ([@stop_split] [@expl:unwrap_logic requires] auth_AuthViewRel_R from <> None)
    /\ (let from_auth = unwrap_Option_R (auth_AuthViewRel_R from) in ([@stop_split] [@expl:frag ensures] rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from))
    -> (let {f0'0 = auth; f1'0 = frag} = update_U self.f0 from_auth (frag_AuthViewRel_R from) in ([@stop_split] [@expl:frag ensures] rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from))
    -> ([@stop_split] [@expl:frag ensures] rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from))
    -> ([@stop_split] [@expl:factor ensures] match factor_R from_auth (frag_AuthViewRel_R from) with
        | Some c -> op_R (frag_AuthViewRel_R from) c = Some from_auth
        | None -> forall c: t_R. op_R (frag_AuthViewRel_R from) c <> Some from_auth
        end)
    -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 from_auth (frag_AuthViewRel_R from))
      /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R (Some (frag_AuthViewRel_R from)) (factor_R from_auth (frag_AuthViewRel_R from))
      = Some'0 (Some from_auth)))
    /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_U self.f0 from_auth (frag_AuthViewRel_R from) in op_Option_R (Some to_frag) (factor_R from_auth (frag_AuthViewRel_R from))
      = Some'0 (Some to_auth))
    -> (let _ = frame_preserving_U self.f0 from_auth (frag_AuthViewRel_R from) (factor_R from_auth (frag_AuthViewRel_R from)) in ([@stop_split] [@expl:new requires] rel_AuthViewRel_R (Some auth) frag)
    /\ (([@stop_split] [@expl:new ensures] ([@stop_split] [@expl:new ensures #0] auth_AuthViewRel_R (new_AuthViewRel_R (Some auth) frag)
        = Some auth)
      /\ ([@stop_split] [@expl:new ensures #1] frag_AuthViewRel_R (new_AuthViewRel_R (Some auth) frag) = frag))
    -> (let result = new_AuthViewRel_R (Some auth) frag in [@stop_split] [@expl:update_AuthUpdate_U ensures] ([@stop_split] [@expl:update ensures #0] auth_AuthViewRel_R result
      = Some ((update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f0'0))
    /\ ([@stop_split] [@expl:update ensures #1] frag_AuthViewRel_R result
    = (update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f1'0)))))))
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__frame_preserving (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate_U = { f0: t_U }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  predicate premise_AuthUpdate_U [@inline:trivial] (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_AuthUpdate_U
  
  type t_Option_View_AuthViewRel_R = None'0 | Some'0 t_View_AuthViewRel_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None; f1'0 = a} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | {f0'0 = a; f1'0 = None} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | _ -> None'0
        end
      | None -> None'0
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  type tup2_R_R = { f0'1: t_R; f1'1: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  type t_Option_Option_R = None'1 | Some'1 t_Option_R
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'1 other
      | {f1'0 = None} -> Some'1 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option_R. premise_U self from_auth from_frag
      -> op_Option_R (Some from_frag) frame = Some'1 (Some from_auth)
      -> (let {f0'1 = to_auth; f1'1 = to_frag} = update_U self from_auth from_frag in op_Option_R (Some to_frag) frame
      = Some'1 (Some to_auth))
  
  function update_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (_3: ()) : t_View_AuthViewRel_R =
    let from_auth = unwrap_Option_R (auth_AuthViewRel_R from) in let {f0'1 = auth; f1'1 = frag} = update_U self.f0 from_auth (frag_AuthViewRel_R from) in let _ = frame_preserving_U self.f0 from_auth (frag_AuthViewRel_R from) (factor_R from_auth (frag_AuthViewRel_R from)) in new_AuthViewRel_R (Some auth) frag
  
  axiom update_AuthUpdate_U_spec:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> auth_AuthViewRel_R (update_AuthUpdate_U self from _3)
      = Some ((update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f0'1)
  
  axiom update_AuthUpdate_U_spec'0:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> frag_AuthViewRel_R (update_AuthUpdate_U self from _3)
      = (update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f1'1
  
  predicate index_Mapping_View_AuthViewRel_R_bool [@inline:trivial] (self: Map.map t_View_AuthViewRel_R bool) (a: t_View_AuthViewRel_R) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_View_AuthViewRel_R_bool
  
  function such_that_View_AuthViewRel_R (p: Map.map t_View_AuthViewRel_R bool) : t_View_AuthViewRel_R
  
  axiom such_that_View_AuthViewRel_R_spec:
    forall p: Map.map t_View_AuthViewRel_R bool. (exists x: t_View_AuthViewRel_R. index_Mapping_View_AuthViewRel_R_bool p x)
      -> index_Mapping_View_AuthViewRel_R_bool p (such_that_View_AuthViewRel_R p)
  
  function unwrap_Option_View_AuthViewRel_R (self: t_Option_View_AuthViewRel_R) : t_View_AuthViewRel_R = match self with
      | Some'0 x -> x
      | None'0 -> such_that_View_AuthViewRel_R (fun (__0: t_View_AuthViewRel_R) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_AuthUpdate_U
  
  constant from : t_View_AuthViewRel_R
  
  constant frame : t_View_AuthViewRel_R
  
  function frame_preserving_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (frame: t_View_AuthViewRel_R) : ()
  
  goal vc_frame_preserving_AuthUpdate_U: premise_AuthUpdate_U self from
    -> op_View_AuthViewRel_R from frame <> None'0
    -> ([@stop_split] [@expl:unwrap_logic requires] auth_AuthViewRel_R from <> None)
    /\ (let auth = unwrap_Option_R (auth_AuthViewRel_R from) in ([@stop_split] [@expl:unwrap_logic requires] op_View_AuthViewRel_R from frame
      <> None'0)
    /\ (([@stop_split] [@expl:frag ensures] rel_AuthViewRel_R (auth_AuthViewRel_R (unwrap_Option_View_AuthViewRel_R (op_View_AuthViewRel_R from frame))) (frag_AuthViewRel_R (unwrap_Option_View_AuthViewRel_R (op_View_AuthViewRel_R from frame))))
    -> (let x = frag_AuthViewRel_R (unwrap_Option_View_AuthViewRel_R (op_View_AuthViewRel_R from frame)) in ([@stop_split] [@expl:factor ensures] match factor_R auth x with
        | Some c -> op_R x c = Some auth
        | None -> forall c: t_R. op_R x c <> Some auth
        end)
    -> ([@stop_split] [@expl:unwrap_logic requires] factor_R auth x <> None)
    /\ (let y = unwrap_Option_R (factor_R auth x) in ([@stop_split] [@expl:frag ensures] rel_AuthViewRel_R (auth_AuthViewRel_R frame) (frag_AuthViewRel_R frame))
    -> ([@stop_split] [@expl:unwrap_logic requires] op_R (frag_AuthViewRel_R frame) y <> None)
    /\ (let f = unwrap_Option_R (op_R (frag_AuthViewRel_R frame) y) in ([@stop_split] [@expl:frag ensures] rel_AuthViewRel_R (auth_AuthViewRel_R from) (frag_AuthViewRel_R from))
    -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 auth (frag_AuthViewRel_R from))
      /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R (Some (frag_AuthViewRel_R from)) (Some f)
      = Some'1 (Some auth)))
    /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'1 = to_auth; f1'1 = to_frag} = update_U self.f0 auth (frag_AuthViewRel_R from) in op_Option_R (Some to_frag) (Some f)
      = Some'1 (Some to_auth))
    -> (let _ = frame_preserving_U self.f0 auth (frag_AuthViewRel_R from) (Some f) in [@stop_split] [@expl:frame_preserving ensures] op_View_AuthViewRel_R (update_AuthUpdate_U self from ()) frame
    <> None'0)))))))
end
module M_logic__ra__excl__impl_RA_for_Excl_T__factor (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl_T
  
  constant factor : t_Excl_T
  
  function factor_Excl_T (self: t_Excl_T) (factor: t_Excl_T) : t_Option_Excl_T
  
  goal vc_factor_Excl_T: [@stop_split] [@expl:factor ensures] match None with
      | Some c -> op_Excl_T factor c = Some self
      | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
      end
end
module M_logic__ra__excl__impl_RA_for_Excl_T__commutative (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Excl_T
  
  constant b : t_Excl_T
  
  function commutative_Excl_T (a: t_Excl_T) (b: t_Excl_T) : ()
  
  goal vc_commutative_Excl_T: [@stop_split] [@expl:commutative ensures] op_Excl_T a b = op_Excl_T b a
end
module M_logic__ra__excl__impl_RA_for_Excl_T__associative (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function and_then_Option_Excl_T (self: t_Option_Excl_T) (f: Map.map t_Excl_T t_Option_Excl_T) : t_Option_Excl_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Excl_T
  
  constant b : t_Excl_T
  
  constant c : t_Excl_T
  
  function associative_Excl_T (a: t_Excl_T) (b: t_Excl_T) (c: t_Excl_T) : ()
  
  goal vc_associative_Excl_T:
    [@stop_split] [@expl:associative ensures] and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
    = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core_idemp (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function core_Excl_T (self: t_Excl_T) : t_Option_Excl_T = None
  
  predicate index_Mapping_Excl_T_bool [@inline:trivial] (self: Map.map t_Excl_T bool) (a: t_Excl_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Excl_T_bool
  
  function such_that_Excl_T (p: Map.map t_Excl_T bool) : t_Excl_T
  
  axiom such_that_Excl_T_spec: forall p: Map.map t_Excl_T bool. (exists x: t_Excl_T. index_Mapping_Excl_T_bool p x)
      -> index_Mapping_Excl_T_bool p (such_that_Excl_T p)
  
  function unwrap_Option_Excl_T (self: t_Option_Excl_T) : t_Excl_T = match self with
      | Some x -> x
      | None -> such_that_Excl_T (fun (__0: t_Excl_T) -> true)
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl_T
  
  function core_idemp_Excl_T (self: t_Excl_T) : ()
  
  goal vc_core_idemp_Excl_T: core_Excl_T self <> None
    -> ([@stop_split] [@expl:core_idemp_Excl_T ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_Excl_T (core_Excl_T self) in op_Excl_T c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_Excl_T (unwrap_Option_Excl_T (core_Excl_T self)) self
    = Some self))
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core_is_maximal_idemp (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function core_Excl_T (self: t_Excl_T) : t_Option_Excl_T = None
  
  function factor_Excl_T (self: t_Excl_T) (factor: t_Excl_T) : t_Option_Excl_T = None
  
  axiom factor_Excl_T_spec: forall self: t_Excl_T, factor: t_Excl_T. match factor_Excl_T self factor with
        | Some c -> op_Excl_T factor c = Some self
        | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
        end
  
  predicate incl_Excl_T (self: t_Excl_T) (other: t_Excl_T) = factor_Excl_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Excl_T
  
  constant i : t_Excl_T
  
  function core_is_maximal_idemp_Excl_T (self: t_Excl_T) (i: t_Excl_T) : ()
  
  goal vc_core_is_maximal_idemp_Excl_T: op_Excl_T i i = Some i
    -> op_Excl_T i self = Some self
    -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Excl_T self with
      | Some c -> incl_Excl_T i c
      | None -> false
      end)
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__update (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate_T = { f0: t_T }
  
  type t_Excl_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T [@inline:trivial] (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  meta "rewrite_def" predicate premise_ExclUpdate_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ExclUpdate_T
  
  constant from : t_Excl_T
  
  constant _3 : ()
  
  function update_ExclUpdate_T (self: t_ExclUpdate_T) (from: t_Excl_T) (_3: ()) : t_Excl_T
  
  goal vc_update_ExclUpdate_T: true
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__frame_preserving (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate_T = { f0: t_T }
  
  type t_Excl_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T [@inline:trivial] (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  meta "rewrite_def" predicate premise_ExclUpdate_T
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function commutative_Excl_T (a: t_Excl_T) (b: t_Excl_T) : () = ()
  
  axiom commutative_Excl_T_spec: forall a: t_Excl_T, b: t_Excl_T. op_Excl_T a b = op_Excl_T b a
  
  function update_ExclUpdate_T [@inline:trivial] (self: t_ExclUpdate_T) (from: t_Excl_T) (_3: ()) : t_Excl_T =
    { f0'0 = self.f0 }
  
  meta "rewrite_def" function update_ExclUpdate_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ExclUpdate_T
  
  constant from : t_Excl_T
  
  constant frame : t_Excl_T
  
  function frame_preserving_ExclUpdate_T (self: t_ExclUpdate_T) (from: t_Excl_T) (frame: t_Excl_T) : ()
  
  goal vc_frame_preserving_ExclUpdate_T: premise_ExclUpdate_T self from
    -> op_Excl_T from frame <> None
    -> ([@stop_split] [@expl:frame_preserving ensures] op_Excl_T (update_ExclUpdate_T self from ()) frame <> None)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__factor (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function factor_Option_V (self: t_Option_V) (factor: t_Option_V) : t_Option_Option_V = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None'0} -> Some'1 x
      | {f0 = None'0} -> None'1
      | {f0 = Some'0 x; f1 = Some'0 y} -> match factor_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_V_spec: forall self: t_Option_V, factor: t_Option_V. match factor_Option_V self factor with
        | Some'1 c -> op_Option_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_V. op_Option_V factor c <> Some'1 self
        end
  
  predicate incl_Option_V (self: t_Option_V) (other: t_Option_V) = factor_Option_V other self <> None'1
  
  function incl_transitive_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : () = ()
  
  axiom incl_transitive_Option_V_spec: forall a: t_Option_V, b: t_Option_V, c: t_Option_V. incl_Option_V a b
      -> incl_Option_V b c -> incl_Option_V a c
  
  function associative_some_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) (ab: t_Option_V) (bc: t_Option_V) : ()
   = let _ = associative_Option_V a b c in ()
  
  axiom associative_some_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V, ab: t_Option_V, bc: t_Option_V. op_Option_V a b = Some'1 ab
      -> op_Option_V b c = Some'1 bc -> op_Option_V a bc = op_Option_V ab c
  
  function associative_none_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) (bc: t_Option_V) : () =
    let _ = associative_Option_V a b c in ()
  
  axiom associative_none_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V, bc: t_Option_V. op_Option_V a b = None'1
      -> op_Option_V b c = Some'1 bc -> op_Option_V a bc = None'1
  
  function incl_op_Option_V (self: t_Option_V) (other: t_Option_V) (comb: t_Option_V) : () = ()
  
  axiom incl_op_Option_V_spec: forall self: t_Option_V, other: t_Option_V, comb: t_Option_V. op_Option_V self other
        = Some'1 comb -> incl_Option_V self comb
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant factor : t_FMap_K_V
  
  function factor_FMap_K_V (self: t_FMap_K_V) (factor: t_FMap_K_V) : t_Option_FMap_K_V
  
  goal vc_factor_FMap_K_V: if forall k: t_K. incl_Option_V (get_K factor k) (get_K self k) then
      (forall __0: tup2_K_V. let {f0'1 = k; f1'1 = vo} = __0 in ([@stop_split] [@expl:factor ensures] match factor_Option_V (Some'0 vo) (get_K factor k) with
              | Some'1 c -> op_Option_V (get_K factor k) c = Some'1 (Some'0 vo)
              | None'1 -> forall c: t_Option_V. op_Option_V (get_K factor k) c <> Some'1 (Some'0 vo)
              end)
          -> match factor_Option_V (Some'0 vo) (get_K factor k) with
            | Some'1 r -> true
            | None'1 -> true
            end)
      /\ (([@stop_split] [@expl:filter_map ensures] forall k: t_K [get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k'0) with
            | Some'1 r -> r
            | None'1 -> None'0
            end)) k]. get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k'0) with
              | Some'1 r -> r
              | None'1 -> None'0
              end)) k
          = match get_K self k with
            | None'0 -> None'0
            | Some'0 v -> index_Mapping_tup2_K_V_Option_V (fun (__0: tup2_K_V) -> let {f0'1 = k'0; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k'0) with
              | Some'1 r -> r
              | None'1 -> None'0
              end) { f0'1 = k; f1'1 = v }
            end)
      -> (let res = filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in match op_FMap_K_V factor res with
        | None -> false
        && ([@stop_split] [@expl:factor ensures] match Some res with
          | Some c -> op_FMap_K_V factor c = Some self
          | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
          end)
        | Some o -> ([@stop_split] [@expl:ext_eq ensures] ext_eq_K o self = (o = self))
        -> ext_eq_K o self
        && ([@stop_split] [@expl:factor ensures] match Some res with
          | Some c -> op_FMap_K_V factor c = Some self
          | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
          end)
        end))
    else
      [@stop_split] [@expl:factor ensures] match None with
        | Some c -> op_FMap_K_V factor c = Some self
        | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
        end

end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__eq (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  type t_Option_Option_V = None'0 | Some'0 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some c -> op_V factor c = Some self
        | None -> forall c: t_V. op_V factor c <> Some self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some ab
      -> op_V b c = Some bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None
      -> op_V b c = Some bc -> op_V a bc = None
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  predicate eq_V (self: t_V) (other: t_V)
  
  axiom eq_V_spec: forall self: t_V, other: t_V. eq_V self other = (self = other)
  
  predicate eq_Option_V [@inline:trivial] (self: t_Option_V) (other: t_Option_V) =
    match { f0 = self; f1 = other } with
      | {f0 = Some s; f1 = Some o} -> eq_V s o
      | {f0 = None; f1 = None} -> true
      | _ -> false
      end
  
  meta "rewrite_def" predicate eq_Option_V
  
  axiom eq_Option_V_spec: forall self: t_Option_V, other: t_Option_V. eq_Option_V self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant other : t_FMap_K_V
  
  predicate eq_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V)
  
  goal vc_eq_FMap_K_V: [@stop_split] [@expl:eq ensures] (forall k: t_K. eq_Option_V (get_K self k) (get_K other k))
    = (self = other)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__commutative (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'1: t_Option_FMap_K_V; f1'1: t_Option_FMap_K_V }
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMap_K_V
  
  constant b : t_FMap_K_V
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : ()
  
  goal vc_commutative_FMap_K_V: match { f0'1 = op_FMap_K_V a b; f1'1 = op_FMap_K_V b a } with
      | {f0'1 = Some ab; f1'1 = Some ba} -> ([@stop_split] [@expl:ext_eq ensures] ext_eq_K ab ba = (ab = ba))
      -> ext_eq_K ab ba && ([@stop_split] [@expl:commutative ensures] op_FMap_K_V a b = op_FMap_K_V b a)
      | {f0'1 = None; f1'1 = None} -> [@stop_split] [@expl:commutative ensures] op_FMap_K_V a b = op_FMap_K_V b a
      | _ -> false && ([@stop_split] [@expl:commutative ensures] op_FMap_K_V a b = op_FMap_K_V b a)
      end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__associative (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'1: t_Option_FMap_K_V; f1'1: t_Option_FMap_K_V }
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FMap_K_V
  
  constant b : t_FMap_K_V
  
  constant c : t_FMap_K_V
  
  function associative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) (c: t_FMap_K_V) : ()
  
  goal vc_associative_FMap_K_V: match { f0'1 = op_FMap_K_V a b; f1'1 = op_FMap_K_V b c } with
      | {f0'1 = Some ab; f1'1 = Some bc} -> match { f0'1 = op_FMap_K_V ab c; f1'1 = op_FMap_K_V a bc } with
        | {f0'1 = Some x; f1'1 = Some y} -> ([@stop_split] [@expl:ext_eq ensures] ext_eq_K x y = (x = y))
        -> ext_eq_K x y
        && ([@stop_split] [@expl:associative ensures] and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab'0: t_FMap_K_V) -> op_FMap_K_V ab'0 c)
        = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc'0: t_FMap_K_V) -> op_FMap_K_V a bc'0))
        | _ -> [@stop_split] [@expl:associative ensures] and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab'0: t_FMap_K_V) -> op_FMap_K_V ab'0 c)
        = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc'0: t_FMap_K_V) -> op_FMap_K_V a bc'0)
        end
      | _ -> [@stop_split] [@expl:associative ensures] and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
      = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
      end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core_idemp (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0 = k; f1 = v }
          end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1 = v} = __0 in core_V v))
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type tup2_V_V = { f0'1: t_V; f1'1: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None'0; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'1 = x; f1'1 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    filter_map_K self (fun (__0: tup2_K_V) -> let {f1 = v} = __0 in core_V v)
  
  axiom core_total_FMap_K_V_spec: forall self: t_FMap_K_V. core_FMap_K_V self = Some (core_total_FMap_K_V self)
  
  function core_total_idemp_FMap_K_V (self: t_FMap_K_V) : () = let c = core_total_FMap_K_V self in ()
  
  axiom core_total_idemp_FMap_K_V_spec:
    forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
      = Some (core_total_FMap_K_V self)
  
  axiom core_total_idemp_FMap_K_V_spec'0: forall self: t_FMap_K_V. op_FMap_K_V (core_total_FMap_K_V self) self
      = Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  function core_idemp_FMap_K_V (self: t_FMap_K_V) : ()
  
  goal vc_core_idemp_FMap_K_V: core_FMap_K_V self <> None
    -> ([@stop_split] [@expl:core_total_idemp ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
        = Some (core_total_FMap_K_V self))
      /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_FMap_K_V (core_total_FMap_K_V self) self = Some self))
    -> ([@stop_split] [@expl:core_idemp_FMap_K_V ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_FMap_K_V (core_FMap_K_V self) in op_FMap_K_V c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_FMap_K_V (unwrap_Option_FMap_K_V (core_FMap_K_V self)) self
    = Some self))
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core_is_maximal_idemp (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v))
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function factor_Option_V (self: t_Option_V) (factor: t_Option_V) : t_Option_Option_V = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None'0} -> Some'1 x
      | {f0 = None'0} -> None'1
      | {f0 = Some'0 x; f1 = Some'0 y} -> match factor_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_V_spec: forall self: t_Option_V, factor: t_Option_V. match factor_Option_V self factor with
        | Some'1 c -> op_Option_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_V. op_Option_V factor c <> Some'1 self
        end
  
  predicate incl_Option_V (self: t_Option_V) (other: t_Option_V) = factor_Option_V other self <> None'1
  
  function incl_transitive_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : () = ()
  
  axiom incl_transitive_Option_V_spec: forall a: t_Option_V, b: t_Option_V, c: t_Option_V. incl_Option_V a b
      -> incl_Option_V b c -> incl_Option_V a c
  
  function associative_some_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) (ab: t_Option_V) (bc: t_Option_V) : ()
   = let _ = associative_Option_V a b c in ()
  
  axiom associative_some_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V, ab: t_Option_V, bc: t_Option_V. op_Option_V a b = Some'1 ab
      -> op_Option_V b c = Some'1 bc -> op_Option_V a bc = op_Option_V ab c
  
  function associative_none_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) (bc: t_Option_V) : () =
    let _ = associative_Option_V a b c in ()
  
  axiom associative_none_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V, bc: t_Option_V. op_Option_V a b = None'1
      -> op_Option_V b c = Some'1 bc -> op_Option_V a bc = None'1
  
  function incl_op_Option_V (self: t_Option_V) (other: t_Option_V) (comb: t_Option_V) : () = ()
  
  axiom incl_op_Option_V_spec: forall self: t_Option_V, other: t_Option_V, comb: t_Option_V. op_Option_V self other
        = Some'1 comb -> incl_Option_V self comb
  
  function factor_FMap_K_V (self: t_FMap_K_V) (factor: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. incl_Option_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in Some res
    else
      None
  
  
  axiom factor_FMap_K_V_spec: forall self: t_FMap_K_V, factor: t_FMap_K_V. match factor_FMap_K_V self factor with
        | Some c -> op_FMap_K_V factor c = Some self
        | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
        end
  
  predicate incl_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) = factor_FMap_K_V other self <> None
  
  function core_is_maximal_idemp_V (self: t_V) (i: t_V) : ()
  
  axiom core_is_maximal_idemp_V_spec: forall self: t_V, i: t_V. op_V i i = Some'0 i
      -> op_V i self = Some'0 self
      -> match core_V self with
        | Some'0 c -> incl_V i c
        | None'0 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant i : t_FMap_K_V
  
  function core_is_maximal_idemp_FMap_K_V (self: t_FMap_K_V) (i: t_FMap_K_V) : ()
  
  goal vc_core_is_maximal_idemp_FMap_K_V: op_FMap_K_V i i = Some i
    -> op_FMap_K_V i self = Some self
    -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_FMap_K_V self with
      | Some c -> incl_FMap_K_V i c
      | None -> false
      end)
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__unit (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use map.Const
  use int.Int
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: to_mapping_K empty_K = Const.const (None'0)
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_FMap_K_V : t_FMap_K_V
  
  goal vc_unit_FMap_K_V:
    (forall x: t_FMap_K_V. ([@stop_split] [@expl:empty ensures] ([@stop_split] [@expl:empty ensures #0] len_K empty_K
            = 0)
          /\ ([@stop_split] [@expl:empty ensures #1] to_mapping_K empty_K = Const.const (None'0)))
        -> ([@stop_split] [@expl:unwrap_logic requires] op_FMap_K_V x empty_K <> None))
    /\ (forall x: t_FMap_K_V. ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V x empty_K)) x)
    && (([@stop_split] [@expl:empty ensures] ([@stop_split] [@expl:empty ensures #0] len_K empty_K = 0)
      /\ ([@stop_split] [@expl:empty ensures #1] to_mapping_K empty_K = Const.const (None'0)))
    -> (let result = empty_K in [@stop_split] [@expl:unit ensures] forall x: t_FMap_K_V [op_FMap_K_V x result]. op_FMap_K_V x result
      = Some x))
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_total (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V
  
  goal vc_core_total_FMap_K_V: (forall __0: tup2_K_V. let {f1'1 = v} = __0 in true)
    /\ (([@stop_split] [@expl:filter_map ensures] forall k: t_K [get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v)) k]. get_K (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v)) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V (fun (__0: tup2_K_V) -> let {f1'1 = v'0} = __0 in core_V v'0) { f0'1 = k;
                                                                                                                        f1'1 = v }
          end)
    -> ([@stop_split] [@expl:core_total ensures] core_FMap_K_V self
    = Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v))))
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_total_idemp (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v))
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v)
  
  axiom core_total_FMap_K_V_spec: forall self: t_FMap_K_V. core_FMap_K_V self = Some (core_total_FMap_K_V self)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some'0 x -> x
      | None'0 -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function core_idemp_V (self: t_V) : ()
  
  axiom core_idemp_V_spec: forall self: t_V. core_V self <> None'0
      -> (let c = unwrap_Option_V (core_V self) in op_V c c = Some'0 c)
  
  axiom core_idemp_V_spec'0: forall self: t_V. core_V self <> None'0
      -> op_V (unwrap_Option_V (core_V self)) self = Some'0 self
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  function core_total_idemp_FMap_K_V (self: t_FMap_K_V) : ()
  
  goal vc_core_total_idemp_FMap_K_V: ([@stop_split] [@expl:core_total ensures] core_FMap_K_V self
      = Some (core_total_FMap_K_V self))
    -> (let c = core_total_FMap_K_V self in ([@stop_split] [@expl:unwrap_logic requires] op_FMap_K_V c c <> None)
    /\ (([@stop_split] [@expl:ext_eq ensures] ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V c c)) c
      = (unwrap_Option_FMap_K_V (op_FMap_K_V c c) = c))
    -> ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V c c)) c
    && ([@stop_split] [@expl:unwrap_logic requires] op_FMap_K_V c self <> None)
    /\ (([@stop_split] [@expl:ext_eq ensures] ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V c self)) self
      = (unwrap_Option_FMap_K_V (op_FMap_K_V c self) = self))
    -> ext_eq_K (unwrap_Option_FMap_K_V (op_FMap_K_V c self)) self
    && ([@stop_split] [@expl:core_total_idemp_FMap_K_V ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
      = Some (core_total_FMap_K_V self))
    /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_FMap_K_V (core_total_FMap_K_V self) self = Some self)))))
end
module M_logic__ra__fmap__impl_FMap_K_V__total_op (* logic::fmap::FMap<K, V> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  type t_Option_Option_V = None'0 | Some'0 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some c -> op_V factor c = Some self
        | None -> forall c: t_V. op_V factor c <> Some self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some ab
      -> op_V b c = Some bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None
      -> op_V b c = Some bc -> op_V a bc = None
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None} -> get_K (merge_K self m f) k = x
          | {f0 = Some x; f1 = Some y} -> get_K (merge_K self m f) k
          = Some (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMap_K_V
  
  constant other : t_FMap_K_V
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V
  
  goal vc_total_op_K: (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'0)
    -> (forall __0: tup2_V_V. let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
          | Some r -> true
          | _ -> [@stop_split] [@expl:such_that requires] exists x'0: t_V. index_Mapping_V_bool (fun (__0'0: t_V) -> true) x'0
          end)
    /\ (([@stop_split] [@expl:merge ensures] forall k: t_K [get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
          | Some r -> r
          | _ -> such_that_V (fun (__0'0: t_V) -> true)
          end)) k]. match { f0 = get_K self k; f1 = get_K other k } with
          | {f0 = None; f1 = y} -> get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y'0} = __0 in match op_V x y'0 with
              | Some r -> r
              | _ -> such_that_V (fun (__0'0: t_V) -> true)
              end)) k
          = y
          | {f0 = x; f1 = None} -> get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x'0; f1'0 = y} = __0 in match op_V x'0 y with
              | Some r -> r
              | _ -> such_that_V (fun (__0'0: t_V) -> true)
              end)) k
          = x
          | {f0 = Some x; f1 = Some y} -> get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x'0; f1'0 = y'0} = __0 in match op_V x'0 y'0 with
              | Some r -> r
              | _ -> such_that_V (fun (__0'0: t_V) -> true)
              end)) k
          = Some (index_Mapping_tup2_V_V_V (fun (__0: tup2_V_V) -> let {f0'0 = x'0; f1'0 = y'0} = __0 in match op_V x'0 y'0 with
            | Some r -> r
            | _ -> such_that_V (fun (__0'0: t_V) -> true)
            end) { f0'0 = x; f1'0 = y })
          end)
    -> ([@stop_split] [@expl:total_op ensures] forall k: t_K. Some'0 (get_K (merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
          | Some r -> r
          | _ -> such_that_V (fun (__0'0: t_V) -> true)
          end)) k)
      = op_Option_V (get_K self k) (get_K other k)))
end
module M_logic__ra__fmap__impl_LocalUpdate_for_FMapInsertLocalUpdate_K_V__frame_preserving (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_K
  
  type t_V
  
  type t_FMapInsertLocalUpdate_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate premise_FMapInsertLocalUpdate_K_V [@inline:trivial] (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (_3: t_FMap_K_V) =
    get_K from_auth self.f0 = None'0
  
  meta "rewrite_def" predicate premise_FMapInsertLocalUpdate_K_V
  
  type t_Option_Option_FMap_K_V = None'1 | Some'1 t_Option_FMap_K_V
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'0: t_Option_FMap_K_V; f1'0: t_Option_FMap_K_V }
  
  function map_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_Option_FMap_K_V
   = match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  type t_Option_Option_V = None'2 | Some'2 t_Option_V
  
  type tup2_Option_V_Option_V = { f0'1: t_Option_V; f1'1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'2
      | Some'0 x -> Some'2 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'1 = self;
                                                                                            f1'1 = other } with
      | {f0'1 = None'0} -> Some'2 other
      | {f1'1 = None'0} -> Some'2 self
      | {f0'1 = Some'0 x; f1'1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type tup2_V_V = { f0'2: t_V; f1'2: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'1 = get_K self k;
                                                                                                                         f1'1 = get_K m k } with
          | {f0'1 = None'0; f1'1 = y} -> get_K (merge_K self m f) k = y
          | {f0'1 = x; f1'1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'1 = Some'0 x; f1'1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'2 = x; f1'2 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'2 = x; f1'2 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2 then Some (total_op_K self other) else None
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  function op_Option_FMap_K_V (self: t_Option_FMap_K_V) (other: t_Option_FMap_K_V) : t_Option_Option_FMap_K_V =
    match { f0'0 = self; f1'0 = other } with
      | {f0'0 = None} -> Some'1 other
      | {f1'0 = None} -> Some'1 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_FMap_K_V (op_FMap_K_V x y) (fun (z: t_FMap_K_V) -> Some z)
      end
  
  function commutative_Option_FMap_K_V (a: t_Option_FMap_K_V) (b: t_Option_FMap_K_V) : ()
  
  axiom commutative_Option_FMap_K_V_spec: forall a: t_Option_FMap_K_V, b: t_Option_FMap_K_V. op_Option_FMap_K_V a b
      = op_Option_FMap_K_V b a
  
  type tup2_FMap_K_V_FMap_K_V = { f0'3: t_FMap_K_V; f1'3: t_FMap_K_V }
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. to_mapping_K (insert_K self k v)
      = Map.set (to_mapping_K self) k (Some'0 v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function update_FMapInsertLocalUpdate_K_V [@inline:trivial] (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (from_frag: t_FMap_K_V) : tup2_FMap_K_V_FMap_K_V
   = { f0'3 = insert_K from_auth self.f0 self.f1; f1'3 = insert_K from_frag self.f0 self.f1 }
  
  meta "rewrite_def" function update_FMapInsertLocalUpdate_K_V
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FMapInsertLocalUpdate_K_V
  
  constant from_auth : t_FMap_K_V
  
  constant from_frag : t_FMap_K_V
  
  constant frame : t_Option_FMap_K_V
  
  function frame_preserving_FMapInsertLocalUpdate_K_V (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (from_frag: t_FMap_K_V) (frame: t_Option_FMap_K_V) : ()
  
  goal vc_frame_preserving_FMapInsertLocalUpdate_K_V: premise_FMapInsertLocalUpdate_K_V self from_auth from_frag
    -> op_Option_FMap_K_V (Some from_frag) frame = Some'1 (Some from_auth)
    -> (let {f0'3 = to_auth; f1'3 = to_frag} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in match op_Option_FMap_K_V (Some to_frag) frame with
      | Some'1 (Some x) -> ([@stop_split] [@expl:ext_eq ensures] ext_eq_K to_auth x = (to_auth = x))
      -> ext_eq_K to_auth x
      && ([@stop_split] [@expl:frame_preserving ensures] let {f0'3 = to_auth'0; f1'3 = to_frag'0} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some to_frag'0) frame
      = Some'1 (Some to_auth'0))
      | _ -> false
      && ([@stop_split] [@expl:frame_preserving ensures] let {f0'3 = to_auth'0; f1'3 = to_frag'0} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some to_frag'0) frame
      = Some'1 (Some to_auth'0))
      end)
end
module M_logic__ra__int__impl_RA_for_Int__factor (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : int
  
  constant factor : int
  
  function factor_Int (self: int) (factor: int) : t_Option_Int
  
  goal vc_factor_Int: [@stop_split] [@expl:factor ensures] match Some (self - factor) with
      | Some c -> op_Int factor c = Some self
      | None -> false
      end
end
module M_logic__ra__int__impl_RA_for_Int__commutative (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : int
  
  constant b : int
  
  function commutative_Int (a: int) (b: int) : ()
  
  goal vc_commutative_Int: [@stop_split] [@expl:commutative ensures] op_Int a b = op_Int b a
end
module M_logic__ra__int__impl_RA_for_Int__associative (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function and_then_Option_Int (self: t_Option_Int) (f: Map.map int t_Option_Int) : t_Option_Int = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : int
  
  constant b : int
  
  constant c : int
  
  function associative_Int (a: int) (b: int) (c: int) : ()
  
  goal vc_associative_Int:
    [@stop_split] [@expl:associative ensures] and_then_Option_Int (op_Int a b) (fun (ab: int) -> op_Int ab c)
    = and_then_Option_Int (op_Int b c) (fun (bc: int) -> op_Int a bc)
end
module M_logic__ra__int__impl_RA_for_Int__core_idemp (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Option_Int = None | Some int
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  function unwrap_Option_Int (self: t_Option_Int) : int = match self with
      | Some x -> x
      | None -> such_that_Int (fun (__0: int) -> true)
      end
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : int
  
  function core_idemp_Int (self: int) : ()
  
  goal vc_core_idemp_Int:
    [@stop_split] [@expl:core_idemp_Int ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_Int (core_Int self) in op_Int c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_Int (unwrap_Option_Int (core_Int self)) self = Some self)
end
module M_logic__ra__int__impl_RA_for_Int__core_is_maximal_idemp (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  function factor_Int [@inline:trivial] (self: int) (factor: int) : t_Option_Int = Some (self - factor)
  
  meta "rewrite_def" function factor_Int
  
  axiom factor_Int_spec: forall self: int, factor: int. match factor_Int self factor with
        | Some c -> op_Int factor c = Some self
        | None -> false
        end
  
  predicate incl_Int (self: int) (other: int) = factor_Int other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : int
  
  constant i : int
  
  function core_is_maximal_idemp_Int (self: int) (i: int) : ()
  
  goal vc_core_is_maximal_idemp_Int: op_Int i i = Some i
    -> op_Int i self = Some self
    -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Int self with
      | Some c -> incl_Int i c
      | None -> false
      end)
end
module M_logic__ra__int__impl_UnitRA_for_Int__unit (* <logic::int::Int as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_Int : int
  
  goal vc_unit_Int:
    let result = 0 in [@stop_split] [@expl:unit ensures] forall x: int [op_Int x result]. op_Int x result = Some x
end
module M_logic__ra__int__impl_UnitRA_for_Int__core_total (* <logic::int::Int as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : int
  
  function core_total_Int (self: int) : int
  
  goal vc_core_total_Int: [@stop_split] [@expl:core_total ensures] core_Int self = Some 0
end
module M_logic__ra__int__impl_UnitRA_for_Int__core_total_idemp (* <logic::int::Int as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  function core_total_Int [@inline:trivial] (self: int) : int = 0
  
  meta "rewrite_def" function core_total_Int
  
  axiom core_total_Int_spec: forall self: int. core_Int self = Some (core_total_Int self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : int
  
  function core_total_idemp_Int (self: int) : ()
  
  goal vc_core_total_idemp_Int:
    [@stop_split] [@expl:core_total_idemp_Int ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_Int (core_total_Int self) (core_total_Int self)
      = Some (core_total_Int self))
    /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_Int (core_total_Int self) self = Some self)
end
module M_logic__ra__int__impl_LocalUpdate_for_Int__frame_preserving (* <logic::int::Int as logic::ra::update::LocalUpdate<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Option_Int = None | Some int
  
  predicate premise_Int [@inline:trivial] (self: int) (_2: int) (_3: int) = true
  
  meta "rewrite_def" predicate premise_Int
  
  type t_Option_Option_Int = None'0 | Some'0 t_Option_Int
  
  type tup2_Option_Int_Option_Int = { f0: t_Option_Int; f1: t_Option_Int }
  
  function map_Option_Int (self: t_Option_Int) (f: Map.map int t_Option_Int) : t_Option_Option_Int = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  function op_Option_Int (self: t_Option_Int) (other: t_Option_Int) : t_Option_Option_Int = match { f0 = self;
                                                                                                    f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_Int (op_Int x y) (fun (z: int) -> Some z)
      end
  
  function commutative_Option_Int (a: t_Option_Int) (b: t_Option_Int) : ()
  
  axiom commutative_Option_Int_spec: forall a: t_Option_Int, b: t_Option_Int. op_Option_Int a b = op_Option_Int b a
  
  type tup2_Int_Int = { f0'0: int; f1'0: int }
  
  function update_Int [@inline:trivial] (self: int) (from_auth: int) (from_frag: int) : tup2_Int_Int =
    { f0'0 = from_auth + self; f1'0 = from_frag + self }
  
  meta "rewrite_def" function update_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : int
  
  constant from_auth : int
  
  constant from_frag : int
  
  constant frame : t_Option_Int
  
  function frame_preserving_Int (self: int) (from_auth: int) (from_frag: int) (frame: t_Option_Int) : ()
  
  goal vc_frame_preserving_Int: premise_Int self from_auth from_frag
    -> op_Option_Int (Some from_frag) frame = Some'0 (Some from_auth)
    -> ([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_Int self from_auth from_frag in op_Option_Int (Some to_frag) frame
    = Some'0 (Some to_auth))
end
module M_logic__ra__nat__impl_RA_for_Nat__factor (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  predicate ext_eq (self: t_Nat) (other: t_Nat) = to_int self = to_int other
  
  axiom ext_eq_spec: forall self: t_Nat, other: t_Nat. ext_eq self other = (self = other)
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  constant factor : t_Nat
  
  function factor_Nat (self: t_Nat) (factor: t_Nat) : t_Option_Nat
  
  goal vc_factor_Nat: ([@stop_split] [@expl:to_int ensures] to_int self >= 0)
    -> ([@stop_split] [@expl:to_int ensures] to_int factor >= 0)
    -> (if to_int self >= to_int factor then
      ([@stop_split] [@expl:to_int ensures] to_int self >= 0)
      -> ([@stop_split] [@expl:to_int ensures] to_int factor >= 0)
      -> ([@stop_split] [@expl:new requires] to_int self - to_int factor >= 0)
      /\ (([@stop_split] [@expl:new ensures] to_int (new (to_int self - to_int factor)) = to_int self - to_int factor)
      -> ([@stop_split] [@expl:factor ensures] match Some (new (to_int self - to_int factor)) with
        | Some c -> op_Nat factor c = Some self
        | None -> forall c: t_Nat. op_Nat factor c <> Some self
        end))
    else
      [@stop_split] [@expl:factor ensures] match None with
        | Some c -> op_Nat factor c = Some self
        | None -> forall c: t_Nat. op_Nat factor c <> Some self
        end
    )
end
module M_logic__ra__nat__impl_RA_for_Nat__eq (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  predicate ext_eq (self: t_Nat) (other: t_Nat) = to_int self = to_int other
  
  axiom ext_eq_spec: forall self: t_Nat, other: t_Nat. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  constant other : t_Nat
  
  predicate eq_Nat (self: t_Nat) (other: t_Nat)
  
  goal vc_eq_Nat: ([@stop_split] [@expl:ext_eq ensures] ext_eq self other = (self = other))
    -> ([@stop_split] [@expl:eq ensures] ext_eq self other = (self = other))
end
module M_logic__ra__nat__impl_RA_for_Nat__commutative (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  predicate ext_eq (self: t_Nat) (other: t_Nat) = to_int self = to_int other
  
  axiom ext_eq_spec: forall self: t_Nat, other: t_Nat. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Nat
  
  constant b : t_Nat
  
  function commutative_Nat (a: t_Nat) (b: t_Nat) : ()
  
  goal vc_commutative_Nat: [@stop_split] [@expl:commutative ensures] op_Nat a b = op_Nat b a
end
module M_logic__ra__nat__impl_RA_for_Nat__associative (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function and_then_Option_Nat (self: t_Option_Nat) (f: Map.map t_Nat t_Option_Nat) : t_Option_Nat = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  predicate ext_eq (self: t_Nat) (other: t_Nat) = to_int self = to_int other
  
  axiom ext_eq_spec: forall self: t_Nat, other: t_Nat. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Nat
  
  constant b : t_Nat
  
  constant c : t_Nat
  
  function associative_Nat (a: t_Nat) (b: t_Nat) (c: t_Nat) : ()
  
  goal vc_associative_Nat:
    [@stop_split] [@expl:associative ensures] and_then_Option_Nat (op_Nat a b) (fun (ab: t_Nat) -> op_Nat ab c)
    = and_then_Option_Nat (op_Nat b c) (fun (bc: t_Nat) -> op_Nat a bc)
end
module M_logic__ra__nat__impl_RA_for_Nat__core_idemp (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  predicate index_Mapping_Nat_bool [@inline:trivial] (self: Map.map t_Nat bool) (a: t_Nat) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Nat_bool
  
  function such_that_Nat (p: Map.map t_Nat bool) : t_Nat
  
  axiom such_that_Nat_spec: forall p: Map.map t_Nat bool. (exists x: t_Nat. index_Mapping_Nat_bool p x)
      -> index_Mapping_Nat_bool p (such_that_Nat p)
  
  function unwrap_Option_Nat (self: t_Option_Nat) : t_Nat = match self with
      | Some x -> x
      | None -> such_that_Nat (fun (__0: t_Nat) -> true)
      end
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  predicate ext_eq (self: t_Nat) (other: t_Nat) = to_int self = to_int other
  
  axiom ext_eq_spec: forall self: t_Nat, other: t_Nat. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  function core_idemp_Nat (self: t_Nat) : ()
  
  goal vc_core_idemp_Nat:
    [@stop_split] [@expl:core_idemp_Nat ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_Nat (core_Nat self) in op_Nat c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_Nat (unwrap_Option_Nat (core_Nat self)) self = Some self)
end
module M_logic__ra__nat__impl_RA_for_Nat__core_is_maximal_idemp (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  function factor_Nat [@inline:trivial] (self: t_Nat) (factor: t_Nat) : t_Option_Nat = if to_int self
    >= to_int factor then
      Some (new (to_int self - to_int factor))
    else
      None
  
  
  meta "rewrite_def" function factor_Nat
  
  axiom factor_Nat_spec: forall self: t_Nat, factor: t_Nat. match factor_Nat self factor with
        | Some c -> op_Nat factor c = Some self
        | None -> forall c: t_Nat. op_Nat factor c <> Some self
        end
  
  predicate incl_Nat (self: t_Nat) (other: t_Nat) = factor_Nat other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  constant i : t_Nat
  
  function core_is_maximal_idemp_Nat (self: t_Nat) (i: t_Nat) : ()
  
  goal vc_core_is_maximal_idemp_Nat: op_Nat i i = Some i
    -> op_Nat i self = Some self
    -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Nat self with
      | Some c -> incl_Nat i c
      | None -> false
      end)
end
module M_logic__ra__nat__impl_UnitRA_for_Nat__unit (* <logic::int::Nat as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function commutative_Nat (a: t_Nat) (b: t_Nat) : () = ()
  
  axiom commutative_Nat_spec: forall a: t_Nat, b: t_Nat. op_Nat a b = op_Nat b a
  
  predicate ext_eq (self: t_Nat) (other: t_Nat) = to_int self = to_int other
  
  axiom ext_eq_spec: forall self: t_Nat, other: t_Nat. ext_eq self other = (self = other)
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_Nat : t_Nat
  
  goal vc_unit_Nat: ([@stop_split] [@expl:new requires] 0 >= 0)
    /\ (([@stop_split] [@expl:new ensures] to_int (new 0) = 0)
    -> (let result = new 0 in [@stop_split] [@expl:unit ensures] forall x: t_Nat [op_Nat x result]. op_Nat x result
      = Some x))
end
module M_logic__ra__nat__impl_UnitRA_for_Nat__core_total (* <logic::int::Nat as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function commutative_Nat (a: t_Nat) (b: t_Nat) : () = ()
  
  axiom commutative_Nat_spec: forall a: t_Nat, b: t_Nat. op_Nat a b = op_Nat b a
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  function core_total_Nat (self: t_Nat) : t_Nat
  
  goal vc_core_total_Nat: ([@stop_split] [@expl:new requires] 0 >= 0)
    /\ (([@stop_split] [@expl:new ensures] to_int (new 0) = 0)
    -> ([@stop_split] [@expl:core_total ensures] core_Nat self = Some (new 0)))
end
module M_logic__ra__nat__impl_UnitRA_for_Nat__core_total_idemp (* <logic::int::Nat as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function commutative_Nat (a: t_Nat) (b: t_Nat) : () = ()
  
  axiom commutative_Nat_spec: forall a: t_Nat, b: t_Nat. op_Nat a b = op_Nat b a
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  function core_total_Nat [@inline:trivial] (self: t_Nat) : t_Nat = new 0
  
  meta "rewrite_def" function core_total_Nat
  
  axiom core_total_Nat_spec: forall self: t_Nat. core_Nat self = Some (core_total_Nat self)
  
  predicate ext_eq (self: t_Nat) (other: t_Nat) = to_int self = to_int other
  
  axiom ext_eq_spec: forall self: t_Nat, other: t_Nat. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Nat
  
  function core_total_idemp_Nat (self: t_Nat) : ()
  
  goal vc_core_total_idemp_Nat:
    [@stop_split] [@expl:core_total_idemp_Nat ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_Nat (core_total_Nat self) (core_total_Nat self)
      = Some (core_total_Nat self))
    /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_Nat (core_total_Nat self) self = Some self)
end
module M_logic__ra__option__impl_RA_for_Option_T__factor (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  constant factor : t_Option_T
  
  function factor_Option_T (self: t_Option_T) (factor: t_Option_T) : t_Option_Option_T
  
  goal vc_factor_Option_T: match { f0 = self; f1 = factor } with
      | {f0 = x; f1 = None} -> [@stop_split] [@expl:factor ensures] match Some'0 x with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
      | {f0 = None} -> [@stop_split] [@expl:factor ensures] match None'0 with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
      | {f0 = Some x; f1 = Some y} -> ([@stop_split] [@expl:factor ensures] match factor_T x y with
          | Some c -> op_T y c = Some x
          | None -> forall c: t_T. op_T y c <> Some x
          end)
      -> match factor_T x y with
        | Some z -> [@stop_split] [@expl:factor ensures] match Some'0 (Some z) with
          | Some'0 c -> op_Option_T factor c = Some'0 self
          | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
          end
        | None -> if x = y then
          [@stop_split] [@expl:factor ensures] match Some'0 (None) with
            | Some'0 c -> op_Option_T factor c = Some'0 self
            | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
            end
        else
          [@stop_split] [@expl:factor ensures] match None'0 with
            | Some'0 c -> op_Option_T factor c = Some'0 self
            | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
            end
        
        end
      end
end
module M_logic__ra__option__impl_RA_for_Option_T__eq (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate eq_T (self: t_T) (other: t_T)
  
  axiom eq_T_spec: forall self: t_T, other: t_T. eq_T self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  constant other : t_Option_T
  
  predicate eq_Option_T (self: t_Option_T) (other: t_Option_T)
  
  goal vc_eq_Option_T: match { f0 = self; f1 = other } with
      | {f0 = Some s; f1 = Some o} -> ([@stop_split] [@expl:eq ensures] eq_T s o = (s = o))
      -> ([@stop_split] [@expl:eq ensures] eq_T s o = (self = other))
      | {f0 = None; f1 = None} -> [@stop_split] [@expl:eq ensures] true = (self = other)
      | _ -> [@stop_split] [@expl:eq ensures] false = (self = other)
      end
end
module M_logic__ra__option__impl_RA_for_Option_T__commutative (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant b : t_Option_T
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : ()
  
  goal vc_commutative_Option_T: [@stop_split] [@expl:commutative ensures] op_Option_T a b = op_Option_T b a
end
module M_logic__ra__option__impl_RA_for_Option_T__associative (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Option_T
  
  constant b : t_Option_T
  
  constant c : t_Option_T
  
  function associative_Option_T (a: t_Option_T) (b: t_Option_T) (c: t_Option_T) : ()
  
  goal vc_associative_Option_T:
    [@stop_split] [@expl:associative ensures] and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
    = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
end
module M_logic__ra__option__impl_RA_for_Option_T__core_idemp (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  predicate index_Mapping_Option_T_bool [@inline:trivial] (self: Map.map t_Option_T bool) (a: t_Option_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Option_T_bool
  
  function such_that_Option_T (p: Map.map t_Option_T bool) : t_Option_T
  
  axiom such_that_Option_T_spec:
    forall p: Map.map t_Option_T bool. (exists x: t_Option_T. index_Mapping_Option_T_bool p x)
      -> index_Mapping_Option_T_bool p (such_that_Option_T p)
  
  function unwrap_Option_Option_T (self: t_Option_Option_T) : t_Option_T = match self with
      | Some'0 x -> x
      | None'0 -> such_that_Option_T (fun (__0: t_Option_T) -> true)
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec: forall self: t_Option_T. core_Option_T self = Some'0 (core_total_Option_T self)
  
  function core_total_idemp_Option_T (self: t_Option_T) : () = ()
  
  axiom core_total_idemp_Option_T_spec:
    forall self: t_Option_T. op_Option_T (core_total_Option_T self) (core_total_Option_T self)
      = Some'0 (core_total_Option_T self)
  
  axiom core_total_idemp_Option_T_spec'0: forall self: t_Option_T. op_Option_T (core_total_Option_T self) self
      = Some'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function core_idemp_Option_T (self: t_Option_T) : ()
  
  goal vc_core_idemp_Option_T: core_Option_T self <> None'0
    -> ([@stop_split] [@expl:core_total_idemp ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_Option_T (core_total_Option_T self) (core_total_Option_T self)
        = Some'0 (core_total_Option_T self))
      /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_Option_T (core_total_Option_T self) self = Some'0 self))
    -> ([@stop_split] [@expl:core_idemp_Option_T ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_Option_T (core_Option_T self) in op_Option_T c c
      = Some'0 c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_Option_T (unwrap_Option_Option_T (core_Option_T self)) self
    = Some'0 self))
end
module M_logic__ra__option__impl_RA_for_Option_T__core_is_maximal_idemp (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  function factor_Option_T (self: t_Option_T) (factor: t_Option_T) : t_Option_Option_T = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None} -> Some'0 x
      | {f0 = None} -> None'0
      | {f0 = Some x; f1 = Some y} -> match factor_T x y with
        | Some z -> Some'0 (Some z)
        | None -> if x = y then Some'0 (None) else None'0
        end
      end
  
  axiom factor_Option_T_spec: forall self: t_Option_T, factor: t_Option_T. match factor_Option_T self factor with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
  
  predicate incl_Option_T (self: t_Option_T) (other: t_Option_T) = factor_Option_T other self <> None'0
  
  function core_is_maximal_idemp_T (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_T_spec: forall self: t_T, i: t_T. op_T i i = Some i
      -> op_T i self = Some self
      -> match core_T self with
        | Some c -> incl_T i c
        | None -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  constant i : t_Option_T
  
  function core_is_maximal_idemp_Option_T (self: t_Option_T) (i: t_Option_T) : ()
  
  goal vc_core_is_maximal_idemp_Option_T: op_Option_T i i = Some'0 i
    -> op_Option_T i self = Some'0 self
    -> match { f0 = self; f1 = i } with
      | {f0 = Some x; f1 = Some i'0} -> ([@stop_split] [@expl:core_is_maximal_idemp requires] ([@stop_split] [@expl:core_is_maximal_idemp requires #0] op_T i'0 i'0
          = Some i'0)
        /\ ([@stop_split] [@expl:core_is_maximal_idemp requires #1] op_T i'0 x = Some x))
      /\ (([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_T x with
          | Some c -> incl_T i'0 c
          | None -> false
          end)
      -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Option_T self with
        | Some'0 c -> incl_Option_T i c
        | None'0 -> false
        end))
      | _ -> [@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Option_T self with
        | Some'0 c -> incl_Option_T i c
        | None'0 -> false
        end
      end
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__unit (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_Option_T : t_Option_T
  
  goal vc_unit_Option_T:
    let result = None in [@stop_split] [@expl:unit ensures] forall x: t_Option_T [op_Option_T x result]. op_Option_T x result
      = Some'0 x
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_total (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T
  
  goal vc_core_total_Option_T: match self with
      | None -> [@stop_split] [@expl:core_total ensures] core_Option_T self = Some'0 (None)
      | Some x -> [@stop_split] [@expl:core_total ensures] core_Option_T self = Some'0 (core_T x)
      end
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_total_idemp (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec: forall self: t_Option_T. core_Option_T self = Some'0 (core_total_Option_T self)
  
  predicate index_Mapping_T_bool [@inline:trivial] (self: Map.map t_T bool) (a: t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T_bool
  
  function such_that_T (p: Map.map t_T bool) : t_T
  
  axiom such_that_T_spec: forall p: Map.map t_T bool. (exists x: t_T. index_Mapping_T_bool p x)
      -> index_Mapping_T_bool p (such_that_T p)
  
  function unwrap_Option_T (self: t_Option_T) : t_T = match self with
      | Some x -> x
      | None -> such_that_T (fun (__0: t_T) -> true)
      end
  
  function core_idemp_T (self: t_T) : ()
  
  axiom core_idemp_T_spec: forall self: t_T. core_T self <> None
      -> (let c = unwrap_Option_T (core_T self) in op_T c c = Some c)
  
  axiom core_idemp_T_spec'0: forall self: t_T. core_T self <> None
      -> op_T (unwrap_Option_T (core_T self)) self = Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function core_total_idemp_Option_T (self: t_Option_T) : ()
  
  goal vc_core_total_idemp_Option_T:
    [@stop_split] [@expl:core_total_idemp_Option_T ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_Option_T (core_total_Option_T self) (core_total_Option_T self)
      = Some'0 (core_total_Option_T self))
    /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_Option_T (core_total_Option_T self) self = Some'0 self)
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__update (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_OptionUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U [@inline:trivial] (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0 from'0
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_OptionUpdate_U
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_OptionUpdate_U
  
  constant from : t_Option_R
  
  constant ch : t_Choice
  
  function update_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) (ch: t_Choice) : t_Option_R
  
  goal vc_update_OptionUpdate_U: premise_OptionUpdate_U self from
    -> match from with
      | Some from'0 -> [@stop_split] [@expl:update requires] premise_U self.f0 from'0
      | None -> true
      end
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__frame_preserving (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_OptionUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U [@inline:trivial] (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0 from'0
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_OptionUpdate_U
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : () = ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_OptionUpdate_U [@inline:trivial] (self: t_OptionUpdate_U) (from: t_Option_R) (ch: t_Choice) : t_Option_R
   = match from with
      | Some from'0 -> Some (update_U self.f0 from'0 ch)
      | None -> None
      end
  
  meta "rewrite_def" function update_OptionUpdate_U
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function frame_preserving_U (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R, frame: t_R. premise_U self from
      -> op_R from frame <> None -> op_R (update_U self from (frame_preserving_U self from frame)) frame <> None
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_OptionUpdate_U
  
  constant from : t_Option_R
  
  constant frame : t_Option_R
  
  function frame_preserving_OptionUpdate_U (self: t_OptionUpdate_U) (from: t_Option_R) (frame: t_Option_R) : t_Choice
  
  goal vc_frame_preserving_OptionUpdate_U: premise_OptionUpdate_U self from
    -> op_Option_R from frame <> None'0
    -> match frame with
      | Some frame'0 -> ([@stop_split] [@expl:unwrap_logic requires] from <> None)
      /\ ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 (unwrap_Option_R from))
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_R (unwrap_Option_R from) frame'0 <> None))
      /\ (([@stop_split] [@expl:frame_preserving ensures] op_R (update_U self.f0 (unwrap_Option_R from) (frame_preserving_U self.f0 (unwrap_Option_R from) frame'0)) frame'0
        <> None)
      -> ([@stop_split] [@expl:frame_preserving ensures] op_Option_R (update_OptionUpdate_U self from (frame_preserving_U self.f0 (unwrap_Option_R from) frame'0)) frame
      <> None'0))
      | None -> ([@stop_split] [@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) (such_that_Choice (fun (__0: t_Choice) -> true)))
      -> ([@stop_split] [@expl:frame_preserving ensures] op_Option_R (update_OptionUpdate_U self from (such_that_Choice (fun (__0: t_Choice) -> true))) frame
      <> None'0))
      end
end
module M_logic__ra__option__impl_LocalUpdate_for_OptionLocalUpdate_U__frame_preserving (* <logic::ra::option::OptionLocalUpdate<U> as logic::ra::update::LocalUpdate<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_OptionLocalUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  predicate premise_OptionLocalUpdate_U [@inline:trivial] (self: t_OptionLocalUpdate_U) (from_auth: t_Option_R) (from_frag: t_Option_R) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Some from_auth'0; f1'0 = Some from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | _ -> false
      end
  
  meta "rewrite_def" predicate premise_OptionLocalUpdate_U
  
  type t_Option_Option_Option_R = None'1 | Some'1 t_Option_Option_R
  
  type tup2_Option_Option_R_Option_Option_R = { f0'1: t_Option_Option_R; f1'1: t_Option_Option_R }
  
  function map_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_Option_R
   = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : () = ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function op_Option_Option_R (self: t_Option_Option_R) (other: t_Option_Option_R) : t_Option_Option_Option_R =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None'0} -> Some'1 other
      | {f1'1 = None'0} -> Some'1 self
      | {f0'1 = Some'0 x; f1'1 = Some'0 y} -> map_Option_Option_R (op_Option_R x y) (fun (z: t_Option_R) -> Some'0 z)
      end
  
  function commutative_Option_Option_R (a: t_Option_Option_R) (b: t_Option_Option_R) : () = ()
  
  axiom commutative_Option_Option_R_spec: forall a: t_Option_Option_R, b: t_Option_Option_R. op_Option_Option_R a b
      = op_Option_Option_R b a
  
  type tup2_R_R = { f0'2: t_R; f1'2: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  function update_OptionLocalUpdate_U [@inline:trivial] (self: t_OptionLocalUpdate_U) (from_auth: t_Option_R) (from_frag: t_Option_R) : tup2_Option_R_Option_R
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Some from_auth'0; f1'0 = Some from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Some to_auth;
                                                                                                                                                   f1'0 = Some to_frag }
      | _ -> { f0'0 = None; f1'0 = None }
      end
  
  meta "rewrite_def" function update_OptionLocalUpdate_U
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  function frame_preserving_U (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option_R. premise_U self from_auth from_frag
      -> op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
      -> (let {f0'2 = to_auth; f1'2 = to_frag} = update_U self from_auth from_frag in op_Option_R (Some to_frag) frame
      = Some'0 (Some to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_OptionLocalUpdate_U
  
  constant from_auth : t_Option_R
  
  constant from_frag : t_Option_R
  
  constant frame : t_Option_Option_R
  
  function frame_preserving_OptionLocalUpdate_U (self: t_OptionLocalUpdate_U) (from_auth: t_Option_R) (from_frag: t_Option_R) (frame: t_Option_Option_R) : ()
  
  goal vc_frame_preserving_OptionLocalUpdate_U: premise_OptionLocalUpdate_U self from_auth from_frag
    -> op_Option_Option_R (Some'0 from_frag) frame = Some'1 (Some'0 from_auth)
    -> match frame with
      | None'0 -> let frame'0 = None in ([@stop_split] [@expl:unwrap_logic requires] from_auth <> None)
      /\ ([@stop_split] [@expl:unwrap_logic requires] from_frag <> None)
      /\ ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 (unwrap_Option_R from_auth) (unwrap_Option_R from_frag))
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R (Some (unwrap_Option_R from_frag)) frame'0
        = Some'0 (Some (unwrap_Option_R from_auth))))
      /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 (unwrap_Option_R from_auth) (unwrap_Option_R from_frag) in op_Option_R (Some to_frag) frame'0
        = Some'0 (Some to_auth))
      -> ([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_OptionLocalUpdate_U self from_auth from_frag in op_Option_Option_R (Some'0 to_frag) frame
      = Some'1 (Some'0 to_auth)))
      | Some'0 f -> let frame'0 = f in ([@stop_split] [@expl:unwrap_logic requires] from_auth <> None)
      /\ ([@stop_split] [@expl:unwrap_logic requires] from_frag <> None)
      /\ ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 (unwrap_Option_R from_auth) (unwrap_Option_R from_frag))
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R (Some (unwrap_Option_R from_frag)) frame'0
        = Some'0 (Some (unwrap_Option_R from_auth))))
      /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 (unwrap_Option_R from_auth) (unwrap_Option_R from_frag) in op_Option_R (Some to_frag) frame'0
        = Some'0 (Some to_auth))
      -> ([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_OptionLocalUpdate_U self from_auth from_frag in op_Option_Option_R (Some'0 to_frag) frame
      = Some'1 (Some'0 to_auth)))
      end
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__factor (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  function new (n: Real.real) : t_PositiveReal
  
  axiom new_spec: forall n: Real.real. Real.(>) n (FromInt.from_int 0) -> to_real (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  constant factor : t_PositiveReal
  
  function factor_PositiveReal (self: t_PositiveReal) (factor: t_PositiveReal) : t_Option_PositiveReal
  
  goal vc_factor_PositiveReal: ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real self) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real factor) (FromInt.from_int 0))
    -> (if Real.(>) (to_real self) (to_real factor) then
      ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real self) (FromInt.from_int 0))
      -> ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real factor) (FromInt.from_int 0))
      -> ([@stop_split] [@expl:new requires] Real.(>) (Real.(-) (to_real self) (to_real factor)) (FromInt.from_int 0))
      /\ (([@stop_split] [@expl:new ensures] to_real (new (Real.(-) (to_real self) (to_real factor)))
        = Real.(-) (to_real self) (to_real factor))
      -> ([@stop_split] [@expl:factor ensures] match Some (new (Real.(-) (to_real self) (to_real factor))) with
        | Some c -> op_PositiveReal factor c = Some self
        | None -> forall c: t_PositiveReal. op_PositiveReal factor c <> Some self
        end))
    else
      [@stop_split] [@expl:factor ensures] match None with
        | Some c -> op_PositiveReal factor c = Some self
        | None -> forall c: t_PositiveReal. op_PositiveReal factor c <> Some self
        end
    )
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__eq (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  constant other : t_PositiveReal
  
  predicate eq_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal)
  
  goal vc_eq_PositiveReal: ([@stop_split] [@expl:ext_eq ensures] ext_eq self other = (self = other))
    -> ([@stop_split] [@expl:eq ensures] ext_eq self other = (self = other))
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__commutative (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_PositiveReal
  
  constant b : t_PositiveReal
  
  function commutative_PositiveReal (a: t_PositiveReal) (b: t_PositiveReal) : ()
  
  goal vc_commutative_PositiveReal: [@stop_split] [@expl:commutative ensures] op_PositiveReal a b = op_PositiveReal b a
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__associative (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  function and_then_Option_PositiveReal (self: t_Option_PositiveReal) (f: Map.map t_PositiveReal t_Option_PositiveReal) : t_Option_PositiveReal
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_PositiveReal
  
  constant b : t_PositiveReal
  
  constant c : t_PositiveReal
  
  function associative_PositiveReal (a: t_PositiveReal) (b: t_PositiveReal) (c: t_PositiveReal) : ()
  
  goal vc_associative_PositiveReal:
    [@stop_split] [@expl:associative ensures] and_then_Option_PositiveReal (op_PositiveReal a b) (fun (ab: t_PositiveReal) -> op_PositiveReal ab c)
    = and_then_Option_PositiveReal (op_PositiveReal b c) (fun (bc: t_PositiveReal) -> op_PositiveReal a bc)
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__core_idemp (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  function core_PositiveReal [@inline:trivial] (self: t_PositiveReal) : t_Option_PositiveReal = None
  
  meta "rewrite_def" function core_PositiveReal
  
  predicate index_Mapping_PositiveReal_bool [@inline:trivial] (self: Map.map t_PositiveReal bool) (a: t_PositiveReal) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PositiveReal_bool
  
  function such_that_PositiveReal (p: Map.map t_PositiveReal bool) : t_PositiveReal
  
  axiom such_that_PositiveReal_spec:
    forall p: Map.map t_PositiveReal bool. (exists x: t_PositiveReal. index_Mapping_PositiveReal_bool p x)
      -> index_Mapping_PositiveReal_bool p (such_that_PositiveReal p)
  
  function unwrap_Option_PositiveReal (self: t_Option_PositiveReal) : t_PositiveReal = match self with
      | Some x -> x
      | None -> such_that_PositiveReal (fun (__0: t_PositiveReal) -> true)
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  function core_idemp_PositiveReal (self: t_PositiveReal) : ()
  
  goal vc_core_idemp_PositiveReal: core_PositiveReal self <> None
    -> ([@stop_split] [@expl:core_idemp_PositiveReal ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_PositiveReal (core_PositiveReal self) in op_PositiveReal c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_PositiveReal (unwrap_Option_PositiveReal (core_PositiveReal self)) self
    = Some self))
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__core_is_maximal_idemp (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  function core_PositiveReal [@inline:trivial] (self: t_PositiveReal) : t_Option_PositiveReal = None
  
  meta "rewrite_def" function core_PositiveReal
  
  function new (n: Real.real) : t_PositiveReal
  
  axiom new_spec: forall n: Real.real. Real.(>) n (FromInt.from_int 0) -> to_real (new n) = n
  
  function factor_PositiveReal [@inline:trivial] (self: t_PositiveReal) (factor: t_PositiveReal) : t_Option_PositiveReal
   = if Real.(>) (to_real self) (to_real factor) then Some (new (Real.(-) (to_real self) (to_real factor))) else None
  
  meta "rewrite_def" function factor_PositiveReal
  
  axiom factor_PositiveReal_spec:
    forall self: t_PositiveReal, factor: t_PositiveReal. match factor_PositiveReal self factor with
        | Some c -> op_PositiveReal factor c = Some self
        | None -> forall c: t_PositiveReal. op_PositiveReal factor c <> Some self
        end
  
  predicate incl_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) = factor_PositiveReal other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  constant i : t_PositiveReal
  
  function core_is_maximal_idemp_PositiveReal (self: t_PositiveReal) (i: t_PositiveReal) : ()
  
  goal vc_core_is_maximal_idemp_PositiveReal: op_PositiveReal i i = Some i
    -> op_PositiveReal i self = Some self
    -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_PositiveReal self with
      | Some c -> incl_PositiveReal i c
      | None -> false
      end)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__factor (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  constant factor : tup2_T_U
  
  function factor_tup2_T_U (self: tup2_T_U) (factor: tup2_T_U) : t_Option_tup2_T_U
  
  goal vc_factor_tup2_T_U: ([@stop_split] [@expl:factor ensures] match factor_T self.f0 factor.f0 with
        | Some'0 c -> op_T factor.f0 c = Some'0 (self.f0)
        | None'0 -> forall c: t_T. op_T factor.f0 c <> Some'0 (self.f0)
        end)
    -> ([@stop_split] [@expl:factor ensures] match factor_U self.f1 factor.f1 with
        | Some'1 c -> op_U factor.f1 c = Some'1 (self.f1)
        | None'1 -> forall c: t_U. op_U factor.f1 c <> Some'1 (self.f1)
        end)
    -> match { f0'0 = factor_T self.f0 factor.f0; f1'0 = factor_U self.f1 factor.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> [@stop_split] [@expl:factor ensures] match Some { f0 = x; f1 = y } with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
      | _ -> [@stop_split] [@expl:factor ensures] match None with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
      end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__eq (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_T = None | Some t_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate eq_T (self: t_T) (other: t_T)
  
  axiom eq_T_spec: forall self: t_T, other: t_T. eq_T self other = (self = other)
  
  type t_Option_U = None'0 | Some'0 t_U
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'0 c -> op_U factor c = Some'0 self
        | None'0 -> forall c: t_U. op_U factor c <> Some'0 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'0
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'0 ab
      -> op_U b c = Some'0 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'0
      -> op_U b c = Some'0 bc -> op_U a bc = None'0
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'0 comb -> incl_U self comb
  
  predicate eq_U (self: t_U) (other: t_U)
  
  axiom eq_U_spec: forall self: t_U, other: t_U. eq_U self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  constant other : tup2_T_U
  
  predicate eq_tup2_T_U (self: tup2_T_U) (other: tup2_T_U)
  
  goal vc_eq_tup2_T_U: ([@stop_split] [@expl:eq ensures] eq_T self.f0 other.f0 = (self.f0 = other.f0))
    -> (if eq_T self.f0 other.f0 then
      ([@stop_split] [@expl:eq ensures] eq_U self.f1 other.f1 = (self.f1 = other.f1))
      -> ([@stop_split] [@expl:eq ensures] eq_U self.f1 other.f1 = (self = other))
    else
      [@stop_split] [@expl:eq ensures] false = (self = other)
    )
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__commutative (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : tup2_T_U
  
  constant b : tup2_T_U
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : ()
  
  goal vc_commutative_tup2_T_U: [@stop_split] [@expl:commutative ensures] op_tup2_T_U a b = op_tup2_T_U b a
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__associative (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : tup2_T_U
  
  constant b : tup2_T_U
  
  constant c : tup2_T_U
  
  function associative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) (c: tup2_T_U) : ()
  
  goal vc_associative_tup2_T_U:
    [@stop_split] [@expl:associative ensures] and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
    = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core_idemp (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function core_T (self: t_T) : t_Option_T
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  predicate index_Mapping_tup2_T_U_bool [@inline:trivial] (self: Map.map tup2_T_U bool) (a: tup2_T_U) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_T_U_bool
  
  function such_that_tup2_T_U (p: Map.map tup2_T_U bool) : tup2_T_U
  
  axiom such_that_tup2_T_U_spec: forall p: Map.map tup2_T_U bool. (exists x: tup2_T_U. index_Mapping_tup2_T_U_bool p x)
      -> index_Mapping_tup2_T_U_bool p (such_that_tup2_T_U p)
  
  function unwrap_Option_tup2_T_U (self: t_Option_tup2_T_U) : tup2_T_U = match self with
      | Some x -> x
      | None -> such_that_tup2_T_U (fun (__0: tup2_T_U) -> true)
      end
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  predicate index_Mapping_T_bool [@inline:trivial] (self: Map.map t_T bool) (a: t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T_bool
  
  function such_that_T (p: Map.map t_T bool) : t_T
  
  axiom such_that_T_spec: forall p: Map.map t_T bool. (exists x: t_T. index_Mapping_T_bool p x)
      -> index_Mapping_T_bool p (such_that_T p)
  
  function unwrap_Option_T (self: t_Option_T) : t_T = match self with
      | Some'0 x -> x
      | None'0 -> such_that_T (fun (__0: t_T) -> true)
      end
  
  function core_idemp_T (self: t_T) : ()
  
  axiom core_idemp_T_spec: forall self: t_T. core_T self <> None'0
      -> (let c = unwrap_Option_T (core_T self) in op_T c c = Some'0 c)
  
  axiom core_idemp_T_spec'0: forall self: t_T. core_T self <> None'0
      -> op_T (unwrap_Option_T (core_T self)) self = Some'0 self
  
  predicate index_Mapping_U_bool [@inline:trivial] (self: Map.map t_U bool) (a: t_U) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_U_bool
  
  function such_that_U (p: Map.map t_U bool) : t_U
  
  axiom such_that_U_spec: forall p: Map.map t_U bool. (exists x: t_U. index_Mapping_U_bool p x)
      -> index_Mapping_U_bool p (such_that_U p)
  
  function unwrap_Option_U (self: t_Option_U) : t_U = match self with
      | Some'1 x -> x
      | None'1 -> such_that_U (fun (__0: t_U) -> true)
      end
  
  function core_idemp_U (self: t_U) : ()
  
  axiom core_idemp_U_spec: forall self: t_U. core_U self <> None'1
      -> (let c = unwrap_Option_U (core_U self) in op_U c c = Some'1 c)
  
  axiom core_idemp_U_spec'0: forall self: t_U. core_U self <> None'1
      -> op_U (unwrap_Option_U (core_U self)) self = Some'1 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  function core_idemp_tup2_T_U (self: tup2_T_U) : ()
  
  goal vc_core_idemp_tup2_T_U: core_tup2_T_U self <> None
    -> ([@stop_split] [@expl:core_idemp requires] core_T self.f0 <> None'0)
    /\ (([@stop_split] [@expl:core_idemp ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_T (core_T self.f0) in op_T c c
        = Some'0 c)
      /\ ([@stop_split] [@expl:core_idemp ensures #1] op_T (unwrap_Option_T (core_T self.f0)) self.f0
      = Some'0 (self.f0)))
    -> (let _ = core_idemp_T self.f0 in ([@stop_split] [@expl:core_idemp requires] core_U self.f1 <> None'1)
    /\ (([@stop_split] [@expl:core_idemp ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_U (core_U self.f1) in op_U c c
        = Some'1 c)
      /\ ([@stop_split] [@expl:core_idemp ensures #1] op_U (unwrap_Option_U (core_U self.f1)) self.f1
      = Some'1 (self.f1)))
    -> (let _ = core_idemp_U self.f1 in [@stop_split] [@expl:core_idemp_tup2_T_U ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_tup2_T_U (core_tup2_T_U self) in op_tup2_T_U c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_tup2_T_U (unwrap_Option_tup2_T_U (core_tup2_T_U self)) self
    = Some self)))))
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core_is_maximal_idemp (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function core_T (self: t_T) : t_Option_T
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  function factor_tup2_T_U (self: tup2_T_U) (factor: tup2_T_U) : t_Option_tup2_T_U =
    match { f0'0 = factor_T self.f0 factor.f0; f1'0 = factor_U self.f1 factor.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom factor_tup2_T_U_spec: forall self: tup2_T_U, factor: tup2_T_U. match factor_tup2_T_U self factor with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
  
  predicate incl_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) = factor_tup2_T_U other self <> None
  
  function core_is_maximal_idemp_T (self: t_T) (i: t_T) : ()
  
  axiom core_is_maximal_idemp_T_spec: forall self: t_T, i: t_T. op_T i i = Some'0 i
      -> op_T i self = Some'0 self
      -> match core_T self with
        | Some'0 c -> incl_T i c
        | None'0 -> false
        end
  
  function core_is_maximal_idemp_U (self: t_U) (i: t_U) : ()
  
  axiom core_is_maximal_idemp_U_spec: forall self: t_U, i: t_U. op_U i i = Some'1 i
      -> op_U i self = Some'1 self
      -> match core_U self with
        | Some'1 c -> incl_U i c
        | None'1 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  constant i : tup2_T_U
  
  function core_is_maximal_idemp_tup2_T_U (self: tup2_T_U) (i: tup2_T_U) : ()
  
  goal vc_core_is_maximal_idemp_tup2_T_U: op_tup2_T_U i i = Some i
    -> op_tup2_T_U i self = Some self
    -> ([@stop_split] [@expl:core_is_maximal_idemp requires] ([@stop_split] [@expl:core_is_maximal_idemp requires #0] op_T i.f0 i.f0
        = Some'0 (i.f0))
      /\ ([@stop_split] [@expl:core_is_maximal_idemp requires #1] op_T i.f0 self.f0 = Some'0 (self.f0)))
    /\ (([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_T self.f0 with
        | Some'0 c -> incl_T i.f0 c
        | None'0 -> false
        end)
    -> (let _ = core_is_maximal_idemp_T self.f0 i.f0 in ([@stop_split] [@expl:core_is_maximal_idemp requires] ([@stop_split] [@expl:core_is_maximal_idemp requires #0] op_U i.f1 i.f1
        = Some'1 (i.f1))
      /\ ([@stop_split] [@expl:core_is_maximal_idemp requires #1] op_U i.f1 self.f1 = Some'1 (self.f1)))
    /\ (([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_U self.f1 with
        | Some'1 c -> incl_U i.f1 c
        | None'1 -> false
        end)
    -> (let _ = core_is_maximal_idemp_U self.f1 i.f1 in [@stop_split] [@expl:core_is_maximal_idemp ensures] match core_tup2_T_U self with
      | Some c -> incl_tup2_T_U i c
      | None -> false
      end))))
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__unit (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. core_T self = Some'0 (core_total_T self)
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  constant unit_core_T : ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T : ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  function core_U (self: t_U) : t_Option_U
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. core_U self = Some'1 (core_total_U self)
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  constant unit_core_U : ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U : ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_tup2_T_U : tup2_T_U
  
  goal vc_unit_tup2_T_U: ([@stop_split] [@expl:unit ensures] forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x)
    -> ([@stop_split] [@expl:unit ensures] forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x)
    -> (let result = { f0 = unit_T;
                       f1 = unit_U } in [@stop_split] [@expl:unit ensures] forall x: tup2_T_U [op_tup2_T_U x result]. op_tup2_T_U x result
      = Some x)
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_total (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. core_T self = Some'0 (core_total_T self)
  
  constant unit_core_T : ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T : ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. core_U self = Some'1 (core_total_U self)
  
  constant unit_core_U : ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U : ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  function core_total_tup2_T_U (self: tup2_T_U) : tup2_T_U
  
  goal vc_core_total_tup2_T_U: ([@stop_split] [@expl:core_total ensures] core_T self.f0 = Some'0 (core_total_T self.f0))
    -> ([@stop_split] [@expl:core_total ensures] core_U self.f1 = Some'1 (core_total_U self.f1))
    -> ([@stop_split] [@expl:core_total ensures] core_tup2_T_U self
    = Some { f0 = core_total_T self.f0; f1 = core_total_U self.f1 })
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_total_idemp (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. core_T self = Some'0 (core_total_T self)
  
  constant unit_core_T : ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T : ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. core_U self = Some'1 (core_total_U self)
  
  constant unit_core_U : ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U : ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  function core_total_tup2_T_U (self: tup2_T_U) : tup2_T_U = { f0 = core_total_T self.f0; f1 = core_total_U self.f1 }
  
  axiom core_total_tup2_T_U_spec: forall self: tup2_T_U. core_tup2_T_U self = Some (core_total_tup2_T_U self)
  
  function core_total_idemp_T (self: t_T) : ()
  
  axiom core_total_idemp_T_spec: forall self: t_T. op_T (core_total_T self) (core_total_T self)
      = Some'0 (core_total_T self)
  
  axiom core_total_idemp_T_spec'0: forall self: t_T. op_T (core_total_T self) self = Some'0 self
  
  function core_total_idemp_U (self: t_U) : ()
  
  axiom core_total_idemp_U_spec: forall self: t_U. op_U (core_total_U self) (core_total_U self)
      = Some'1 (core_total_U self)
  
  axiom core_total_idemp_U_spec'0: forall self: t_U. op_U (core_total_U self) self = Some'1 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_T_U
  
  function core_total_idemp_tup2_T_U (self: tup2_T_U) : ()
  
  goal vc_core_total_idemp_tup2_T_U:
    ([@stop_split] [@expl:core_total_idemp ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_T (core_total_T self.f0) (core_total_T self.f0)
        = Some'0 (core_total_T self.f0))
      /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_T (core_total_T self.f0) self.f0 = Some'0 (self.f0)))
    -> (let _ = core_total_idemp_T self.f0 in ([@stop_split] [@expl:core_total_idemp ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_U (core_total_U self.f1) (core_total_U self.f1)
        = Some'1 (core_total_U self.f1))
      /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_U (core_total_U self.f1) self.f1 = Some'1 (self.f1)))
    -> (let _ = core_total_idemp_U self.f1 in [@stop_split] [@expl:core_total_idemp_tup2_T_U ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_tup2_T_U (core_total_tup2_T_U self) (core_total_tup2_T_U self)
      = Some (core_total_tup2_T_U self))
    /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_tup2_T_U (core_total_tup2_T_U self) self = Some self)))
end
module M_logic__ra__prod__impl_Update_for_tup2_U1_U2__update (* <(U1, U2) as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type tup2_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'1: t_Choice; f1'1: t_Choice'0 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0 from.f0'0 /\ premise_U2 self.f1 from.f1'0
  
  meta "rewrite_def" predicate premise_tup2_U1_U2
  
  function update_U1 (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_U2 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_U1_U2
  
  constant from : tup2_R1_R2
  
  constant ch : tup2_Choice_Choice
  
  function update_tup2_U1_U2 (self: tup2_U1_U2) (from: tup2_R1_R2) (ch: tup2_Choice_Choice) : tup2_R1_R2
  
  goal vc_update_tup2_U1_U2: premise_tup2_U1_U2 self from
    -> ([@stop_split] [@expl:update requires] premise_U1 self.f0 from.f0'0)
    /\ ([@stop_split] [@expl:update requires] premise_U2 self.f1 from.f1'0)
end
module M_logic__ra__prod__impl_Update_for_tup2_U1_U2__frame_preserving (* <(U1, U2) as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type tup2_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'1: t_Choice; f1'1: t_Choice'0 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0 from.f0'0 /\ premise_U2 self.f1 from.f1'0
  
  meta "rewrite_def" predicate premise_tup2_U1_U2
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  type tup2_Option_R1_Option_R2 = { f0'2: t_Option_R1; f1'2: t_Option_R2 }
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match { f0'2 = op_R1 self.f0'0 other.f0'0; f1'2 = op_R2 self.f1'0 other.f1'0 } with
      | {f0'2 = Some'0 r1; f1'2 = Some'1 r2} -> Some { f0'0 = r1; f1'0 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  function update_U1 (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_U2 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  function update_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from: tup2_R1_R2) (ch: tup2_Choice_Choice) : tup2_R1_R2
   = { f0'0 = update_U1 self.f0 from.f0'0 ch.f0'1; f1'0 = update_U2 self.f1 from.f1'0 ch.f1'1 }
  
  meta "rewrite_def" function update_tup2_U1_U2
  
  function frame_preserving_U1 (self: t_U1) (from: t_R1) (frame: t_R1) : t_Choice
  
  axiom frame_preserving_U1_spec: forall self: t_U1, from: t_R1, frame: t_R1. premise_U1 self from
      -> op_R1 from frame <> None'0 -> op_R1 (update_U1 self from (frame_preserving_U1 self from frame)) frame <> None'0
  
  function frame_preserving_U2 (self: t_U2) (from: t_R2) (frame: t_R2) : t_Choice'0
  
  axiom frame_preserving_U2_spec: forall self: t_U2, from: t_R2, frame: t_R2. premise_U2 self from
      -> op_R2 from frame <> None'1 -> op_R2 (update_U2 self from (frame_preserving_U2 self from frame)) frame <> None'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_U1_U2
  
  constant from : tup2_R1_R2
  
  constant frame : tup2_R1_R2
  
  function frame_preserving_tup2_U1_U2 (self: tup2_U1_U2) (from: tup2_R1_R2) (frame: tup2_R1_R2) : tup2_Choice_Choice
  
  goal vc_frame_preserving_tup2_U1_U2: premise_tup2_U1_U2 self from
    -> op_tup2_R1_R2 from frame <> None
    -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U1 self.f0 from.f0'0)
      /\ ([@stop_split] [@expl:frame_preserving requires #1] op_R1 from.f0'0 frame.f0'0 <> None'0))
    /\ (([@stop_split] [@expl:frame_preserving ensures] op_R1 (update_U1 self.f0 from.f0'0 (frame_preserving_U1 self.f0 from.f0'0 frame.f0'0)) frame.f0'0
      <> None'0)
    -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U2 self.f1 from.f1'0)
      /\ ([@stop_split] [@expl:frame_preserving requires #1] op_R2 from.f1'0 frame.f1'0 <> None'1))
    /\ (([@stop_split] [@expl:frame_preserving ensures] op_R2 (update_U2 self.f1 from.f1'0 (frame_preserving_U2 self.f1 from.f1'0 frame.f1'0)) frame.f1'0
      <> None'1)
    -> ([@stop_split] [@expl:frame_preserving ensures] op_tup2_R1_R2 (update_tup2_U1_U2 self from { f0'1 = frame_preserving_U1 self.f0 from.f0'0 frame.f0'0;
                                                                                                    f1'1 = frame_preserving_U2 self.f1 from.f1'0 frame.f1'0 }) frame
    <> None)))
end
module M_logic__ra__prod__impl_LocalUpdate_for_tup2_U1_U2__frame_preserving (* <(U1, U2) as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type tup2_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  predicate premise_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) =
    premise_U1 self.f0 from_auth.f0'0 from_frag.f0'0 /\ premise_U2 self.f1 from_auth.f1'0 from_frag.f1'0
  
  meta "rewrite_def" predicate premise_tup2_U1_U2
  
  type t_Option_Option_tup2_R1_R2 = None'0 | Some'0 t_Option_tup2_R1_R2
  
  type tup2_Option_tup2_R1_R2_Option_tup2_R1_R2 = { f0'1: t_Option_tup2_R1_R2; f1'1: t_Option_tup2_R1_R2 }
  
  function map_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  type tup2_Option_R1_Option_R2 = { f0'2: t_Option_R1; f1'2: t_Option_R2 }
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'1 ab
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'1
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = None'1
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'2 ab
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'2
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = None'2
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match { f0'2 = op_R1 self.f0'0 other.f0'0; f1'2 = op_R2 self.f1'0 other.f1'0 } with
      | {f0'2 = Some'1 r1; f1'2 = Some'2 r2} -> Some { f0'0 = r1; f1'0 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  function op_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (other: t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_tup2_R1_R2 (op_tup2_R1_R2 x y) (fun (z: tup2_R1_R2) -> Some z)
      end
  
  function commutative_Option_tup2_R1_R2 (a: t_Option_tup2_R1_R2) (b: t_Option_tup2_R1_R2) : ()
  
  axiom commutative_Option_tup2_R1_R2_spec:
    forall a: t_Option_tup2_R1_R2, b: t_Option_tup2_R1_R2. op_Option_tup2_R1_R2 a b = op_Option_tup2_R1_R2 b a
  
  type tup2_tup2_R1_R2_tup2_R1_R2 = { f0'3: tup2_R1_R2; f1'3: tup2_R1_R2 }
  
  type tup2_R1_R1 = { f0'4: t_R1; f1'4: t_R1 }
  
  function update_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  type tup2_R2_R2 = { f0'5: t_R2; f1'5: t_R2 }
  
  function update_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  function update_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) : tup2_tup2_R1_R2_tup2_R1_R2
   =
    let {f0'4 = to_auth0; f1'4 = to_frag0} = update_U1 self.f0 from_auth.f0'0 from_frag.f0'0 in let {f0'5 = to_auth1; f1'5 = to_frag1} = update_U2 self.f1 from_auth.f1'0 from_frag.f1'0 in { f0'3 = { f0'0 = to_auth0;
                                                                                                                                                                                                       f1'0 = to_auth1 };
                                                                                                                                                                                              f1'3 = { f0'0 = to_frag0;
                                                                                                                                                                                                       f1'0 = to_frag1 } }
  
  meta "rewrite_def" function update_tup2_U1_U2
  
  function map_Option_tup2_R1_R2'0 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_R1) : t_Option_R1 =
    match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  type t_Option_Option_R1 = None'3 | Some'3 t_Option_R1
  
  type tup2_Option_R1_Option_R1 = { f0'6: t_Option_R1; f1'6: t_Option_R1 }
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_Option_R1 = match self with
      | None'1 -> None'3
      | Some'1 x -> Some'3 (Map.get f x)
      end
  
  function op_Option_R1 (self: t_Option_R1) (other: t_Option_R1) : t_Option_Option_R1 = match { f0'6 = self;
                                                                                                f1'6 = other } with
      | {f0'6 = None'1} -> Some'3 other
      | {f1'6 = None'1} -> Some'3 self
      | {f0'6 = Some'1 x; f1'6 = Some'1 y} -> map_Option_R1 (op_R1 x y) (fun (z: t_R1) -> Some'1 z)
      end
  
  function commutative_Option_R1 (a: t_Option_R1) (b: t_Option_R1) : ()
  
  axiom commutative_Option_R1_spec: forall a: t_Option_R1, b: t_Option_R1. op_Option_R1 a b = op_Option_R1 b a
  
  function frame_preserving_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option_R1) : ()
  
  axiom frame_preserving_U1_spec:
    forall self: t_U1, from_auth: t_R1, from_frag: t_R1, frame: t_Option_R1. premise_U1 self from_auth from_frag
      -> op_Option_R1 (Some'1 from_frag) frame = Some'3 (Some'1 from_auth)
      -> (let {f0'4 = to_auth; f1'4 = to_frag} = update_U1 self from_auth from_frag in op_Option_R1 (Some'1 to_frag) frame
      = Some'3 (Some'1 to_auth))
  
  function map_Option_tup2_R1_R2'1 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_R2) : t_Option_R2 =
    match self with
      | None -> None'2
      | Some x -> Some'2 (Map.get f x)
      end
  
  type t_Option_Option_R2 = None'4 | Some'4 t_Option_R2
  
  type tup2_Option_R2_Option_R2 = { f0'7: t_Option_R2; f1'7: t_Option_R2 }
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_Option_R2 = match self with
      | None'2 -> None'4
      | Some'2 x -> Some'4 (Map.get f x)
      end
  
  function op_Option_R2 (self: t_Option_R2) (other: t_Option_R2) : t_Option_Option_R2 = match { f0'7 = self;
                                                                                                f1'7 = other } with
      | {f0'7 = None'2} -> Some'4 other
      | {f1'7 = None'2} -> Some'4 self
      | {f0'7 = Some'2 x; f1'7 = Some'2 y} -> map_Option_R2 (op_R2 x y) (fun (z: t_R2) -> Some'2 z)
      end
  
  function commutative_Option_R2 (a: t_Option_R2) (b: t_Option_R2) : ()
  
  axiom commutative_Option_R2_spec: forall a: t_Option_R2, b: t_Option_R2. op_Option_R2 a b = op_Option_R2 b a
  
  function frame_preserving_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option_R2) : ()
  
  axiom frame_preserving_U2_spec:
    forall self: t_U2, from_auth: t_R2, from_frag: t_R2, frame: t_Option_R2. premise_U2 self from_auth from_frag
      -> op_Option_R2 (Some'2 from_frag) frame = Some'4 (Some'2 from_auth)
      -> (let {f0'5 = to_auth; f1'5 = to_frag} = update_U2 self from_auth from_frag in op_Option_R2 (Some'2 to_frag) frame
      = Some'4 (Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_U1_U2
  
  constant from_auth : tup2_R1_R2
  
  constant from_frag : tup2_R1_R2
  
  constant frame : t_Option_tup2_R1_R2
  
  function frame_preserving_tup2_U1_U2 (self: tup2_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) (frame: t_Option_tup2_R1_R2) : ()
  
  goal vc_frame_preserving_tup2_U1_U2: premise_tup2_U1_U2 self from_auth from_frag
    -> op_Option_tup2_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
    -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U1 self.f0 from_auth.f0'0 from_frag.f0'0)
      /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R1 (Some'1 (from_frag.f0'0)) (map_Option_tup2_R1_R2'0 frame (fun (f: tup2_R1_R2) -> f.f0'0))
      = Some'3 (Some'1 (from_auth.f0'0))))
    /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'4 = to_auth; f1'4 = to_frag} = update_U1 self.f0 from_auth.f0'0 from_frag.f0'0 in op_Option_R1 (Some'1 to_frag) (map_Option_tup2_R1_R2'0 frame (fun (f: tup2_R1_R2) -> f.f0'0))
      = Some'3 (Some'1 to_auth))
    -> (let _ = frame_preserving_U1 self.f0 from_auth.f0'0 from_frag.f0'0 (map_Option_tup2_R1_R2'0 frame (fun (f: tup2_R1_R2) -> f.f0'0)) in ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U2 self.f1 from_auth.f1'0 from_frag.f1'0)
      /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R2 (Some'2 (from_frag.f1'0)) (map_Option_tup2_R1_R2'1 frame (fun (f: tup2_R1_R2) -> f.f1'0))
      = Some'4 (Some'2 (from_auth.f1'0))))
    /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'5 = to_auth; f1'5 = to_frag} = update_U2 self.f1 from_auth.f1'0 from_frag.f1'0 in op_Option_R2 (Some'2 to_frag) (map_Option_tup2_R1_R2'1 frame (fun (f: tup2_R1_R2) -> f.f1'0))
      = Some'4 (Some'2 to_auth))
    -> (let _ = frame_preserving_U2 self.f1 from_auth.f1'0 from_frag.f1'0 (map_Option_tup2_R1_R2'1 frame (fun (f: tup2_R1_R2) -> f.f1'0)) in [@stop_split] [@expl:frame_preserving ensures] let {f0'3 = to_auth; f1'3 = to_frag} = update_tup2_U1_U2 self from_auth from_frag in op_Option_tup2_R1_R2 (Some to_frag) frame
    = Some'0 (Some to_auth)))))
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__factor (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum_R1_R2
  
  constant factor : t_Sum_R1_R2
  
  function factor_Sum_R1_R2 (self: t_Sum_R1_R2) (factor: t_Sum_R1_R2) : t_Option_Sum_R1_R2
  
  goal vc_factor_Sum_R1_R2: match { f0 = self; f1 = factor } with
      | {f0 = Left x; f1 = Left y} -> ([@stop_split] [@expl:factor ensures] match factor_R1 x y with
          | Some'0 c -> op_R1 y c = Some'0 x
          | None'0 -> forall c: t_R1. op_R1 y c <> Some'0 x
          end)
      -> ([@stop_split] [@expl:factor ensures] match map_Option_R1 (factor_R1 x y) (fun (l: t_R1) -> Left l) with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end)
      | {f0 = Right x; f1 = Right y} -> ([@stop_split] [@expl:factor ensures] match factor_R2 x y with
          | Some'1 c -> op_R2 y c = Some'1 x
          | None'1 -> forall c: t_R2. op_R2 y c <> Some'1 x
          end)
      -> ([@stop_split] [@expl:factor ensures] match map_Option_R2 (factor_R2 x y) (fun (r: t_R2) -> Right r) with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end)
      | _ -> [@stop_split] [@expl:factor ensures] match None with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end
      end
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__eq (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None | Some t_R1
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some c -> op_R1 factor c = Some self
        | None -> forall c: t_R1. op_R1 factor c <> Some self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some ab
      -> op_R1 b c = Some bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None
      -> op_R1 b c = Some bc -> op_R1 a bc = None
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some comb -> incl_R1 self comb
  
  predicate eq_R1 (self: t_R1) (other: t_R1)
  
  axiom eq_R1_spec: forall self: t_R1, other: t_R1. eq_R1 self other = (self = other)
  
  type t_Option_R2 = None'0 | Some'0 t_R2
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'0 c -> op_R2 factor c = Some'0 self
        | None'0 -> forall c: t_R2. op_R2 factor c <> Some'0 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'0
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'0 ab
      -> op_R2 b c = Some'0 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'0
      -> op_R2 b c = Some'0 bc -> op_R2 a bc = None'0
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'0 comb -> incl_R2 self comb
  
  predicate eq_R2 (self: t_R2) (other: t_R2)
  
  axiom eq_R2_spec: forall self: t_R2, other: t_R2. eq_R2 self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum_R1_R2
  
  constant other : t_Sum_R1_R2
  
  predicate eq_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2)
  
  goal vc_eq_Sum_R1_R2: match { f0 = self; f1 = other } with
      | {f0 = Left s; f1 = Left o} -> ([@stop_split] [@expl:eq ensures] eq_R1 s o = (s = o))
      -> ([@stop_split] [@expl:eq ensures] eq_R1 s o = (self = other))
      | {f0 = Right s; f1 = Right o} -> ([@stop_split] [@expl:eq ensures] eq_R2 s o = (s = o))
      -> ([@stop_split] [@expl:eq ensures] eq_R2 s o = (self = other))
      | _ -> [@stop_split] [@expl:eq ensures] false = (self = other)
      end
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__commutative (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Sum_R1_R2
  
  constant b : t_Sum_R1_R2
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : ()
  
  goal vc_commutative_Sum_R1_R2: [@stop_split] [@expl:commutative ensures] op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__associative (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Sum_R1_R2
  
  constant b : t_Sum_R1_R2
  
  constant c : t_Sum_R1_R2
  
  function associative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) (c: t_Sum_R1_R2) : ()
  
  goal vc_associative_Sum_R1_R2:
    [@stop_split] [@expl:associative ensures] and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
    = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core_idemp (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  function core_R1 (self: t_R1) : t_Option_R1
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function core_R2 (self: t_R2) : t_Option_R2
  
  function core_Sum_R1_R2 (self: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | Left x -> map_Option_R1 (core_R1 x) (fun (l: t_R1) -> Left l)
      | Right x -> map_Option_R2 (core_R2 x) (fun (r: t_R2) -> Right r)
      end
  
  predicate index_Mapping_Sum_R1_R2_bool [@inline:trivial] (self: Map.map t_Sum_R1_R2 bool) (a: t_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Sum_R1_R2_bool
  
  function such_that_Sum_R1_R2 (p: Map.map t_Sum_R1_R2 bool) : t_Sum_R1_R2
  
  axiom such_that_Sum_R1_R2_spec:
    forall p: Map.map t_Sum_R1_R2 bool. (exists x: t_Sum_R1_R2. index_Mapping_Sum_R1_R2_bool p x)
      -> index_Mapping_Sum_R1_R2_bool p (such_that_Sum_R1_R2 p)
  
  function unwrap_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) : t_Sum_R1_R2 = match self with
      | Some x -> x
      | None -> such_that_Sum_R1_R2 (fun (__0: t_Sum_R1_R2) -> true)
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  predicate index_Mapping_R1_bool [@inline:trivial] (self: Map.map t_R1 bool) (a: t_R1) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R1_bool
  
  function such_that_R1 (p: Map.map t_R1 bool) : t_R1
  
  axiom such_that_R1_spec: forall p: Map.map t_R1 bool. (exists x: t_R1. index_Mapping_R1_bool p x)
      -> index_Mapping_R1_bool p (such_that_R1 p)
  
  function unwrap_Option_R1 (self: t_Option_R1) : t_R1 = match self with
      | Some'0 x -> x
      | None'0 -> such_that_R1 (fun (__0: t_R1) -> true)
      end
  
  function core_idemp_R1 (self: t_R1) : ()
  
  axiom core_idemp_R1_spec: forall self: t_R1. core_R1 self <> None'0
      -> (let c = unwrap_Option_R1 (core_R1 self) in op_R1 c c = Some'0 c)
  
  axiom core_idemp_R1_spec'0: forall self: t_R1. core_R1 self <> None'0
      -> op_R1 (unwrap_Option_R1 (core_R1 self)) self = Some'0 self
  
  predicate index_Mapping_R2_bool [@inline:trivial] (self: Map.map t_R2 bool) (a: t_R2) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R2_bool
  
  function such_that_R2 (p: Map.map t_R2 bool) : t_R2
  
  axiom such_that_R2_spec: forall p: Map.map t_R2 bool. (exists x: t_R2. index_Mapping_R2_bool p x)
      -> index_Mapping_R2_bool p (such_that_R2 p)
  
  function unwrap_Option_R2 (self: t_Option_R2) : t_R2 = match self with
      | Some'1 x -> x
      | None'1 -> such_that_R2 (fun (__0: t_R2) -> true)
      end
  
  function core_idemp_R2 (self: t_R2) : ()
  
  axiom core_idemp_R2_spec: forall self: t_R2. core_R2 self <> None'1
      -> (let c = unwrap_Option_R2 (core_R2 self) in op_R2 c c = Some'1 c)
  
  axiom core_idemp_R2_spec'0: forall self: t_R2. core_R2 self <> None'1
      -> op_R2 (unwrap_Option_R2 (core_R2 self)) self = Some'1 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum_R1_R2
  
  function core_idemp_Sum_R1_R2 (self: t_Sum_R1_R2) : ()
  
  goal vc_core_idemp_Sum_R1_R2: core_Sum_R1_R2 self <> None
    -> ([@stop_split] [@expl:core_idemp_Sum_R1_R2 ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_Sum_R1_R2 (core_Sum_R1_R2 self) in op_Sum_R1_R2 c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_Sum_R1_R2 (unwrap_Option_Sum_R1_R2 (core_Sum_R1_R2 self)) self
    = Some self))
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core_is_maximal_idemp (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function core_R1 (self: t_R1) : t_Option_R1
  
  function core_R2 (self: t_R2) : t_Option_R2
  
  function core_Sum_R1_R2 (self: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | Left x -> map_Option_R1 (core_R1 x) (fun (l: t_R1) -> Left l)
      | Right x -> map_Option_R2 (core_R2 x) (fun (r: t_R2) -> Right r)
      end
  
  function factor_Sum_R1_R2 (self: t_Sum_R1_R2) (factor: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                     f1 = factor } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (factor_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (factor_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  axiom factor_Sum_R1_R2_spec: forall self: t_Sum_R1_R2, factor: t_Sum_R1_R2. match factor_Sum_R1_R2 self factor with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end
  
  predicate incl_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) = factor_Sum_R1_R2 other self <> None
  
  function core_is_maximal_idemp_R1 (self: t_R1) (i: t_R1) : ()
  
  axiom core_is_maximal_idemp_R1_spec: forall self: t_R1, i: t_R1. op_R1 i i = Some'0 i
      -> op_R1 i self = Some'0 self
      -> match core_R1 self with
        | Some'0 c -> incl_R1 i c
        | None'0 -> false
        end
  
  function core_is_maximal_idemp_R2 (self: t_R2) (i: t_R2) : ()
  
  axiom core_is_maximal_idemp_R2_spec: forall self: t_R2, i: t_R2. op_R2 i i = Some'1 i
      -> op_R2 i self = Some'1 self
      -> match core_R2 self with
        | Some'1 c -> incl_R2 i c
        | None'1 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Sum_R1_R2
  
  constant i : t_Sum_R1_R2
  
  function core_is_maximal_idemp_Sum_R1_R2 (self: t_Sum_R1_R2) (i: t_Sum_R1_R2) : ()
  
  goal vc_core_is_maximal_idemp_Sum_R1_R2: op_Sum_R1_R2 i i = Some i
    -> op_Sum_R1_R2 i self = Some self
    -> match { f0 = self; f1 = i } with
      | {f0 = Left s; f1 = Left i'0} -> ([@stop_split] [@expl:core_is_maximal_idemp requires] ([@stop_split] [@expl:core_is_maximal_idemp requires #0] op_R1 i'0 i'0
          = Some'0 i'0)
        /\ ([@stop_split] [@expl:core_is_maximal_idemp requires #1] op_R1 i'0 s = Some'0 s))
      /\ (([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_R1 s with
          | Some'0 c -> incl_R1 i'0 c
          | None'0 -> false
          end)
      -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Sum_R1_R2 self with
        | Some c -> incl_Sum_R1_R2 i c
        | None -> false
        end))
      | {f0 = Right s; f1 = Right i'0} -> ([@stop_split] [@expl:core_is_maximal_idemp requires] ([@stop_split] [@expl:core_is_maximal_idemp requires #0] op_R2 i'0 i'0
          = Some'1 i'0)
        /\ ([@stop_split] [@expl:core_is_maximal_idemp requires #1] op_R2 i'0 s = Some'1 s))
      /\ (([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_R2 s with
          | Some'1 c -> incl_R2 i'0 c
          | None'1 -> false
          end)
      -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Sum_R1_R2 self with
        | Some c -> incl_Sum_R1_R2 i c
        | None -> false
        end))
      | _ -> [@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Sum_R1_R2 self with
        | Some c -> incl_Sum_R1_R2 i c
        | None -> false
        end
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__update (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U [@inline:trivial] (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0 from'0
      | Right _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateL_U
  
  function update_U (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateL_U
  
  constant from : t_Sum_R1_R2
  
  constant ch : t_Choice
  
  function update_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (ch: t_Choice) : t_Sum_R1_R2
  
  goal vc_update_SumUpdateL_U: premise_SumUpdateL_U self from
    -> match from with
      | Left from'0 -> [@stop_split] [@expl:update requires] premise_U self.f0 from'0
      | x -> true
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__frame_preserving (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U [@inline:trivial] (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0 from'0
      | Right _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateL_U
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function update_U (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_SumUpdateL_U [@inline:trivial] (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (ch: t_Choice) : t_Sum_R1_R2
   = match from with
      | Left from'0 -> Left (update_U self.f0 from'0 ch)
      | x -> x
      end
  
  meta "rewrite_def" function update_SumUpdateL_U
  
  function frame_preserving_U (self: t_U) (from: t_R1) (frame: t_R1) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R1, frame: t_R1. premise_U self from
      -> op_R1 from frame <> None'0 -> op_R1 (update_U self from (frame_preserving_U self from frame)) frame <> None'0
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateL_U
  
  constant from : t_Sum_R1_R2
  
  constant frame : t_Sum_R1_R2
  
  function frame_preserving_SumUpdateL_U (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (frame: t_Sum_R1_R2) : t_Choice
  
  goal vc_frame_preserving_SumUpdateL_U: premise_SumUpdateL_U self from
    -> op_Sum_R1_R2 from frame <> None
    -> match { f0'0 = from; f1'0 = frame } with
      | {f0'0 = Left from'0; f1'0 = Left frame'0} -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 from'0)
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_R1 from'0 frame'0 <> None'0))
      /\ (([@stop_split] [@expl:frame_preserving ensures] op_R1 (update_U self.f0 from'0 (frame_preserving_U self.f0 from'0 frame'0)) frame'0
        <> None'0)
      -> ([@stop_split] [@expl:frame_preserving ensures] op_Sum_R1_R2 (update_SumUpdateL_U self from (frame_preserving_U self.f0 from'0 frame'0)) frame
      <> None))
      | _ -> ([@stop_split] [@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) (such_that_Choice (fun (__0: t_Choice) -> true)))
      -> ([@stop_split] [@expl:frame_preserving ensures] op_Sum_R1_R2 (update_SumUpdateL_U self from (such_that_Choice (fun (__0: t_Choice) -> true))) frame
      <> None))
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__update (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateR_U = { f0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U [@inline:trivial] (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0 from'0
      | Left _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateR_U
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateR_U
  
  constant from : t_Sum_V_R
  
  constant ch : t_Choice
  
  function update_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) (ch: t_Choice) : t_Sum_V_R
  
  goal vc_update_SumUpdateR_U: premise_SumUpdateR_U self from
    -> match from with
      | Right from'0 -> [@stop_split] [@expl:update requires] premise_U self.f0 from'0
      | x -> true
      end
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__frame_preserving (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateR_U = { f0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  type t_Choice
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U [@inline:trivial] (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0 from'0
      | Left _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateR_U
  
  type t_Option_Sum_V_R = None | Some t_Sum_V_R
  
  type tup2_Sum_V_R_Sum_V_R = { f0'0: t_Sum_V_R; f1'0: t_Sum_V_R }
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  type t_Option_R = None'1 | Some'1 t_R
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'1 c -> op_R factor c = Some'1 self
        | None'1 -> forall c: t_R. op_R factor c <> Some'1 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'1
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'1 ab
      -> op_R b c = Some'1 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'1
      -> op_R b c = Some'1 bc -> op_R a bc = None'1
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'1 comb -> incl_R self comb
  
  function op_Sum_V_R (self: t_Sum_V_R) (other: t_Sum_V_R) : t_Option_Sum_V_R = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_V (op_V x y) (fun (l: t_V) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R (op_R x y) (fun (r: t_R) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_V_R (a: t_Sum_V_R) (b: t_Sum_V_R) : () = ()
  
  axiom commutative_Sum_V_R_spec: forall a: t_Sum_V_R, b: t_Sum_V_R. op_Sum_V_R a b = op_Sum_V_R b a
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_SumUpdateR_U [@inline:trivial] (self: t_SumUpdateR_U) (from: t_Sum_V_R) (ch: t_Choice) : t_Sum_V_R =
    match from with
      | Right from'0 -> Right (update_U self.f0 from'0 ch)
      | x -> x
      end
  
  meta "rewrite_def" function update_SumUpdateR_U
  
  function frame_preserving_U (self: t_U) (from: t_R) (frame: t_R) : t_Choice
  
  axiom frame_preserving_U_spec: forall self: t_U, from: t_R, frame: t_R. premise_U self from
      -> op_R from frame <> None'1 -> op_R (update_U self from (frame_preserving_U self from frame)) frame <> None'1
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumUpdateR_U
  
  constant from : t_Sum_V_R
  
  constant frame : t_Sum_V_R
  
  function frame_preserving_SumUpdateR_U (self: t_SumUpdateR_U) (from: t_Sum_V_R) (frame: t_Sum_V_R) : t_Choice
  
  goal vc_frame_preserving_SumUpdateR_U: premise_SumUpdateR_U self from
    -> op_Sum_V_R from frame <> None
    -> match { f0'0 = from; f1'0 = frame } with
      | {f0'0 = Right from'0; f1'0 = Right frame'0} -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 from'0)
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_R from'0 frame'0 <> None'1))
      /\ (([@stop_split] [@expl:frame_preserving ensures] op_R (update_U self.f0 from'0 (frame_preserving_U self.f0 from'0 frame'0)) frame'0
        <> None'1)
      -> ([@stop_split] [@expl:frame_preserving ensures] op_Sum_V_R (update_SumUpdateR_U self from (frame_preserving_U self.f0 from'0 frame'0)) frame
      <> None))
      | _ -> ([@stop_split] [@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Choice_bool (fun (__0: t_Choice) -> true) (such_that_Choice (fun (__0: t_Choice) -> true)))
      -> ([@stop_split] [@expl:frame_preserving ensures] op_Sum_V_R (update_SumUpdateR_U self from (such_that_Choice (fun (__0: t_Choice) -> true))) frame
      <> None))
      end
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateL_U__frame_preserving (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  predicate premise_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_SumLocalUpdateL_U [@inline:trivial] (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | {f0'0 = Right _; f1'0 = Right _} -> false
      | _ -> true
      end
  
  meta "rewrite_def" predicate premise_SumLocalUpdateL_U
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0'1: t_Option_Sum_R1_R2; f1'1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'1 ab
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'1
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = None'1
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'2 ab
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'2
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = None'2
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type tup2_R1_R1 = { f0'2: t_R1; f1'2: t_R1 }
  
  function update_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateL_U [@inline:trivial] (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Left to_auth;
                                                                                                                                                   f1'0 = Left to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  meta "rewrite_def" function update_SumLocalUpdateL_U
  
  type tup3_Sum_R1_R2_Sum_R1_R2_Option_Sum_R1_R2 = { f0'3: t_Sum_R1_R2; f1'3: t_Sum_R1_R2; f2'3: t_Option_Sum_R1_R2 }
  
  type t_Option_Option_R1 = None'3 | Some'3 t_Option_R1
  
  type tup2_Option_R1_Option_R1 = { f0'4: t_Option_R1; f1'4: t_Option_R1 }
  
  function map_Option_R1'0 (self: t_Option_R1) (f: Map.map t_R1 t_Option_R1) : t_Option_Option_R1 = match self with
      | None'1 -> None'3
      | Some'1 x -> Some'3 (Map.get f x)
      end
  
  function op_Option_R1 (self: t_Option_R1) (other: t_Option_R1) : t_Option_Option_R1 = match { f0'4 = self;
                                                                                                f1'4 = other } with
      | {f0'4 = None'1} -> Some'3 other
      | {f1'4 = None'1} -> Some'3 self
      | {f0'4 = Some'1 x; f1'4 = Some'1 y} -> map_Option_R1'0 (op_R1 x y) (fun (z: t_R1) -> Some'1 z)
      end
  
  function commutative_Option_R1 (a: t_Option_R1) (b: t_Option_R1) : ()
  
  axiom commutative_Option_R1_spec: forall a: t_Option_R1, b: t_Option_R1. op_Option_R1 a b = op_Option_R1 b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1) (frame: t_Option_R1) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R1, from_frag: t_R1, frame: t_Option_R1. premise_U self from_auth from_frag
      -> op_Option_R1 (Some'1 from_frag) frame = Some'3 (Some'1 from_auth)
      -> (let {f0'2 = to_auth; f1'2 = to_frag} = update_U self from_auth from_frag in op_Option_R1 (Some'1 to_frag) frame
      = Some'3 (Some'1 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumLocalUpdateL_U
  
  constant from_auth : t_Sum_R1_R2
  
  constant from_frag : t_Sum_R1_R2
  
  constant frame : t_Option_Sum_R1_R2
  
  function frame_preserving_SumLocalUpdateL_U (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) (frame: t_Option_Sum_R1_R2) : ()
  
  goal vc_frame_preserving_SumLocalUpdateL_U: premise_SumLocalUpdateL_U self from_auth from_frag
    -> op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
    -> match { f0'3 = from_auth; f1'3 = from_frag; f2'3 = frame } with
      | {f0'3 = Left from_auth'0; f1'3 = Left from_frag'0; f2'3 = Some (Left frame'0)} -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R1 (Some'1 from_frag'0) (Some'1 frame'0)
        = Some'3 (Some'1 from_auth'0)))
      /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R1 (Some'1 to_frag) (Some'1 frame'0)
        = Some'3 (Some'1 to_auth))
      -> ([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | {f0'3 = Left from_auth'0; f1'3 = Left from_frag'0; f2'3 = None} -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R1 (Some'1 from_frag'0) (None'1)
        = Some'3 (Some'1 from_auth'0)))
      /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R1 (Some'1 to_frag) (None'1)
        = Some'3 (Some'1 to_auth))
      -> ([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | _ -> [@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)
      end
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateR_U__frame_preserving (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateR_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  predicate premise_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_SumLocalUpdateR_U [@inline:trivial] (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | {f0'0 = Left _; f1'0 = Left _} -> false
      | _ -> true
      end
  
  meta "rewrite_def" predicate premise_SumLocalUpdateR_U
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0'1: t_Option_Sum_R1_R2; f1'1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'1 ab
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'1
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = None'1
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'2 ab
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'2
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = None'2
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type tup2_R2_R2 = { f0'2: t_R2; f1'2: t_R2 }
  
  function update_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateR_U [@inline:trivial] (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Right to_auth;
                                                                                                                                                     f1'0 = Right to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  meta "rewrite_def" function update_SumLocalUpdateR_U
  
  type tup3_Sum_R1_R2_Sum_R1_R2_Option_Sum_R1_R2 = { f0'3: t_Sum_R1_R2; f1'3: t_Sum_R1_R2; f2'3: t_Option_Sum_R1_R2 }
  
  type t_Option_Option_R2 = None'3 | Some'3 t_Option_R2
  
  type tup2_Option_R2_Option_R2 = { f0'4: t_Option_R2; f1'4: t_Option_R2 }
  
  function map_Option_R2'0 (self: t_Option_R2) (f: Map.map t_R2 t_Option_R2) : t_Option_Option_R2 = match self with
      | None'2 -> None'3
      | Some'2 x -> Some'3 (Map.get f x)
      end
  
  function op_Option_R2 (self: t_Option_R2) (other: t_Option_R2) : t_Option_Option_R2 = match { f0'4 = self;
                                                                                                f1'4 = other } with
      | {f0'4 = None'2} -> Some'3 other
      | {f1'4 = None'2} -> Some'3 self
      | {f0'4 = Some'2 x; f1'4 = Some'2 y} -> map_Option_R2'0 (op_R2 x y) (fun (z: t_R2) -> Some'2 z)
      end
  
  function commutative_Option_R2 (a: t_Option_R2) (b: t_Option_R2) : ()
  
  axiom commutative_Option_R2_spec: forall a: t_Option_R2, b: t_Option_R2. op_Option_R2 a b = op_Option_R2 b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2) (frame: t_Option_R2) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R2, from_frag: t_R2, frame: t_Option_R2. premise_U self from_auth from_frag
      -> op_Option_R2 (Some'2 from_frag) frame = Some'3 (Some'2 from_auth)
      -> (let {f0'2 = to_auth; f1'2 = to_frag} = update_U self from_auth from_frag in op_Option_R2 (Some'2 to_frag) frame
      = Some'3 (Some'2 to_auth))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SumLocalUpdateR_U
  
  constant from_auth : t_Sum_R1_R2
  
  constant from_frag : t_Sum_R1_R2
  
  constant frame : t_Option_Sum_R1_R2
  
  function frame_preserving_SumLocalUpdateR_U (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) (frame: t_Option_Sum_R1_R2) : ()
  
  goal vc_frame_preserving_SumLocalUpdateR_U: premise_SumLocalUpdateR_U self from_auth from_frag
    -> op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
    -> match { f0'3 = from_auth; f1'3 = from_frag; f2'3 = frame } with
      | {f0'3 = Right from_auth'0; f1'3 = Right from_frag'0; f2'3 = Some (Right frame'0)} -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R2 (Some'2 from_frag'0) (Some'2 frame'0)
        = Some'3 (Some'2 from_auth'0)))
      /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R2 (Some'2 to_frag) (Some'2 frame'0)
        = Some'3 (Some'2 to_auth))
      -> ([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | {f0'3 = Right from_auth'0; f1'3 = Right from_frag'0; f2'3 = None} -> ([@stop_split] [@expl:frame_preserving requires] ([@stop_split] [@expl:frame_preserving requires #0] premise_U self.f0 from_auth'0 from_frag'0)
        /\ ([@stop_split] [@expl:frame_preserving requires #1] op_Option_R2 (Some'2 from_frag'0) (None'2)
        = Some'3 (Some'2 from_auth'0)))
      /\ (([@stop_split] [@expl:frame_preserving ensures] let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in op_Option_R2 (Some'2 to_frag) (None'2)
        = Some'3 (Some'2 to_auth))
      -> ([@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)))
      | _ -> [@stop_split] [@expl:frame_preserving ensures] let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
      = Some'0 (Some to_auth)
      end
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__update (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R [@inline:trivial] (self: t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  meta "rewrite_def" predicate premise_Snapshot_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_R
  
  constant from : t_R
  
  constant _3 : ()
  
  function update_Snapshot_R (self: t_R) (from: t_R) (_3: ()) : t_R
  
  goal vc_update_Snapshot_R: true
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__frame_preserving (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R [@inline:trivial] (self: t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  meta "rewrite_def" predicate premise_Snapshot_R
  
  function update_Snapshot_R [@inline:trivial] (self: t_R) (from: t_R) (_3: ()) : t_R = self
  
  meta "rewrite_def" function update_Snapshot_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_R
  
  constant from : t_R
  
  constant frame : t_R
  
  function frame_preserving_Snapshot_R (self: t_R) (from: t_R) (frame: t_R) : ()
  
  goal vc_frame_preserving_Snapshot_R: premise_Snapshot_R self from
    -> op_R from frame <> None
    -> ([@stop_split] [@expl:frame_preserving ensures] op_R (update_Snapshot_R self from ()) frame <> None)
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__update (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  meta "rewrite_def" predicate premise_Snapshot_Mapping_Choice_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Map.map t_Choice t_R
  
  constant from : t_R
  
  constant ch : t_Choice
  
  function update_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R
  
  goal vc_update_Snapshot_Mapping_Choice_R: true
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__frame_preserving (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  meta "rewrite_def" predicate premise_Snapshot_Mapping_Choice_R
  
  function update_Snapshot_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R
   = index_Mapping_Choice_R self ch
  
  meta "rewrite_def" function update_Snapshot_Mapping_Choice_R
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Map.map t_Choice t_R
  
  constant from : t_R
  
  constant frame : t_R
  
  function frame_preserving_Snapshot_Mapping_Choice_R (self: Map.map t_Choice t_R) (from: t_R) (frame: t_R) : t_Choice
  
  goal vc_frame_preserving_Snapshot_Mapping_Choice_R: premise_Snapshot_Mapping_Choice_R self from
    -> op_R from frame <> None
    -> (forall ch: t_Choice. [@stop_split] [@expl:update requires] premise_Snapshot_Mapping_Choice_R self from)
    /\ ([@stop_split] [@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
        <> None) x)
    /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
      <> None) (such_that_Choice (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
      <> None)))
    -> ([@stop_split] [@expl:frame_preserving ensures] op_R (update_Snapshot_Mapping_Choice_R self from (such_that_Choice (fun (ch: t_Choice) -> op_R (update_Snapshot_Mapping_Choice_R self from ch) frame
      <> None))) frame
    <> None))
end
module M_logic__ra__update__impl_Update_for_unit__frame_preserving (* <() as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : ()
  
  constant from : t_R
  
  constant frame : t_R
  
  function frame_preserving_unit (self: ()) (from: t_R) (frame: t_R) : ()
  
  goal vc_frame_preserving_unit: op_R from frame <> None
    -> ([@stop_split] [@expl:frame_preserving ensures] op_R from frame <> None)
end
module M_logic__ra__update__impl_LocalUpdate_for_Snapshot_tup2_R_R__frame_preserving (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type tup2_R_R = { f0: t_R; f1: t_R }
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  predicate premise_Snapshot_tup2_R_R [@inline:trivial] (self: tup2_R_R) (from_auth: t_R) (from_frag: t_R) =
    forall f: t_Option_R. op_Option_R (Some from_frag) f = Some'0 (Some from_auth)
      -> op_Option_R (Some (self.f1)) f = Some'0 (Some (self.f0))
  
  meta "rewrite_def" predicate premise_Snapshot_tup2_R_R
  
  function update_Snapshot_tup2_R_R [@inline:trivial] (self: tup2_R_R) (_2: t_R) (_3: t_R) : tup2_R_R = self
  
  meta "rewrite_def" function update_Snapshot_tup2_R_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : tup2_R_R
  
  constant from_auth : t_R
  
  constant from_frag : t_R
  
  constant frame : t_Option_R
  
  function frame_preserving_Snapshot_tup2_R_R (self: tup2_R_R) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  goal vc_frame_preserving_Snapshot_tup2_R_R: premise_Snapshot_tup2_R_R self from_auth from_frag
    -> op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
    -> ([@stop_split] [@expl:frame_preserving ensures] let {f0 = to_auth; f1 = to_frag} = update_Snapshot_tup2_R_R self from_auth from_frag in op_Option_R (Some to_frag) frame
    = Some'0 (Some to_auth))
end
module M_logic__ra__update__impl_LocalUpdate_for_unit__frame_preserving (* <() as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : ()
  
  constant auth : t_R
  
  constant frag : t_R
  
  constant frame : t_Option_R
  
  function frame_preserving_unit (self: ()) (auth: t_R) (frag: t_R) (frame: t_Option_R) : ()
  
  goal vc_frame_preserving_unit: op_Option_R (Some frag) frame = Some'0 (Some auth)
    -> ([@stop_split] [@expl:frame_preserving ensures] op_Option_R (Some frag) frame = Some'0 (Some auth))
end
module M_logic__ra__view__impl_InhabitedInvariant_for_ViewInner_R__inhabits (* <logic::ra::view::ViewInner<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function inhabits_ViewInner_R : t_ViewInner_R
  
  goal vc_inhabits_ViewInner_R:
    ([@stop_split] [@expl:unit ensures] forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x)
    -> ([@stop_split] [@expl:inhabits ensures] invariant_ViewInner_R { auth = None; frag = unit_Frag })
end
module M_logic__ra__view__impl_View_R__frag (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function frag_R (self: t_View_R) : t_Frag
  
  goal vc_frag_R: ([@stop_split] [@expl:inner ensures] invariant_ViewInner_R (inner_ViewInner_R self.f0))
    -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R self) (inner_ViewInner_R self.f0).frag)
end
module M_logic__ra__view__impl_View_R__new (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant auth'0 : t_Option_Auth
  
  constant frag'0 : t_Frag
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R
  
  goal vc_new_R: rel_R auth'0 frag'0
    -> ([@stop_split] [@expl:new_logic requires] invariant_ViewInner_R { auth = auth'0; frag = frag'0 })
    /\ (([@stop_split] [@expl:new_logic ensures] inner_ViewInner_R (new_ViewInner_R { auth = auth'0; frag = frag'0 })
      = { auth = auth'0; frag = frag'0 })
    -> (let result = { f0 = new_ViewInner_R { auth = auth'0;
                                              frag = frag'0 } } in [@stop_split] [@expl:new_R ensures] ([@stop_split] [@expl:new ensures #0] auth_R result
      = auth'0)
    /\ ([@stop_split] [@expl:new ensures #1] frag_R result = frag'0)))
end
module M_logic__ra__view__impl_View_R__new_frag (* logic::ra::view::View<R> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant frag'0 : t_Frag
  
  function new_frag_R (frag'0: t_Frag) : t_View_R
  
  goal vc_new_frag_R: rel_R (None) frag'0 -> ([@stop_split] [@expl:new requires] rel_R (None) frag'0)
end
module M_logic__ra__view__impl_RA_for_View_R__factor (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function inner_inj_ViewInner_R (self: t_Subset_ViewInner_R) (other: t_Subset_ViewInner_R) : ()
  
  axiom inner_inj_ViewInner_R_spec:
    forall self: t_Subset_ViewInner_R, other: t_Subset_ViewInner_R. inner_ViewInner_R self = inner_ViewInner_R other
      -> self = other
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  constant factor : t_View_R
  
  function factor_View_R (self: t_View_R) (factor: t_View_R) : t_Option_View_R
  
  goal vc_factor_View_R: ([@stop_split] [@expl:frag ensures] rel_R (auth_R self) (frag_R self))
    -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R factor) (frag_R factor))
    -> ([@stop_split] [@expl:factor ensures] match factor_Frag (frag_R self) (frag_R factor) with
        | Some'0 c -> op_Frag (frag_R factor) c = Some'0 (frag_R self)
        | None'0 -> forall c: t_Frag. op_Frag (frag_R factor) c <> Some'0 (frag_R self)
        end)
    -> match factor_Frag (frag_R self) (frag_R factor) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R factor } with
        | {f0'0 = Some'1 a; f1'0 = None'1} -> ([@stop_split] [@expl:new requires] rel_R (Some'1 a) f)
        /\ (([@stop_split] [@expl:new ensures] ([@stop_split] [@expl:new ensures #0] auth_R (new_R (Some'1 a) f)
            = Some'1 a)
          /\ ([@stop_split] [@expl:new ensures #1] frag_R (new_R (Some'1 a) f) = f))
        -> ([@stop_split] [@expl:factor ensures] match Some (new_R (Some'1 a) f) with
          | Some c -> op_View_R factor c = Some self
          | None -> forall c: t_View_R. op_View_R factor c <> Some self
          end))
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then
          ([@stop_split] [@expl:new_frag requires] rel_R (None'1) f)
          /\ ([@stop_split] [@expl:factor ensures] match Some (new_frag_R f) with
            | Some c -> op_View_R factor c = Some self
            | None -> forall c: t_View_R. op_View_R factor c <> Some self
            end)
        else
          [@stop_split] [@expl:factor ensures] match None with
            | Some c -> op_View_R factor c = Some self
            | None -> forall c: t_View_R. op_View_R factor c <> Some self
            end
        
        end
      | None'0 -> [@stop_split] [@expl:factor ensures] match None with
        | Some c -> op_View_R factor c = Some self
        | None -> forall c: t_View_R. op_View_R factor c <> Some self
        end
      end
end
module M_logic__ra__view__impl_RA_for_View_R__eq (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function inner_inj_ViewInner_R (self: t_Subset_ViewInner_R) (other: t_Subset_ViewInner_R) : ()
  
  axiom inner_inj_ViewInner_R_spec:
    forall self: t_Subset_ViewInner_R, other: t_Subset_ViewInner_R. inner_ViewInner_R self = inner_ViewInner_R other
      -> self = other
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  constant other : t_View_R
  
  predicate eq_View_R (self: t_View_R) (other: t_View_R)
  
  goal vc_eq_View_R: if auth_R self = auth_R other then
      ([@stop_split] [@expl:frag ensures] rel_R (auth_R self) (frag_R self))
      -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R other) (frag_R other))
      -> ([@stop_split] [@expl:eq ensures] (frag_R self = frag_R other) = (self = other))
    else
      [@stop_split] [@expl:eq ensures] false = (self = other)

end
module M_logic__ra__view__impl_RA_for_View_R__commutative (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_View_R
  
  constant b : t_View_R
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : ()
  
  goal vc_commutative_View_R: [@stop_split] [@expl:commutative ensures] op_View_R a b = op_View_R b a
end
module M_logic__ra__view__impl_RA_for_View_R__associative (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  type tup2_Option_Frag_Option_Frag = { f0'1: t_Option_Frag; f1'1: t_Option_Frag }
  
  type tup3_Option_Auth_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth; f2'2: t_Option_Auth }
  
  function inner_inj_ViewInner_R (self: t_Subset_ViewInner_R) (other: t_Subset_ViewInner_R) : ()
  
  axiom inner_inj_ViewInner_R_spec:
    forall self: t_Subset_ViewInner_R, other: t_Subset_ViewInner_R. inner_ViewInner_R self = inner_ViewInner_R other
      -> self = other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_View_R
  
  constant b : t_View_R
  
  constant c : t_View_R
  
  function associative_View_R (a: t_View_R) (b: t_View_R) (c: t_View_R) : ()
  
  goal vc_associative_View_R: ([@stop_split] [@expl:frag ensures] rel_R (auth_R a) (frag_R a))
    -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R b) (frag_R b))
    -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R b) (frag_R b))
    -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R c) (frag_R c))
    -> match { f0'1 = op_Frag (frag_R a) (frag_R b); f1'1 = op_Frag (frag_R b) (frag_R c) } with
      | {f0'1 = Some'0 fab; f1'1 = Some'0 fbc} -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R c) (frag_R c))
      -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R a) (frag_R a))
      -> match { f0'1 = op_Frag fab (frag_R c); f1'1 = op_Frag (frag_R a) fbc } with
        | {f0'1 = Some'0 fabc1; f1'1 = Some'0 fabc2} -> fabc1 = fabc2
        && match { f0'2 = auth_R a; f1'2 = auth_R b; f2'2 = auth_R c } with
          | {f0'2 = Some'1 _; f1'2 = None'1; f2'2 = None'1} | {f0'2 = None'1; f1'2 = Some'1 _; f2'2 = None'1} | {f0'2 = None'1; f1'2 = None'1; f2'2 = Some'1 _} -> [@stop_split] [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
          = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
          | _ -> [@stop_split] [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
          = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
          end
        | _ -> [@stop_split] [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
        = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
        end
      | _ -> [@stop_split] [@expl:associative ensures] and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
      = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
      end
end
module M_logic__ra__view__impl_RA_for_View_R__core_idemp (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Auth
  
  type t_Option_Auth = None'0 | Some'0 t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'1 | Some'1 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'1 c -> op_Frag factor c = Some'1 self
        | None'1 -> forall c: t_Frag. op_Frag factor c <> Some'1 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'1
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'1 ab -> op_Frag b c = Some'1 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'1
      -> op_Frag b c = Some'1 bc -> op_Frag a bc = None'1
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'1 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'1 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'1 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'0) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'0) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  predicate index_Mapping_View_R_bool [@inline:trivial] (self: Map.map t_View_R bool) (a: t_View_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_View_R_bool
  
  function such_that_View_R (p: Map.map t_View_R bool) : t_View_R
  
  axiom such_that_View_R_spec: forall p: Map.map t_View_R bool. (exists x: t_View_R. index_Mapping_View_R_bool p x)
      -> index_Mapping_View_R_bool p (such_that_View_R p)
  
  function unwrap_Option_View_R (self: t_Option_View_R) : t_View_R = match self with
      | Some x -> x
      | None -> such_that_View_R (fun (__0: t_View_R) -> true)
      end
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'1 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'0; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'0} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'1 -> None
      end
  
  function core_total_idemp_Frag (self: t_Frag) : ()
  
  axiom core_total_idemp_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'1 (core_total_Frag self)
  
  axiom core_total_idemp_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'1 self
  
  function core_total_View_R (self: t_View_R) : t_View_R =
    let _ = core_total_idemp_Frag (frag_R self) in new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. core_View_R self = Some (core_total_View_R self)
  
  function core_total_idemp_View_R (self: t_View_R) : () = ()
  
  axiom core_total_idemp_View_R_spec: forall self: t_View_R. op_View_R (core_total_View_R self) (core_total_View_R self)
      = Some (core_total_View_R self)
  
  axiom core_total_idemp_View_R_spec'0: forall self: t_View_R. op_View_R (core_total_View_R self) self = Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function core_idemp_View_R (self: t_View_R) : ()
  
  goal vc_core_idemp_View_R: core_View_R self <> None
    -> ([@stop_split] [@expl:core_total_idemp ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_View_R (core_total_View_R self) (core_total_View_R self)
        = Some (core_total_View_R self))
      /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_View_R (core_total_View_R self) self = Some self))
    -> ([@stop_split] [@expl:core_idemp_View_R ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_View_R (core_View_R self) in op_View_R c c
      = Some c)
    /\ ([@stop_split] [@expl:core_idemp ensures #1] op_View_R (unwrap_Option_View_R (core_View_R self)) self
    = Some self))
end
module M_logic__ra__view__impl_RA_for_View_R__core_is_maximal_idemp (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  function factor_View_R (self: t_View_R) (factor: t_View_R) : t_Option_View_R =
    match factor_Frag (frag_R self) (frag_R factor) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R factor } with
        | {f0'0 = Some'1 a; f1'0 = None'1} -> Some (new_R (Some'1 a) f)
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then Some (new_frag_R f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_R_spec: forall self: t_View_R, factor: t_View_R. match factor_View_R self factor with
        | Some c -> op_View_R factor c = Some self
        | None -> forall c: t_View_R. op_View_R factor c <> Some self
        end
  
  predicate incl_View_R (self: t_View_R) (other: t_View_R) = factor_View_R other self <> None
  
  function core_total_idemp_Frag (self: t_Frag) : ()
  
  axiom core_total_idemp_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_idemp_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  function core_is_maximal_idemp_Frag (self: t_Frag) (i: t_Frag) : ()
  
  axiom core_is_maximal_idemp_Frag_spec: forall self: t_Frag, i: t_Frag. op_Frag i i = Some'0 i
      -> op_Frag i self = Some'0 self
      -> match core_Frag self with
        | Some'0 c -> incl_Frag i c
        | None'0 -> false
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  constant i : t_View_R
  
  function core_is_maximal_idemp_View_R (self: t_View_R) (i: t_View_R) : ()
  
  goal vc_core_is_maximal_idemp_View_R: op_View_R i i = Some i
    -> op_View_R i self = Some self
    -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R self) (frag_R self))
    -> ([@stop_split] [@expl:core_total_idemp ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_Frag (core_total_Frag (frag_R self)) (core_total_Frag (frag_R self))
        = Some'0 (core_total_Frag (frag_R self)))
      /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_Frag (core_total_Frag (frag_R self)) (frag_R self)
      = Some'0 (frag_R self)))
    -> (let _ = core_total_idemp_Frag (frag_R self) in ([@stop_split] [@expl:frag ensures] rel_R (auth_R self) (frag_R self))
    -> ([@stop_split] [@expl:frag ensures] rel_R (auth_R i) (frag_R i))
    -> ([@stop_split] [@expl:core_is_maximal_idemp requires] ([@stop_split] [@expl:core_is_maximal_idemp requires #0] op_Frag (frag_R i) (frag_R i)
        = Some'0 (frag_R i))
      /\ ([@stop_split] [@expl:core_is_maximal_idemp requires #1] op_Frag (frag_R i) (frag_R self)
      = Some'0 (frag_R self)))
    /\ (([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Frag (frag_R self) with
        | Some'0 c -> incl_Frag (frag_R i) c
        | None'0 -> false
        end)
    -> ([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_View_R self with
      | Some c -> incl_View_R i c
      | None -> false
      end)))
end
module M_logic__ra__view__impl_UnitRA_for_View_R__unit (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  predicate eq_View_R [@inline:trivial] (self: t_View_R) (other: t_View_R) =
    auth_R self = auth_R other /\ frag_R self = frag_R other
  
  meta "rewrite_def" predicate eq_View_R
  
  axiom eq_View_R_spec: forall self: t_View_R, other: t_View_R. eq_View_R self other = (self = other)
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_View_R : t_View_R
  
  goal vc_unit_View_R: ([@stop_split] [@expl:unit ensures] forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag
        = Some'0 x)
    -> ([@stop_split] [@expl:new_frag requires] rel_R (None'1) unit_Frag)
    /\ (let result = new_frag_R unit_Frag in [@stop_split] [@expl:unit ensures] forall x: t_View_R [op_View_R x result]. op_View_R x result
      = Some x)
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_total (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  function core_total_idemp_Frag (self: t_Frag) : ()
  
  axiom core_total_idemp_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_idemp_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function core_total_View_R (self: t_View_R) : t_View_R
  
  goal vc_core_total_View_R: ([@stop_split] [@expl:frag ensures] rel_R (auth_R self) (frag_R self))
    -> ([@stop_split] [@expl:core_total_idemp ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_Frag (core_total_Frag (frag_R self)) (core_total_Frag (frag_R self))
        = Some'0 (core_total_Frag (frag_R self)))
      /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_Frag (core_total_Frag (frag_R self)) (frag_R self)
      = Some'0 (frag_R self)))
    -> (let _ = core_total_idemp_Frag (frag_R self) in ([@stop_split] [@expl:frag ensures] rel_R (auth_R self) (frag_R self))
    -> ([@stop_split] [@expl:core_total ensures] core_Frag (frag_R self) = Some'0 (core_total_Frag (frag_R self)))
    -> ([@stop_split] [@expl:new_frag requires] rel_R (None'1) (core_total_Frag (frag_R self)))
    /\ ([@stop_split] [@expl:core_total ensures] core_View_R self = Some (new_frag_R (core_total_Frag (frag_R self)))))
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_total_idemp (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  function core_total_idemp_Frag (self: t_Frag) : ()
  
  axiom core_total_idemp_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_idemp_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  function core_total_View_R (self: t_View_R) : t_View_R =
    let _ = core_total_idemp_Frag (frag_R self) in new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. core_View_R self = Some (core_total_View_R self)
  
  predicate eq_View_R [@inline:trivial] (self: t_View_R) (other: t_View_R) =
    auth_R self = auth_R other /\ frag_R self = frag_R other
  
  meta "rewrite_def" predicate eq_View_R
  
  axiom eq_View_R_spec: forall self: t_View_R, other: t_View_R. eq_View_R self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_View_R
  
  function core_total_idemp_View_R (self: t_View_R) : ()
  
  goal vc_core_total_idemp_View_R:
    [@stop_split] [@expl:core_total_idemp_View_R ensures] ([@stop_split] [@expl:core_total_idemp ensures #0] op_View_R (core_total_View_R self) (core_total_View_R self)
      = Some (core_total_View_R self))
    /\ ([@stop_split] [@expl:core_total_idemp ensures #1] op_View_R (core_total_View_R self) self = Some self)
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__update (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Auth_Frag = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'0: Map.map t_Choice tup2_Auth_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'1: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'1).auth
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'1).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdate_R_Choice [@inline:trivial] (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None
    /\ (forall ch: t_Choice. rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1 frame with
          | Some'0 ff -> rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) ff
          | None'0 -> false
          end))
  
  meta "rewrite_def" predicate premise_ViewUpdate_R_Choice
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'1 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdate_R_Choice
  
  constant from : t_View_R
  
  constant ch : t_Choice
  
  function update_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) (ch: t_Choice) : t_View_R
  
  goal vc_update_ViewUpdate_R_Choice: premise_ViewUpdate_R_Choice self from
    -> ([@stop_split] [@expl:new requires] rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__frame_preserving (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Auth_Frag = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'0: Map.map t_Choice tup2_Auth_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'1: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'1).auth
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'1).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdate_R_Choice [@inline:trivial] (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None
    /\ (forall ch: t_Choice. rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1 frame with
          | Some'0 ff -> rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) ff
          | None'0 -> false
          end))
  
  meta "rewrite_def" predicate premise_ViewUpdate_R_Choice
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'1 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None; f1'2 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'2 = a; f1'2 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function update_ViewUpdate_R_Choice [@inline:trivial] (self: t_ViewUpdate_R_Choice) (from: t_View_R) (ch: t_Choice) : t_View_R
   =
    new_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1
  
  meta "rewrite_def" function update_ViewUpdate_R_Choice
  
  predicate index_Mapping_Choice_bool [@inline:trivial] (self: Map.map t_Choice bool) (a: t_Choice) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Choice_bool
  
  function such_that_Choice (p: Map.map t_Choice bool) : t_Choice
  
  axiom such_that_Choice_spec: forall p: Map.map t_Choice bool. (exists x: t_Choice. index_Mapping_Choice_bool p x)
      -> index_Mapping_Choice_bool p (such_that_Choice p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdate_R_Choice
  
  constant from : t_View_R
  
  constant frame : t_View_R
  
  function frame_preserving_ViewUpdate_R_Choice (self: t_ViewUpdate_R_Choice) (from: t_View_R) (frame: t_View_R) : t_Choice
  
  goal vc_frame_preserving_ViewUpdate_R_Choice: premise_ViewUpdate_R_Choice self from
    -> op_View_R from frame <> None'1
    -> (forall ch: t_Choice. [@stop_split] [@expl:update requires] premise_ViewUpdate_R_Choice self from)
    /\ ([@stop_split] [@expl:such_that requires] exists x: t_Choice. index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
        <> None'1) x)
    /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Choice_bool (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
      <> None'1) (such_that_Choice (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
      <> None'1)))
    -> ([@stop_split] [@expl:frame_preserving ensures] op_View_R (update_ViewUpdate_R_Choice self from (such_that_Choice (fun (ch: t_Choice) -> op_View_R (update_ViewUpdate_R_Choice self from ch) frame
      <> None'1))) frame
    <> None'1))
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__update (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateInsert_R = { f0: t_Auth; f1: t_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  predicate premise_ViewUpdateInsert_R [@inline:trivial] (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1 f with
        | Some'0 ff -> rel_R (Some (self.f0)) ff
        | None'0 -> false
        end)
  
  meta "rewrite_def" predicate premise_ViewUpdateInsert_R
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateInsert_R
  
  constant from : t_View_R
  
  constant _3 : ()
  
  function update_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) (_3: ()) : t_View_R
  
  goal vc_update_ViewUpdateInsert_R: premise_ViewUpdateInsert_R self from
    -> ([@stop_split] [@expl:new requires] rel_R (Some (self.f0)) self.f1)
    /\ (([@stop_split] [@expl:new ensures] ([@stop_split] [@expl:new ensures #0] auth_R (new_R (Some (self.f0)) self.f1)
        = Some (self.f0))
      /\ ([@stop_split] [@expl:new ensures #1] frag_R (new_R (Some (self.f0)) self.f1) = self.f1))
    -> ([@stop_split] [@expl:update ensures] rel_R (Some (self.f0)) self.f1))
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__frame_preserving (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateInsert_R = { f0: t_Auth; f1: t_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  predicate premise_ViewUpdateInsert_R [@inline:trivial] (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1 f with
        | Some'0 ff -> rel_R (Some (self.f0)) ff
        | None'0 -> false
        end)
  
  meta "rewrite_def" predicate premise_ViewUpdateInsert_R
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'1 = auth_R self; f1'1 = auth_R other } with
        | {f0'1 = None; f1'1 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'1 = a; f1'1 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function update_ViewUpdateInsert_R [@inline:trivial] (self: t_ViewUpdateInsert_R) (from: t_View_R) (_3: ()) : t_View_R
   = new_R (Some (self.f0)) self.f1
  
  meta "rewrite_def" function update_ViewUpdateInsert_R
  
  axiom update_ViewUpdateInsert_R_spec:
    forall self: t_ViewUpdateInsert_R, from: t_View_R, _3: (). premise_ViewUpdateInsert_R self from
      -> rel_R (Some (self.f0)) self.f1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateInsert_R
  
  constant from : t_View_R
  
  constant frame : t_View_R
  
  function frame_preserving_ViewUpdateInsert_R (self: t_ViewUpdateInsert_R) (from: t_View_R) (frame: t_View_R) : ()
  
  goal vc_frame_preserving_ViewUpdateInsert_R: premise_ViewUpdateInsert_R self from
    -> op_View_R from frame <> None'1
    -> rel_R (Some (self.f0)) self.f1
    && ([@stop_split] [@expl:frame_preserving ensures] op_View_R (update_ViewUpdateInsert_R self from ()) frame
    <> None'1)
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__update (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateRemove_R = { f0: t_Auth }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdateRemove_R [@inline:trivial] (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some (self.f0)) f)
  
  meta "rewrite_def" predicate premise_ViewUpdateRemove_R
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function new_auth_R [@inline:trivial] (auth'0: t_Auth) : t_View_R = new_R (Some auth'0) unit_Frag
  
  meta "rewrite_def" function new_auth_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateRemove_R
  
  constant from : t_View_R
  
  constant _3 : ()
  
  function update_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) (_3: ()) : t_View_R
  
  goal vc_update_ViewUpdateRemove_R: premise_ViewUpdateRemove_R self from
    -> ([@stop_split] [@expl:update ensures] rel_R (Some (self.f0)) unit_Frag)
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__frame_preserving (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateRemove_R = { f0: t_Auth }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdateRemove_R [@inline:trivial] (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some (self.f0)) f)
  
  meta "rewrite_def" predicate premise_ViewUpdateRemove_R
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  type tup2_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'1 = auth_R self; f1'1 = auth_R other } with
        | {f0'1 = None; f1'1 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'1 = a; f1'1 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_auth_R [@inline:trivial] (auth'0: t_Auth) : t_View_R = new_R (Some auth'0) unit_Frag
  
  meta "rewrite_def" function new_auth_R
  
  function update_ViewUpdateRemove_R [@inline:trivial] (self: t_ViewUpdateRemove_R) (from: t_View_R) (_3: ()) : t_View_R
   = new_auth_R self.f0
  
  meta "rewrite_def" function update_ViewUpdateRemove_R
  
  axiom update_ViewUpdateRemove_R_spec:
    forall self: t_ViewUpdateRemove_R, from: t_View_R, _3: (). premise_ViewUpdateRemove_R self from
      -> rel_R (Some (self.f0)) unit_Frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_ViewUpdateRemove_R
  
  constant from : t_View_R
  
  constant frame : t_View_R
  
  function frame_preserving_ViewUpdateRemove_R (self: t_ViewUpdateRemove_R) (from: t_View_R) (frame: t_View_R) : ()
  
  goal vc_frame_preserving_ViewUpdateRemove_R: premise_ViewUpdateRemove_R self from
    -> op_View_R from frame <> None'1
    -> ([@stop_split] [@expl:frame_preserving ensures] op_View_R (update_ViewUpdateRemove_R self from ()) frame
    <> None'1)
end
module M_logic__ra__trait_RA__eq
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Self
  
  constant other : t_Self
  
  predicate eq_Self (self: t_Self) (other: t_Self)
  
  goal vc_eq_Self: [@stop_split] [@expl:eq ensures] (self = other) = (self = other)
end
module M_logic__ra__trait_RA__incl_op
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Self
  
  constant other : t_Self
  
  constant comb : t_Self
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
  goal vc_incl_op_Self: op_Self self other = Some comb -> ([@stop_split] [@expl:incl_op ensures] incl_Self self comb)
end
module M_logic__ra__trait_RA__associative_none
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function and_then_Option_Self (self: t_Option_Self) (f: Map.map t_Self t_Option_Self) : t_Option_Self =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function associative_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_Self_spec:
    forall a: t_Self, b: t_Self, c: t_Self. and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc: t_Self) -> op_Self a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Self
  
  constant b : t_Self
  
  constant c : t_Self
  
  constant bc : t_Self
  
  function associative_none_Self (a: t_Self) (b: t_Self) (c: t_Self) (bc: t_Self) : ()
  
  goal vc_associative_none_Self: op_Self a b = None
    -> op_Self b c = Some bc
    -> ([@stop_split] [@expl:associative ensures] and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc'0: t_Self) -> op_Self a bc'0))
    -> (let _ = associative_Self a b c in [@stop_split] [@expl:associative_none ensures] op_Self a bc = None)
end
module M_logic__ra__trait_RA__associative_some
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function and_then_Option_Self (self: t_Option_Self) (f: Map.map t_Self t_Option_Self) : t_Option_Self =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function associative_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_Self_spec:
    forall a: t_Self, b: t_Self, c: t_Self. and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc: t_Self) -> op_Self a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Self
  
  constant b : t_Self
  
  constant c : t_Self
  
  constant ab : t_Self
  
  constant bc : t_Self
  
  function associative_some_Self (a: t_Self) (b: t_Self) (c: t_Self) (ab: t_Self) (bc: t_Self) : ()
  
  goal vc_associative_some_Self: op_Self a b = Some ab
    -> op_Self b c = Some bc
    -> ([@stop_split] [@expl:associative ensures] and_then_Option_Self (op_Self a b) (fun (ab'0: t_Self) -> op_Self ab'0 c)
      = and_then_Option_Self (op_Self b c) (fun (bc'0: t_Self) -> op_Self a bc'0))
    -> (let _ = associative_Self a b c in [@stop_split] [@expl:associative_some ensures] op_Self a bc = op_Self ab c)
end
module M_logic__ra__trait_RA__incl_transitive
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function and_then_Option_Self (self: t_Option_Self) (f: Map.map t_Self t_Option_Self) : t_Option_Self =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function associative_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom associative_Self_spec:
    forall a: t_Self, b: t_Self, c: t_Self. and_then_Option_Self (op_Self a b) (fun (ab: t_Self) -> op_Self ab c)
      = and_then_Option_Self (op_Self b c) (fun (bc: t_Self) -> op_Self a bc)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Self
  
  constant b : t_Self
  
  constant c : t_Self
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  goal vc_incl_transitive_Self: incl_Self a b
    -> incl_Self b c -> ([@stop_split] [@expl:incl_transitive ensures] incl_Self a c)
end
module M_logic__ra__trait_UnitRA__incl_refl
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom incl_transitive_Self_spec: forall a: t_Self, b: t_Self, c: t_Self. incl_Self a b
      -> incl_Self b c -> incl_Self a c
  
  function associative_some_Self (a: t_Self) (b: t_Self) (c: t_Self) (ab: t_Self) (bc: t_Self) : ()
  
  axiom associative_some_Self_spec: forall a: t_Self, b: t_Self, c: t_Self, ab: t_Self, bc: t_Self. op_Self a b
        = Some ab -> op_Self b c = Some bc -> op_Self a bc = op_Self ab c
  
  function associative_none_Self (a: t_Self) (b: t_Self) (c: t_Self) (bc: t_Self) : ()
  
  axiom associative_none_Self_spec: forall a: t_Self, b: t_Self, c: t_Self, bc: t_Self. op_Self a b = None
      -> op_Self b c = Some bc -> op_Self a bc = None
  
  function commutative_Self (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_Self_spec: forall a: t_Self, b: t_Self. op_Self a b = op_Self b a
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
  axiom incl_op_Self_spec: forall self: t_Self, other: t_Self, comb: t_Self. op_Self self other = Some comb
      -> incl_Self self comb
  
  constant unit_Self : t_Self
  
  axiom unit_Self_spec: forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function incl_refl_Self : ()
  
  goal vc_incl_refl_Self:
    ([@stop_split] [@expl:unit ensures] forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x)
    -> (let _ = unit_Self in [@stop_split] [@expl:incl_refl ensures] forall x: t_Self. incl_Self x x)
end
module M_logic__ra__trait_UnitRA__core_total
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom incl_transitive_Self_spec: forall a: t_Self, b: t_Self, c: t_Self. incl_Self a b
      -> incl_Self b c -> incl_Self a c
  
  function associative_some_Self (a: t_Self) (b: t_Self) (c: t_Self) (ab: t_Self) (bc: t_Self) : ()
  
  axiom associative_some_Self_spec: forall a: t_Self, b: t_Self, c: t_Self, ab: t_Self, bc: t_Self. op_Self a b
        = Some ab -> op_Self b c = Some bc -> op_Self a bc = op_Self ab c
  
  function associative_none_Self (a: t_Self) (b: t_Self) (c: t_Self) (bc: t_Self) : ()
  
  axiom associative_none_Self_spec: forall a: t_Self, b: t_Self, c: t_Self, bc: t_Self. op_Self a b = None
      -> op_Self b c = Some bc -> op_Self a bc = None
  
  function commutative_Self (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_Self_spec: forall a: t_Self, b: t_Self. op_Self a b = op_Self b a
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
  axiom incl_op_Self_spec: forall self: t_Self, other: t_Self, comb: t_Self. op_Self self other = Some comb
      -> incl_Self self comb
  
  function core_Self (self: t_Self) : t_Option_Self
  
  constant unit_Self : t_Self
  
  axiom unit_Self_spec: forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x
  
  function core_is_maximal_idemp_Self (self: t_Self) (i: t_Self) : ()
  
  axiom core_is_maximal_idemp_Self_spec: forall self: t_Self, i: t_Self. op_Self i i = Some i
      -> op_Self i self = Some self
      -> match core_Self self with
        | Some c -> incl_Self i c
        | None -> false
        end
  
  predicate index_Mapping_Self_bool [@inline:trivial] (self: Map.map t_Self bool) (a: t_Self) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Self_bool
  
  function such_that_Self (p: Map.map t_Self bool) : t_Self
  
  axiom such_that_Self_spec: forall p: Map.map t_Self bool. (exists x: t_Self. index_Mapping_Self_bool p x)
      -> index_Mapping_Self_bool p (such_that_Self p)
  
  function unwrap_Option_Self (self: t_Option_Self) : t_Self = match self with
      | Some x -> x
      | None -> such_that_Self (fun (__0: t_Self) -> true)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Self
  
  function core_total_Self (self: t_Self) : t_Self
  
  goal vc_core_total_Self:
    ([@stop_split] [@expl:unit ensures] forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x)
    -> ([@stop_split] [@expl:core_is_maximal_idemp requires] ([@stop_split] [@expl:core_is_maximal_idemp requires #0] op_Self unit_Self unit_Self
        = Some unit_Self)
      /\ ([@stop_split] [@expl:core_is_maximal_idemp requires #1] op_Self unit_Self self = Some self))
    /\ (([@stop_split] [@expl:core_is_maximal_idemp ensures] match core_Self self with
        | Some c -> incl_Self unit_Self c
        | None -> false
        end)
    -> (let _ = core_is_maximal_idemp_Self self unit_Self in ([@stop_split] [@expl:unwrap_logic requires] core_Self self
      <> None)
    /\ ([@stop_split] [@expl:core_total ensures] core_Self self = Some (unwrap_Option_Self (core_Self self)))))
end
module M_logic__ra__trait_UnitRA__unit_core
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Self
  
  type t_Option_Self = None | Some t_Self
  
  function op_Self (self: t_Self) (other: t_Self) : t_Option_Self
  
  function factor_Self (self: t_Self) (factor: t_Self) : t_Option_Self
  
  axiom factor_Self_spec: forall self: t_Self, factor: t_Self. match factor_Self self factor with
        | Some c -> op_Self factor c = Some self
        | None -> forall c: t_Self. op_Self factor c <> Some self
        end
  
  predicate incl_Self (self: t_Self) (other: t_Self) = factor_Self other self <> None
  
  function incl_transitive_Self (a: t_Self) (b: t_Self) (c: t_Self) : ()
  
  axiom incl_transitive_Self_spec: forall a: t_Self, b: t_Self, c: t_Self. incl_Self a b
      -> incl_Self b c -> incl_Self a c
  
  function associative_some_Self (a: t_Self) (b: t_Self) (c: t_Self) (ab: t_Self) (bc: t_Self) : ()
  
  axiom associative_some_Self_spec: forall a: t_Self, b: t_Self, c: t_Self, ab: t_Self, bc: t_Self. op_Self a b
        = Some ab -> op_Self b c = Some bc -> op_Self a bc = op_Self ab c
  
  function associative_none_Self (a: t_Self) (b: t_Self) (c: t_Self) (bc: t_Self) : ()
  
  axiom associative_none_Self_spec: forall a: t_Self, b: t_Self, c: t_Self, bc: t_Self. op_Self a b = None
      -> op_Self b c = Some bc -> op_Self a bc = None
  
  function commutative_Self (a: t_Self) (b: t_Self) : ()
  
  axiom commutative_Self_spec: forall a: t_Self, b: t_Self. op_Self a b = op_Self b a
  
  function incl_op_Self (self: t_Self) (other: t_Self) (comb: t_Self) : ()
  
  axiom incl_op_Self_spec: forall self: t_Self, other: t_Self, comb: t_Self. op_Self self other = Some comb
      -> incl_Self self comb
  
  function core_Self (self: t_Self) : t_Option_Self
  
  function core_total_Self (self: t_Self) : t_Self
  
  axiom core_total_Self_spec: forall self: t_Self. core_Self self = Some (core_total_Self self)
  
  constant unit_Self : t_Self
  
  axiom unit_Self_spec: forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x
  
  predicate index_Mapping_Self_bool [@inline:trivial] (self: Map.map t_Self bool) (a: t_Self) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Self_bool
  
  function such_that_Self (p: Map.map t_Self bool) : t_Self
  
  axiom such_that_Self_spec: forall p: Map.map t_Self bool. (exists x: t_Self. index_Mapping_Self_bool p x)
      -> index_Mapping_Self_bool p (such_that_Self p)
  
  function unwrap_Option_Self (self: t_Option_Self) : t_Self = match self with
      | Some x -> x
      | None -> such_that_Self (fun (__0: t_Self) -> true)
      end
  
  function core_idemp_Self (self: t_Self) : ()
  
  axiom core_idemp_Self_spec: forall self: t_Self. core_Self self <> None
      -> (let c = unwrap_Option_Self (core_Self self) in op_Self c c = Some c)
  
  axiom core_idemp_Self_spec'0: forall self: t_Self. core_Self self <> None
      -> op_Self (unwrap_Option_Self (core_Self self)) self = Some self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function unit_core_Self : ()
  
  goal vc_unit_core_Self:
    ([@stop_split] [@expl:unit ensures] forall x: t_Self [op_Self x unit_Self]. op_Self x unit_Self = Some x)
    -> ([@stop_split] [@expl:core_idemp requires] core_Self unit_Self <> None)
    /\ (([@stop_split] [@expl:core_idemp ensures] ([@stop_split] [@expl:core_idemp ensures #0] let c = unwrap_Option_Self (core_Self unit_Self) in op_Self c c
        = Some c)
      /\ ([@stop_split] [@expl:core_idemp ensures #1] op_Self (unwrap_Option_Self (core_Self unit_Self)) unit_Self
      = Some unit_Self)) -> ([@stop_split] [@expl:unit_core ensures] core_total_Self unit_Self = unit_Self))
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_le_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_le_log_Real: [@stop_split] [@expl:cmp_le_log ensures] Real.(<=) x y = (cmp_log_Real x y <> Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_lt_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_lt_log_Real: [@stop_split] [@expl:cmp_lt_log ensures] Real.(<) x y = (cmp_log_Real x y = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_ge_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_ge_log_Real: [@stop_split] [@expl:cmp_ge_log ensures] Real.(>=) x y = (cmp_log_Real x y <> Less)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_gt_log (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_cmp_gt_log_Real: [@stop_split] [@expl:cmp_gt_log ensures] Real.(>) x y = (cmp_log_Real x y = Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__refl (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  function refl_Real (x: Real.real) : ()
  
  goal vc_refl_Real: [@stop_split] [@expl:refl ensures] cmp_log_Real x x = Equal
end
module M_logic__real__impl_OrdLogic_for_Real__trans (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  constant z : Real.real
  
  constant o : t_Ordering
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  goal vc_trans_Real: cmp_log_Real x y = o
    -> cmp_log_Real y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_Real x z = o)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym1 (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_antisym1_Real: cmp_log_Real x y = Less -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_Real y x = Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym2 (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_antisym2_Real: cmp_log_Real x y = Greater -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_Real y x = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__eq_cmp (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : Real.real
  
  constant y : Real.real
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  goal vc_eq_cmp_Real: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_Real x y = Equal)
end
module M_logic__real__impl_InhabitedInvariant_for_PositiveRealInner__inhabits (* <logic::real::PositiveRealInner as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveRealInner = { f0: Real.real }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0 (FromInt.from_int 0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function inhabits_PositiveRealInner : t_PositiveRealInner
  
  goal vc_inhabits_PositiveRealInner:
    [@stop_split] [@expl:inhabits ensures] invariant_PositiveRealInner { f0 = FromInt.from_int 1 }
end
module M_logic__real__impl_PositiveReal__to_real (* logic::real::PositiveReal *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  function to_real (self: t_PositiveReal) : Real.real
  
  goal vc_to_real: ([@stop_split] [@expl:inner ensures] invariant_PositiveRealInner (inner_PositiveRealInner self.f0))
    -> ([@stop_split] [@expl:to_real ensures] Real.(>) (inner_PositiveRealInner self.f0).f0'0 (FromInt.from_int 0))
end
module M_logic__real__impl_PositiveReal__new (* logic::real::PositiveReal *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function new_PositiveRealInner (x: t_PositiveRealInner) : t_Subset_PositiveRealInner
  
  axiom new_PositiveRealInner_spec: forall x: t_PositiveRealInner. invariant_PositiveRealInner x
      -> inner_PositiveRealInner (new_PositiveRealInner x) = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant n : Real.real
  
  function new (n: Real.real) : t_PositiveReal
  
  goal vc_new: Real.(>) n (FromInt.from_int 0)
    -> ([@stop_split] [@expl:new_logic requires] invariant_PositiveRealInner { f0'0 = n })
    /\ (([@stop_split] [@expl:new_logic ensures] inner_PositiveRealInner (new_PositiveRealInner { f0'0 = n })
      = { f0'0 = n }) -> ([@stop_split] [@expl:new ensures] to_real { f0 = new_PositiveRealInner { f0'0 = n } } = n))
end
module M_logic__real__impl_PositiveReal__ext_eq (* logic::real::PositiveReal *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function inner_inj_PositiveRealInner (self: t_Subset_PositiveRealInner) (other: t_Subset_PositiveRealInner) : ()
  
  axiom inner_inj_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner, other: t_Subset_PositiveRealInner. inner_PositiveRealInner self
        = inner_PositiveRealInner other -> self = other
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  constant other : t_PositiveReal
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal)
  
  goal vc_ext_eq: ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real self) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real other) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:ext_eq ensures] (to_real self = to_real other) = (self = other))
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_le_log (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate le_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(<=) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  function cmp_le_log_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) : ()
  
  goal vc_cmp_le_log_PositiveReal: [@stop_split] [@expl:cmp_le_log ensures] le_log_PositiveReal x y
    = (cmp_log_PositiveReal x y <> Greater)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_lt_log (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate lt_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(<) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  function cmp_lt_log_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) : ()
  
  goal vc_cmp_lt_log_PositiveReal: [@stop_split] [@expl:cmp_lt_log ensures] lt_log_PositiveReal x y
    = (cmp_log_PositiveReal x y = Less)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_ge_log (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate ge_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(>=) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  function cmp_ge_log_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) : ()
  
  goal vc_cmp_ge_log_PositiveReal: [@stop_split] [@expl:cmp_ge_log ensures] ge_log_PositiveReal x y
    = (cmp_log_PositiveReal x y <> Less)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_gt_log (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate gt_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(>) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  function cmp_gt_log_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) : ()
  
  goal vc_cmp_gt_log_PositiveReal: [@stop_split] [@expl:cmp_gt_log ensures] gt_log_PositiveReal x y
    = (cmp_log_PositiveReal x y = Greater)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__refl (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  function refl_PositiveReal (x: t_PositiveReal) : ()
  
  goal vc_refl_PositiveReal: [@stop_split] [@expl:refl ensures] cmp_log_PositiveReal x x = Equal
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__trans (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  constant z : t_PositiveReal
  
  constant o : t_Ordering
  
  function trans_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) (z: t_PositiveReal) (o: t_Ordering) : ()
  
  goal vc_trans_PositiveReal: cmp_log_PositiveReal x y = o
    -> cmp_log_PositiveReal y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_PositiveReal x z = o)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__antisym1 (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  function antisym1_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) : ()
  
  goal vc_antisym1_PositiveReal: cmp_log_PositiveReal x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_PositiveReal y x = Greater)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__antisym2 (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  function antisym2_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) : ()
  
  goal vc_antisym2_PositiveReal: cmp_log_PositiveReal x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_PositiveReal y x = Less)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__eq_cmp (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  predicate ext_eq (self: t_PositiveReal) (other: t_PositiveReal) = to_real self = to_real other
  
  axiom ext_eq_spec: forall self: t_PositiveReal, other: t_PositiveReal. ext_eq self other = (self = other)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PositiveReal
  
  constant y : t_PositiveReal
  
  function eq_cmp_PositiveReal (x: t_PositiveReal) (y: t_PositiveReal) : ()
  
  goal vc_eq_cmp_PositiveReal: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_PositiveReal x y = Equal)
end
module M_logic__real__impl_AddLogic_for_PositiveReal__add (* <logic::real::PositiveReal as logic::ops::arithmetic::AddLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function new_PositiveRealInner (x: t_PositiveRealInner) : t_Subset_PositiveRealInner
  
  axiom new_PositiveRealInner_spec: forall x: t_PositiveRealInner. invariant_PositiveRealInner x
      -> inner_PositiveRealInner (new_PositiveRealInner x) = x
  
  function new (n: Real.real) : t_PositiveReal = { f0 = new_PositiveRealInner { f0'0 = n } }
  
  axiom new_spec: forall n: Real.real. Real.(>) n (FromInt.from_int 0) -> to_real (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  constant other : t_PositiveReal
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  goal vc_add_PositiveReal: ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real self) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real other) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:new requires] Real.(>) (Real.(+) (to_real self) (to_real other)) (FromInt.from_int 0))
    /\ (([@stop_split] [@expl:new ensures] to_real (new (Real.(+) (to_real self) (to_real other)))
      = Real.(+) (to_real self) (to_real other))
    -> ([@stop_split] [@expl:add ensures] to_real (new (Real.(+) (to_real self) (to_real other)))
    = Real.(+) (to_real self) (to_real other)))
end
module M_logic__real__impl_MulLogic_for_PositiveReal__mul (* <logic::real::PositiveReal as logic::ops::arithmetic::MulLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function new_PositiveRealInner (x: t_PositiveRealInner) : t_Subset_PositiveRealInner
  
  axiom new_PositiveRealInner_spec: forall x: t_PositiveRealInner. invariant_PositiveRealInner x
      -> inner_PositiveRealInner (new_PositiveRealInner x) = x
  
  function new (n: Real.real) : t_PositiveReal = { f0 = new_PositiveRealInner { f0'0 = n } }
  
  axiom new_spec: forall n: Real.real. Real.(>) n (FromInt.from_int 0) -> to_real (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  constant other : t_PositiveReal
  
  function mul_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  goal vc_mul_PositiveReal: ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real self) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real other) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:new requires] Real.(>) (Real.(*) (to_real self) (to_real other)) (FromInt.from_int 0))
    /\ (([@stop_split] [@expl:new ensures] to_real (new (Real.(*) (to_real self) (to_real other)))
      = Real.(*) (to_real self) (to_real other))
    -> ([@stop_split] [@expl:mul ensures] to_real (new (Real.(*) (to_real self) (to_real other)))
    = Real.(*) (to_real self) (to_real other)))
end
module M_logic__real__impl_DivLogic_for_PositiveReal__div (* <logic::real::PositiveReal as logic::ops::arithmetic::DivLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function new_PositiveRealInner (x: t_PositiveRealInner) : t_Subset_PositiveRealInner
  
  axiom new_PositiveRealInner_spec: forall x: t_PositiveRealInner. invariant_PositiveRealInner x
      -> inner_PositiveRealInner (new_PositiveRealInner x) = x
  
  function new (n: Real.real) : t_PositiveReal = { f0 = new_PositiveRealInner { f0'0 = n } }
  
  axiom new_spec: forall n: Real.real. Real.(>) n (FromInt.from_int 0) -> to_real (new n) = n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_PositiveReal
  
  constant other : t_PositiveReal
  
  function div_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  goal vc_div_PositiveReal: ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real self) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:to_real ensures] Real.(>) (to_real other) (FromInt.from_int 0))
    -> ([@stop_split] [@expl:new requires] Real.(>) (Real.(/) (to_real self) (to_real other)) (FromInt.from_int 0))
    /\ (([@stop_split] [@expl:new ensures] to_real (new (Real.(/) (to_real self) (to_real other)))
      = Real.(/) (to_real self) (to_real other))
    -> ([@stop_split] [@expl:div ensures] to_real (new (Real.(/) (to_real self) (to_real other)))
    = Real.(/) (to_real self) (to_real other)))
end
module M_logic__seq__impl_Seq_T__map (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  type t_U
  
  function index_Mapping_T_U [@inline:trivial] (self: Map.map t_T t_U) (a: t_T) : t_U = Map.get self a
  
  meta "rewrite_def" function index_Mapping_T_U
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function push_front_U [@inline:trivial] (self: Seq.seq t_U) (x: t_U) : Seq.seq t_U = Seq.cons x self
  
  meta "rewrite_def" function push_front_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq t_T
  
  constant m : Map.map t_T t_U
  
  function map_T (self: Seq.seq t_T) (m: Map.map t_T t_U) : Seq.seq t_U
  
  goal vc_map_T: if Seq.length self = 0 then
      let result = Seq.empty: Seq.seq t_U in [@stop_split] [@expl:map_T ensures] ([@stop_split] [@expl:map ensures #0] Seq.length result
        = Seq.length self)
      /\ ([@stop_split] [@expl:map ensures #1] forall i: int. 0 <= i /\ i < Seq.length self
        -> Seq.get result i = index_Mapping_T_U m (Seq.get self i))
    else
      ([@expl:variant decreases] well_founded_relation_Int (Seq.length self) (Seq.length (tail_T self)))
      /\ (([@stop_split] [@expl:map ensures] ([@stop_split] [@expl:map ensures #0] Seq.length (map_T (tail_T self) m)
          = Seq.length (tail_T self))
        /\ ([@stop_split] [@expl:map ensures #1] forall i: int. 0 <= i /\ i < Seq.length (tail_T self)
          -> Seq.get (map_T (tail_T self) m) i = index_Mapping_T_U m (Seq.get (tail_T self) i)))
      -> (let result = push_front_U (map_T (tail_T self) m) (Map.get m (Seq.get self 0)) in [@stop_split] [@expl:map_T ensures] ([@stop_split] [@expl:map ensures #0] Seq.length result
        = Seq.length self)
      /\ ([@stop_split] [@expl:map ensures #1] forall i: int. 0 <= i /\ i < Seq.length self
        -> Seq.get result i = index_Mapping_T_U m (Seq.get self i))))

end
module M_logic__seq__impl_Seq_T__flat_map (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_T
  
  type t_U
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq t_T
  
  constant other : Map.map t_T (Seq.seq t_U)
  
  function flat_map_T (self: Seq.seq t_T) (other: Map.map t_T (Seq.seq t_U)) : Seq.seq t_U
  
  goal vc_flat_map_T: if Seq.length self = 0 then
      true
    else
      [@expl:variant decreases] well_founded_relation_Int (Seq.length self) (Seq.length (tail_T self))

end
module M_logic__seq__impl_Seq_T__concat_contains (* logic::seq::Seq<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_T
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function concat_contains_T : ()
  
  goal vc_concat_contains_T:
    [@stop_split] [@expl:concat_contains ensures] forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a b) x
        = contains_T a x
      \/ contains_T b x
end
module M_logic__seq__impl_Seq_Seq_T__flatten (* logic::seq::Seq<logic::seq::Seq<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_T
  
  function tail_Seq_T (self: Seq.seq (Seq.seq t_T)) : Seq.seq (Seq.seq t_T) = Seq.([..]) self 1 (Seq.length self)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : Seq.seq (Seq.seq t_T)
  
  function flatten_T (self: Seq.seq (Seq.seq t_T)) : Seq.seq t_T
  
  goal vc_flatten_T: if Seq.length self = 0 then
      true
    else
      [@expl:variant decreases] well_founded_relation_Int (Seq.length self) (Seq.length (tail_Seq_T self))

end
module M_logic__seq__impl_Index_for_Seq_T__index (* <logic::seq::Seq<T> as std::ops::Index<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  let rec get_ghost_T (self: Seq.seq t_T) (index: int) (return (x: t_Option_ref_T)) =
    {[@stop_split] [@expl:get_ghost 'self' type invariant] inv_ref_Seq_T self}
    any
    [ return (result: t_Option_ref_T) ->
    {[@stop_split] [@expl:get_ghost_T ensures] ([@stop_split] [@expl:get_ghost result type invariant] inv_Option_ref_T result)
      /\ ([@stop_split] [@expl:get_ghost ensures] match get_T self index with
        | None'0 -> result = None
        | Some'0 v -> result = Some v
        end)}
      (! return {result}) ]
  
  let rec unwrap_ref_T (self_: t_Option_ref_T) (return (x: t_T)) =
    {[@stop_split] [@expl:unwrap_ref_T requires] ([@stop_split] [@expl:unwrap 'self_' type invariant] inv_Option_ref_T self_)
    /\ ([@stop_split] [@expl:unwrap requires] self_ <> None)}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:unwrap_ref_T ensures] ([@stop_split] [@expl:unwrap result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:unwrap ensures] Some result = self_)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_Seq_T (self: Seq.seq t_T) (index: int) (return (x: t_T)) =
    {[@stop_split] [@expl:index_Seq_T requires] ([@stop_split] [@expl:index 'self' type invariant] inv_ref_Seq_T self)
    /\ ([@stop_split] [@expl:index requires] 0 <= index /\ index < Seq.length self)}
    (! bb0
    [ bb0 = s0
      [ s0 = get_ghost_T {self} {index} (fun (_x: t_Option_ref_T) -> [ &_10 <- _x ] s1)
      | s1 = unwrap_ref_T {_10} (fun (_x: t_T) -> [ &_9 <- _x ] s2)
      | s2 = [ &_ret <- _9 ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l ()
    | & self: Seq.seq t_T = self
    | & index: int = index
    | & _9: t_T = Any.any_l ()
    | & _10: t_Option_ref_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:index_Seq_T ensures] ([@stop_split] [@expl:index result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:index ensures] result = Seq.get self index)}
      (! return {result}) ]
end
module M_logic__seq__impl_IndexMut_for_Seq_T__index_mut (* <logic::seq::Seq<T> as std::ops::IndexMut<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  type t_Option_refmut_T = None | Some (MutBorrow.t t_T)
  
  predicate invariant_refmut_Seq_T [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) =
    inv_Seq_T self.current /\ inv_Seq_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Seq_T
  
  predicate inv_refmut_Seq_T [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = invariant_refmut_Seq_T _1
  
  meta "rewrite_def" predicate inv_refmut_Seq_T
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate inv_Option_refmut_T (_1: t_Option_refmut_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_refmut_T [inv_Option_refmut_T x]. inv_Option_refmut_T x
      = match x with
        | None -> true
        | Some f0 -> inv_refmut_T f0
        end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  let rec get_mut_ghost_T (self: MutBorrow.t (Seq.seq t_T)) (index: int) (return (x: t_Option_refmut_T)) =
    {[@stop_split] [@expl:get_mut_ghost 'self' type invariant] inv_refmut_Seq_T self}
    any
    [ return (result: t_Option_refmut_T) ->
    {[@stop_split] [@expl:get_mut_ghost_T ensures] ([@stop_split] [@expl:get_mut_ghost result type invariant] inv_Option_refmut_T result)
      /\ ([@stop_split] [@expl:get_mut_ghost ensures #0] match result with
          | None -> get_T self.current index = None'0 /\ self.current = self.final
          | Some r -> get_T self.current index = Some'0 (r.current) /\ r.final = Seq.get self.final index
          end)
      /\ ([@stop_split] [@expl:get_mut_ghost ensures #1] forall i: int. i <> index
          -> get_T self.current i = get_T self.final i)
      /\ ([@stop_split] [@expl:get_mut_ghost ensures #2] Seq.length self.current = Seq.length self.final)}
      (! return {result}) ]
  
  let rec unwrap_refmut_T (self_: t_Option_refmut_T) (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:unwrap_refmut_T requires] ([@stop_split] [@expl:unwrap 'self_' type invariant] inv_Option_refmut_T self_)
    /\ ([@stop_split] [@expl:unwrap requires] self_ <> None)}
    any
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:unwrap_refmut_T ensures] ([@stop_split] [@expl:unwrap result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:unwrap ensures] Some result = self_)}
      (! return {result}) ]
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate resolve_refmut_Seq_T [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Seq_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec index_mut_Seq_T (self: MutBorrow.t (Seq.seq t_T)) (index: int) (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:index_mut_Seq_T requires] ([@stop_split] [@expl:index_mut 'self' type invariant] inv_refmut_Seq_T self)
    /\ ([@stop_split] [@expl:index_mut requires] 0 <= index /\ index < Seq.length self.current)}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Seq.seq t_T> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t (Seq.seq t_T)) ->
            [ &_17 <- _bor ] -{inv_Seq_T _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
        [ _ck -> (! {[@expl:type invariant] inv_Seq_T self.current} any) ]
      | s1 = get_mut_ghost_T {_17} {index} (fun (_x: t_Option_refmut_T) -> [ &_16 <- _x ] s2)
      | s2 = unwrap_refmut_T {_16} (fun (_x: MutBorrow.t t_T) -> [ &_15 <- _x ] s3)
      | s3 = MutBorrow.borrow_final <t_T> {_15.current} {MutBorrow.get_id _15}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_3 <- _bor ] -{inv_T _bor.final}-
            [ &_15 <- { _15 with current = _bor.final } ] s4)
        [ _ck -> (! {[@expl:type invariant] inv_T _15.current} any) ]
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _15} any) ]
      | s5 = -{resolve_refmut_T _15}- s6
      | s6 = MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_ret <- _bor ] -{inv_T _bor.final}-
            [ &_3 <- { _3 with current = _bor.final } ] s7) [ _ck -> (! {[@expl:type invariant] inv_T _3.current} any) ]
      | s7 = s8 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _3} any) ]
      | s8 = -{resolve_refmut_T _3}- s9
      | s9 = s10 [ _ck -> (! {[@expl:type invariant] inv_refmut_Seq_T self} any) ]
      | s10 = -{resolve_refmut_Seq_T self}- s11
      | s11 = return {_ret} ] ]
    [ & _ret: MutBorrow.t t_T = Any.any_l ()
    | & self: MutBorrow.t (Seq.seq t_T) = self
    | & index: int = index
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _15: MutBorrow.t t_T = Any.any_l ()
    | & _16: t_Option_refmut_T = Any.any_l ()
    | & _17: MutBorrow.t (Seq.seq t_T) = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:index_mut_Seq_T ensures] ([@stop_split] [@expl:index_mut result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:index_mut ensures #0] Seq.length self.current = Seq.length self.final)
      /\ ([@stop_split] [@expl:index_mut ensures #1] result.current = Seq.get self.current index
        /\ result.final = Seq.get self.final index)
      /\ ([@stop_split] [@expl:index_mut ensures #2] forall i: int. i <> index
        -> get_T self.current i = get_T self.final i)}
      (! return {result}) ]
end
module M_logic__seq__impl_Plain_for_Seq_T__into_ghost (* <logic::seq::Seq<T> as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.Int128
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_Ghost_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_Ghost_Seq_T
  
  predicate inv_Ghost_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Ghost_Seq_T _1
  
  meta "rewrite_def" predicate inv_Ghost_Seq_T
  
  let rec new_T (return (x: Seq.seq t_T)) = any
    [ return (result: Seq.seq t_T) ->
    {[@stop_split] [@expl:new_T ensures] ([@stop_split] [@expl:new result type invariant] inv_Ghost_Seq_T result)
      /\ ([@stop_split] [@expl:new ensures] result = (Seq.empty: Seq.seq t_T))}
      (! return {result}) ]
  
  let rec into_inner_Seq_T (self: Seq.seq t_T) (return (x: Seq.seq t_T)) =
    {[@stop_split] [@expl:into_inner 'self' type invariant] inv_Ghost_Seq_T self}
    any
    [ return (result: Seq.seq t_T) ->
    {[@stop_split] [@expl:into_inner_Seq_T ensures] ([@stop_split] [@expl:into_inner result type invariant] inv_Seq_T result)
      /\ ([@stop_split] [@expl:into_inner ensures] result = self)}
      (! return {result}) ]
  
  let rec into_ghost_Int (self: int) (return (x: int)) = any
    [ return (result: int) -> {[@stop_split] [@expl:into_ghost ensures] result = self} (! return {result}) ]
  
  let rec into_inner_Int (self: int) (return (x: int)) = any
    [ return (result: int) -> {[@stop_split] [@expl:into_inner ensures] result = self} (! return {result}) ]
  
  let rec new (value: Int128.t) (return (x: int)) = any
    [ return (result: int) -> {[@stop_split] [@expl:new ensures] result = Int128.to_int value} (! return {result}) ]
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  let rec lt_Int (self: int) (other: int) (return (x: bool)) = any
    [ return (result: bool) -> {[@stop_split] [@expl:lt ensures] result = (self < other)} (! return {result}) ]
  
  predicate invariant_Ghost_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_Ghost_T
  
  predicate inv_Ghost_T [@inline:trivial] (_1: t_T) = invariant_Ghost_T _1
  
  meta "rewrite_def" predicate inv_Ghost_T
  
  let rec into_ghost_T (self: t_T) (return (x: t_T)) = any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:into_ghost_T ensures] ([@stop_split] [@expl:into_ghost result type invariant] inv_Ghost_T result)
      /\ ([@stop_split] [@expl:into_ghost ensures] result = self)}
      (! return {result}) ]
  
  let rec into_inner_T (self: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:into_inner 'self' type invariant] inv_Ghost_T self}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:into_inner_T ensures] ([@stop_split] [@expl:into_inner result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:into_inner ensures] result = self)}
      (! return {result}) ]
  
  predicate invariant_refmut_Seq_T [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) =
    inv_Seq_T self.current /\ inv_Seq_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Seq_T
  
  predicate inv_refmut_Seq_T [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = invariant_refmut_Seq_T _1
  
  meta "rewrite_def" predicate inv_refmut_Seq_T
  
  let rec push_back_ghost_T (self: MutBorrow.t (Seq.seq t_T)) (x: t_T) (return (x'0: ())) =
    {[@stop_split] [@expl:push_back_ghost_T requires] ([@stop_split] [@expl:push_back_ghost 'self' type invariant] inv_refmut_Seq_T self)
    /\ ([@stop_split] [@expl:push_back_ghost 'x' type invariant] inv_T x)}
    any
    [ return (result: ()) -> {[@stop_split] [@expl:push_back_ghost ensures] self.final = Seq.snoc self.current x}
      (! return {result}) ]
  
  let rec add_Int (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {[@stop_split] [@expl:add ensures] result = self + other} (! return {result}) ]
  
  let rec new_Seq_T (x: Seq.seq t_T) (return (x'0: Seq.seq t_T)) =
    {[@stop_split] [@expl:new 'x' type invariant] inv_Seq_T x}
    any
    [ return (result: Seq.seq t_T) ->
    {[@stop_split] [@expl:new_Seq_T ensures] ([@stop_split] [@expl:new result type invariant] inv_Ghost_Seq_T result)
      /\ ([@stop_split] [@expl:new ensures] result = x)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_ghost_Seq_T (snap: Seq.seq t_T) (return (x: Seq.seq t_T)) = (! bb0
    [ bb0 = s0
      [ s0 = new_T (fun (_x: Seq.seq t_T) -> [ &_6 <- _x ] s1)
      | s1 = into_inner_Seq_T {_6} (fun (_x: Seq.seq t_T) -> [ &res <- _x ] s2)
      | s2 = [ &len <- Seq.length snap ] s3
      | s3 = into_ghost_Int {len} (fun (_x: int) -> [ &_11 <- _x ] s4)
      | s4 = into_inner_Int {_11} (fun (_x: int) -> [ &len'0 <- _x ] s5)
      | s5 = new {(0: Int128.t)} (fun (_x: int) -> [ &_14 <- _x ] s6)
      | s6 = into_inner_Int {_14} (fun (_x: int) -> [ &i <- _x ] s7)
      | s7 = bb8 ]
    | bb8 = bb8invariant
      [ bb8 = {[@expl:loop variant] well_founded_relation_Int variant_old_bb8 (len'0 - i)} bb8invariant
      | bb8invariant = {[@expl:inferred invariant: type invariant] inv_Seq_T res}
        {[@expl:loop invariant #0] i <= len'0}
        {[@expl:loop invariant #1] Seq.length res = i}
        {[@expl:loop invariant #2] forall j: int. 0 <= j /\ j < i -> Seq.get res j = Seq.get snap j}
        (! [ &variant_old_bb8 <- len'0 - i ] s0)
        [ s0 = lt_Int {i} {len'0} (fun (_x: bool) -> [ &_31 <- _x ] s1)
        | s1 = any [ br0 -> {_31 = false} (! bb19) | br1 -> {_31} (! bb11) ] ]
        [ bb11 = s0
          [ s0 = [ &elem <- Seq.get snap i ] s1
          | s1 = into_ghost_T {elem} (fun (_x: t_T) -> [ &_41 <- _x ] s2)
          | s2 = into_inner_T {_41} (fun (_x: t_T) -> [ &_40 <- _x ] s3)
          | s3 = MutBorrow.borrow_mut <Seq.seq t_T> {res}
              (fun (_bor: MutBorrow.t (Seq.seq t_T)) ->
                [ &_39 <- _bor ] -{inv_Seq_T _bor.final}-
                [ &res <- _bor.final ] s4) [ _ck -> (! {[@expl:type invariant] inv_Seq_T res} any) ]
          | s4 = push_back_ghost_T {_39} {_40} (fun (_x: ()) -> [ &_38 <- _x ] s5)
          | s5 = new {(1: Int128.t)} (fun (_x: int) -> [ &_46 <- _x ] s6)
          | s6 = into_inner_Int {_46} (fun (_x: int) -> [ &_45 <- _x ] s7)
          | s7 = add_Int {i} {_45} (fun (_x: int) -> [ &_43 <- _x ] s8)
          | s8 = [ &i <- _43 ] s9
          | s9 = bb8 ] ] ]
    | bb19 = s0 [ s0 = new_Seq_T {res} (fun (_x: Seq.seq t_T) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Seq.seq t_T = Any.any_l ()
    | & snap: Seq.seq t_T = snap
    | & res: Seq.seq t_T = Any.any_l ()
    | & _6: Seq.seq t_T = Any.any_l ()
    | & len: int = Any.any_l ()
    | & len'0: int = Any.any_l ()
    | & _11: int = Any.any_l ()
    | & i: int = Any.any_l ()
    | & _14: int = Any.any_l ()
    | & _31: bool = Any.any_l ()
    | & elem: t_T = Any.any_l ()
    | & _38: () = Any.any_l ()
    | & _39: MutBorrow.t (Seq.seq t_T) = Any.any_l ()
    | & _40: t_T = Any.any_l ()
    | & _41: t_T = Any.any_l ()
    | & _43: int = Any.any_l ()
    | & _45: int = Any.any_l ()
    | & _46: int = Any.any_l ()
    | & variant_old_bb8: int = Any.any_l () ])
    [ return (result: Seq.seq t_T) ->
    {[@stop_split] [@expl:into_ghost_Seq_T ensures] ([@stop_split] [@expl:into_ghost result type invariant] inv_Ghost_Seq_T result)
      /\ ([@stop_split] [@expl:into_ghost ensures] result = snap)}
      (! return {result}) ]
end
module M_logic__seq__impl_IntoIterator_for_Seq_T__into_iter (* <logic::seq::Seq<T> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter_Seq_T (self: Seq.seq t_T) (return (x: t_SeqIter_T)) =
    {[@stop_split] [@expl:into_iter 'self' type invariant] inv_Seq_T self}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { inner = self } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_SeqIter_T = Any.any_l () | & self: Seq.seq t_T = self ])
    [ return (result: t_SeqIter_T) ->
    {[@stop_split] [@expl:into_iter_Seq_T ensures] ([@stop_split] [@expl:into_iter result type invariant] inv_SeqIter_T result)
      /\ ([@stop_split] [@expl:into_iter ensures] view_SeqIter_T result = self)}
      (! return {result}) ]
end
module M_logic__seq__impl_Iterator_for_SeqIter_T__next (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  type t_Option_T = None | Some t_T
  
  predicate invariant_refmut_Seq_T [@inline:trivial] (self: MutBorrow.t (Seq.seq t_T)) =
    inv_Seq_T self.current /\ inv_Seq_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Seq_T
  
  predicate inv_refmut_Seq_T [@inline:trivial] (_1: MutBorrow.t (Seq.seq t_T)) = invariant_refmut_Seq_T _1
  
  meta "rewrite_def" predicate inv_refmut_Seq_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  let rec pop_front_ghost_T (self: MutBorrow.t (Seq.seq t_T)) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:pop_front_ghost 'self' type invariant] inv_refmut_Seq_T self}
    any
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:pop_front_ghost_T ensures] ([@stop_split] [@expl:pop_front_ghost result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:pop_front_ghost ensures] match result with
        | None -> self.current = (Seq.empty: Seq.seq t_T) /\ self.current = self.final
        | Some r -> Seq.length self.current > 0 /\ r = Seq.get self.current 0 /\ self.final = tail_T self.current
        end)}
      (! return {result}) ]
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  predicate invariant_refmut_SeqIter_T [@inline:trivial] (self: MutBorrow.t t_SeqIter_T) =
    inv_SeqIter_T self.current /\ inv_SeqIter_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_SeqIter_T
  
  predicate inv_refmut_SeqIter_T [@inline:trivial] (_1: MutBorrow.t t_SeqIter_T) = invariant_refmut_SeqIter_T _1
  
  meta "rewrite_def" predicate inv_refmut_SeqIter_T
  
  predicate resolve_refmut_SeqIter_T [@inline:trivial] (_1: MutBorrow.t t_SeqIter_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_SeqIter_T
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  function produces_trans_SeqIter_T (a: t_SeqIter_T) (ab: Seq.seq t_T) (b: t_SeqIter_T) (bc: Seq.seq t_T) (c: t_SeqIter_T) : ()
   = ()
  
  axiom produces_trans_SeqIter_T_spec:
    forall a: t_SeqIter_T, ab: Seq.seq t_T, b: t_SeqIter_T, bc: Seq.seq t_T, c: t_SeqIter_T. produces_SeqIter_T a ab b
      -> produces_SeqIter_T b bc c -> produces_SeqIter_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIter_T (self: t_SeqIter_T) : () = ()
  
  axiom produces_refl_SeqIter_T_spec: forall self: t_SeqIter_T. produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIter_T (self: MutBorrow.t t_SeqIter_T) = view_SeqIter_T self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_SeqIter_T (self: MutBorrow.t t_SeqIter_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:next 'self' type invariant] inv_refmut_SeqIter_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Seq.seq t_T> {self.current.inner} {MutBorrow.inherit_id (MutBorrow.get_id self) 0}
          (fun (_bor: MutBorrow.t (Seq.seq t_T)) ->
            [ &_4 <- _bor ] -{inv_Seq_T _bor.final}-
            [ &self <- { self with current = { inner = _bor.final } } ] s1)
        [ _ck -> (! {[@expl:type invariant] inv_Seq_T self.current.inner} any) ]
      | s1 = pop_front_ghost_T {_4} (fun (_x: t_Option_T) -> [ &_ret <- _x ] s2)
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_SeqIter_T self} any) ]
      | s3 = -{resolve_refmut_SeqIter_T self}- s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self: MutBorrow.t t_SeqIter_T = self
    | & _4: MutBorrow.t (Seq.seq t_T) = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:next_SeqIter_T ensures] ([@stop_split] [@expl:next result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:next ensures] match result with
        | None -> completed_SeqIter_T self
        | Some v -> produces_SeqIter_T self.current (Seq.singleton v) self.final
        end)}
      (! return {result}) ]
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_refl (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIter_T
  
  function produces_refl_SeqIter_T (self: t_SeqIter_T) : ()
  
  goal vc_produces_refl_SeqIter_T:
    [@stop_split] [@expl:produces_refl ensures] produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_trans (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_SeqIter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_SeqIter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_SeqIter_T
  
  function produces_trans_SeqIter_T (a: t_SeqIter_T) (ab: Seq.seq t_T) (b: t_SeqIter_T) (bc: Seq.seq t_T) (c: t_SeqIter_T) : ()
  
  goal vc_produces_trans_SeqIter_T: produces_SeqIter_T a ab b
    -> produces_SeqIter_T b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_SeqIter_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IntoIterator_for_ref_Seq_T__into_iter (* <&'a logic::seq::Seq<T> as std::iter::IntoIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  let rec len_ghost_T (self: Seq.seq t_T) (return (x: int)) =
    {[@stop_split] [@expl:len_ghost 'self' type invariant] inv_ref_Seq_T self}
    any
    [ return (result: int) -> {[@stop_split] [@expl:len_ghost ensures] result = Seq.length self} (! return {result}) ]
  
  let rec sub_Int (self: int) (other: int) (return (x: int)) = any
    [ return (result: int) -> {[@stop_split] [@expl:sub ensures] result = self - other} (! return {result}) ]
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  predicate invariant_SeqIterRef_T (self: t_SeqIterRef_T) = 0 <= self.index /\ self.index <= Seq.length self.inner
  
  predicate inv_SeqIterRef_T (_1: t_SeqIterRef_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIterRef_T [inv_SeqIterRef_T x]. inv_SeqIterRef_T x
      = (invariant_SeqIterRef_T x /\ inv_ref_Seq_T x.inner)
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_iter_ref_Seq_T (self: Seq.seq t_T) (return (x: t_SeqIterRef_T)) =
    {[@stop_split] [@expl:into_iter 'self' type invariant] inv_ref_Seq_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = len_ghost_T {self} (fun (_x: int) -> [ &_6 <- _x ] s1)
      | s1 = len_ghost_T {self} (fun (_x: int) -> [ &_8 <- _x ] s2)
      | s2 = sub_Int {_6} {_8} (fun (_x: int) -> [ &_5 <- _x ] s3)
      | s3 = [ &_ret <- { inner = self; index = _5 } ] s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_SeqIterRef_T = Any.any_l ()
    | & self: Seq.seq t_T = self
    | & _5: int = Any.any_l ()
    | & _6: int = Any.any_l ()
    | & _8: int = Any.any_l () ])
    [ return (result: t_SeqIterRef_T) ->
    {[@stop_split] [@expl:into_iter_ref_Seq_T ensures] ([@stop_split] [@expl:into_iter result type invariant] inv_SeqIterRef_T result)
      /\ ([@stop_split] [@expl:into_iter ensures] view_SeqIterRef_T result = self)}
      (! return {result}) ]
end
module M_logic__seq__impl_Iterator_for_SeqIterRef_T__next (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  type t_Option_ref_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  let rec get_ghost_T (self: Seq.seq t_T) (index'0: int) (return (x: t_Option_ref_T)) =
    {[@stop_split] [@expl:get_ghost 'self' type invariant] inv_ref_Seq_T self}
    any
    [ return (result: t_Option_ref_T) ->
    {[@stop_split] [@expl:get_ghost_T ensures] ([@stop_split] [@expl:get_ghost result type invariant] inv_Option_ref_T result)
      /\ ([@stop_split] [@expl:get_ghost ensures] match get_T self index'0 with
        | None'0 -> result = None
        | Some'0 v -> result = Some v
        end)}
      (! return {result}) ]
  
  predicate invariant_SeqIterRef_T (self: t_SeqIterRef_T) = 0 <= self.index /\ self.index <= Seq.length self.inner
  
  predicate inv_SeqIterRef_T (_1: t_SeqIterRef_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_SeqIterRef_T [inv_SeqIterRef_T x]. inv_SeqIterRef_T x
      = (invariant_SeqIterRef_T x /\ inv_ref_Seq_T x.inner)
  
  predicate invariant_refmut_SeqIterRef_T [@inline:trivial] (self: MutBorrow.t t_SeqIterRef_T) =
    inv_SeqIterRef_T self.current /\ inv_SeqIterRef_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_SeqIterRef_T
  
  predicate inv_refmut_SeqIterRef_T [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef_T) =
    invariant_refmut_SeqIterRef_T _1
  
  meta "rewrite_def" predicate inv_refmut_SeqIterRef_T
  
  predicate resolve_refmut_SeqIterRef_T [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_SeqIterRef_T
  
  let rec elim_Some (_x: t_Option_ref_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  let rec incr_ghost (self: MutBorrow.t int) (return (x: ())) = any
    [ return (result: ()) -> {[@stop_split] [@expl:incr_ghost ensures] self.final = self.current + 1}
      (! return {result}) ]
  
  function tail_T (self: Seq.seq t_T) : Seq.seq t_T = Seq.([..]) self 1 (Seq.length self)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  function produces_trans_SeqIterRef_T (a: t_SeqIterRef_T) (ab: Seq.seq t_T) (b: t_SeqIterRef_T) (bc: Seq.seq t_T) (c: t_SeqIterRef_T) : ()
   = ()
  
  axiom produces_trans_SeqIterRef_T_spec:
    forall a: t_SeqIterRef_T, ab: Seq.seq t_T, b: t_SeqIterRef_T, bc: Seq.seq t_T, c: t_SeqIterRef_T. produces_SeqIterRef_T a ab b
      -> produces_SeqIterRef_T b bc c -> produces_SeqIterRef_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIterRef_T (self: t_SeqIterRef_T) : () = ()
  
  axiom produces_refl_SeqIterRef_T_spec:
    forall self: t_SeqIterRef_T. produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIterRef_T (self: MutBorrow.t t_SeqIterRef_T) =
    view_SeqIterRef_T self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_SeqIterRef_T (self: MutBorrow.t t_SeqIterRef_T) (return (x: t_Option_ref_T)) =
    {[@stop_split] [@expl:next 'self' type invariant] inv_refmut_SeqIterRef_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_before <- view_SeqIterRef_T self.current ] s1
      | s1 = get_ghost_T {self.current.inner} {self.current.index} (fun (_x: t_Option_ref_T) -> [ &_7 <- _x ] s2)
      | s2 = any [ br0 -> {_7 = None} (! bb6) | br1 (x0: t_T) -> {_7 = Some x0} (! bb4) ] ]
    | bb6 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_SeqIterRef_T self} any) ]
      | s1 = -{resolve_refmut_SeqIterRef_T self}- s2
      | s2 = {[@expl:assertion] self.current.index = Seq.length self.current.inner} s3
      | s3 = {[@expl:assertion] view_SeqIterRef_T self.current = (Seq.empty: Seq.seq t_T)} s4
      | s4 = [ &_ret <- None ] s5
      | s5 = return {_ret} ]
    | bb4 = s0
      [ s0 = elim_Some {_7} (fun (r0: t_T) -> [ &res <- r0 ] s1)
      | s1 = MutBorrow.borrow_final <int> {self.current.index} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_bor: MutBorrow.t int) ->
            [ &_13 <- _bor ] [ &self <- { self with current = { self.current with index = _bor.final } } ] s2)
      | s2 = incr_ghost {_13} (fun (_x: ()) -> [ &_12 <- _x ] s3)
      | s3 = s4 [ _ck -> (! {[@expl:type invariant] inv_refmut_SeqIterRef_T self} any) ]
      | s4 = -{resolve_refmut_SeqIterRef_T self}- s5
      | s5 = {[@expl:assertion] view_SeqIterRef_T self.current = tail_T _before} s6
      | s6 = [ &_ret <- Some res ] s7
      | s7 = return {_ret} ] ]
    [ & _ret: t_Option_ref_T = Any.any_l ()
    | & self: MutBorrow.t t_SeqIterRef_T = self
    | & _before: Seq.seq t_T = Any.any_l ()
    | & _7: t_Option_ref_T = Any.any_l ()
    | & res: t_T = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & _13: MutBorrow.t int = Any.any_l () ])
    [ return (result: t_Option_ref_T) ->
    {[@stop_split] [@expl:next_SeqIterRef_T ensures] ([@stop_split] [@expl:next result type invariant] inv_Option_ref_T result)
      /\ ([@stop_split] [@expl:next ensures] match result with
        | None -> completed_SeqIterRef_T self
        | Some v -> produces_SeqIterRef_T self.current (Seq.singleton v) self.final
        end)}
      (! return {result}) ]
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_refl (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIterRef_T
  
  function produces_refl_SeqIterRef_T (self: t_SeqIterRef_T) : ()
  
  goal vc_produces_refl_SeqIterRef_T:
    [@stop_split] [@expl:produces_refl ensures] produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_trans (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_SeqIterRef_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_SeqIterRef_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_SeqIterRef_T
  
  function produces_trans_SeqIterRef_T (a: t_SeqIterRef_T) (ab: Seq.seq t_T) (b: t_SeqIterRef_T) (bc: Seq.seq t_T) (c: t_SeqIterRef_T) : ()
  
  goal vc_produces_trans_SeqIterRef_T: produces_SeqIterRef_T a ab b
    -> produces_SeqIterRef_T b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_SeqIterRef_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_Resolve_for_SeqIter_T__resolve_coherence (* <logic::seq::SeqIter<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  type t_Option_T = None | Some t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  predicate resolve_Seq_T (self: Seq.seq t_T) = forall i: int. resolve_Option_T (get_T self i)
  
  predicate resolve_Seq_T'0 (_1: Seq.seq t_T)
  
  axiom resolve_axiom'0: forall x: Seq.seq t_T [resolve_Seq_T'0 x]. resolve_Seq_T'0 x -> resolve_Seq_T x
  
  predicate structural_resolve_SeqIter_T (_1: t_SeqIter_T) = resolve_Seq_T'0 _1.inner
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate resolve_SeqIter_T [@inline:trivial] (self: t_SeqIter_T) = resolve_Seq_T'0 (view_SeqIter_T self)
  
  meta "rewrite_def" predicate resolve_SeqIter_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_SeqIter_T
  
  function resolve_coherence_SeqIter_T (self: t_SeqIter_T) : ()
  
  goal vc_resolve_coherence_SeqIter_T: structural_resolve_SeqIter_T self
    -> ([@stop_split] [@expl:resolve_coherence ensures] resolve_SeqIter_T self)
end
module M_logic__seq__flat_map_singleton
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  
  type t_A
  
  type t_B
  
  function tail_A (self: Seq.seq t_A) : Seq.seq t_A = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map_A (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  axiom flat_map_A_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map_A self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq t_B
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map_A (tail_A self) other)
      )
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  function flat_map_singleton_A : ()
  
  goal vc_flat_map_singleton_A:
    [@stop_split] [@expl:flat_map_singleton ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.singleton x) f
      = Map.get f x
end
module M_logic__seq__flat_map_push_back
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_A
  
  type t_B
  
  function tail_A (self: Seq.seq t_A) : Seq.seq t_A = Seq.([..]) self 1 (Seq.length self)
  
  function flat_map_A (self: Seq.seq t_A) (other: Map.map t_A (Seq.seq t_B)) : Seq.seq t_B
  
  axiom flat_map_A_def: forall self: Seq.seq t_A, other: Map.map t_A (Seq.seq t_B). flat_map_A self other
      = (if Seq.length self = 0 then
        Seq.empty: Seq.seq t_B
      else
        Seq.(++) (Map.get other (Seq.get self 0)) (flat_map_A (tail_A self) other)
      )
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant xs : Seq.seq t_A
  
  function flat_map_push_back_A (xs: Seq.seq t_A) : ()
  
  goal vc_flat_map_push_back_A: if Seq.length xs > 0 then
      ([@expl:variant decreases] well_founded_relation_Int (Seq.length xs) (Seq.length (tail_A xs)))
      /\ (([@stop_split] [@expl:flat_map_push_back ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.snoc (tail_A xs) x) f
          = Seq.(++) (flat_map_A (tail_A xs) f) (Map.get f x))
      -> (let _ = flat_map_push_back_A (tail_A xs) in (forall x: t_A. Seq.snoc (tail_A xs) x = tail_A (Seq.snoc xs x))
      && ([@stop_split] [@expl:flat_map_push_back ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.snoc xs x) f
        = Seq.(++) (flat_map_A xs f) (Map.get f x))))
    else
      [@stop_split] [@expl:flat_map_push_back ensures] forall x: t_A, f: Map.map t_A (Seq.seq t_B). flat_map_A (Seq.snoc xs x) f
        = Seq.(++) (flat_map_A xs f) (Map.get f x)

end
module M_logic__well_founded__impl_WellFounded_for_u8__no_infinite_decreasing_sequence (* <u8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom eq_cmp_u8_spec: forall x: UInt8.t, y: UInt8.t. (x = y) = (cmp_log_u8 x y = Equal)
  
  function antisym2_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym2_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Greater -> cmp_log_u8 y x = Less
  
  function antisym1_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym1_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Less -> cmp_log_u8 y x = Greater
  
  function trans_u8 (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  axiom trans_u8_spec: forall x: UInt8.t, y: UInt8.t, z: UInt8.t, o: t_Ordering. cmp_log_u8 x y = o
      -> cmp_log_u8 y z = o -> cmp_log_u8 x z = o
  
  function refl_u8 (x: UInt8.t) : ()
  
  axiom refl_u8_spec: forall x: UInt8.t. cmp_log_u8 x x = Equal
  
  function cmp_gt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_gt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.gt x y = (cmp_log_u8 x y = Greater)
  
  function cmp_ge_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_ge_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.ge x y = (cmp_log_u8 x y <> Less)
  
  function cmp_lt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_lt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.lt x y = (cmp_log_u8 x y = Less)
  
  function cmp_le_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_le_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.le x y = (cmp_log_u8 x y <> Greater)
  
  predicate well_founded_relation_u8 [@inline:trivial] (self: UInt8.t) (other: UInt8.t) = UInt8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u8
  
  function index_Mapping_Int_u8 [@inline:trivial] (self: Map.map int UInt8.t) (a: int) : UInt8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u8
  
  constant const_MIN: UInt8.t = (0: UInt8.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt8.t
  
  function no_infinite_decreasing_sequence_u8 (s: Map.map int UInt8.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u8:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
          - UInt8.t'int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
      - UInt8.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
      - UInt8.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
      - UInt8.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
        - UInt8.t'int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt8.t'int (index_Mapping_Int_u8 s i)
    - UInt8.t'int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_u8 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u8 (index_Mapping_Int_u8 s result) (index_Mapping_Int_u8 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u16__no_infinite_decreasing_sequence (* <u16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom eq_cmp_u16_spec: forall x: UInt16.t, y: UInt16.t. (x = y) = (cmp_log_u16 x y = Equal)
  
  function antisym2_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym2_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Greater -> cmp_log_u16 y x = Less
  
  function antisym1_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym1_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Less -> cmp_log_u16 y x = Greater
  
  function trans_u16 (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  axiom trans_u16_spec: forall x: UInt16.t, y: UInt16.t, z: UInt16.t, o: t_Ordering. cmp_log_u16 x y = o
      -> cmp_log_u16 y z = o -> cmp_log_u16 x z = o
  
  function refl_u16 (x: UInt16.t) : ()
  
  axiom refl_u16_spec: forall x: UInt16.t. cmp_log_u16 x x = Equal
  
  function cmp_gt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_gt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.gt x y = (cmp_log_u16 x y = Greater)
  
  function cmp_ge_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_ge_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.ge x y = (cmp_log_u16 x y <> Less)
  
  function cmp_lt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_lt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.lt x y = (cmp_log_u16 x y = Less)
  
  function cmp_le_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_le_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.le x y = (cmp_log_u16 x y <> Greater)
  
  predicate well_founded_relation_u16 [@inline:trivial] (self: UInt16.t) (other: UInt16.t) = UInt16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u16
  
  function index_Mapping_Int_u16 [@inline:trivial] (self: Map.map int UInt16.t) (a: int) : UInt16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u16
  
  constant const_MIN: UInt16.t = (0: UInt16.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt16.t
  
  function no_infinite_decreasing_sequence_u16 (s: Map.map int UInt16.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u16:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
          - UInt16.t'int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
      - UInt16.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
      - UInt16.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
      - UInt16.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
        - UInt16.t'int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt16.t'int (index_Mapping_Int_u16 s i)
    - UInt16.t'int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_u16 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u16 (index_Mapping_Int_u16 s result) (index_Mapping_Int_u16 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u32__no_infinite_decreasing_sequence (* <u32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom eq_cmp_u32_spec: forall x: UInt32.t, y: UInt32.t. (x = y) = (cmp_log_u32 x y = Equal)
  
  function antisym2_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym2_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Greater -> cmp_log_u32 y x = Less
  
  function antisym1_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym1_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Less -> cmp_log_u32 y x = Greater
  
  function trans_u32 (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  axiom trans_u32_spec: forall x: UInt32.t, y: UInt32.t, z: UInt32.t, o: t_Ordering. cmp_log_u32 x y = o
      -> cmp_log_u32 y z = o -> cmp_log_u32 x z = o
  
  function refl_u32 (x: UInt32.t) : ()
  
  axiom refl_u32_spec: forall x: UInt32.t. cmp_log_u32 x x = Equal
  
  function cmp_gt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_gt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.gt x y = (cmp_log_u32 x y = Greater)
  
  function cmp_ge_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_ge_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.ge x y = (cmp_log_u32 x y <> Less)
  
  function cmp_lt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_lt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.lt x y = (cmp_log_u32 x y = Less)
  
  function cmp_le_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_le_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.le x y = (cmp_log_u32 x y <> Greater)
  
  predicate well_founded_relation_u32 [@inline:trivial] (self: UInt32.t) (other: UInt32.t) = UInt32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u32
  
  function index_Mapping_Int_u32 [@inline:trivial] (self: Map.map int UInt32.t) (a: int) : UInt32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u32
  
  constant const_MIN: UInt32.t = (0: UInt32.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt32.t
  
  function no_infinite_decreasing_sequence_u32 (s: Map.map int UInt32.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u32:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
          - UInt32.t'int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
      - UInt32.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
      - UInt32.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
      - UInt32.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
        - UInt32.t'int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt32.t'int (index_Mapping_Int_u32 s i)
    - UInt32.t'int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_u32 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u32 (index_Mapping_Int_u32 s result) (index_Mapping_Int_u32 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u64__no_infinite_decreasing_sequence (* <u64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate well_founded_relation_u64 [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u64
  
  function index_Mapping_Int_u64 [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u64
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt64.t
  
  function no_infinite_decreasing_sequence_u64 (s: Map.map int UInt64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u64:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
          - UInt64.t'int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
      - UInt64.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
        - UInt64.t'int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_u64 s i)
    - UInt64.t'int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_u64 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u64 (index_Mapping_Int_u64 s result) (index_Mapping_Int_u64 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_u128__no_infinite_decreasing_sequence (* <u128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom eq_cmp_u128_spec: forall x: UInt128.t, y: UInt128.t. (x = y) = (cmp_log_u128 x y = Equal)
  
  function antisym2_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym2_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Greater -> cmp_log_u128 y x = Less
  
  function antisym1_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym1_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Less -> cmp_log_u128 y x = Greater
  
  function trans_u128 (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  axiom trans_u128_spec: forall x: UInt128.t, y: UInt128.t, z: UInt128.t, o: t_Ordering. cmp_log_u128 x y = o
      -> cmp_log_u128 y z = o -> cmp_log_u128 x z = o
  
  function refl_u128 (x: UInt128.t) : ()
  
  axiom refl_u128_spec: forall x: UInt128.t. cmp_log_u128 x x = Equal
  
  function cmp_gt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_gt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.gt x y = (cmp_log_u128 x y = Greater)
  
  function cmp_ge_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_ge_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.ge x y = (cmp_log_u128 x y <> Less)
  
  function cmp_lt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_lt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.lt x y = (cmp_log_u128 x y = Less)
  
  function cmp_le_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_le_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.le x y = (cmp_log_u128 x y <> Greater)
  
  predicate well_founded_relation_u128 [@inline:trivial] (self: UInt128.t) (other: UInt128.t) = UInt128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u128
  
  function index_Mapping_Int_u128 [@inline:trivial] (self: Map.map int UInt128.t) (a: int) : UInt128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u128
  
  constant const_MIN: UInt128.t = (0: UInt128.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt128.t
  
  function no_infinite_decreasing_sequence_u128 (s: Map.map int UInt128.t) : int
  
  goal vc_no_infinite_decreasing_sequence_u128:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
          - UInt128.t'int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
      - UInt128.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
      - UInt128.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
      - UInt128.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
        - UInt128.t'int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt128.t'int (index_Mapping_Int_u128 s i)
    - UInt128.t'int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_u128 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_u128 (index_Mapping_Int_u128 s result) (index_Mapping_Int_u128 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_usize__no_infinite_decreasing_sequence (* <usize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  predicate well_founded_relation_usize [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_usize
  
  function index_Mapping_Int_usize [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_usize
  
  constant const_MIN: UInt64.t = (0: UInt64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int UInt64.t
  
  function no_infinite_decreasing_sequence_usize (s: Map.map int UInt64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_usize:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
          - UInt64.t'int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
      - UInt64.t'int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
      - UInt64.t'int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
        - UInt64.t'int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> UInt64.t'int (index_Mapping_Int_usize s i)
    - UInt64.t'int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_usize ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_usize (index_Mapping_Int_usize s result) (index_Mapping_Int_usize s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i8__no_infinite_decreasing_sequence (* <i8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom eq_cmp_i8_spec: forall x: Int8.t, y: Int8.t. (x = y) = (cmp_log_i8 x y = Equal)
  
  function antisym2_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym2_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Greater -> cmp_log_i8 y x = Less
  
  function antisym1_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym1_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Less -> cmp_log_i8 y x = Greater
  
  function trans_i8 (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  axiom trans_i8_spec: forall x: Int8.t, y: Int8.t, z: Int8.t, o: t_Ordering. cmp_log_i8 x y = o
      -> cmp_log_i8 y z = o -> cmp_log_i8 x z = o
  
  function refl_i8 (x: Int8.t) : ()
  
  axiom refl_i8_spec: forall x: Int8.t. cmp_log_i8 x x = Equal
  
  function cmp_gt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_gt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.gt x y = (cmp_log_i8 x y = Greater)
  
  function cmp_ge_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_ge_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.ge x y = (cmp_log_i8 x y <> Less)
  
  function cmp_lt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_lt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.lt x y = (cmp_log_i8 x y = Less)
  
  function cmp_le_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_le_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.le x y = (cmp_log_i8 x y <> Greater)
  
  predicate well_founded_relation_i8 [@inline:trivial] (self: Int8.t) (other: Int8.t) = Int8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i8
  
  function index_Mapping_Int_i8 [@inline:trivial] (self: Map.map int Int8.t) (a: int) : Int8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i8
  
  constant const_MIN: Int8.t = (-128: Int8.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int8.t
  
  function no_infinite_decreasing_sequence_i8 (s: Map.map int Int8.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i8:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
          - Int8.to_int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
      - Int8.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
      - Int8.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
      - Int8.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
        - Int8.to_int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int8.to_int (index_Mapping_Int_i8 s i)
    - Int8.to_int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_i8 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i8 (index_Mapping_Int_i8 s result) (index_Mapping_Int_i8 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i16__no_infinite_decreasing_sequence (* <i16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom eq_cmp_i16_spec: forall x: Int16.t, y: Int16.t. (x = y) = (cmp_log_i16 x y = Equal)
  
  function antisym2_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym2_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Greater -> cmp_log_i16 y x = Less
  
  function antisym1_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym1_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Less -> cmp_log_i16 y x = Greater
  
  function trans_i16 (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  axiom trans_i16_spec: forall x: Int16.t, y: Int16.t, z: Int16.t, o: t_Ordering. cmp_log_i16 x y = o
      -> cmp_log_i16 y z = o -> cmp_log_i16 x z = o
  
  function refl_i16 (x: Int16.t) : ()
  
  axiom refl_i16_spec: forall x: Int16.t. cmp_log_i16 x x = Equal
  
  function cmp_gt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_gt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.gt x y = (cmp_log_i16 x y = Greater)
  
  function cmp_ge_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_ge_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.ge x y = (cmp_log_i16 x y <> Less)
  
  function cmp_lt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_lt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.lt x y = (cmp_log_i16 x y = Less)
  
  function cmp_le_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_le_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.le x y = (cmp_log_i16 x y <> Greater)
  
  predicate well_founded_relation_i16 [@inline:trivial] (self: Int16.t) (other: Int16.t) = Int16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i16
  
  function index_Mapping_Int_i16 [@inline:trivial] (self: Map.map int Int16.t) (a: int) : Int16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i16
  
  constant const_MIN: Int16.t = (-32768: Int16.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int16.t
  
  function no_infinite_decreasing_sequence_i16 (s: Map.map int Int16.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i16:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
          - Int16.to_int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
      - Int16.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
      - Int16.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
      - Int16.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
        - Int16.to_int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int16.to_int (index_Mapping_Int_i16 s i)
    - Int16.to_int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_i16 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i16 (index_Mapping_Int_i16 s result) (index_Mapping_Int_i16 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i32__no_infinite_decreasing_sequence (* <i32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_i32_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log_i32 x y = Equal)
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Greater -> cmp_log_i32 y x = Less
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Less -> cmp_log_i32 y x = Greater
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_i32_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log_i32 x y = o
      -> cmp_log_i32 y z = o -> cmp_log_i32 x z = o
  
  function refl_i32 (x: Int32.t) : ()
  
  axiom refl_i32_spec: forall x: Int32.t. cmp_log_i32 x x = Equal
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log_i32 x y = Greater)
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log_i32 x y <> Less)
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log_i32 x y = Less)
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log_i32 x y <> Greater)
  
  predicate well_founded_relation_i32 [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i32
  
  function index_Mapping_Int_i32 [@inline:trivial] (self: Map.map int Int32.t) (a: int) : Int32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i32
  
  constant const_MIN: Int32.t = (-2147483648: Int32.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int32.t
  
  function no_infinite_decreasing_sequence_i32 (s: Map.map int Int32.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i32:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
          - Int32.to_int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
      - Int32.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
      - Int32.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
      - Int32.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
        - Int32.to_int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int32.to_int (index_Mapping_Int_i32 s i)
    - Int32.to_int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_i32 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i32 (index_Mapping_Int_i32 s result) (index_Mapping_Int_i32 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i64__no_infinite_decreasing_sequence (* <i64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_i64_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_i64 x y = Equal)
  
  function antisym2_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Greater -> cmp_log_i64 y x = Less
  
  function antisym1_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Less -> cmp_log_i64 y x = Greater
  
  function trans_i64 (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_i64_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_i64 x y = o
      -> cmp_log_i64 y z = o -> cmp_log_i64 x z = o
  
  function refl_i64 (x: Int64.t) : ()
  
  axiom refl_i64_spec: forall x: Int64.t. cmp_log_i64 x x = Equal
  
  function cmp_gt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_i64 x y = Greater)
  
  function cmp_ge_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_i64 x y <> Less)
  
  function cmp_lt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_i64 x y = Less)
  
  function cmp_le_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_i64 x y <> Greater)
  
  predicate well_founded_relation_i64 [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i64
  
  function index_Mapping_Int_i64 [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i64
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int64.t
  
  function no_infinite_decreasing_sequence_i64 (s: Map.map int Int64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i64:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
          - Int64.to_int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
      - Int64.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
        - Int64.to_int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_i64 s i)
    - Int64.to_int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_i64 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i64 (index_Mapping_Int_i64 s result) (index_Mapping_Int_i64 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_i128__no_infinite_decreasing_sequence (* <i128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom eq_cmp_i128_spec: forall x: Int128.t, y: Int128.t. (x = y) = (cmp_log_i128 x y = Equal)
  
  function antisym2_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym2_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Greater -> cmp_log_i128 y x = Less
  
  function antisym1_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym1_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Less -> cmp_log_i128 y x = Greater
  
  function trans_i128 (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  axiom trans_i128_spec: forall x: Int128.t, y: Int128.t, z: Int128.t, o: t_Ordering. cmp_log_i128 x y = o
      -> cmp_log_i128 y z = o -> cmp_log_i128 x z = o
  
  function refl_i128 (x: Int128.t) : ()
  
  axiom refl_i128_spec: forall x: Int128.t. cmp_log_i128 x x = Equal
  
  function cmp_gt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_gt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.gt x y = (cmp_log_i128 x y = Greater)
  
  function cmp_ge_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_ge_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.ge x y = (cmp_log_i128 x y <> Less)
  
  function cmp_lt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_lt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.lt x y = (cmp_log_i128 x y = Less)
  
  function cmp_le_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_le_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.le x y = (cmp_log_i128 x y <> Greater)
  
  predicate well_founded_relation_i128 [@inline:trivial] (self: Int128.t) (other: Int128.t) = Int128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i128
  
  function index_Mapping_Int_i128 [@inline:trivial] (self: Map.map int Int128.t) (a: int) : Int128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i128
  
  constant const_MIN: Int128.t = (-170141183460469231731687303715884105728: Int128.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int128.t
  
  function no_infinite_decreasing_sequence_i128 (s: Map.map int Int128.t) : int
  
  goal vc_no_infinite_decreasing_sequence_i128:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
          - Int128.to_int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
      - Int128.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
      - Int128.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
      - Int128.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
        - Int128.to_int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int128.to_int (index_Mapping_Int_i128 s i)
    - Int128.to_int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_i128 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_i128 (index_Mapping_Int_i128 s result) (index_Mapping_Int_i128 s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_isize__no_infinite_decreasing_sequence (* <isize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate well_founded_relation_isize [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_isize
  
  function index_Mapping_Int_isize [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_isize
  
  constant const_MIN: Int64.t = (-9223372036854775808: Int64.t)
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  function no_infinite_decreasing_sequence_Int (s: Map.map int int) : int
  
  axiom no_infinite_decreasing_sequence_Int_spec: forall s: Map.map int int. no_infinite_decreasing_sequence_Int s >= 0
  
  axiom no_infinite_decreasing_sequence_Int_spec'0:
    forall s: Map.map int int. not well_founded_relation_Int (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s)) (index_Mapping_Int_Int s (no_infinite_decreasing_sequence_Int s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int Int64.t
  
  function no_infinite_decreasing_sequence_isize (s: Map.map int Int64.t) : int
  
  goal vc_no_infinite_decreasing_sequence_isize:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
          - Int64.to_int const_MIN)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Int (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
      - Int64.to_int const_MIN))) (index_Mapping_Int_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
      - Int64.to_int const_MIN) (no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
        - Int64.to_int const_MIN)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_Int (fun (i: int) -> Int64.to_int (index_Mapping_Int_isize s i)
    - Int64.to_int const_MIN) in [@stop_split] [@expl:no_infinite_decreasing_sequence_isize ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_isize (index_Mapping_Int_isize s result) (index_Mapping_Int_isize s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_ref_T__no_infinite_decreasing_sequence (* <&T as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_ref_T [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_ref_T
  
  function index_Mapping_Int_ref_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_ref_T
  
  function index_Mapping_Int_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T
  
  function no_infinite_decreasing_sequence_T (s: Map.map int t_T) : int
  
  axiom no_infinite_decreasing_sequence_T_spec: forall s: Map.map int t_T. no_infinite_decreasing_sequence_T s >= 0
  
  axiom no_infinite_decreasing_sequence_T_spec'0:
    forall s: Map.map int t_T. not well_founded_relation_T (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s)) (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T
  
  function no_infinite_decreasing_sequence_ref_T (s: Map.map int t_T) : int
  
  goal vc_no_infinite_decreasing_sequence_ref_T:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_ref_T s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i))) (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_ref_T s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_ref_T s i) in [@stop_split] [@expl:no_infinite_decreasing_sequence_ref_T ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_ref_T (index_Mapping_Int_ref_T s result) (index_Mapping_Int_ref_T s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_Box_T_Global__no_infinite_decreasing_sequence (* <std::boxed::Box<T> as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_Box_T_Global [@inline:trivial] (self: t_T) (other: t_T) =
    well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_Box_T_Global
  
  function index_Mapping_Int_Box_T_Global [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Box_T_Global
  
  function index_Mapping_Int_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T
  
  function no_infinite_decreasing_sequence_T (s: Map.map int t_T) : int
  
  axiom no_infinite_decreasing_sequence_T_spec: forall s: Map.map int t_T. no_infinite_decreasing_sequence_T s >= 0
  
  axiom no_infinite_decreasing_sequence_T_spec'0:
    forall s: Map.map int t_T. not well_founded_relation_T (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s)) (index_Mapping_Int_T s (no_infinite_decreasing_sequence_T s
      + 1))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T
  
  function no_infinite_decreasing_sequence_Box_T_Global (s: Map.map int t_T) : int
  
  goal vc_no_infinite_decreasing_sequence_Box_T_Global:
    ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i)
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i))) (index_Mapping_Int_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i) (no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i)
      + 1))))
    -> (let result = no_infinite_decreasing_sequence_T (fun (i: int) -> index_Mapping_Int_Box_T_Global s i) in [@stop_split] [@expl:no_infinite_decreasing_sequence_Box_T_Global ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_Box_T_Global (index_Mapping_Int_Box_T_Global s result) (index_Mapping_Int_Box_T_Global s (result
    + 1))))
end
module M_logic__well_founded__impl_WellFounded_for_unit__no_infinite_decreasing_sequence (* <() as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  predicate well_founded_relation_unit [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation_unit
  
  function index_Mapping_Int_unit [@inline:trivial] (self: Map.map int ()) (a: int) : () = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_unit
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int ()
  
  function no_infinite_decreasing_sequence_unit (s: Map.map int ()) : int
  
  goal vc_no_infinite_decreasing_sequence_unit:
    let result = 0 in [@stop_split] [@expl:no_infinite_decreasing_sequence_unit ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
      >= 0)
    /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_unit (index_Mapping_Int_unit s result) (index_Mapping_Int_unit s (result
    + 1)))
end
module M_logic__well_founded__impl_WellFounded_for_tup8_T0_T1_T2_T3_T4_T5_T6_T7__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5, T6, T7) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type t_T7
  
  type tup8_T0_T1_T2_T3_T4_T5_T6_T7 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6; f7: t_T7 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_T7 (self: t_T7) (other: t_T7)
  
  predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup8_T0_T1_T2_T3_T4_T5_T6_T7) (other: tup8_T0_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2
      /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3
    /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ self.f6 = other.f6 /\ well_founded_relation_T7 self.f7 other.f7
  
  meta "rewrite_def" predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7) (a: int) : tup8_T0_T1_T2_T3_T4_T5_T6_T7
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup7_T1_T2_T3_T4_T5_T6_T7 = {
    f0'0: t_T1;
    f1'0: t_T2;
    f2'0: t_T3;
    f3'0: t_T4;
    f4'0: t_T5;
    f5'0: t_T6;
    f6'0: t_T7 }
  
  type tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 = { f0'1: t_T0; f1'1: tup7_T1_T2_T3_T4_T5_T6_T7 }
  
  function tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (self: tup8_T0_T1_T2_T3_T4_T5_T6_T7) : tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
   = { f0'1 = self.f0;
       f1'1 = { f0'0 = self.f1;
                f1'0 = self.f2;
                f2'0 = self.f3;
                f3'0 = self.f4;
                f4'0 = self.f5;
                f5'0 = self.f6;
                f6'0 = self.f7 } }
  
  predicate well_founded_relation_tup7_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup7_T1_T2_T3_T4_T5_T6_T7) (other: tup7_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation_T5 self.f4'0 other.f4'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0
      /\ self.f3'0 = other.f3'0 /\ self.f4'0 = other.f4'0 /\ well_founded_relation_T6 self.f5'0 other.f5'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0
    /\ self.f3'0 = other.f3'0
    /\ self.f4'0 = other.f4'0 /\ self.f5'0 = other.f5'0 /\ well_founded_relation_T7 self.f6'0 other.f6'0
  
  meta "rewrite_def" predicate well_founded_relation_tup7_T1_T2_T3_T4_T5_T6_T7
  
  predicate well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (other: tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup7_T1_T2_T3_T4_T5_T6_T7 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (a: int) : tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i).f0'1 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0:
    forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i).f0'1 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i'0) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7) : Map.map int t_T0 =
    fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s i) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  function no_infinite_decreasing_sequence_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (s: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7) : int
  
  goal vc_no_infinite_decreasing_sequence_tup8_T0_T1_T2_T3_T4_T5_T6_T7: if exists r: int. r >= 0
      /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
      + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
          + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
        + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s r) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup8_T0_T1_T2_T3_T4_T5_T6_T7 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0)) i) (index_Mapping_Int_tup2_T0_tup7_T1_T2_T3_T4_T5_T6_T7 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup8_T0_T1_T2_T3_T4_T5_T6_T7 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup7_T0_T1_T2_T3_T4_T5_T6__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5, T6) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type tup7_T0_T1_T2_T3_T4_T5_T6 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup7_T0_T1_T2_T3_T4_T5_T6) (other: tup7_T0_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
  
  meta "rewrite_def" predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6) (a: int) : tup7_T0_T1_T2_T3_T4_T5_T6
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup6_T1_T2_T3_T4_T5_T6 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4; f4'0: t_T5; f5'0: t_T6 }
  
  type tup2_T0_tup6_T1_T2_T3_T4_T5_T6 = { f0'1: t_T0; f1'1: tup6_T1_T2_T3_T4_T5_T6 }
  
  function tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (self: tup7_T0_T1_T2_T3_T4_T5_T6) : tup2_T0_tup6_T1_T2_T3_T4_T5_T6 =
    { f0'1 = self.f0;
      f1'1 = { f0'0 = self.f1; f1'0 = self.f2; f2'0 = self.f3; f3'0 = self.f4; f4'0 = self.f5; f5'0 = self.f6 } }
  
  predicate well_founded_relation_tup6_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup6_T1_T2_T3_T4_T5_T6) (other: tup6_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0
      /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation_T5 self.f4'0 other.f4'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0
    /\ self.f3'0 = other.f3'0 /\ self.f4'0 = other.f4'0 /\ well_founded_relation_T6 self.f5'0 other.f5'0
  
  meta "rewrite_def" predicate well_founded_relation_tup6_T1_T2_T3_T4_T5_T6
  
  predicate well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (other: tup2_T0_tup6_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup6_T1_T2_T3_T4_T5_T6 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (a: int) : tup2_T0_tup6_T1_T2_T3_T4_T5_T6
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i).f0'1 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i).f0'1 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i'0) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6) : Map.map int t_T0 =
    fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup6_T1_T2_T3_T4_T5_T6. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s i) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup7_T0_T1_T2_T3_T4_T5_T6
  
  function no_infinite_decreasing_sequence_tup7_T0_T1_T2_T3_T4_T5_T6 (s: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6) : int
  
  goal vc_no_infinite_decreasing_sequence_tup7_T0_T1_T2_T3_T4_T5_T6: if exists r: int. r >= 0
      /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
      + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
          + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
        + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s r) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup7_T0_T1_T2_T3_T4_T5_T6 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0)) i) (index_Mapping_Int_tup2_T0_tup6_T1_T2_T3_T4_T5_T6 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup7_T0_T1_T2_T3_T4_T5_T6 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup6_T0_T1_T2_T3_T4_T5__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4, T5) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type tup6_T0_T1_T2_T3_T4_T5 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup6_T0_T1_T2_T3_T4_T5) (other: tup6_T0_T1_T2_T3_T4_T5) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
  
  meta "rewrite_def" predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: Map.map int tup6_T0_T1_T2_T3_T4_T5) (a: int) : tup6_T0_T1_T2_T3_T4_T5
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup5_T1_T2_T3_T4_T5 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4; f4'0: t_T5 }
  
  type tup2_T0_tup5_T1_T2_T3_T4_T5 = { f0'1: t_T0; f1'1: tup5_T1_T2_T3_T4_T5 }
  
  function tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (self: tup6_T0_T1_T2_T3_T4_T5) : tup2_T0_tup5_T1_T2_T3_T4_T5 =
    { f0'1 = self.f0; f1'1 = { f0'0 = self.f1; f1'0 = self.f2; f2'0 = self.f3; f3'0 = self.f4; f4'0 = self.f5 } }
  
  predicate well_founded_relation_tup5_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup5_T1_T2_T3_T4_T5) (other: tup5_T1_T2_T3_T4_T5) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
      /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0
    /\ self.f2'0 = other.f2'0 /\ self.f3'0 = other.f3'0 /\ well_founded_relation_T5 self.f4'0 other.f4'0
  
  meta "rewrite_def" predicate well_founded_relation_tup5_T1_T2_T3_T4_T5
  
  predicate well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup2_T0_tup5_T1_T2_T3_T4_T5) (other: tup2_T0_tup5_T1_T2_T3_T4_T5) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup5_T1_T2_T3_T4_T5 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 [@inline:trivial] (self: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) (a: int) : tup2_T0_tup5_T1_T2_T3_T4_T5
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i).f0'1 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0
            <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i).f0'1 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i'0) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5) : Map.map int t_T0 =
    fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup5_T1_T2_T3_T4_T5. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s i) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup6_T0_T1_T2_T3_T4_T5
  
  function no_infinite_decreasing_sequence_tup6_T0_T1_T2_T3_T4_T5 (s: Map.map int tup6_T0_T1_T2_T3_T4_T5) : int
  
  goal vc_no_infinite_decreasing_sequence_tup6_T0_T1_T2_T3_T4_T5: if exists r: int. r >= 0
      /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
      + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
          + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
        + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s r) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup6_T0_T1_T2_T3_T4_T5 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup5_T1_T2_T3_T4_T5 (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0)) i) (index_Mapping_Int_tup2_T0_tup5_T1_T2_T3_T4_T5 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup6_T0_T1_T2_T3_T4_T5 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup5_T0_T1_T2_T3_T4__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3, T4) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type tup5_T0_T1_T2_T3_T4 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: tup5_T0_T1_T2_T3_T4) (other: tup5_T0_T1_T2_T3_T4) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
  
  meta "rewrite_def" predicate well_founded_relation_tup5_T0_T1_T2_T3_T4
  
  function index_Mapping_Int_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: Map.map int tup5_T0_T1_T2_T3_T4) (a: int) : tup5_T0_T1_T2_T3_T4
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup5_T0_T1_T2_T3_T4
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup4_T1_T2_T3_T4 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3; f3'0: t_T4 }
  
  type tup2_T0_tup4_T1_T2_T3_T4 = { f0'1: t_T0; f1'1: tup4_T1_T2_T3_T4 }
  
  function tuple_to_pair_tup5_T0_T1_T2_T3_T4 (self: tup5_T0_T1_T2_T3_T4) : tup2_T0_tup4_T1_T2_T3_T4 = { f0'1 = self.f0;
                                                                                                        f1'1 = { f0'0 = self.f1;
                                                                                                                 f1'0 = self.f2;
                                                                                                                 f2'0 = self.f3;
                                                                                                                 f3'0 = self.f4 } }
  
  predicate well_founded_relation_tup4_T1_T2_T3_T4 [@inline:trivial] (self: tup4_T1_T2_T3_T4) (other: tup4_T1_T2_T3_T4) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
    \/ self.f0'0 = other.f0'0
    /\ self.f1'0 = other.f1'0 /\ self.f2'0 = other.f2'0 /\ well_founded_relation_T4 self.f3'0 other.f3'0
  
  meta "rewrite_def" predicate well_founded_relation_tup4_T1_T2_T3_T4
  
  predicate well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 [@inline:trivial] (self: tup2_T0_tup4_T1_T2_T3_T4) (other: tup2_T0_tup4_T1_T2_T3_T4) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup4_T1_T2_T3_T4 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4
  
  function index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 [@inline:trivial] (self: Map.map int tup2_T0_tup4_T1_T2_T3_T4) (a: int) : tup2_T0_tup4_T1_T2_T3_T4
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup4_T1_T2_T3_T4) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i).f0'1 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i).f0'1 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup4_T1_T2_T3_T4) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i'0) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup4_T1_T2_T3_T4) : Map.map int t_T0 = fun (i: int) -> if 0
    <= i then
      (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup4_T1_T2_T3_T4. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s i) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup5_T0_T1_T2_T3_T4
  
  function no_infinite_decreasing_sequence_tup5_T0_T1_T2_T3_T4 (s: Map.map int tup5_T0_T1_T2_T3_T4) : int
  
  goal vc_no_infinite_decreasing_sequence_tup5_T0_T1_T2_T3_T4: if exists r: int. r >= 0
      /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
      + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
          + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
        + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s r) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup5_T0_T1_T2_T3_T4 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup4_T1_T2_T3_T4 (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0)) i) (index_Mapping_Int_tup2_T0_tup4_T1_T2_T3_T4 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup5_T0_T1_T2_T3_T4 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup4_T0_T1_T2_T3__no_infinite_decreasing_sequence (* <(T0, T1, T2, T3) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type tup4_T0_T1_T2_T3 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_tup4_T0_T1_T2_T3 [@inline:trivial] (self: tup4_T0_T1_T2_T3) (other: tup4_T0_T1_T2_T3) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
  
  meta "rewrite_def" predicate well_founded_relation_tup4_T0_T1_T2_T3
  
  function index_Mapping_Int_tup4_T0_T1_T2_T3 [@inline:trivial] (self: Map.map int tup4_T0_T1_T2_T3) (a: int) : tup4_T0_T1_T2_T3
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup4_T0_T1_T2_T3
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup3_T1_T2_T3 = { f0'0: t_T1; f1'0: t_T2; f2'0: t_T3 }
  
  type tup2_T0_tup3_T1_T2_T3 = { f0'1: t_T0; f1'1: tup3_T1_T2_T3 }
  
  function tuple_to_pair_tup4_T0_T1_T2_T3 (self: tup4_T0_T1_T2_T3) : tup2_T0_tup3_T1_T2_T3 = { f0'1 = self.f0;
                                                                                               f1'1 = { f0'0 = self.f1;
                                                                                                        f1'0 = self.f2;
                                                                                                        f2'0 = self.f3 } }
  
  predicate well_founded_relation_tup3_T1_T2_T3 [@inline:trivial] (self: tup3_T1_T2_T3) (other: tup3_T1_T2_T3) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
    \/ self.f0'0 = other.f0'0 /\ self.f1'0 = other.f1'0 /\ well_founded_relation_T3 self.f2'0 other.f2'0
  
  meta "rewrite_def" predicate well_founded_relation_tup3_T1_T2_T3
  
  predicate well_founded_relation_tup2_T0_tup3_T1_T2_T3 [@inline:trivial] (self: tup2_T0_tup3_T1_T2_T3) (other: tup2_T0_tup3_T1_T2_T3) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup3_T1_T2_T3 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup3_T1_T2_T3
  
  function index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 [@inline:trivial] (self: Map.map int tup2_T0_tup3_T1_T2_T3) (a: int) : tup2_T0_tup3_T1_T2_T3
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup3_T1_T2_T3
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup3_T1_T2_T3) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i).f0'1 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i).f0'1 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup3_T1_T2_T3) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup3_T1_T2_T3, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i'0) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup3_T1_T2_T3) : Map.map int t_T0 = fun (i: int) -> if 0
    <= i then
      (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup3_T1_T2_T3. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s i) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup4_T0_T1_T2_T3
  
  function no_infinite_decreasing_sequence_tup4_T0_T1_T2_T3 (s: Map.map int tup4_T0_T1_T2_T3) : int
  
  goal vc_no_infinite_decreasing_sequence_tup4_T0_T1_T2_T3: if exists r: int. r >= 0
      /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
      + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
          + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
        + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s r) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup4_T0_T1_T2_T3 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup3_T1_T2_T3 (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0)) i) (index_Mapping_Int_tup2_T0_tup3_T1_T2_T3 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup4_T0_T1_T2_T3 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup3_T0_T1_T2__no_infinite_decreasing_sequence (* <(T0, T1, T2) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type tup3_T0_T1_T2 = { f0: t_T0; f1: t_T1; f2: t_T2 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup3_T0_T1_T2 [@inline:trivial] (self: tup3_T0_T1_T2) (other: tup3_T0_T1_T2) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
  
  meta "rewrite_def" predicate well_founded_relation_tup3_T0_T1_T2
  
  function index_Mapping_Int_tup3_T0_T1_T2 [@inline:trivial] (self: Map.map int tup3_T0_T1_T2) (a: int) : tup3_T0_T1_T2
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup3_T0_T1_T2
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup2_T1_T2 = { f0'0: t_T1; f1'0: t_T2 }
  
  type tup2_T0_tup2_T1_T2 = { f0'1: t_T0; f1'1: tup2_T1_T2 }
  
  function tuple_to_pair_tup3_T0_T1_T2 (self: tup3_T0_T1_T2) : tup2_T0_tup2_T1_T2 = { f0'1 = self.f0;
                                                                                      f1'1 = { f0'0 = self.f1;
                                                                                               f1'0 = self.f2 } }
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_T2 self.f1'0 other.f1'0
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  predicate well_founded_relation_tup2_T0_tup2_T1_T2 [@inline:trivial] (self: tup2_T0_tup2_T1_T2) (other: tup2_T0_tup2_T1_T2) =
    well_founded_relation_T0 self.f0'1 other.f0'1
    \/ self.f0'1 = other.f0'1 /\ well_founded_relation_tup2_T1_T2 self.f1'1 other.f1'1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup2_T1_T2
  
  function index_Mapping_Int_tup2_T0_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T0_tup2_T1_T2) (a: int) : tup2_T0_tup2_T1_T2
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup2_T1_T2
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup2_T1_T2) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i).f0'1 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i
      + 1)).f0'1 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i).f0'1 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (extract_next_decr_T0 s i)).f0'1
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup2_T1_T2) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s prev).f0'1 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (extract_nth_T0 s i)).f0'1)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup2_T1_T2) : Map.map int t_T0 = fun (i: int) -> if 0
    <= i then
      (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (extract_nth_T0 s i)).f0'1
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup2_T1_T2. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 s i) (index_Mapping_Int_tup2_T0_tup2_T1_T2 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup3_T0_T1_T2
  
  function no_infinite_decreasing_sequence_tup3_T0_T1_T2 (s: Map.map int tup3_T0_T1_T2) : int
  
  goal vc_no_infinite_decreasing_sequence_tup3_T0_T1_T2: if exists r: int. r >= 0
      /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
      + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
          + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
        + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s r) (index_Mapping_Int_tup3_T0_T1_T2 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup3_T0_T1_T2 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup2_T1_T2 (index_Mapping_Int_tup2_T0_tup2_T1_T2 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0)) i) (index_Mapping_Int_tup2_T0_tup2_T1_T2 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup3_T0_T1_T2 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup2_T0_T1__no_infinite_decreasing_sequence (* <(T0, T1) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type tup2_T0_T1 = { f0: t_T0; f1: t_T1 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_tup2_T0_T1 [@inline:trivial] (self: tup2_T0_T1) (other: tup2_T0_T1) =
    well_founded_relation_T0 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_T1
  
  function index_Mapping_Int_tup2_T0_T1 [@inline:trivial] (self: Map.map int tup2_T0_T1) (a: int) : tup2_T0_T1 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_T1
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup2_T0_tup1_T1 = { f0'0: t_T0; f1'0: t_T1 }
  
  function tuple_to_pair_tup2_T0_T1 (self: tup2_T0_T1) : tup2_T0_tup1_T1 = { f0'0 = self.f0; f1'0 = self.f1 }
  
  predicate well_founded_relation_tup1_T1 [@inline:trivial] (self: t_T1) (other: t_T1) =
    well_founded_relation_T1 self other
  
  meta "rewrite_def" predicate well_founded_relation_tup1_T1
  
  predicate well_founded_relation_tup2_T0_tup1_T1 [@inline:trivial] (self: tup2_T0_tup1_T1) (other: tup2_T0_tup1_T1) =
    well_founded_relation_T0 self.f0'0 other.f0'0
    \/ self.f0'0 = other.f0'0 /\ well_founded_relation_tup1_T1 self.f1'0 other.f1'0
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_tup1_T1
  
  function index_Mapping_Int_tup2_T0_tup1_T1 [@inline:trivial] (self: Map.map int tup2_T0_tup1_T1) (a: int) : tup2_T0_tup1_T1
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_tup1_T1
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_tup1_T1) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup1_T1 s i).f0'0 (index_Mapping_Int_tup2_T0_tup1_T1 s (i
      + 1)).f0'0 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup1_T1 s i).f0'0 (index_Mapping_Int_tup2_T0_tup1_T1 s (extract_next_decr_T0 s i)).f0'0
  
  function extract_nth_T0 (s: Map.map int tup2_T0_tup1_T1) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_tup1_T1, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i'0) (index_Mapping_Int_tup2_T0_tup1_T1 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_tup1_T1 s prev).f0'0 (index_Mapping_Int_tup2_T0_tup1_T1 s (extract_nth_T0 s i)).f0'0)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_tup1_T1) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_tup1_T1 s (extract_nth_T0 s i)).f0'0
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_tup1_T1. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 s i) (index_Mapping_Int_tup2_T0_tup1_T1 s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T0_T1
  
  function no_infinite_decreasing_sequence_tup2_T0_T1 (s: Map.map int tup2_T0_T1) : int
  
  goal vc_no_infinite_decreasing_sequence_tup2_T0_T1: if exists r: int. r >= 0
      /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
      + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
          + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
        + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s r) (index_Mapping_Int_tup2_T0_T1 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup2_T0_T1 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_tup1_T1 (index_Mapping_Int_tup2_T0_tup1_T1 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0)) i) (index_Mapping_Int_tup2_T0_tup1_T1 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup2_T0_T1 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
      + 1)))))))

end
module M_logic__well_founded__impl_WellFounded_for_tup1_T0__no_infinite_decreasing_sequence (* <(T0,) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_tup1_T0 [@inline:trivial] (self: t_T0) (other: t_T0) =
    well_founded_relation_T0 self other
  
  meta "rewrite_def" predicate well_founded_relation_tup1_T0
  
  function index_Mapping_Int_tup1_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup1_T0
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  type tup2_T0_unit = { f0: t_T0; f1: () }
  
  function tuple_to_pair_tup1_T0 (self: t_T0) : tup2_T0_unit = { f0 = self; f1 = () }
  
  predicate well_founded_relation_unit [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation_unit
  
  predicate well_founded_relation_tup2_T0_unit [@inline:trivial] (self: tup2_T0_unit) (other: tup2_T0_unit) =
    well_founded_relation_T0 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_unit self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_unit
  
  function index_Mapping_Int_tup2_T0_unit [@inline:trivial] (self: Map.map int tup2_T0_unit) (a: int) : tup2_T0_unit =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_unit
  
  function index_Mapping_Int_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T0
  
  function extract_next_decr_T0 (s: Map.map int tup2_T0_unit) (i: int) : int
  
  axiom extract_next_decr_T0_def: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T0 s i
      = (if well_founded_relation_T0 (index_Mapping_Int_tup2_T0_unit s i).f0 (index_Mapping_Int_tup2_T0_unit s (i
      + 1)).f0 then
        i + 1
      else
        extract_next_decr_T0 s (i + 1)
      )
  
  axiom extract_next_decr_T0_spec: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T0 s i
  
  axiom extract_next_decr_T0_spec'0: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T0 (index_Mapping_Int_tup2_T0_unit s i).f0 (index_Mapping_Int_tup2_T0_unit s (extract_next_decr_T0 s i)).f0
  
  function extract_nth_T0 (s: Map.map int tup2_T0_unit) (i: int) : int
  
  axiom extract_nth_T0_def: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T0 s i = (if i = 0 then 0 else let prev = extract_nth_T0 s (i - 1) in extract_next_decr_T0 s prev)
  
  axiom extract_nth_T0_spec: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T0 s i
  
  axiom extract_nth_T0_spec'0: forall s: Map.map int tup2_T0_unit, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i'0) (index_Mapping_Int_tup2_T0_unit s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T0 s (i - 1) in prev < extract_nth_T0 s i
      /\ well_founded_relation_T0 (index_Mapping_Int_tup2_T0_unit s prev).f0 (index_Mapping_Int_tup2_T0_unit s (extract_nth_T0 s i)).f0)
  
  predicate index_Mapping_T0_bool [@inline:trivial] (self: Map.map t_T0 bool) (a: t_T0) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T0_bool
  
  function such_that_T0 (p: Map.map t_T0 bool) : t_T0
  
  axiom such_that_T0_spec: forall p: Map.map t_T0 bool. (exists x: t_T0. index_Mapping_T0_bool p x)
      -> index_Mapping_T0_bool p (such_that_T0 p)
  
  function first_component_decr_T0 (s: Map.map int tup2_T0_unit) : Map.map int t_T0 = fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T0_unit s (extract_nth_T0 s i)).f0
    else
      such_that_T0 (fun (__0: t_T0) -> true)
  
  
  axiom first_component_decr_T0_spec: forall s: Map.map int tup2_T0_unit. (forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit s i) (index_Mapping_Int_tup2_T0_unit s (i
          + 1)))
      -> (forall i: int. 0 <= i
        -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 s) i) (index_Mapping_Int_T0 (first_component_decr_T0 s) (i
        + 1)))
  
  function no_infinite_decreasing_sequence_T0 (s: Map.map int t_T0) : int
  
  axiom no_infinite_decreasing_sequence_T0_spec: forall s: Map.map int t_T0. no_infinite_decreasing_sequence_T0 s >= 0
  
  axiom no_infinite_decreasing_sequence_T0_spec'0:
    forall s: Map.map int t_T0. not well_founded_relation_T0 (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s)) (index_Mapping_Int_T0 s (no_infinite_decreasing_sequence_T0 s
      + 1))
  
  constant unreachable_Int : int
  
  axiom unreachable_Int_spec: false -> false
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int t_T0
  
  function no_infinite_decreasing_sequence_tup1_T0 (s: Map.map int t_T0) : int
  
  goal vc_no_infinite_decreasing_sequence_tup1_T0: if exists r: int. r >= 0
      /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r + 1)) then
      ([@stop_split] [@expl:such_that requires] exists x: int. index_Mapping_Int_bool (fun (r: int) -> r >= 0
          /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r + 1))) x)
      /\ (([@stop_split] [@expl:such_that ensures] index_Mapping_Int_bool (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r
        + 1))) (such_that_Int (fun (r: int) -> r >= 0
        /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r + 1)))))
      -> (let result = such_that_Int (fun (r: int) -> r >= 0
      /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s r) (index_Mapping_Int_tup1_T0 s (r
      + 1))) in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup1_T0 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
      + 1)))))
    else
      ([@stop_split] [@expl:first_component_decr requires] forall i: int. 0 <= i
          -> well_founded_relation_tup2_T0_unit (index_Mapping_Int_tup2_T0_unit (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0)) i) (index_Mapping_Int_tup2_T0_unit (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0)) (i
          + 1)))
      /\ (([@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
          -> well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0))) i) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i'0: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i'0))) (i
          + 1)))
      -> ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i)))
          >= 0)
        /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_T0 (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))))) (index_Mapping_Int_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))) (no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i)))
        + 1))))
      -> (let _ = no_infinite_decreasing_sequence_T0 (first_component_decr_T0 (fun (i: int) -> tuple_to_pair_tup1_T0 (index_Mapping_Int_tup1_T0 s i))) in ([@stop_split] [@expl:unreachable requires] false)
      /\ (([@stop_split] [@expl:unreachable ensures] false)
      -> (let result = unreachable_Int in [@stop_split] [@expl:no_infinite_decreasing_sequence_tup1_T0 ensures] ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #0] result
        >= 0)
      /\ ([@stop_split] [@expl:no_infinite_decreasing_sequence ensures #1] not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
      + 1)))))))

end
module M_logic__well_founded__extract_next_decr
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T1
  
  type t_T2
  
  type tup2_T1_T2 = { f0: t_T1; f1: t_T2 }
  
  function index_Mapping_Int_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T1_T2) (a: int) : tup2_T1_T2 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T1_T2
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T2 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T1_T2
  
  constant i : int
  
  function extract_next_decr_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  goal vc_extract_next_decr_T1: (forall i'0: int. 0 <= i'0
        -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
        + 1)))
    -> 0 <= i
    -> (if well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (i
    + 1)).f0 then
      let result = i
      + 1 in [@stop_split] [@expl:extract_next_decr_T1 ensures] ([@stop_split] [@expl:extract_next_decr ensures #0] i
        < result)
      /\ ([@stop_split] [@expl:extract_next_decr ensures #1] well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0)
    else
      (([@stop_split] [@expl:extract_next_decr requires] ([@stop_split] [@expl:extract_next_decr requires #0] forall i'0: int. 0
                <= i'0
              -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
              + 1)))
          /\ ([@stop_split] [@expl:extract_next_decr requires #1] 0 <= i + 1))
        /\ ([@expl:variant decreases] well_founded_relation_T2 (index_Mapping_Int_tup2_T1_T2 s i).f1 (index_Mapping_Int_tup2_T1_T2 s (i
        + 1)).f1))
      /\ (([@stop_split] [@expl:extract_next_decr ensures] ([@stop_split] [@expl:extract_next_decr ensures #0] i + 1
          < extract_next_decr_T1 s (i + 1))
        /\ ([@stop_split] [@expl:extract_next_decr ensures #1] well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s (i
        + 1)).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s (i + 1))).f0))
      -> (let result = extract_next_decr_T1 s (i
      + 1) in [@stop_split] [@expl:extract_next_decr_T1 ensures] ([@stop_split] [@expl:extract_next_decr ensures #0] i
        < result)
      /\ ([@stop_split] [@expl:extract_next_decr ensures #1] well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0)))
    )
end
module M_logic__well_founded__extract_nth
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T1
  
  type t_T2
  
  type tup2_T1_T2 = { f0: t_T1; f1: t_T2 }
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T2 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  function index_Mapping_Int_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T1_T2) (a: int) : tup2_T1_T2 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T1_T2
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function extract_next_decr_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  axiom extract_next_decr_T1_def: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T1 s i
      = (if well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (i
      + 1)).f0 then
        i + 1
      else
        extract_next_decr_T1 s (i + 1)
      )
  
  axiom extract_next_decr_T1_spec: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T1 s i
  
  axiom extract_next_decr_T1_spec'0: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s i)).f0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T1_T2
  
  constant i : int
  
  function extract_nth_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  goal vc_extract_nth_T1: (forall i'0: int. 0 <= i'0
        -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
        + 1)))
    -> 0 <= i
    -> (if i = 0 then
      let result = 0 in [@stop_split] [@expl:extract_nth_T1 ensures] ([@stop_split] [@expl:extract_nth ensures #0] 0
        <= result)
      /\ ([@stop_split] [@expl:extract_nth ensures #1] 0 < i
      -> (let prev = extract_nth_T1 s (i - 1) in prev < result
      /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0))
    else
      (([@stop_split] [@expl:extract_nth requires] ([@stop_split] [@expl:extract_nth requires #0] forall i'0: int. 0
                <= i'0
              -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
              + 1)))
          /\ ([@stop_split] [@expl:extract_nth requires #1] 0 <= i - 1))
        /\ ([@expl:variant decreases] well_founded_relation_Int i (i - 1)))
      /\ (([@stop_split] [@expl:extract_nth ensures] ([@stop_split] [@expl:extract_nth ensures #0] 0
          <= extract_nth_T1 s (i - 1))
        /\ ([@stop_split] [@expl:extract_nth ensures #1] 0 < i - 1
        -> (let prev = extract_nth_T1 s (i - 1 - 1) in prev < extract_nth_T1 s (i - 1)
        /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_nth_T1 s (i
        - 1))).f0)))
      -> (let prev = extract_nth_T1 s (i
      - 1) in ([@stop_split] [@expl:extract_next_decr requires] ([@stop_split] [@expl:extract_next_decr requires #0] forall i'0: int. 0
              <= i'0
            -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
            + 1)))
        /\ ([@stop_split] [@expl:extract_next_decr requires #1] 0 <= prev))
      /\ (([@stop_split] [@expl:extract_next_decr ensures] ([@stop_split] [@expl:extract_next_decr ensures #0] prev
          < extract_next_decr_T1 s prev)
        /\ ([@stop_split] [@expl:extract_next_decr ensures #1] well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s prev)).f0))
      -> (let result = extract_next_decr_T1 s prev in [@stop_split] [@expl:extract_nth_T1 ensures] ([@stop_split] [@expl:extract_nth ensures #0] 0
        <= result)
      /\ ([@stop_split] [@expl:extract_nth ensures #1] 0 < i
      -> (let prev'0 = extract_nth_T1 s (i - 1) in prev'0 < result
      /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev'0).f0 (index_Mapping_Int_tup2_T1_T2 s result).f0))))))
    )
end
module M_logic__well_founded__first_component_decr
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T1
  
  type t_T2
  
  type tup2_T1_T2 = { f0: t_T1; f1: t_T2 }
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup2_T1_T2 [@inline:trivial] (self: tup2_T1_T2) (other: tup2_T1_T2) =
    well_founded_relation_T1 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T2 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T1_T2
  
  function index_Mapping_Int_tup2_T1_T2 [@inline:trivial] (self: Map.map int tup2_T1_T2) (a: int) : tup2_T1_T2 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T1_T2
  
  function index_Mapping_Int_T1 [@inline:trivial] (self: Map.map int t_T1) (a: int) : t_T1 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_T1
  
  function extract_next_decr_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  axiom extract_next_decr_T1_def: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_next_decr_T1 s i
      = (if well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (i
      + 1)).f0 then
        i + 1
      else
        extract_next_decr_T1 s (i + 1)
      )
  
  axiom extract_next_decr_T1_spec: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> i < extract_next_decr_T1 s i
  
  axiom extract_next_decr_T1_spec'0: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s i).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_next_decr_T1 s i)).f0
  
  function extract_nth_T1 (s: Map.map int tup2_T1_T2) (i: int) : int
  
  axiom extract_nth_T1_def: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> extract_nth_T1 s i = (if i = 0 then 0 else let prev = extract_nth_T1 s (i - 1) in extract_next_decr_T1 s prev)
  
  axiom extract_nth_T1_spec: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1))) -> 0 <= i -> 0 <= extract_nth_T1 s i
  
  axiom extract_nth_T1_spec'0: forall s: Map.map int tup2_T1_T2, i: int. (forall i'0: int. 0 <= i'0
          -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
          + 1)))
      -> 0 <= i
      -> 0 < i
      -> (let prev = extract_nth_T1 s (i - 1) in prev < extract_nth_T1 s i
      /\ well_founded_relation_T1 (index_Mapping_Int_tup2_T1_T2 s prev).f0 (index_Mapping_Int_tup2_T1_T2 s (extract_nth_T1 s i)).f0)
  
  predicate index_Mapping_T1_bool [@inline:trivial] (self: Map.map t_T1 bool) (a: t_T1) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T1_bool
  
  function such_that_T1 (p: Map.map t_T1 bool) : t_T1
  
  axiom such_that_T1_spec: forall p: Map.map t_T1 bool. (exists x: t_T1. index_Mapping_T1_bool p x)
      -> index_Mapping_T1_bool p (such_that_T1 p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant s : Map.map int tup2_T1_T2
  
  function first_component_decr_T1 (s: Map.map int tup2_T1_T2) : Map.map int t_T1
  
  goal vc_first_component_decr_T1: (forall i: int. 0 <= i
        -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i) (index_Mapping_Int_tup2_T1_T2 s (i + 1)))
    -> (forall i: int. if 0 <= i then
          [@stop_split] [@expl:extract_nth requires] ([@stop_split] [@expl:extract_nth requires #0] forall i'0: int. 0
                <= i'0
              -> well_founded_relation_tup2_T1_T2 (index_Mapping_Int_tup2_T1_T2 s i'0) (index_Mapping_Int_tup2_T1_T2 s (i'0
              + 1)))
          /\ ([@stop_split] [@expl:extract_nth requires #1] 0 <= i)
        else
          [@stop_split] [@expl:such_that requires] exists x: t_T1. index_Mapping_T1_bool (fun (__0: t_T1) -> true) x
      )
    /\ (let result = fun (i: int) -> if 0 <= i then
      (index_Mapping_Int_tup2_T1_T2 s (extract_nth_T1 s i)).f0
    else
      such_that_T1 (fun (__0: t_T1) -> true)
     in [@stop_split] [@expl:first_component_decr ensures] forall i: int. 0 <= i
      -> well_founded_relation_T1 (index_Mapping_Int_T1 result i) (index_Mapping_Int_T1 result (i + 1)))
end
module M_peano__impl_Default_for_PeanoInt__default (* <peano::PeanoInt as std::default::Default> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  let rec default_u64 (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:default ensures] result = (0: UInt64.t)} (! return {result}) ]
  
  type t_PeanoInt = { f0: UInt64.t }
  
  predicate postcondition_once_default [@inline:trivial] (self: ()) (args: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_once_default
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default [@inline:trivial] (self: ()) (args: ()) (result_state: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_mut_default
  
  function fn_mut_once_default (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: UInt64.t. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: UInt64.t. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default [@inline:trivial] (self: ()) (args: ()) (result: UInt64.t) =
    let () = args in result = (0: UInt64.t)
  
  meta "rewrite_def" predicate postcondition_default
  
  function fn_once_default (self: ()) (args: ()) (res: UInt64.t) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: UInt64.t. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: UInt64.t. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec default_PeanoInt (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0
      [ s0 = default_u64 (fun (_x: UInt64.t) -> [ &_2 <- _x ] s1)
      | s1 = [ &_ret <- { f0 = _2 } ] s2
      | s2 = return {_ret} ] ] [ & _ret: t_PeanoInt = Any.any_l () | & _2: UInt64.t = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@stop_split] [@expl:default ensures] true
      /\ postcondition_default () () result.f0}
      (! return {result}) ]
end
module M_peano__impl_Clone_for_PeanoInt__clone (* <peano::PeanoInt as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec clone_u64 (self_: UInt64.t) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:clone ensures] result = self_} (! return {result}) ]
  
  predicate postcondition_once_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_once_clone
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result_state: ()) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_mut_clone
  
  function fn_mut_once_clone (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone [@inline:trivial] (self: ()) (args: UInt64.t) (result: UInt64.t) =
    let self_ = args in result = self_
  
  meta "rewrite_def" predicate postcondition_clone
  
  function fn_once_clone (self: ()) (args: UInt64.t) (res: UInt64.t) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: UInt64.t, res: UInt64.t. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: UInt64.t) (res_state: ()) (res: UInt64.t) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: UInt64.t, res_state: (), res: UInt64.t. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_PeanoInt (self: t_PeanoInt) (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- self.f0 ] s1
      | s1 = clone_u64 {_6} (fun (_x: UInt64.t) -> [ &_4 <- _x ] s2)
      | s2 = [ &_ret <- { f0 = _4 } ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_PeanoInt = Any.any_l ()
    | & self: t_PeanoInt = self
    | & _4: UInt64.t = Any.any_l ()
    | & _6: UInt64.t = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@stop_split] [@expl:clone ensures] postcondition_clone () self.f0 result.f0}
      (! return {result}) ]
end
module M_peano__impl_Eq_for_PeanoInt__assert_receiver_is_total_eq (* <peano::PeanoInt as std::cmp::Eq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec assert_receiver_is_total_eq_PeanoInt (self: t_PeanoInt) (return (x: ())) = (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_le_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_le_log_PeanoInt: [@stop_split] [@expl:cmp_le_log ensures] le_log_PeanoInt x y
    = (cmp_log_PeanoInt x y <> Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_lt_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_lt_log_PeanoInt: [@stop_split] [@expl:cmp_lt_log ensures] lt_log_PeanoInt x y
    = (cmp_log_PeanoInt x y = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_ge_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_ge_log_PeanoInt: [@stop_split] [@expl:cmp_ge_log ensures] ge_log_PeanoInt x y
    = (cmp_log_PeanoInt x y <> Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_gt_log (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_cmp_gt_log_PeanoInt: [@stop_split] [@expl:cmp_gt_log ensures] gt_log_PeanoInt x y
    = (cmp_log_PeanoInt x y = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__refl (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  function refl_PeanoInt (x: t_PeanoInt) : ()
  
  goal vc_refl_PeanoInt: [@stop_split] [@expl:refl ensures] cmp_log_PeanoInt x x = Equal
end
module M_peano__impl_OrdLogic_for_PeanoInt__trans (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  constant z : t_PeanoInt
  
  constant o : t_Ordering
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : ()
  
  goal vc_trans_PeanoInt: cmp_log_PeanoInt x y = o
    -> cmp_log_PeanoInt y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_PeanoInt x z = o)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym1 (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_antisym1_PeanoInt: cmp_log_PeanoInt x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_PeanoInt y x = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym2 (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_antisym2_PeanoInt: cmp_log_PeanoInt x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_PeanoInt y x = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__eq_cmp (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_PeanoInt
  
  constant y : t_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : ()
  
  goal vc_eq_cmp_PeanoInt: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_PeanoInt x y = Equal)
end
module M_peano__impl_PartialOrd_for_PeanoInt__partial_cmp (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {[@stop_split] [@expl:cmp ensures] result = cmp_log_PeanoInt self other}
      (! return {result}) ]
  
  type t_Option_Ordering = None | Some t_Ordering
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = (! bb0
    [ bb0 = s0
      [ s0 = cmp_PeanoInt {self} {other} (fun (_x: t_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = [ &_ret <- Some _6 ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Option_Ordering = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _6: t_Ordering = Any.any_l () ])
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_PeanoInt self other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__lt (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_PeanoInt self other)}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec lt_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:lt ensures] result
      = UInt64.lt (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__le (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_PeanoInt self other)}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec le_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:le ensures] result
      = UInt64.le (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__gt (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_PeanoInt self other)}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec gt_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:gt ensures] result
      = UInt64.gt (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_PartialOrd_for_PeanoInt__ge (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  let rec partial_cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_PeanoInt self other)}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ge_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_PeanoInt {self} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:ge ensures] result
      = UInt64.ge (view_PeanoInt self) (view_PeanoInt other)}
      (! return {result}) ]
end
module M_peano__impl_Ord_for_PeanoInt__cmp (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Ordering)) = any
    [ return (result: t_Ordering) -> {[@stop_split] [@expl:cmp ensures] result
      = cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs)}
      (! return {result}) ]
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec cmp_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: t_Ordering)) = (! bb0
    [ bb0 = s0
      [ s0 = [ &_8 <- other.f0 ] s1
      | s1 = cmp_u64 {self.f0} {_8} (fun (_x: t_Ordering) -> [ &_ret <- _x ] s2)
      | s2 = return {_ret} ] ]
    [ & _ret: t_Ordering = Any.any_l ()
    | & self: t_PeanoInt = self
    | & other: t_PeanoInt = other
    | & _8: UInt64.t = Any.any_l () ])
    [ return (result: t_Ordering) -> {[@stop_split] [@expl:cmp ensures] result = cmp_log_PeanoInt self other}
      (! return {result}) ]
end
module M_peano__impl_PartialEq_for_PeanoInt__eq (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec eq_PeanoInt (self: t_PeanoInt) (other: t_PeanoInt) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self.f0 = other.f0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self: t_PeanoInt = self | & other: t_PeanoInt = other ])
    [ return (result: bool) -> {[@stop_split] [@expl:eq ensures] result = (self = other)} (! return {result}) ]
end
module M_peano__impl_PeanoInt__new (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new (return (x: t_PeanoInt)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { f0 = (0: UInt64.t) } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_PeanoInt = Any.any_l () ])
    [ return (result: t_PeanoInt) -> {[@stop_split] [@expl:new ensures] result.f0 = (0: UInt64.t)} (! return {result}) ]
end
module M_peano__impl_PeanoInt__to_u64 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u64 (self: t_PeanoInt) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self.f0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt64.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:to_u64 ensures] result = self.f0} (! return {result}) ]
end
module M_peano__impl_PeanoInt__to_u128 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_u128 (self: t_PeanoInt) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = UInt128.of_int {UInt64.t'int self.f0} (fun (_x: UInt128.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: UInt128.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: UInt128.t) -> {[@stop_split] [@expl:to_u128 ensures] UInt128.t'int result = UInt64.t'int self.f0}
      (! return {result}) ]
end
module M_peano__impl_PeanoInt__to_i128 (* peano::PeanoInt *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec to_i128 (self: t_PeanoInt) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0
      [ s0 = Int128.of_int {UInt64.t'int self.f0} (fun (_x: Int128.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int128.t = Any.any_l () | & self: t_PeanoInt = self ])
    [ return (result: Int128.t) -> {[@stop_split] [@expl:to_i128 ensures] Int128.to_int result = UInt64.t'int self.f0}
      (! return {result}) ]
end
module M_peano__impl_From_for_u64__from (* <u64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_u64 (self: t_PeanoInt) (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:to_u64 ensures] result = self.f0} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_u64 (val': t_PeanoInt) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_u64 {val'} (fun (_x: UInt64.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: UInt64.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:from ensures] result = val'.f0} (! return {result}) ]
end
module M_peano__impl_From_for_i64__from (* <i64 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_i64 (self: t_PeanoInt) (return (x: Int64.t)) = any
    [ return (result: Int64.t) -> {[@stop_split] [@expl:to_i64 ensures] Int64.to_int result = UInt64.t'int self.f0}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_i64 (val': t_PeanoInt) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_i64 {val'} (fun (_x: Int64.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int64.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: Int64.t) -> {[@stop_split] [@expl:from ensures] Int64.to_int result = UInt64.t'int val'.f0}
      (! return {result}) ]
end
module M_peano__impl_From_for_u128__from (* <u128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_u128 (self: t_PeanoInt) (return (x: UInt128.t)) = any
    [ return (result: UInt128.t) -> {[@stop_split] [@expl:to_u128 ensures] UInt128.t'int result = UInt64.t'int self.f0}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_u128 (val': t_PeanoInt) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_u128 {val'} (fun (_x: UInt128.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: UInt128.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: UInt128.t) -> {[@stop_split] [@expl:from ensures] UInt128.t'int result = UInt64.t'int val'.f0}
      (! return {result}) ]
end
module M_peano__impl_From_for_i128__from (* <i128 as std::convert::From<peano::PeanoInt>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.int.Int128
  use creusot.prelude.Any
  
  type t_PeanoInt = { f0: UInt64.t }
  
  let rec to_i128 (self: t_PeanoInt) (return (x: Int128.t)) = any
    [ return (result: Int128.t) -> {[@stop_split] [@expl:to_i128 ensures] Int128.to_int result = UInt64.t'int self.f0}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec from_i128 (val': t_PeanoInt) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = to_i128 {val'} (fun (_x: Int128.t) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: Int128.t = Any.any_l () | & val': t_PeanoInt = val' ])
    [ return (result: Int128.t) -> {[@stop_split] [@expl:from ensures] Int128.to_int result = UInt64.t'int val'.f0}
      (! return {result}) ]
end
module M_resolve__impl_Resolve_for_ref_T__resolve_coherence (* <&'a T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate resolve_ref_T (self: t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_T
  
  function resolve_coherence_ref_T (self: t_T) : ()
  
  goal vc_resolve_coherence_ref_T: [@stop_split] [@expl:resolve_coherence ensures] resolve_ref_T self
end
module M_resolve__impl_Resolve_for_refmut_T__resolve_coherence (* <&'a mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate resolve_refmut_T (self: MutBorrow.t t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_T
  
  function resolve_coherence_refmut_T (self: MutBorrow.t t_T) : ()
  
  goal vc_resolve_coherence_refmut_T: [@stop_split] [@expl:resolve_coherence ensures] resolve_refmut_T self
end
module M_snapshot__impl_Clone_for_Snapshot_T__clone (* <snapshot::Snapshot<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec clone_Snapshot_T (self: t_T) (return (x: t_T)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self ] s1 | s1 = return {_ret} ] ] [ & _ret: t_T = Any.any_l () | & self: t_T = self ])
    [ return (result: t_T) -> {[@stop_split] [@expl:clone ensures] result = self} (! return {result}) ]
end
module M_snapshot__impl_Snapshot_T_0__into_ghost (* snapshot::Snapshot<T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition_into_ghost (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_into_ghost () args]. (let snap = args in true)
      -> precondition_into_ghost () args
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Ghost_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_Ghost_T
  
  predicate inv_Ghost_T [@inline:trivial] (_1: t_T) = invariant_Ghost_T _1
  
  meta "rewrite_def" predicate inv_Ghost_T
  
  predicate postcondition_once_into_ghost (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_into_ghost () args res]. postcondition_once_into_ghost () args res
      -> (let snap = args in inv_Ghost_T res /\ res = snap)
  
  let rec into_ghost_T (snap: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:into_ghost requires] precondition_into_ghost () snap}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:into_ghost ensures] postcondition_once_into_ghost () snap result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec into_ghost_T'0 (self: t_T) (return (x: t_T)) = (! bb0
    [ bb0 = s0 [ s0 = into_ghost_T {self} (fun (_x: t_T) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & self: t_T = self ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:into_ghost_T ensures] ([@stop_split] [@expl:into_ghost result type invariant] inv_Ghost_T result)
      /\ ([@stop_split] [@expl:into_ghost ensures] result = self)}
      (! return {result}) ]
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_refl (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T
  
  function produces_refl_IntoIter_T (self: t_IntoIter_T) : ()
  
  goal vc_produces_refl_IntoIter_T:
    [@stop_split] [@expl:produces_refl ensures] produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_trans (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T
  
  function produces_trans_IntoIter_T (a: t_IntoIter_T) (ab: Seq.seq t_T) (b: t_IntoIter_T) (bc: Seq.seq t_T) (c: t_IntoIter_T) : ()
  
  goal vc_produces_trans_IntoIter_T: produces_IntoIter_T a ab b
    -> produces_IntoIter_T b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__clone__extern_spec_Clone_bool_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_bool_clone_body (self_: bool) (return (x: bool)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self_: bool = self_ ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_Clone_bool_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__clone__extern_spec_Clone_f32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.float.Float32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f32_clone_body (self_: Float32.t) (return (x: Float32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Float32.t = Any.any_l () | & self_: Float32.t = self_ ])
    [ return (result: Float32.t) -> {[@stop_split] [@expl:extern_spec_Clone_f32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__clone__extern_spec_Clone_f64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.float.Float64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_f64_clone_body (self_: Float64.t) (return (x: Float64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Float64.t = Any.any_l () | & self_: Float64.t = self_ ])
    [ return (result: Float64.t) -> {[@stop_split] [@expl:extern_spec_Clone_f64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__clone__extern_spec_T_Clone_ref_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_ref_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_T
  
  predicate inv_ref_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone__ref_T_clone_body_T (self_: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_T_Clone__ref_T_clone_body 'self_' type invariant] inv_ref_ref_T self_}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & self_: t_T = self_ ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_T_Clone__ref_T_clone_body_T ensures] ([@stop_split] [@expl:extern_spec_T_Clone__ref_T_clone_body result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:extern_spec_T_Clone__ref_T_clone_body ensures] result = self_)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_PartialEq_Rhs_ne_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate invariant_ref_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_ref_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_ref_Self_
  
  predicate inv_ref_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_ref_Self_
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate invariant_ref_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_ref_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_ref_Rhs
  
  predicate inv_ref_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_ref_Rhs
  
  type t_DeepModelTy
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_ref_Self_ self
  
  meta "rewrite_def" function deep_model_ref_ref_Self_
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  function deep_model_ref_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_ref_Rhs self
  
  meta "rewrite_def" function deep_model_ref_ref_Rhs
  
  let rec eq_ref_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: bool)) =
    {[@stop_split] [@expl:eq_ref_Self_ requires] ([@stop_split] [@expl:eq 'self_' type invariant] inv_ref_ref_Self_ self_)
    /\ ([@stop_split] [@expl:eq 'rhs' type invariant] inv_ref_ref_Rhs rhs)}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:eq ensures] result
      = (deep_model_ref_ref_Self_ self_ = deep_model_ref_ref_Rhs rhs)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_PartialEq_Rhs_ne_body_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_PartialEq_Rhs_ne_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_PartialEq_Rhs_ne_body 'self_' type invariant] inv_ref_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_PartialEq_Rhs_ne_body 'rhs' type invariant] inv_ref_Rhs rhs)}
    (! bb0
    [ bb0 = s0
      [ s0 = eq_ref_Self_ {self_} {rhs} (fun (_x: bool) -> [ &_6 <- _x ] s1)
      | s1 = [ &_ret <- not _6 ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self_: t_Self_ = self_ | & rhs: t_Rhs = rhs | & _6: bool = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_core_cmp_PartialEq_Rhs_ne_body ensures] result
      = (deep_model_ref_Self_ self_ <> deep_model_ref_Rhs rhs)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_PartialOrd_Rhs_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Self_ self_
        /\ inv_ref_Rhs rhs) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@stop_split] [@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) ->
    {[@stop_split] [@expl:partial_cmp ensures] postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_PartialOrd_Rhs_lt_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_lt_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_lt_body 'self_' type invariant] inv_ref_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_lt_body 'other' type invariant] inv_ref_Rhs other)}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_lt_body ensures] result
      = lt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_PartialOrd_Rhs_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Self_ self_
        /\ inv_ref_Rhs rhs) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@stop_split] [@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) ->
    {[@stop_split] [@expl:partial_cmp ensures] postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_PartialOrd_Rhs_le_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_le_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_le_body 'self_' type invariant] inv_ref_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_le_body 'other' type invariant] inv_ref_Rhs other)}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_le_body ensures] result
      = le_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_PartialOrd_Rhs_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Self_ self_
        /\ inv_ref_Rhs rhs) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@stop_split] [@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) ->
    {[@stop_split] [@expl:partial_cmp ensures] postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_PartialOrd_Rhs_gt_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_gt_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_gt_body 'self_' type invariant] inv_ref_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_gt_body 'other' type invariant] inv_ref_Rhs other)}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_gt_body ensures] result
      = gt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_PartialOrd_Rhs_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type t_Rhs
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  type tup2_ref_Self__ref_Rhs = { f0: t_Self_; f1: t_Rhs }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate inv_Rhs (_1: t_Rhs)
  
  predicate invariant_ref_Rhs [@inline:trivial] (self: t_Rhs) = inv_Rhs self
  
  meta "rewrite_def" predicate invariant_ref_Rhs
  
  predicate inv_ref_Rhs [@inline:trivial] (_1: t_Rhs) = invariant_ref_Rhs _1
  
  meta "rewrite_def" predicate inv_ref_Rhs
  
  predicate precondition_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs [precondition_partial_cmp () args]. (let {f0 = self_; f1 = rhs} = args in inv_ref_Self_ self_
        /\ inv_ref_Rhs rhs) -> precondition_partial_cmp () args
  
  type t_DeepModelTy
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_Rhs (self: t_Rhs) : t_DeepModelTy
  
  predicate postcondition_once_partial_cmp (self: ()) (args: tup2_ref_Self__ref_Rhs) (result: t_Option_Ordering)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Rhs, res: t_Option_Ordering [postcondition_once_partial_cmp () args res]. postcondition_once_partial_cmp () args res
      -> (let {f0 = self_; f1 = rhs} = args in res
      = Some (cmp_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Rhs rhs)))
  
  let rec partial_cmp_Self_ (self_: t_Self_) (rhs: t_Rhs) (return (x: t_Option_Ordering)) =
    {[@stop_split] [@expl:partial_cmp requires] precondition_partial_cmp () { f0 = self_; f1 = rhs }}
    any
    [ return (result: t_Option_Ordering) ->
    {[@stop_split] [@expl:partial_cmp ensures] postcondition_once_partial_cmp () { f0 = self_; f1 = rhs } result}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0'0: t_Ordering)) = any
    [ _k (f0'0: t_Ordering) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  function deep_model_ref_Rhs [@inline:trivial] (self: t_Rhs) : t_DeepModelTy = deep_model_Rhs self
  
  meta "rewrite_def" function deep_model_ref_Rhs
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_PartialOrd_Rhs_ge_body_Self_ (self_: t_Self_) (other: t_Rhs) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_ge_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_ge_body 'self_' type invariant] inv_ref_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_ge_body 'other' type invariant] inv_ref_Rhs other)}
    (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_Self_ {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: t_Self_ = self_
    | & other: t_Rhs = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_core_cmp_PartialOrd_Rhs_ge_body ensures] result
      = ge_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Rhs other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_Ord_max_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tup2_ref_Self__ref_Self_ = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_le (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Self_ [precondition_le () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ self_
        /\ inv_ref_Self_ other) -> precondition_le () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  predicate postcondition_once_le (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_le () args res]. postcondition_once_le () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = le_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec le_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@stop_split] [@expl:le requires] precondition_le () { f0 = self_; f1 = other }}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:le ensures] postcondition_once_le () { f0 = self_;
                                                                                            f1 = other } result}
      (! return {result}) ]
  
  predicate resolve_Self_ (_1: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_Ord_max_body_Self_ (self_: t_Self_) (o: t_Self_) (return (x: t_Self_)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body 'self_' type invariant] inv_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body 'o' type invariant] inv_Self_ o)}
    (! bb0
    [ bb0 = s0
      [ s0 = le_Self_ {self_} {o} (fun (_x: bool) -> [ &_16 <- _x ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb3) | br1 -> {_16} (! bb2) ] ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ self_} any) ]
      | s1 = -{resolve_Self_ self_}- s2
      | s2 = [ &_ret <- o ] s3
      | s3 = return {_ret} ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ o} any) ]
      | s1 = -{resolve_Self_ o}- s2
      | s2 = [ &_ret <- self_ ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Self_ = Any.any_l () | & self_: t_Self_ = self_ | & o: t_Self_ = o | & _16: bool = Any.any_l () ])
    [ return (result: t_Self_) ->
    {[@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body_Self_ ensures] ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body result type invariant] inv_Self_ result)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body ensures #0] ge_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ self_))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body ensures #1] ge_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ o))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body ensures #2] result = self_ \/ result = o)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body ensures #3] le_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ o)
        -> result = o)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_max_body ensures #4] lt_log_DeepModelTy (deep_model_Self_ o) (deep_model_Self_ self_)
      -> result = self_)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_Ord_min_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tup2_ref_Self__ref_Self_ = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_lt (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Self_ [precondition_lt () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ self_
        /\ inv_ref_Self_ other) -> precondition_lt () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  predicate postcondition_once_lt (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_lt () args res]. postcondition_once_lt () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = lt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec lt_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@stop_split] [@expl:lt requires] precondition_lt () { f0 = self_; f1 = other }}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:lt ensures] postcondition_once_lt () { f0 = self_;
                                                                                            f1 = other } result}
      (! return {result}) ]
  
  predicate resolve_Self_ (_1: t_Self_)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_Ord_min_body_Self_ (self_: t_Self_) (o: t_Self_) (return (x: t_Self_)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body 'self_' type invariant] inv_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body 'o' type invariant] inv_Self_ o)}
    (! bb0
    [ bb0 = s0
      [ s0 = lt_Self_ {self_} {o} (fun (_x: bool) -> [ &_16 <- _x ] s1)
      | s1 = any [ br0 -> {_16 = false} (! bb3) | br1 -> {_16} (! bb2) ] ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ o} any) ]
      | s1 = -{resolve_Self_ o}- s2
      | s2 = [ &_ret <- self_ ] s3
      | s3 = return {_ret} ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ self_} any) ]
      | s1 = -{resolve_Self_ self_}- s2
      | s2 = [ &_ret <- o ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Self_ = Any.any_l () | & self_: t_Self_ = self_ | & o: t_Self_ = o | & _16: bool = Any.any_l () ])
    [ return (result: t_Self_) ->
    {[@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body_Self_ ensures] ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body result type invariant] inv_Self_ result)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body ensures #0] le_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ self_))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body ensures #1] le_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ o))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body ensures #2] result = self_ \/ result = o)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body ensures #3] lt_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ o)
        -> result = self_)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_min_body ensures #4] le_log_DeepModelTy (deep_model_Self_ o) (deep_model_Self_ self_)
      -> result = o)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_Ord_clamp_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Self_
  
  type tup2_ref_Self__ref_Self_ = { f0: t_Self_; f1: t_Self_ }
  
  predicate inv_Self_ (_1: t_Self_)
  
  predicate invariant_ref_Self_ [@inline:trivial] (self: t_Self_) = inv_Self_ self
  
  meta "rewrite_def" predicate invariant_ref_Self_
  
  predicate inv_ref_Self_ [@inline:trivial] (_1: t_Self_) = invariant_ref_Self_ _1
  
  meta "rewrite_def" predicate inv_ref_Self_
  
  predicate precondition_gt (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef:
    forall args: tup2_ref_Self__ref_Self_ [precondition_gt () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ self_
        /\ inv_ref_Self_ other) -> precondition_gt () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_Self_ (self: t_Self_) : t_DeepModelTy
  
  function deep_model_ref_Self_ [@inline:trivial] (self: t_Self_) : t_DeepModelTy = deep_model_Self_ self
  
  meta "rewrite_def" function deep_model_ref_Self_
  
  predicate postcondition_once_gt (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_gt () args res]. postcondition_once_gt () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = gt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec gt_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@stop_split] [@expl:gt requires] precondition_gt () { f0 = self_; f1 = other }}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:gt ensures] postcondition_once_gt () { f0 = self_;
                                                                                            f1 = other } result}
      (! return {result}) ]
  
  predicate resolve_Self_ (_1: t_Self_)
  
  predicate precondition_lt (self: ()) (args: tup2_ref_Self__ref_Self_)
  
  axiom precondition_fndef'0:
    forall args: tup2_ref_Self__ref_Self_ [precondition_lt () args]. (let {f0 = self_; f1 = other} = args in inv_ref_Self_ self_
        /\ inv_ref_Self_ other) -> precondition_lt () args
  
  predicate postcondition_once_lt (self: ()) (args: tup2_ref_Self__ref_Self_) (result: bool)
  
  axiom postcondition_fndef'0:
    forall args: tup2_ref_Self__ref_Self_, res: bool [postcondition_once_lt () args res]. postcondition_once_lt () args res
      -> (let {f0 = self_; f1 = other} = args in res
      = lt_log_DeepModelTy (deep_model_ref_Self_ self_) (deep_model_ref_Self_ other))
  
  let rec lt_Self_ (self_: t_Self_) (other: t_Self_) (return (x: bool)) =
    {[@stop_split] [@expl:lt requires] precondition_lt () { f0 = self_; f1 = other }}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:lt ensures] postcondition_once_lt () { f0 = self_;
                                                                                            f1 = other } result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_Ord_clamp_body_Self_ (self_: t_Self_) (min: t_Self_) (max: t_Self_)
    (return (x: t_Self_)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body_Self_ requires] ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body 'self_' type invariant] inv_Self_ self_)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body 'min' type invariant] inv_Self_ min)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body 'max' type invariant] inv_Self_ max)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body requires] le_log_DeepModelTy (deep_model_Self_ min) (deep_model_Self_ max))}
    (! bb0
    [ bb0 = s0
      [ s0 = gt_Self_ {self_} {max} (fun (_x: bool) -> [ &_19 <- _x ] s1)
      | s1 = any [ br0 -> {_19 = false} (! bb3) | br1 -> {_19} (! bb2) ] ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ min} any) ]
      | s1 = -{resolve_Self_ min}- s2
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_Self_ self_} any) ]
      | s3 = -{resolve_Self_ self_}- s4
      | s4 = [ &_ret <- max ] s5
      | s5 = return {_ret} ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ max} any) ]
      | s1 = -{resolve_Self_ max}- s2
      | s2 = lt_Self_ {self_} {min} (fun (_x: bool) -> [ &_22 <- _x ] s3)
      | s3 = any [ br0 -> {_22 = false} (! bb6) | br1 -> {_22} (! bb5) ] ]
    | bb5 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ self_} any) ]
      | s1 = -{resolve_Self_ self_}- s2
      | s2 = [ &_ret <- min ] s3
      | s3 = return {_ret} ]
    | bb6 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Self_ min} any) ]
      | s1 = -{resolve_Self_ min}- s2
      | s2 = [ &_ret <- self_ ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Self_ = Any.any_l ()
    | & self_: t_Self_ = self_
    | & min: t_Self_ = min
    | & max: t_Self_ = max
    | & _19: bool = Any.any_l ()
    | & _22: bool = Any.any_l () ])
    [ return (result: t_Self_) ->
    {[@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body_Self_ ensures] ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body result type invariant] inv_Self_ result)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body ensures #0] ge_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ min))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body ensures #1] le_log_DeepModelTy (deep_model_Self_ result) (deep_model_Self_ max))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body ensures #2] result = self_
        \/ result = min \/ result = max)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_Ord_clamp_body ensures #3] if gt_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ max) then
        result = max
      else
        if lt_log_DeepModelTy (deep_model_Self_ self_) (deep_model_Self_ min) then result = min else result = self_
      )}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_max_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type tup2_T_T = { f0: t_T; f1: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate precondition_max (self: ()) (args: tup2_T_T)
  
  axiom precondition_fndef:
    forall args: tup2_T_T [precondition_max () args]. (let {f0 = self_; f1 = o} = args in inv_T self_ /\ inv_T o)
      -> precondition_max () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once_max (self: ()) (args: tup2_T_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: tup2_T_T, res: t_T [postcondition_once_max () args res]. postcondition_once_max () args res
      -> (let {f0 = self_; f1 = o} = args in inv_T res
      /\ ge_log_DeepModelTy (deep_model_T res) (deep_model_T self_)
      /\ ge_log_DeepModelTy (deep_model_T res) (deep_model_T o)
      /\ (res = self_ \/ res = o)
      /\ (le_log_DeepModelTy (deep_model_T self_) (deep_model_T o) -> res = o)
      /\ (lt_log_DeepModelTy (deep_model_T o) (deep_model_T self_) -> res = self_))
  
  let rec max_T (self_: t_T) (o: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:max requires] precondition_max () { f0 = self_; f1 = o }}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:max ensures] postcondition_once_max () { f0 = self_;
                                                                                             f1 = o } result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_max_body_T (v1: t_T) (v2: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_max_body_T requires] ([@stop_split] [@expl:extern_spec_core_cmp_max_body 'v1' type invariant] inv_T v1)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_max_body 'v2' type invariant] inv_T v2)}
    (! bb0
    [ bb0 = s0 [ s0 = max_T {v1} {v2} (fun (_x: t_T) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & v1: t_T = v1 | & v2: t_T = v2 ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_cmp_max_body_T ensures] ([@stop_split] [@expl:extern_spec_core_cmp_max_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_max_body ensures #0] ge_log_DeepModelTy (deep_model_T result) (deep_model_T v1))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_max_body ensures #1] ge_log_DeepModelTy (deep_model_T result) (deep_model_T v2))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_max_body ensures #2] result = v1 \/ result = v2)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_max_body ensures #3] le_log_DeepModelTy (deep_model_T v1) (deep_model_T v2)
        -> result = v2)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_max_body ensures #4] lt_log_DeepModelTy (deep_model_T v2) (deep_model_T v1)
      -> result = v1)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_core_cmp_min_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type tup2_T_T = { f0: t_T; f1: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate precondition_min (self: ()) (args: tup2_T_T)
  
  axiom precondition_fndef:
    forall args: tup2_T_T [precondition_min () args]. (let {f0 = self_; f1 = o} = args in inv_T self_ /\ inv_T o)
      -> precondition_min () args
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate postcondition_once_min (self: ()) (args: tup2_T_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: tup2_T_T, res: t_T [postcondition_once_min () args res]. postcondition_once_min () args res
      -> (let {f0 = self_; f1 = o} = args in inv_T res
      /\ le_log_DeepModelTy (deep_model_T res) (deep_model_T self_)
      /\ le_log_DeepModelTy (deep_model_T res) (deep_model_T o)
      /\ (res = self_ \/ res = o)
      /\ (lt_log_DeepModelTy (deep_model_T self_) (deep_model_T o) -> res = self_)
      /\ (le_log_DeepModelTy (deep_model_T o) (deep_model_T self_) -> res = o))
  
  let rec min_T (self_: t_T) (o: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:min requires] precondition_min () { f0 = self_; f1 = o }}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:min ensures] postcondition_once_min () { f0 = self_;
                                                                                             f1 = o } result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_cmp_min_body_T (v1: t_T) (v2: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_cmp_min_body_T requires] ([@stop_split] [@expl:extern_spec_core_cmp_min_body 'v1' type invariant] inv_T v1)
    /\ ([@stop_split] [@expl:extern_spec_core_cmp_min_body 'v2' type invariant] inv_T v2)}
    (! bb0
    [ bb0 = s0 [ s0 = min_T {v1} {v2} (fun (_x: t_T) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & v1: t_T = v1 | & v2: t_T = v2 ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_cmp_min_body_T ensures] ([@stop_split] [@expl:extern_spec_core_cmp_min_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_min_body ensures #0] le_log_DeepModelTy (deep_model_T result) (deep_model_T v1))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_min_body ensures #1] le_log_DeepModelTy (deep_model_T result) (deep_model_T v2))
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_min_body ensures #2] result = v1 \/ result = v2)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_min_body ensures #3] lt_log_DeepModelTy (deep_model_T v1) (deep_model_T v2)
        -> result = v1)
      /\ ([@stop_split] [@expl:extern_spec_core_cmp_min_body ensures #4] le_log_DeepModelTy (deep_model_T v2) (deep_model_T v1)
      -> result = v2)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_lt_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i8_i8_lt_body ensures] result
      = (deep_model_ref_i8 self_ < deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_le_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i8_i8_le_body ensures] result
      = (deep_model_ref_i8 self_ <= deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_gt_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i8_i8_gt_body ensures] result
      = (deep_model_ref_i8 self_ > deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i8_i8_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i8 [@inline:trivial] (self: Int8.t) : int = Int8.to_int self
  
  meta "rewrite_def" function deep_model_i8
  
  let rec partial_cmp_i8 (self_: Int8.t) (rhs: Int8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i8 self_) (deep_model_i8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i8 [@inline:trivial] (self: Int8.t) : int = deep_model_i8 self
  
  meta "rewrite_def" function deep_model_ref_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i8_i8_ge_body (self_: Int8.t) (other: Int8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int8.t = self_
    | & other: Int8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i8_i8_ge_body ensures] result
      = (deep_model_ref_i8 self_ >= deep_model_ref_i8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_lt_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i16_i16_lt_body ensures] result
      = (deep_model_ref_i16 self_ < deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_le_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i16_i16_le_body ensures] result
      = (deep_model_ref_i16 self_ <= deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_gt_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i16_i16_gt_body ensures] result
      = (deep_model_ref_i16 self_ > deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i16_i16_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i16 [@inline:trivial] (self: Int16.t) : int = Int16.to_int self
  
  meta "rewrite_def" function deep_model_i16
  
  let rec partial_cmp_i16 (self_: Int16.t) (rhs: Int16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i16 self_) (deep_model_i16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i16 [@inline:trivial] (self: Int16.t) : int = deep_model_i16 self
  
  meta "rewrite_def" function deep_model_ref_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i16_i16_ge_body (self_: Int16.t) (other: Int16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int16.t = self_
    | & other: Int16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i16_i16_ge_body ensures] result
      = (deep_model_ref_i16 self_ >= deep_model_ref_i16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_lt_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i32_i32_lt_body ensures] result
      = (deep_model_ref_i32 self_ < deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_le_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i32_i32_le_body ensures] result
      = (deep_model_ref_i32 self_ <= deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_gt_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i32_i32_gt_body ensures] result
      = (deep_model_ref_i32 self_ > deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i32_i32_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i32 [@inline:trivial] (self: Int32.t) : int = Int32.to_int self
  
  meta "rewrite_def" function deep_model_i32
  
  let rec partial_cmp_i32 (self_: Int32.t) (rhs: Int32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i32 self_) (deep_model_i32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i32 [@inline:trivial] (self: Int32.t) : int = deep_model_i32 self
  
  meta "rewrite_def" function deep_model_ref_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i32_i32_ge_body (self_: Int32.t) (other: Int32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int32.t = self_
    | & other: Int32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i32_i32_ge_body ensures] result
      = (deep_model_ref_i32 self_ >= deep_model_ref_i32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_lt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i64_i64_lt_body ensures] result
      = (deep_model_ref_i64 self_ < deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_le_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i64_i64_le_body ensures] result
      = (deep_model_ref_i64 self_ <= deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_gt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i64_i64_gt_body ensures] result
      = (deep_model_ref_i64 self_ > deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i64_i64_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i64 [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_i64
  
  let rec partial_cmp_i64 (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i64 self_) (deep_model_i64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i64 [@inline:trivial] (self: Int64.t) : int = deep_model_i64 self
  
  meta "rewrite_def" function deep_model_ref_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i64_i64_ge_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i64_i64_ge_body ensures] result
      = (deep_model_ref_i64 self_ >= deep_model_ref_i64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_lt_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i128_i128_lt_body ensures] result
      = (deep_model_ref_i128 self_ < deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_le_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i128_i128_le_body ensures] result
      = (deep_model_ref_i128 self_ <= deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_gt_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i128_i128_gt_body ensures] result
      = (deep_model_ref_i128 self_ > deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_i128_i128_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_i128 [@inline:trivial] (self: Int128.t) : int = Int128.to_int self
  
  meta "rewrite_def" function deep_model_i128
  
  let rec partial_cmp_i128 (self_: Int128.t) (rhs: Int128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_i128 self_) (deep_model_i128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_i128 [@inline:trivial] (self: Int128.t) : int = deep_model_i128 self
  
  meta "rewrite_def" function deep_model_ref_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_i128_i128_ge_body (self_: Int128.t) (other: Int128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_i128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int128.t = self_
    | & other: Int128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_i128_i128_ge_body ensures] result
      = (deep_model_ref_i128 self_ >= deep_model_ref_i128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_lt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_isize_isize_lt_body ensures] result
      = (deep_model_ref_isize self_ < deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_le_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_isize_isize_le_body ensures] result
      = (deep_model_ref_isize self_ <= deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_gt_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_isize_isize_gt_body ensures] result
      = (deep_model_ref_isize self_ > deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_isize_isize_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_isize [@inline:trivial] (self: Int64.t) : int = Int64.to_int self
  
  meta "rewrite_def" function deep_model_isize
  
  let rec partial_cmp_isize (self_: Int64.t) (rhs: Int64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_isize self_) (deep_model_isize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_isize [@inline:trivial] (self: Int64.t) : int = deep_model_isize self
  
  meta "rewrite_def" function deep_model_ref_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_isize_isize_ge_body (self_: Int64.t) (other: Int64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_isize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Int64.t = self_
    | & other: Int64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_isize_isize_ge_body ensures] result
      = (deep_model_ref_isize self_ >= deep_model_ref_isize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_lt_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u8_u8_lt_body ensures] result
      = (deep_model_ref_u8 self_ < deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_le_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u8_u8_le_body ensures] result
      = (deep_model_ref_u8 self_ <= deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_gt_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u8_u8_gt_body ensures] result
      = (deep_model_ref_u8 self_ > deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u8_u8_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u8 [@inline:trivial] (self: UInt8.t) : int = UInt8.t'int self
  
  meta "rewrite_def" function deep_model_u8
  
  let rec partial_cmp_u8 (self_: UInt8.t) (rhs: UInt8.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u8 self_) (deep_model_u8 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u8 [@inline:trivial] (self: UInt8.t) : int = deep_model_u8 self
  
  meta "rewrite_def" function deep_model_ref_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u8_u8_ge_body (self_: UInt8.t) (other: UInt8.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u8 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt8.t = self_
    | & other: UInt8.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u8_u8_ge_body ensures] result
      = (deep_model_ref_u8 self_ >= deep_model_ref_u8 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_lt_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u16_u16_lt_body ensures] result
      = (deep_model_ref_u16 self_ < deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_le_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u16_u16_le_body ensures] result
      = (deep_model_ref_u16 self_ <= deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_gt_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u16_u16_gt_body ensures] result
      = (deep_model_ref_u16 self_ > deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u16_u16_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u16 [@inline:trivial] (self: UInt16.t) : int = UInt16.t'int self
  
  meta "rewrite_def" function deep_model_u16
  
  let rec partial_cmp_u16 (self_: UInt16.t) (rhs: UInt16.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u16 self_) (deep_model_u16 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u16 [@inline:trivial] (self: UInt16.t) : int = deep_model_u16 self
  
  meta "rewrite_def" function deep_model_ref_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u16_u16_ge_body (self_: UInt16.t) (other: UInt16.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u16 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt16.t = self_
    | & other: UInt16.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u16_u16_ge_body ensures] result
      = (deep_model_ref_u16 self_ >= deep_model_ref_u16 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_lt_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u32_u32_lt_body ensures] result
      = (deep_model_ref_u32 self_ < deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_le_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u32_u32_le_body ensures] result
      = (deep_model_ref_u32 self_ <= deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_gt_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u32_u32_gt_body ensures] result
      = (deep_model_ref_u32 self_ > deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u32_u32_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u32 [@inline:trivial] (self: UInt32.t) : int = UInt32.t'int self
  
  meta "rewrite_def" function deep_model_u32
  
  let rec partial_cmp_u32 (self_: UInt32.t) (rhs: UInt32.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u32 self_) (deep_model_u32 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u32 [@inline:trivial] (self: UInt32.t) : int = deep_model_u32 self
  
  meta "rewrite_def" function deep_model_ref_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u32_u32_ge_body (self_: UInt32.t) (other: UInt32.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u32 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt32.t = self_
    | & other: UInt32.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u32_u32_ge_body ensures] result
      = (deep_model_ref_u32 self_ >= deep_model_ref_u32 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_lt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u64_u64_lt_body ensures] result
      = (deep_model_ref_u64 self_ < deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_le_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u64_u64_le_body ensures] result
      = (deep_model_ref_u64 self_ <= deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_gt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u64_u64_gt_body ensures] result
      = (deep_model_ref_u64 self_ > deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u64_u64_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u64 [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_u64
  
  let rec partial_cmp_u64 (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u64 self_) (deep_model_u64 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u64 [@inline:trivial] (self: UInt64.t) : int = deep_model_u64 self
  
  meta "rewrite_def" function deep_model_ref_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u64_u64_ge_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u64 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u64_u64_ge_body ensures] result
      = (deep_model_ref_u64 self_ >= deep_model_ref_u64 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_lt_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u128_u128_lt_body ensures] result
      = (deep_model_ref_u128 self_ < deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_le_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u128_u128_le_body ensures] result
      = (deep_model_ref_u128 self_ <= deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_gt_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u128_u128_gt_body ensures] result
      = (deep_model_ref_u128 self_ > deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_u128_u128_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_u128 [@inline:trivial] (self: UInt128.t) : int = UInt128.t'int self
  
  meta "rewrite_def" function deep_model_u128
  
  let rec partial_cmp_u128 (self_: UInt128.t) (rhs: UInt128.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_u128 self_) (deep_model_u128 rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_u128 [@inline:trivial] (self: UInt128.t) : int = deep_model_u128 self
  
  meta "rewrite_def" function deep_model_ref_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_u128_u128_ge_body (self_: UInt128.t) (other: UInt128.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_u128 {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt128.t = self_
    | & other: UInt128.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_u128_u128_ge_body ensures] result
      = (deep_model_ref_u128 self_ >= deep_model_ref_u128 other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_lt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_lt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_usize_usize_lt_body ensures] result
      = (deep_model_ref_usize self_ < deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_le_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_le_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb5) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb2) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_usize_usize_le_body ensures] result
      = (deep_model_ref_usize self_ <= deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_gt_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_gt_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb2) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_usize_usize_gt_body ensures] result
      = (deep_model_ref_usize self_ > deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__extern_spec_PartialOrd_usize_usize_ge_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Int (x: int) (y: int) : ()
  
  axiom eq_cmp_Int_spec: forall x: int, y: int. (x = y) = (cmp_log_Int x y = Equal)
  
  function antisym2_Int (x: int) (y: int) : ()
  
  axiom antisym2_Int_spec: forall x: int, y: int. cmp_log_Int x y = Greater -> cmp_log_Int y x = Less
  
  function antisym1_Int (x: int) (y: int) : ()
  
  axiom antisym1_Int_spec: forall x: int, y: int. cmp_log_Int x y = Less -> cmp_log_Int y x = Greater
  
  function trans_Int (x: int) (y: int) (z: int) (o: t_Ordering) : ()
  
  axiom trans_Int_spec: forall x: int, y: int, z: int, o: t_Ordering. cmp_log_Int x y = o
      -> cmp_log_Int y z = o -> cmp_log_Int x z = o
  
  function refl_Int (x: int) : ()
  
  axiom refl_Int_spec: forall x: int. cmp_log_Int x x = Equal
  
  function cmp_gt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_gt_log_Int_spec: forall x: int, y: int. (x > y) = (cmp_log_Int x y = Greater)
  
  function cmp_ge_log_Int (x: int) (y: int) : ()
  
  axiom cmp_ge_log_Int_spec: forall x: int, y: int. (x >= y) = (cmp_log_Int x y <> Less)
  
  function cmp_lt_log_Int (x: int) (y: int) : ()
  
  axiom cmp_lt_log_Int_spec: forall x: int, y: int. (x < y) = (cmp_log_Int x y = Less)
  
  function cmp_le_log_Int (x: int) (y: int) : ()
  
  axiom cmp_le_log_Int_spec: forall x: int, y: int. (x <= y) = (cmp_log_Int x y <> Greater)
  
  function deep_model_usize [@inline:trivial] (self: UInt64.t) : int = UInt64.t'int self
  
  meta "rewrite_def" function deep_model_usize
  
  let rec partial_cmp_usize (self_: UInt64.t) (rhs: UInt64.t) (return (x: t_Option_Ordering)) = any
    [ return (result: t_Option_Ordering) -> {[@stop_split] [@expl:partial_cmp ensures] result
      = Some (cmp_log_Int (deep_model_usize self_) (deep_model_usize rhs))}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Ordering) (return (f0: t_Ordering)) = any
    [ _k (f0: t_Ordering) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  function deep_model_ref_usize [@inline:trivial] (self: UInt64.t) : int = deep_model_usize self
  
  meta "rewrite_def" function deep_model_ref_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_PartialOrd_usize_usize_ge_body (self_: UInt64.t) (other: UInt64.t) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = partial_cmp_usize {self_} {other} (fun (_x: t_Option_Ordering) -> [ &_6 <- _x ] s1)
      | s1 = any [ br0 -> {_6 = None} (! bb2) | br1 (x0: t_Ordering) -> {_6 = Some x0} (! bb3) ] ]
    | bb3 = elim_Some {_6}
        (fun (r0: t_Ordering) ->
          any [ br0 -> {r0 = Less} (! bb2) | br1 -> {r0 = Equal} (! bb5) | br2 -> {r0 = Greater} (! bb5) ])
    | bb2 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb5 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: UInt64.t = self_
    | & other: UInt64.t = other
    | & _6: t_Option_Ordering = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_PartialOrd_usize_usize_ge_body ensures] result
      = (deep_model_ref_usize self_ >= deep_model_ref_usize other)}
      (! return {result}) ]
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_le_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate le_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_le_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_le_log_Reverse_T: [@stop_split] [@expl:cmp_le_log ensures] le_log_Reverse_T x y
    = (cmp_log_Reverse_T x y <> Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_lt_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate lt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_lt_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_lt_log_Reverse_T: [@stop_split] [@expl:cmp_lt_log ensures] lt_log_Reverse_T x y
    = (cmp_log_Reverse_T x y = Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_ge_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate ge_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_ge_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_ge_log_Reverse_T: [@stop_split] [@expl:cmp_ge_log ensures] ge_log_Reverse_T x y
    = (cmp_log_Reverse_T x y <> Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_gt_log (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate gt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function cmp_gt_log_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_cmp_gt_log_Reverse_T: [@stop_split] [@expl:cmp_gt_log ensures] gt_log_Reverse_T x y
    = (cmp_log_Reverse_T x y = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__refl (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  function refl_Reverse_T (x: t_Reverse_T) : ()
  
  goal vc_refl_Reverse_T: [@stop_split] [@expl:refl ensures] cmp_log_Reverse_T x x = Equal
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__trans (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  constant z : t_Reverse_T
  
  constant o : t_Ordering
  
  function trans_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) (z: t_Reverse_T) (o: t_Ordering) : ()
  
  goal vc_trans_Reverse_T: cmp_log_Reverse_T x y = o
    -> cmp_log_Reverse_T y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_Reverse_T x z = o)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym1 (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function antisym1_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_antisym1_Reverse_T: cmp_log_Reverse_T x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_Reverse_T y x = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym2 (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function antisym2_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_antisym2_Reverse_T: cmp_log_Reverse_T x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_Reverse_T y x = Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__eq_cmp (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Reverse_T
  
  constant y : t_Reverse_T
  
  function eq_cmp_Reverse_T (x: t_Reverse_T) (y: t_Reverse_T) : ()
  
  goal vc_eq_cmp_Reverse_T: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_Reverse_T x y = Equal)
end
module M_std__hint__extern_spec_core_hint_assert_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_hint_assert_unchecked_body (cond: bool) (return (x: ())) =
    {[@stop_split] [@expl:extern_spec_core_hint_assert_unchecked_body requires] cond}
    (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_std__hint__extern_spec_core_hint_black_box_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_hint_black_box_body_T (dummy: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_hint_black_box_body 'dummy' type invariant] inv_T dummy}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- dummy ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & dummy: t_T = dummy ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_hint_black_box_body_T ensures] ([@stop_split] [@expl:extern_spec_core_hint_black_box_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_hint_black_box_body ensures] result = dummy)}
      (! return {result}) ]
end
module M_std__hint__extern_spec_core_hint_spin_loop_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_hint_spin_loop_body (return (x: ())) = (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_std__hint__extern_spec_core_hint_unreachable_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  predicate inv_never [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_never
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_hint_unreachable_unchecked_body (return (x: ())) =
    {[@stop_split] [@expl:extern_spec_core_hint_unreachable_unchecked_body requires] false}
    (! bb0
    [ bb0 = {false} any ])
    [ return (result: ()) ->
    {[@stop_split] [@expl:extern_spec_core_hint_unreachable_unchecked_body result type invariant] inv_never result}
      (! return {result}) ]
end
module M_std__hint__extern_spec_core_hint_must_use_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_hint_must_use_body_T (value: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_hint_must_use_body 'value' type invariant] inv_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- value ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & value: t_T = value ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_hint_must_use_body_T ensures] ([@stop_split] [@expl:extern_spec_core_hint_must_use_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_hint_must_use_body ensures] result = value)}
      (! return {result}) ]
end
module M_std__intrinsics__extern_spec_core_intrinsics_assume_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_intrinsics_assume_body (b: bool) (return (x: ())) =
    {[@stop_split] [@expl:extern_spec_core_intrinsics_assume_body requires] b}
    (! bb0
    [ bb0 = any [ br0 -> {b = false} (! bb1) | br1 -> {b} (! bb2) ] | bb2 = return {_ret} | bb1 = {false} any ]
    [ & _ret: () = Any.any_l () | & b: bool = b ]) [ return (result: ()) -> (! return {result}) ]
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_refl (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Cloned_I
  
  function produces_refl_Cloned_I (self: t_Cloned_I) : ()
  
  goal vc_produces_refl_Cloned_I:
    [@stop_split] [@expl:produces_refl ensures] produces_Cloned_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_trans (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Cloned_I
  
  constant ab : Seq.seq t_T
  
  constant b : t_Cloned_I
  
  constant bc : Seq.seq t_T
  
  constant c : t_Cloned_I
  
  function produces_trans_Cloned_I (a: t_Cloned_I) (ab: Seq.seq t_T) (b: t_Cloned_I) (bc: Seq.seq t_T) (c: t_Cloned_I) : ()
  
  goal vc_produces_trans_Cloned_I: produces_Cloned_I a ab b
    -> produces_Cloned_I b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Cloned_I a (Seq.(++) ab bc) c)
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_refl (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Copied_I
  
  function produces_refl_Copied_I (self: t_Copied_I) : ()
  
  goal vc_produces_refl_Copied_I:
    [@stop_split] [@expl:produces_refl ensures] produces_Copied_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_trans (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Copied_I
  
  constant ab : Seq.seq t_T
  
  constant b : t_Copied_I
  
  constant bc : Seq.seq t_T
  
  constant c : t_Copied_I
  
  function produces_trans_Copied_I (a: t_Copied_I) (ab: Seq.seq t_T) (b: t_Copied_I) (bc: Seq.seq t_T) (c: t_Copied_I) : ()
  
  goal vc_produces_trans_Copied_I: produces_Copied_I a ab b
    -> produces_Copied_I b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Copied_I a (Seq.(++) ab bc) c)
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_refl (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Empty_T
  
  function produces_refl_Empty_T (self: t_Empty_T) : ()
  
  goal vc_produces_refl_Empty_T:
    [@stop_split] [@expl:produces_refl ensures] produces_Empty_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_trans (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Empty_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Empty_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Empty_T
  
  function produces_trans_Empty_T (a: t_Empty_T) (ab: Seq.seq t_T) (b: t_Empty_T) (bc: Seq.seq t_T) (c: t_Empty_T) : ()
  
  goal vc_produces_trans_Empty_T: produces_Empty_T a ab b
    -> produces_Empty_T b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Empty_T a (Seq.(++) ab bc) c)
end
module M_std__iter__enumerate__impl_Invariant_for_Enumerate_I__invariant (* <std::iter::Enumerate<I> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_Enumerate_I
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Enumerate_I
  
  predicate invariant_Enumerate_I (self: t_Enumerate_I)
  
  goal vc_invariant_Enumerate_I: if inv_I (iter_Enumerate_I self) then
      if forall s: Seq.seq t_Item, i: t_I [produces_I (iter_Enumerate_I self) s i]. produces_I (iter_Enumerate_I self) s i
        -> UInt64.t'int (n_Enumerate_I self) + Seq.length s < UInt64.t'int const_MAX then
        [@stop_split] [@expl:invariant ensures] (forall i: MutBorrow.t t_I. completed_I i
            -> produces_I i.current (Seq.empty: Seq.seq t_Item) i.final) -> inv_I (iter_Enumerate_I self)
      else
        [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Enumerate_I self)
    
    else
      [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Enumerate_I self)

end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_refl (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Enumerate_I
  
  function produces_refl_Enumerate_I (self: t_Enumerate_I) : ()
  
  goal vc_produces_refl_Enumerate_I:
    [@stop_split] [@expl:produces_refl ensures] produces_Enumerate_I self (Seq.empty: Seq.seq tup2_usize_Item) self
end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_trans (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Enumerate_I
  
  constant ab : Seq.seq tup2_usize_Item
  
  constant b : t_Enumerate_I
  
  constant bc : Seq.seq tup2_usize_Item
  
  constant c : t_Enumerate_I
  
  function produces_trans_Enumerate_I (a: t_Enumerate_I) (ab: Seq.seq tup2_usize_Item) (b: t_Enumerate_I) (bc: Seq.seq tup2_usize_Item) (c: t_Enumerate_I) : ()
  
  goal vc_produces_trans_Enumerate_I: produces_Enumerate_I a ab b
    -> produces_Enumerate_I b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_Enumerate_I a (Seq.(++) ab bc) c)
end
module M_std__iter__filter__impl_Invariant_for_Filter_I_F__invariant (* <std::iter::Filter<I, F> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Filter_I_F
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  type t_Item
  
  predicate inv_Item (_1: t_Item)
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) =
    forall f: t_F, i: t_Item. inv_F f /\ inv_ref_Item i -> precondition_F f i
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Filter_I_F
  
  predicate invariant_Filter_I_F (self: t_Filter_I_F)
  
  goal vc_invariant_Filter_I_F: if inv_I (iter_Filter_I_F self) then
      if inv_F (func_Filter_I_F self) then
        [@stop_split] [@expl:invariant ensures] private_invariant_I self
        -> inv_I (iter_Filter_I_F self) /\ inv_F (func_Filter_I_F self)
      else
        [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Filter_I_F self) /\ inv_F (func_Filter_I_F self)
    
    else
      [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Filter_I_F self) /\ inv_F (func_Filter_I_F self)

end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_refl (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_Item (_1: t_Item)
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) =
    forall f: t_F, i: t_Item. inv_F f /\ inv_ref_Item i -> precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Filter_I_F
  
  function produces_refl_Filter_I_F (self: t_Filter_I_F) : ()
  
  goal vc_produces_refl_Filter_I_F:
    [@stop_split] [@expl:produces_refl ensures] produces_Filter_I_F self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_trans (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_Item (_1: t_Item)
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) =
    forall f: t_F, i: t_Item. inv_F f /\ inv_ref_Item i -> precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Filter_I_F
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Filter_I_F
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Filter_I_F
  
  function produces_trans_Filter_I_F (a: t_Filter_I_F) (ab: Seq.seq t_Item) (b: t_Filter_I_F) (bc: Seq.seq t_Item) (c: t_Filter_I_F) : ()
  
  goal vc_produces_trans_Filter_I_F: produces_Filter_I_F a ab b
    -> produces_Filter_I_F b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_Filter_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_refl (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate inv_Item (_1: t_Item)
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. inv_Item i -> precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_FilterMap_I_F
  
  function produces_refl_FilterMap_I_F (self: t_FilterMap_I_F) : ()
  
  goal vc_produces_refl_FilterMap_I_F:
    [@stop_split] [@expl:produces_refl ensures] produces_FilterMap_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_trans (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate inv_Item (_1: t_Item)
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. inv_Item i -> precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_FilterMap_I_F
  
  constant ab : Seq.seq t_B
  
  constant b : t_FilterMap_I_F
  
  constant bc : Seq.seq t_B
  
  constant c : t_FilterMap_I_F
  
  function produces_trans_FilterMap_I_F (a: t_FilterMap_I_F) (ab: Seq.seq t_B) (b: t_FilterMap_I_F) (bc: Seq.seq t_B) (c: t_FilterMap_I_F) : ()
  
  goal vc_produces_trans_FilterMap_I_F: produces_FilterMap_I_F a ab b
    -> produces_FilterMap_I_F b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_FilterMap_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_refl (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Fuse_I
  
  function produces_refl_Fuse_I (self: t_Fuse_I) : ()
  
  goal vc_produces_refl_Fuse_I:
    [@stop_split] [@expl:produces_refl ensures] produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_trans (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Fuse_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Fuse_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Fuse_I
  
  function produces_trans_Fuse_I (a: t_Fuse_I) (ab: Seq.seq t_Item) (b: t_Fuse_I) (bc: Seq.seq t_Item) (c: t_Fuse_I) : ()
  
  goal vc_produces_trans_Fuse_I: produces_Fuse_I a ab b
    -> produces_Fuse_I b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Fuse_I a (Seq.(++) ab bc) c)
end
module M_std__iter__fuse__impl_FusedIterator_for_Fuse_I__is_fused (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  function produces_trans_Fuse_I (a: t_Fuse_I) (ab: Seq.seq t_Item) (b: t_Fuse_I) (bc: Seq.seq t_Item) (c: t_Fuse_I) : ()
   = ()
  
  axiom produces_trans_Fuse_I_spec:
    forall a: t_Fuse_I, ab: Seq.seq t_Item, b: t_Fuse_I, bc: Seq.seq t_Item, c: t_Fuse_I. produces_Fuse_I a ab b
      -> produces_Fuse_I b bc c -> produces_Fuse_I a (Seq.(++) ab bc) c
  
  function produces_refl_Fuse_I (self: t_Fuse_I) : () = ()
  
  axiom produces_refl_Fuse_I_spec: forall self: t_Fuse_I. produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate completed_Fuse_I (self: MutBorrow.t t_Fuse_I) =
    (view_Fuse_I self.current = None
      \/ (exists it: MutBorrow.t t_I. completed_I it /\ view_Fuse_I self.current = Some (it.current)))
    /\ view_Fuse_I self.final = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_Fuse_I
  
  constant steps : Seq.seq t_Item
  
  constant next : t_Fuse_I
  
  function is_fused_Fuse_I (self: MutBorrow.t t_Fuse_I) (steps: Seq.seq t_Item) (next: t_Fuse_I) : ()
  
  goal vc_is_fused_Fuse_I: completed_Fuse_I self
    -> produces_Fuse_I self.final steps next
    -> ([@stop_split] [@expl:is_fused ensures] steps = (Seq.empty: Seq.seq t_Item))
end
module M_std__iter__map__impl_Invariant_for_Map_I_F__invariant (* <std::iter::Map<I, F> as invariant::Invariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_Map_I_F
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate inv_Item (_1: t_Item)
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate next_precondition_I [@inline:trivial] (iter: t_I) (func: t_F) =
    forall e: t_Item, i: t_I [produces_I iter (Seq.singleton e) i]. inv_Item e /\ produces_I iter (Seq.singleton e) i
      -> precondition_F func e
  
  meta "rewrite_def" predicate next_precondition_I
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate invariant_Seq_Item [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_Item (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_Item
  
  predicate inv_Seq_Item [@inline:trivial] (_1: Seq.seq t_Item) = invariant_Seq_Item _1
  
  meta "rewrite_def" predicate inv_Seq_Item
  
  predicate invariant_refmut_F [@inline:trivial] (self: MutBorrow.t t_F) = inv_F self.current /\ inv_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_F
  
  predicate inv_refmut_F [@inline:trivial] (_1: MutBorrow.t t_F) = invariant_refmut_F _1
  
  meta "rewrite_def" predicate inv_refmut_F
  
  predicate preservation_I [@inline:trivial] (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I [produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i, postcondition_mut_F f.current e1 f.final b]. hist_inv_F func f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current e1 f.final b -> precondition_F f.final e2
  
  meta "rewrite_def" predicate preservation_I
  
  predicate reinitialize_I [@inline:trivial] =
    forall iter: MutBorrow.t t_I, func: t_F. completed_I iter
      -> next_precondition_I iter.final func /\ preservation_I iter.final func
  
  meta "rewrite_def" predicate reinitialize_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map_I_F
  
  predicate invariant_Map_I_F (self: t_Map_I_F)
  
  goal vc_invariant_Map_I_F: if inv_I (iter_Map_I_F self) then
      if inv_F (func_Map_I_F self) then
        if reinitialize_I then
          if preservation_I (iter_Map_I_F self) (func_Map_I_F self) then
            [@stop_split] [@expl:invariant ensures] next_precondition_I (iter_Map_I_F self) (func_Map_I_F self)
            -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
          else
            [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
        
        else
          [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
      
      else
        [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)
    
    else
      [@stop_split] [@expl:invariant ensures] false -> inv_I (iter_Map_I_F self) /\ inv_F (func_Map_I_F self)

end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_refl (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Map_I_F
  
  function produces_refl_Map_I_F (self: t_Map_I_F) : ()
  
  goal vc_produces_refl_Map_I_F:
    [@stop_split] [@expl:produces_refl ensures] produces_Map_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_trans (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Map_I_F
  
  constant ab : Seq.seq t_B
  
  constant b : t_Map_I_F
  
  constant bc : Seq.seq t_B
  
  constant c : t_Map_I_F
  
  function produces_trans_Map_I_F (a: t_Map_I_F) (ab: Seq.seq t_B) (b: t_Map_I_F) (bc: Seq.seq t_B) (c: t_Map_I_F) : ()
  
  goal vc_produces_trans_Map_I_F: produces_Map_I_F a ab b
    -> produces_Map_I_F b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Map_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_refl (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv_I_F
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : ()
  
  goal vc_produces_refl_MapInv_I_F:
    [@stop_split] [@expl:produces_refl ensures] produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_trans (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_MapInv_I_F
  
  constant ab : Seq.seq t_B
  
  constant b : t_MapInv_I_F
  
  constant bc : Seq.seq t_B
  
  constant c : t_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
  
  goal vc_produces_trans_MapInv_I_F: produces_MapInv_I_F a ab b
    -> produces_MapInv_I_F b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_MapInv_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__map_inv__impl_Iterator_for_MapInv_I_F__next (* <std::iter::map_inv::MapInv<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.prelude.Any
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  predicate inv_I (_1: t_I)
  
  type t_Option_Item = None | Some t_Item
  
  predicate invariant_refmut_I [@inline:trivial] (self: MutBorrow.t t_I) = inv_I self.current /\ inv_I self.final
  
  meta "rewrite_def" predicate invariant_refmut_I
  
  predicate inv_refmut_I [@inline:trivial] (_1: MutBorrow.t t_I) = invariant_refmut_I _1
  
  meta "rewrite_def" predicate inv_refmut_I
  
  predicate precondition_next (self: ()) (args: MutBorrow.t t_I)
  
  axiom precondition_fndef:
    forall args: MutBorrow.t t_I [precondition_next () args]. (let self_ = args in inv_refmut_I self_)
      -> precondition_next () args
  
  predicate inv_Item (_1: t_Item)
  
  predicate inv_Option_Item (_1: t_Option_Item)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_Item [inv_Option_Item x]. inv_Option_Item x
      = match x with
        | None -> true
        | Some f0 -> inv_Item f0
        end
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate postcondition_once_next (self: ()) (args: MutBorrow.t t_I) (result: t_Option_Item)
  
  axiom postcondition_fndef:
    forall args: MutBorrow.t t_I, res: t_Option_Item [postcondition_once_next () args res]. postcondition_once_next () args res
      -> (let self_ = args in inv_Option_Item res
      /\ match res with
        | None -> completed_I self_
        | Some v -> produces_I self_.current (Seq.singleton v) self_.final
        end)
  
  let rec next_I (self_: MutBorrow.t t_I) (return (x: t_Option_Item)) =
    {[@stop_split] [@expl:next requires] precondition_next () self_}
    any
    [ return (result: t_Option_Item) -> {[@stop_split] [@expl:next ensures] postcondition_once_next () self_ result}
      (! return {result}) ]
  
  let rec elim_Some (_x: t_Option_Item) (return (f0: t_Item)) = any
    [ _k (f0: t_Item) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate inv_F (_1: t_F)
  
  type t_B
  
  predicate invariant_refmut_F [@inline:trivial] (self: MutBorrow.t t_F) = inv_F self.current /\ inv_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_F
  
  predicate inv_refmut_F [@inline:trivial] (_1: MutBorrow.t t_F) = invariant_refmut_F _1
  
  meta "rewrite_def" predicate inv_refmut_F
  
  predicate inv_tup2_Item_Snapshot_Seq_Item [@inline:trivial] (_1: tup2_Item_Snapshot_Seq_Item) = inv_Item _1.f0
  
  meta "rewrite_def" predicate inv_tup2_Item_Snapshot_Seq_Item
  
  predicate inv_B (_1: t_B)
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  let rec call_mut_F (self_: MutBorrow.t t_F) (arg: tup2_Item_Snapshot_Seq_Item) (return (x: t_B)) =
    {[@stop_split] [@expl:call_mut_F requires] ([@stop_split] [@expl:call_mut 'self_' type invariant] inv_refmut_F self_)
    /\ ([@stop_split] [@expl:call_mut 'arg' type invariant] inv_tup2_Item_Snapshot_Seq_Item arg)
    /\ ([@stop_split] [@expl:call_mut requires] precondition_F self_.current arg)}
    any
    [ return (result: t_B) ->
    {[@stop_split] [@expl:call_mut_F ensures] ([@stop_split] [@expl:call_mut result type invariant] inv_B result)
      /\ ([@stop_split] [@expl:call_mut ensures] postcondition_mut_F self_.current arg self_.final result)}
      (! return {result}) ]
  
  predicate next_precondition_I [@inline:trivial] (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. inv_Item e /\ produces_I iter'0 (Seq.singleton e) i
      -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  meta "rewrite_def" predicate next_precondition_I
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate invariant_Seq_Item [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_Item (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_Item
  
  predicate inv_Seq_Item [@inline:trivial] (_1: Seq.seq t_Item) = invariant_Seq_Item _1
  
  meta "rewrite_def" predicate inv_Seq_Item
  
  predicate preservation_I [@inline:trivial] (iter'0: t_I) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  meta "rewrite_def" predicate preservation_I
  
  predicate reinitialize_I [@inline:trivial] =
    forall iter'0: MutBorrow.t t_I, func'0: t_F. completed_I iter'0
      -> next_precondition_I iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_I iter'0.final func'0
  
  meta "rewrite_def" predicate reinitialize_I
  
  predicate preservation_inv_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced'0 s) e1 }
  
  axiom preservation_inv_I_spec: forall iter'0: t_I, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv_I iter'0 func'0 produced'0 = preservation_I iter'0 func'0
  
  predicate invariant_MapInv_I_F (self: t_MapInv_I_F) =
    reinitialize_I
    /\ preservation_inv_I self.iter self.func self.produced /\ next_precondition_I self.iter self.func self.produced
  
  function produces_one_invariant_I (self: t_MapInv_I_F) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter'0: t_I) : () =
    ()
  
  axiom produces_one_invariant_I_spec:
    forall self: t_MapInv_I_F, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter'0: t_I. inv_Item e /\ inv_refmut_F f
      -> invariant_MapInv_I_F self
      -> produces_I self.iter (Seq.singleton e) iter'0
      -> f.current = self.func
      -> postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final r
      -> preservation_inv_I iter'0 f.final (Seq.snoc self.produced e)
  
  axiom produces_one_invariant_I_spec'0:
    forall self: t_MapInv_I_F, e: t_Item, r: t_B, f: MutBorrow.t t_F, iter'0: t_I. inv_Item e /\ inv_refmut_F f
      -> invariant_MapInv_I_F self
      -> produces_I self.iter (Seq.singleton e) iter'0
      -> f.current = self.func
      -> postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final r
      -> next_precondition_I iter'0 f.final (Seq.snoc self.produced e)
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
   = ()
  
  axiom produces_trans_MapInv_I_F_spec:
    forall a: t_MapInv_I_F, ab: Seq.seq t_B, b: t_MapInv_I_F, bc: Seq.seq t_B, c: t_MapInv_I_F. produces_MapInv_I_F a ab b
      -> produces_MapInv_I_F b bc c -> produces_MapInv_I_F a (Seq.(++) ab bc) c
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : () = ()
  
  axiom produces_refl_MapInv_I_F_spec: forall self: t_MapInv_I_F. produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
  
  predicate produces_one_I (self: t_MapInv_I_F) (visited: t_B) (succ: t_MapInv_I_F) =
    exists f: MutBorrow.t t_F, e: t_Item. f.current = self.func
      /\ f.final = succ.func
      /\ produces_I self.iter (Seq.singleton e) succ.iter
      /\ succ.produced = Seq.snoc self.produced e
      /\ postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final visited
  
  axiom produces_one_I_spec:
    forall self: t_MapInv_I_F, visited: t_B, succ: t_MapInv_I_F. produces_one_I self visited succ
      = produces_MapInv_I_F self (Seq.singleton visited) succ
  
  predicate inv_MapInv_I_F (_1: t_MapInv_I_F)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_MapInv_I_F [inv_MapInv_I_F x]. inv_MapInv_I_F x
      = (invariant_MapInv_I_F x /\ inv_I x.iter /\ inv_F x.func)
  
  predicate invariant_refmut_MapInv_I_F [@inline:trivial] (self: MutBorrow.t t_MapInv_I_F) =
    inv_MapInv_I_F self.current /\ inv_MapInv_I_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_MapInv_I_F
  
  predicate inv_refmut_MapInv_I_F [@inline:trivial] (_1: MutBorrow.t t_MapInv_I_F) = invariant_refmut_MapInv_I_F _1
  
  meta "rewrite_def" predicate inv_refmut_MapInv_I_F
  
  predicate resolve_refmut_MapInv_I_F [@inline:trivial] (_1: MutBorrow.t t_MapInv_I_F) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_MapInv_I_F
  
  type t_Option_B = None'0 | Some'0 t_B
  
  predicate inv_Option_B (_1: t_Option_B)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_B [inv_Option_B x]. inv_Option_B x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_B f0'0
        end
  
  predicate completed_MapInv_I_F (self: MutBorrow.t t_MapInv_I_F) =
    self.final.produced = (Seq.empty: Seq.seq t_Item)
    /\ completed_I (MutBorrow.borrow_logic self.current.iter self.final.iter (MutBorrow.inherit_id (MutBorrow.get_id self) 0))
    /\ self.current.func = self.final.func
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec next_MapInv_I_F (self: MutBorrow.t t_MapInv_I_F) (return (x: t_Option_B)) =
    {[@stop_split] [@expl:next 'self' type invariant] inv_refmut_MapInv_I_F self}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_old_self <- self.current ] s1
      | s1 = MutBorrow.borrow_final <t_I> {self.current.iter} {MutBorrow.inherit_id (MutBorrow.get_id self) 0}
          (fun (_bor: MutBorrow.t t_I) ->
            [ &_8 <- _bor ] -{inv_I _bor.final}-
            [ &self <- { self with current = { self.current with iter = _bor.final } } ] s2)
        [ _ck -> (! {[@expl:type invariant] inv_I self.current.iter} any) ]
      | s2 = next_I {_8} (fun (_x: t_Option_Item) -> [ &_7 <- _x ] s3)
      | s3 = any [ br0 -> {_7 = None} (! bb14) | br1 (x0: t_Item) -> {_7 = Some x0} (! bb6) ] ]
    | bb6 = s0
      [ s0 = elim_Some {_7} (fun (r0: t_Item) -> [ &v <- r0 ] s1)
      | s1 = {[@expl:assertion] precondition_F self.current.func { f0 = v; f1 = self.current.produced }} s2
      | s2 = [ &produced'0 <- Seq.snoc self.current.produced v ] s3
      | s3 = MutBorrow.borrow_final <t_F> {self.current.func} {MutBorrow.inherit_id (MutBorrow.get_id self) 1}
          (fun (_bor: MutBorrow.t t_F) ->
            [ &_21 <- _bor ] -{inv_F _bor.final}-
            [ &self <- { self with current = { self.current with func = _bor.final } } ] s4)
        [ _ck -> (! {[@expl:type invariant] inv_F self.current.func} any) ]
      | s4 = [ &_22 <- { f0 = v; f1 = self.current.produced } ] s5
      | s5 = call_mut_F {_21} {_22} (fun (_x: t_B) -> [ &r <- _x ] s6)
      | s6 = [ &self <- { self with current = { self.current with produced = produced'0 } } ] s7
      | s7 = [ &_26 <- () ] s8
      | s8 = {[@expl:assertion] produces_one_I _old_self r self.current} s9
      | s9 = s10 [ _ck -> (! {[@expl:type invariant] inv_refmut_MapInv_I_F self} any) ]
      | s10 = -{resolve_refmut_MapInv_I_F self}- s11
      | s11 = [ &_ret <- Some'0 r ] s12
      | s12 = return {_ret} ]
    | bb14 = s0
      [ s0 = [ &self <- { self with current = { self.current with produced = Seq.empty: Seq.seq t_Item } } ] s1
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_refmut_MapInv_I_F self} any) ]
      | s2 = -{resolve_refmut_MapInv_I_F self}- s3
      | s3 = [ &_ret <- None'0 ] s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_Option_B = Any.any_l ()
    | & self: MutBorrow.t t_MapInv_I_F = self
    | & _old_self: t_MapInv_I_F = Any.any_l ()
    | & _7: t_Option_Item = Any.any_l ()
    | & _8: MutBorrow.t t_I = Any.any_l ()
    | & v: t_Item = Any.any_l ()
    | & produced'0: Seq.seq t_Item = Any.any_l ()
    | & r: t_B = Any.any_l ()
    | & _21: MutBorrow.t t_F = Any.any_l ()
    | & _22: tup2_Item_Snapshot_Seq_Item = Any.any_l ()
    | & _26: () = Any.any_l () ])
    [ return (result: t_Option_B) ->
    {[@stop_split] [@expl:next_MapInv_I_F ensures] ([@stop_split] [@expl:next result type invariant] inv_Option_B result)
      /\ ([@stop_split] [@expl:next ensures] match result with
        | None'0 -> completed_MapInv_I_F self
        | Some'0 v -> produces_one_I self.current v self.final
        end)}
      (! return {result}) ]
end
module M_std__iter__map_inv__impl_MapInv_I_F__preservation_inv (* std::iter::map_inv::MapInv<I, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate inv_Item (_1: t_Item)
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate invariant_Seq_Item [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_Item (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_Item
  
  predicate inv_Seq_Item [@inline:trivial] (_1: Seq.seq t_Item) = invariant_Seq_Item _1
  
  meta "rewrite_def" predicate inv_Seq_Item
  
  predicate inv_F (_1: t_F)
  
  predicate invariant_refmut_F [@inline:trivial] (self: MutBorrow.t t_F) = inv_F self.current /\ inv_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_F
  
  predicate inv_refmut_F [@inline:trivial] (_1: MutBorrow.t t_F) = invariant_refmut_F _1
  
  meta "rewrite_def" predicate inv_refmut_F
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate preservation_I [@inline:trivial] (iter: t_I) (func: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  meta "rewrite_def" predicate preservation_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant iter : t_I
  
  constant func : t_F
  
  constant produced : Seq.seq t_Item
  
  predicate preservation_inv_I (iter: t_I) (func: t_F) (produced: Seq.seq t_Item)
  
  goal vc_preservation_inv_I: [@stop_split] [@expl:preservation_inv ensures] produced = (Seq.empty: Seq.seq t_Item)
    -> (forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func f.current
        -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
        -> produces_I iter (Seq.snoc (Seq.snoc s e1) e2) i
        -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced s } f.final b
        -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced s) e1 })
    = preservation_I iter func
end
module M_std__iter__map_inv__impl_MapInv_I_F__produces_one_invariant (* std::iter::map_inv::MapInv<I, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  predicate inv_Item (_1: t_Item)
  
  predicate inv_F (_1: t_F)
  
  predicate invariant_refmut_F [@inline:trivial] (self: MutBorrow.t t_F) = inv_F self.current /\ inv_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_F
  
  predicate inv_refmut_F [@inline:trivial] (_1: MutBorrow.t t_F) = invariant_refmut_F _1
  
  meta "rewrite_def" predicate inv_refmut_F
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate next_precondition_I [@inline:trivial] (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. inv_Item e /\ produces_I iter'0 (Seq.singleton e) i
      -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  meta "rewrite_def" predicate next_precondition_I
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate invariant_Seq_Item [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_Item (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_Item
  
  predicate inv_Seq_Item [@inline:trivial] (_1: Seq.seq t_Item) = invariant_Seq_Item _1
  
  meta "rewrite_def" predicate inv_Seq_Item
  
  predicate preservation_I [@inline:trivial] (iter'0: t_I) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  meta "rewrite_def" predicate preservation_I
  
  predicate reinitialize_I [@inline:trivial] =
    forall iter'0: MutBorrow.t t_I, func'0: t_F. completed_I iter'0
      -> next_precondition_I iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_I iter'0.final func'0
  
  meta "rewrite_def" predicate reinitialize_I
  
  predicate preservation_inv_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced'0 s) e1 }
  
  axiom preservation_inv_I_spec: forall iter'0: t_I, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv_I iter'0 func'0 produced'0 = preservation_I iter'0 func'0
  
  predicate invariant_MapInv_I_F (self: t_MapInv_I_F) =
    reinitialize_I
    /\ preservation_inv_I self.iter self.func self.produced /\ next_precondition_I self.iter self.func self.produced
  
  function push_front_Item [@inline:trivial] (self: Seq.seq t_Item) (x: t_Item) : Seq.seq t_Item = Seq.cons x self
  
  meta "rewrite_def" function push_front_Item
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv_I_F
  
  constant e : t_Item
  
  constant r : t_B
  
  constant f : MutBorrow.t t_F
  
  constant iter'0 : t_I
  
  function produces_one_invariant_I (self: t_MapInv_I_F) (e: t_Item) (r: t_B) (f: MutBorrow.t t_F) (iter'0: t_I) : ()
  
  goal vc_produces_one_invariant_I: inv_Item e /\ inv_refmut_F f
    -> invariant_MapInv_I_F self
    -> produces_I self.iter (Seq.singleton e) iter'0
    -> f.current = self.func
    -> postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final r
    -> (forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, i: t_I. produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
        -> produces_I self.iter (Seq.snoc (Seq.snoc (push_front_Item s e) e1) e2) i)
    && ([@stop_split] [@expl:produces_one_invariant_I ensures] ([@stop_split] [@expl:produces_one_invariant ensures #0] preservation_inv_I iter'0 f.final (Seq.snoc self.produced e))
    /\ ([@stop_split] [@expl:produces_one_invariant ensures #1] next_precondition_I iter'0 f.final (Seq.snoc self.produced e)))
end
module M_std__iter__map_inv__impl_MapInv_I_F__produces_one (* std::iter::map_inv::MapInv<I, F> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
   = ()
  
  axiom produces_trans_MapInv_I_F_spec:
    forall a: t_MapInv_I_F, ab: Seq.seq t_B, b: t_MapInv_I_F, bc: Seq.seq t_B, c: t_MapInv_I_F. produces_MapInv_I_F a ab b
      -> produces_MapInv_I_F b bc c -> produces_MapInv_I_F a (Seq.(++) ab bc) c
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : () = ()
  
  axiom produces_refl_MapInv_I_F_spec: forall self: t_MapInv_I_F. produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_MapInv_I_F
  
  constant visited : t_B
  
  constant succ : t_MapInv_I_F
  
  predicate produces_one_I (self: t_MapInv_I_F) (visited: t_B) (succ: t_MapInv_I_F)
  
  goal vc_produces_one_I: [@stop_split] [@expl:produces_one ensures] (exists f: MutBorrow.t t_F, e: t_Item. f.current
          = self.func
        /\ f.final = succ.func
        /\ produces_I self.iter (Seq.singleton e) succ.iter
        /\ succ.produced = Seq.snoc self.produced e
        /\ postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final visited)
    = produces_MapInv_I_F self (Seq.singleton visited) succ
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_refl (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Once_T
  
  function produces_refl_Once_T (self: t_Once_T) : ()
  
  goal vc_produces_refl_Once_T:
    [@stop_split] [@expl:produces_refl ensures] produces_Once_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_trans (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Once_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Once_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Once_T
  
  function produces_trans_Once_T (a: t_Once_T) (ab: Seq.seq t_T) (b: t_Once_T) (bc: Seq.seq t_T) (c: t_Once_T) : ()
  
  goal vc_produces_trans_Once_T: produces_Once_T a ab b
    -> produces_Once_T b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Once_T a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_refl (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Range_Idx
  
  function produces_refl_Range_Idx (self: t_Range_Idx) : ()
  
  goal vc_produces_refl_Range_Idx:
    [@stop_split] [@expl:produces_refl ensures] produces_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_trans (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Range_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_Range_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_Range_Idx
  
  function produces_trans_Range_Idx (a: t_Range_Idx) (ab: Seq.seq t_Idx) (b: t_Range_Idx) (bc: Seq.seq t_Idx) (c: t_Range_Idx) : ()
  
  goal vc_produces_trans_Range_Idx: produces_Range_Idx a ab b
    -> produces_Range_Idx b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_refl (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Range_Idx
  
  function produces_back_refl_Range_Idx (self: t_Range_Idx) : ()
  
  goal vc_produces_back_refl_Range_Idx:
    [@stop_split] [@expl:produces_back_refl ensures] produces_back_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_trans (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Range_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_Range_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_Range_Idx
  
  function produces_back_trans_Range_Idx (a: t_Range_Idx) (ab: Seq.seq t_Idx) (b: t_Range_Idx) (bc: Seq.seq t_Idx) (c: t_Range_Idx) : ()
  
  goal vc_produces_back_trans_Range_Idx: produces_back_Range_Idx a ab b
    -> produces_back_Range_Idx b bc c
    -> ([@stop_split] [@expl:produces_back_trans ensures] produces_back_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__range_inclusive_len
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant r : t_RangeInclusive_Idx
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int
  
  goal vc_range_inclusive_len_Idx: ([@stop_split] [@expl:is_empty_log ensures] not is_empty_log_RangeInclusive_Idx r
      -> deep_model_Idx (start_log_RangeInclusive_Idx r) <= deep_model_Idx (end_log_RangeInclusive_Idx r))
    -> (if is_empty_log_RangeInclusive_Idx r then
      [@stop_split] [@expl:range_inclusive_len ensures] is_empty_log_RangeInclusive_Idx r = (0 = 0)
    else
      [@stop_split] [@expl:range_inclusive_len ensures] is_empty_log_RangeInclusive_Idx r
      = (deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1 = 0)
    )
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_refl (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_RangeInclusive_Idx
  
  function produces_refl_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_refl_RangeInclusive_Idx:
    [@stop_split] [@expl:produces_refl ensures] produces_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_trans (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_RangeInclusive_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_RangeInclusive_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_RangeInclusive_Idx
  
  function produces_trans_RangeInclusive_Idx (a: t_RangeInclusive_Idx) (ab: Seq.seq t_Idx) (b: t_RangeInclusive_Idx) (bc: Seq.seq t_Idx) (c: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_trans_RangeInclusive_Idx: produces_RangeInclusive_Idx a ab b
    -> produces_RangeInclusive_Idx b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_refl (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_RangeInclusive_Idx
  
  function produces_back_refl_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_back_refl_RangeInclusive_Idx:
    [@stop_split] [@expl:produces_back_refl ensures] produces_back_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_trans (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_RangeInclusive_Idx
  
  constant ab : Seq.seq t_Idx
  
  constant b : t_RangeInclusive_Idx
  
  constant bc : Seq.seq t_Idx
  
  constant c : t_RangeInclusive_Idx
  
  function produces_back_trans_RangeInclusive_Idx (a: t_RangeInclusive_Idx) (ab: Seq.seq t_Idx) (b: t_RangeInclusive_Idx) (bc: Seq.seq t_Idx) (c: t_RangeInclusive_Idx) : ()
  
  goal vc_produces_back_trans_RangeInclusive_Idx: produces_back_RangeInclusive_Idx a ab b
    -> produces_back_RangeInclusive_Idx b bc c
    -> ([@stop_split] [@expl:produces_back_trans ensures] produces_back_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_refl (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Repeat_T
  
  function produces_refl_Repeat_T (self: t_Repeat_T) : ()
  
  goal vc_produces_refl_Repeat_T:
    [@stop_split] [@expl:produces_refl ensures] produces_Repeat_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_trans (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Repeat_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Repeat_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Repeat_T
  
  function produces_trans_Repeat_T (a: t_Repeat_T) (ab: Seq.seq t_T) (b: t_Repeat_T) (bc: Seq.seq t_T) (c: t_Repeat_T) : ()
  
  goal vc_produces_trans_Repeat_T: produces_Repeat_T a ab b
    -> produces_Repeat_T b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Repeat_T a (Seq.(++) ab bc) c)
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_refl (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Rev_I
  
  function produces_refl_Rev_I (self: t_Rev_I) : ()
  
  goal vc_produces_refl_Rev_I:
    [@stop_split] [@expl:produces_refl ensures] produces_Rev_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_trans (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Rev_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Rev_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Rev_I
  
  function produces_trans_Rev_I (a: t_Rev_I) (ab: Seq.seq t_Item) (b: t_Rev_I) (bc: Seq.seq t_Item) (c: t_Rev_I) : ()
  
  goal vc_produces_trans_Rev_I: produces_Rev_I a ab b
    -> produces_Rev_I b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Rev_I a (Seq.(++) ab bc) c)
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_refl (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Skip_I
  
  function produces_refl_Skip_I (self: t_Skip_I) : ()
  
  goal vc_produces_refl_Skip_I:
    [@stop_split] [@expl:produces_refl ensures] produces_Skip_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_trans (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Skip_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Skip_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Skip_I
  
  function produces_trans_Skip_I (a: t_Skip_I) (ab: Seq.seq t_Item) (b: t_Skip_I) (bc: Seq.seq t_Item) (c: t_Skip_I) : ()
  
  goal vc_produces_trans_Skip_I: produces_Skip_I a ab b
    -> produces_Skip_I b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Skip_I a (Seq.(++) ab bc) c)
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_refl (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Take_I
  
  function produces_refl_Take_I (self: t_Take_I) : ()
  
  goal vc_produces_refl_Take_I:
    [@stop_split] [@expl:produces_refl ensures] produces_Take_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_trans (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Take_I
  
  constant ab : Seq.seq t_Item
  
  constant b : t_Take_I
  
  constant bc : Seq.seq t_Item
  
  constant c : t_Take_I
  
  function produces_trans_Take_I (a: t_Take_I) (ab: Seq.seq t_Item) (b: t_Take_I) (bc: Seq.seq t_Item) (c: t_Take_I) : ()
  
  goal vc_produces_trans_Take_I: produces_Take_I a ab b
    -> produces_Take_I b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Take_I a (Seq.(++) ab bc) c)
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_refl (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Zip_A_B
  
  function produces_refl_Zip_A_B (self: t_Zip_A_B) : ()
  
  goal vc_produces_refl_Zip_A_B:
    [@stop_split] [@expl:produces_refl ensures] produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_trans (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Zip_A_B
  
  constant ab : Seq.seq tup2_Item_Item
  
  constant b : t_Zip_A_B
  
  constant bc : Seq.seq tup2_Item_Item
  
  constant c : t_Zip_A_B
  
  function produces_trans_Zip_A_B (a: t_Zip_A_B) (ab: Seq.seq tup2_Item_Item) (b: t_Zip_A_B) (bc: Seq.seq tup2_Item_Item) (c: t_Zip_A_B) : ()
  
  goal vc_produces_trans_Zip_A_B: produces_Zip_A_B a ab b
    -> produces_Zip_A_B b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Zip_A_B a (Seq.(++) ab bc) c)
end
module M_std__iter__trait_IteratorSpec__map_inv
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.Any
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_Item
  
  type t_Self
  
  type t_F
  
  type t_MapInv_Self_F = { iter: t_Self; func: t_F; produced: Seq.seq t_Item }
  
  predicate inv_Self (_1: t_Self)
  
  predicate inv_F (_1: t_F)
  
  predicate produces_Self (self: t_Self) (visited: Seq.seq t_Item) (o: t_Self)
  
  predicate inv_Item (_1: t_Item)
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate completed_Self (self: MutBorrow.t t_Self)
  
  predicate next_precondition_Self [@inline:trivial] (iter'0: t_Self) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_Self. inv_Item e /\ produces_Self iter'0 (Seq.singleton e) i
      -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  meta "rewrite_def" predicate next_precondition_Self
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate invariant_Seq_Item [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_Item (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_Item
  
  predicate inv_Seq_Item [@inline:trivial] (_1: Seq.seq t_Item) = invariant_Seq_Item _1
  
  meta "rewrite_def" predicate inv_Seq_Item
  
  predicate invariant_refmut_F [@inline:trivial] (self: MutBorrow.t t_F) = inv_F self.current /\ inv_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_F
  
  predicate inv_refmut_F [@inline:trivial] (_1: MutBorrow.t t_F) = invariant_refmut_F _1
  
  meta "rewrite_def" predicate inv_refmut_F
  
  predicate preservation_Self [@inline:trivial] (iter'0: t_Self) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_Self. hist_inv_F func'0 f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_Self iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  meta "rewrite_def" predicate preservation_Self
  
  predicate reinitialize_Self [@inline:trivial] =
    forall iter'0: MutBorrow.t t_Self, func'0: t_F. completed_Self iter'0
      -> next_precondition_Self iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_Self iter'0.final func'0
  
  meta "rewrite_def" predicate reinitialize_Self
  
  predicate preservation_inv_Self (iter'0: t_Self) (func'0: t_F) (produced'0: Seq.seq t_Item)
  
  axiom preservation_inv_Self_spec: forall iter'0: t_Self, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item)
      -> preservation_inv_Self iter'0 func'0 produced'0 = preservation_Self iter'0 func'0
  
  predicate invariant_MapInv_Self_F (self: t_MapInv_Self_F) =
    reinitialize_Self
    /\ preservation_inv_Self self.iter self.func self.produced
    /\ next_precondition_Self self.iter self.func self.produced
  
  predicate inv_MapInv_Self_F (_1: t_MapInv_Self_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv_Self_F [inv_MapInv_Self_F x]. inv_MapInv_Self_F x
      = (invariant_MapInv_Self_F x /\ inv_Self x.iter /\ inv_F x.func)
  
  type tup2_Self_F = { f0'0: t_Self; f1'0: t_F }
  
  predicate precondition_map_inv (self: ()) (args: tup2_Self_F)
  
  axiom precondition_fndef:
    forall args: tup2_Self_F [precondition_map_inv () args]. (let {f0'0 = self; f1'0 = func'0} = args in inv_Self self
        /\ inv_F func'0
        /\ (forall e: t_Item, i2: t_Self. produces_Self self (Seq.singleton e) i2 /\ inv_Item e
            -> precondition_F func'0 { f0 = e; f1 = Seq.empty: Seq.seq t_Item })
        /\ reinitialize_Self /\ preservation_Self self func'0) -> precondition_map_inv () args
  
  predicate postcondition_once_map_inv (self: ()) (args: tup2_Self_F) (result: t_MapInv_Self_F)
  
  axiom postcondition_fndef:
    forall args: tup2_Self_F, res: t_MapInv_Self_F [postcondition_once_map_inv () args res]. postcondition_once_map_inv () args res
      -> (let {f0'0 = self; f1'0 = func'0} = args in inv_MapInv_Self_F res
      /\ res = { iter = self; func = func'0; produced = Seq.empty: Seq.seq t_Item })
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec map_inv_Self (self: t_Self) (func'0: t_F) (return (x: t_MapInv_Self_F)) =
    {[@stop_split] [@expl:map_inv_Self requires] ([@stop_split] [@expl:map_inv 'self' type invariant] inv_Self self)
    /\ ([@stop_split] [@expl:map_inv 'func' type invariant] inv_F func'0)
    /\ ([@stop_split] [@expl:map_inv requires #0] forall e: t_Item, i2: t_Self. produces_Self self (Seq.singleton e) i2
          /\ inv_Item e -> precondition_F func'0 { f0 = e; f1 = Seq.empty: Seq.seq t_Item })
    /\ ([@stop_split] [@expl:map_inv requires #1] reinitialize_Self)
    /\ ([@stop_split] [@expl:map_inv requires #2] preservation_Self self func'0)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_ret <- { iter = self; func = func'0; produced = Seq.empty: Seq.seq t_Item } ] s1
      | s1 = return {_ret} ] ]
    [ & _ret: t_MapInv_Self_F = Any.any_l () | & self: t_Self = self | & func'0: t_F = func'0 ])
    [ return (result: t_MapInv_Self_F) ->
    {[@stop_split] [@expl:map_inv_Self ensures] ([@stop_split] [@expl:map_inv result type invariant] inv_MapInv_Self_F result)
      /\ ([@stop_split] [@expl:map_inv ensures] result
      = { iter = self; func = func'0; produced = Seq.empty: Seq.seq t_Item })}
      (! return {result}) ]
end
module M_std__iter__impl_IteratorSpec_for_refmut_I__produces_refl (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_refmut_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : MutBorrow.t t_I
  
  function produces_refl_refmut_I (self: MutBorrow.t t_I) : ()
  
  goal vc_produces_refl_refmut_I:
    [@stop_split] [@expl:produces_refl ensures] produces_refmut_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__impl_IteratorSpec_for_refmut_I__produces_trans (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_refmut_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : MutBorrow.t t_I
  
  constant ab : Seq.seq t_Item
  
  constant b : MutBorrow.t t_I
  
  constant bc : Seq.seq t_Item
  
  constant c : MutBorrow.t t_I
  
  function produces_trans_refmut_I (a: MutBorrow.t t_I) (ab: Seq.seq t_Item) (b: MutBorrow.t t_I) (bc: Seq.seq t_Item) (c: MutBorrow.t t_I) : ()
  
  goal vc_produces_trans_refmut_I: produces_refmut_I a ab b
    -> produces_refmut_I b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_refmut_I a (Seq.(++) ab bc) c)
end
module M_std__mem__extern_spec_core_mem_replace_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  let rec swap_T (x: MutBorrow.t t_T) (y: MutBorrow.t t_T) (return (x'0: ())) =
    {[@stop_split] [@expl:swap_T requires] ([@stop_split] [@expl:swap 'x' type invariant] inv_refmut_T x)
    /\ ([@stop_split] [@expl:swap 'y' type invariant] inv_refmut_T y)}
    any
    [ return (result: ()) -> {[@stop_split] [@expl:swap_T ensures] ([@stop_split] [@expl:swap ensures #0] x.final
        = y.current)
      /\ ([@stop_split] [@expl:swap ensures #1] y.final = x.current)}
      (! return {result}) ]
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_mem_replace_body_T (dest: MutBorrow.t t_T) (src: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_mem_replace_body_T requires] ([@stop_split] [@expl:extern_spec_core_mem_replace_body 'dest' type invariant] inv_refmut_T dest)
    /\ ([@stop_split] [@expl:extern_spec_core_mem_replace_body 'src' type invariant] inv_T src)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &src'0 <- src ] s1
      | s1 = MutBorrow.borrow_mut <t_T> {src'0}
          (fun (_bor: MutBorrow.t t_T) -> [ &_12 <- _bor ] -{inv_T _bor.final}- [ &src'0 <- _bor.final ] s2)
        [ _ck -> (! {[@expl:type invariant] inv_T src'0} any) ]
      | s2 = MutBorrow.borrow_final <t_T> {dest.current} {MutBorrow.get_id dest}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_10 <- _bor ] -{inv_T _bor.final}-
            [ &dest <- { dest with current = _bor.final } ] s3)
        [ _ck -> (! {[@expl:type invariant] inv_T dest.current} any) ]
      | s3 = MutBorrow.borrow_final <t_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_11 <- _bor ] -{inv_T _bor.final}-
            [ &_12 <- { _12 with current = _bor.final } ] s4)
        [ _ck -> (! {[@expl:type invariant] inv_T _12.current} any) ]
      | s4 = swap_T {_10} {_11} (fun (_x: ()) -> [ &_9 <- _x ] s5)
      | s5 = s6 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _12} any) ]
      | s6 = -{resolve_refmut_T _12}- s7
      | s7 = s8 [ _ck -> (! {[@expl:type invariant] inv_refmut_T dest} any) ]
      | s8 = -{resolve_refmut_T dest}- s9
      | s9 = [ &_ret <- src'0 ] s10
      | s10 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l ()
    | & dest: MutBorrow.t t_T = dest
    | & src: t_T = src
    | & src'0: t_T = Any.any_l ()
    | & _9: () = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l ()
    | & _12: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_mem_replace_body_T ensures] ([@stop_split] [@expl:extern_spec_core_mem_replace_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_mem_replace_body ensures #0] dest.final = src)
      /\ ([@stop_split] [@expl:extern_spec_core_mem_replace_body ensures #1] result = dest.current)}
      (! return {result}) ]
end
module M_std__mem__extern_spec_core_mem_take_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@stop_split] [@expl:default requires] precondition_default () ()}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:default ensures] postcondition_once_default () () result}
      (! return {result}) ]
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  let rec replace_T (dest: MutBorrow.t t_T) (src: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:replace_T requires] ([@stop_split] [@expl:replace 'dest' type invariant] inv_refmut_T dest)
    /\ ([@stop_split] [@expl:replace 'src' type invariant] inv_T src)}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:replace_T ensures] ([@stop_split] [@expl:replace result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:replace ensures #0] dest.final = src)
      /\ ([@stop_split] [@expl:replace ensures #1] result = dest.current)}
      (! return {result}) ]
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut_default () args () res]. postcondition_mut_default () args () res
      -> (let () = args in inv_T res)
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_default () args res]. postcondition_default () args res
      -> (let () = args in inv_T res)
  
  function fn_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_mem_take_body_T (dest: MutBorrow.t t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_mem_take_body 'dest' type invariant] inv_refmut_T dest}
    (! bb0
    [ bb0 = s0
      [ s0 = default_T (fun (_x: t_T) -> [ &_7 <- _x ] s1)
      | s1 = MutBorrow.borrow_final <t_T> {dest.current} {MutBorrow.get_id dest}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_6 <- _bor ] -{inv_T _bor.final}-
            [ &dest <- { dest with current = _bor.final } ] s2)
        [ _ck -> (! {[@expl:type invariant] inv_T dest.current} any) ]
      | s2 = replace_T {_6} {_7} (fun (_x: t_T) -> [ &_ret <- _x ] s3)
      | s3 = s4 [ _ck -> (! {[@expl:type invariant] inv_refmut_T dest} any) ]
      | s4 = -{resolve_refmut_T dest}- s5
      | s5 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l ()
    | & dest: MutBorrow.t t_T = dest
    | & _6: MutBorrow.t t_T = Any.any_l ()
    | & _7: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_mem_take_body_T ensures] ([@stop_split] [@expl:extern_spec_core_mem_take_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_mem_take_body ensures #0] result = dest.current)
      /\ ([@stop_split] [@expl:extern_spec_core_mem_take_body ensures #1] postcondition_default () () dest.final)}
      (! return {result}) ]
end
module M_std__mem__extern_spec_core_mem_drop_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_mem_drop_body_T (t: t_T) (return (x: ())) =
    {[@stop_split] [@expl:extern_spec_core_mem_drop_body 't' type invariant] inv_T t}
    (! bb0
    [ bb0 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_T t} any) ] | s1 = -{resolve_T t}- s2 | s2 = return {_ret} ] ]
    [ & _ret: () = Any.any_l () | & t: t_T = t ])
    [ return (result: ()) -> {[@stop_split] [@expl:extern_spec_core_mem_drop_body ensures] resolve_T t}
      (! return {result}) ]
end
module M_std__mem__extern_spec_core_mem_forget_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_mem_forget_body_T (t: t_T) (return (x: ())) =
    {[@stop_split] [@expl:extern_spec_core_mem_forget_body 't' type invariant] inv_T t}
    (! bb0
    [ bb0 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_T t} any) ] | s1 = -{resolve_T t}- s2 | s2 = return {_ret} ] ]
    [ & _ret: () = Any.any_l () | & t: t_T = t ])
    [ return (result: ()) -> {[@stop_split] [@expl:extern_spec_core_mem_forget_body ensures] resolve_T t}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u8_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u8_default_body (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: UInt8.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: UInt8.t = Any.any_l () ])
    [ return (result: UInt8.t) -> {[@stop_split] [@expl:extern_spec_Default_u8_default_body ensures] result
      = (0: UInt8.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u8_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u8_clone_body (self_: UInt8.t) (return (x: UInt8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt8.t = Any.any_l () | & self_: UInt8.t = self_ ])
    [ return (result: UInt8.t) -> {[@stop_split] [@expl:extern_spec_Clone_u8_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u16_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u16_default_body (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: UInt16.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: UInt16.t = Any.any_l () ])
    [ return (result: UInt16.t) -> {[@stop_split] [@expl:extern_spec_Default_u16_default_body ensures] result
      = (0: UInt16.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u16_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u16_clone_body (self_: UInt16.t) (return (x: UInt16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt16.t = Any.any_l () | & self_: UInt16.t = self_ ])
    [ return (result: UInt16.t) -> {[@stop_split] [@expl:extern_spec_Clone_u16_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u32_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u32_default_body (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: UInt32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: UInt32.t = Any.any_l () ])
    [ return (result: UInt32.t) -> {[@stop_split] [@expl:extern_spec_Default_u32_default_body ensures] result
      = (0: UInt32.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u32_clone_body (self_: UInt32.t) (return (x: UInt32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt32.t = Any.any_l () | & self_: UInt32.t = self_ ])
    [ return (result: UInt32.t) -> {[@stop_split] [@expl:extern_spec_Clone_u32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u64_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u64_default_body (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: UInt64.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:extern_spec_Default_u64_default_body ensures] result
      = (0: UInt64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u64_clone_body (self_: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt64.t = Any.any_l () | & self_: UInt64.t = self_ ])
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:extern_spec_Clone_u64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_u128_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_u128_default_body (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: UInt128.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: UInt128.t = Any.any_l () ])
    [ return (result: UInt128.t) -> {[@stop_split] [@expl:extern_spec_Default_u128_default_body ensures] result
      = (0: UInt128.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_u128_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_u128_clone_body (self_: UInt128.t) (return (x: UInt128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt128.t = Any.any_l () | & self_: UInt128.t = self_ ])
    [ return (result: UInt128.t) -> {[@stop_split] [@expl:extern_spec_Clone_u128_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_usize_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_usize_default_body (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: UInt64.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: UInt64.t = Any.any_l () ])
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:extern_spec_Default_usize_default_body ensures] result
      = (0: UInt64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_usize_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_usize_clone_body (self_: UInt64.t) (return (x: UInt64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: UInt64.t = Any.any_l () | & self_: UInt64.t = self_ ])
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:extern_spec_Clone_usize_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i8_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i8_default_body (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: Int8.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int8.t = Any.any_l () ])
    [ return (result: Int8.t) -> {[@stop_split] [@expl:extern_spec_Default_i8_default_body ensures] result
      = (0: Int8.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i8_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i8_clone_body (self_: Int8.t) (return (x: Int8.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Int8.t = Any.any_l () | & self_: Int8.t = self_ ])
    [ return (result: Int8.t) -> {[@stop_split] [@expl:extern_spec_Clone_i8_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i16_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i16_default_body (return (x: Int16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: Int16.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int16.t = Any.any_l () ])
    [ return (result: Int16.t) -> {[@stop_split] [@expl:extern_spec_Default_i16_default_body ensures] result
      = (0: Int16.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i16_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i16_clone_body (self_: Int16.t) (return (x: Int16.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Int16.t = Any.any_l () | & self_: Int16.t = self_ ])
    [ return (result: Int16.t) -> {[@stop_split] [@expl:extern_spec_Clone_i16_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i32_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i32_default_body (return (x: Int32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: Int32.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int32.t = Any.any_l () ])
    [ return (result: Int32.t) -> {[@stop_split] [@expl:extern_spec_Default_i32_default_body ensures] result
      = (0: Int32.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i32_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i32_clone_body (self_: Int32.t) (return (x: Int32.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Int32.t = Any.any_l () | & self_: Int32.t = self_ ])
    [ return (result: Int32.t) -> {[@stop_split] [@expl:extern_spec_Clone_i32_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i64_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i64_default_body (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: Int64.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@stop_split] [@expl:extern_spec_Default_i64_default_body ensures] result
      = (0: Int64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i64_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i64_clone_body (self_: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Int64.t = Any.any_l () | & self_: Int64.t = self_ ])
    [ return (result: Int64.t) -> {[@stop_split] [@expl:extern_spec_Clone_i64_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_i128_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_i128_default_body (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: Int128.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int128.t = Any.any_l () ])
    [ return (result: Int128.t) -> {[@stop_split] [@expl:extern_spec_Default_i128_default_body ensures] result
      = (0: Int128.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_i128_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_i128_clone_body (self_: Int128.t) (return (x: Int128.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Int128.t = Any.any_l () | & self_: Int128.t = self_ ])
    [ return (result: Int128.t) -> {[@stop_split] [@expl:extern_spec_Clone_i128_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__num__extern_spec_Default_isize_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Default_isize_default_body (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- (0: Int64.t) ] s1 | s1 = return {_ret} ] ] [ & _ret: Int64.t = Any.any_l () ])
    [ return (result: Int64.t) -> {[@stop_split] [@expl:extern_spec_Default_isize_default_body ensures] result
      = (0: Int64.t)}
      (! return {result}) ]
end
module M_std__num__extern_spec_Clone_isize_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_Clone_isize_clone_body (self_: Int64.t) (return (x: Int64.t)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Int64.t = Any.any_l () | & self_: Int64.t = self_ ])
    [ return (result: Int64.t) -> {[@stop_split] [@expl:extern_spec_Clone_isize_clone_body ensures] result = self_}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_option_T_Try_Option_T_from_output_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_from_output_body_T (output: t_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_from_output_body 'output' type invariant] inv_T output}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- Some output ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l () | & output: t_T = output ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_from_output_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_from_output_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_from_output_body ensures] result = Some output)}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_option_T_Try_Option_T_branch_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Option_Infallible = None'0 | Some'0 ()
  
  type t_ControlFlow_Option_Infallible_T = Continue t_T | Break t_Option_Infallible
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Infallible f0
        end
  
  predicate inv_ControlFlow_Option_Infallible_T (_1: t_ControlFlow_Option_Infallible_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_ControlFlow_Option_Infallible_T [inv_ControlFlow_Option_Infallible_T x]. inv_ControlFlow_Option_Infallible_T x
      = match x with
        | Continue f0 -> inv_T f0
        | Break f0 -> inv_Option_Infallible f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Try_Option_T_branch_body_T (self_: t_Option_T)
    (return (x: t_ControlFlow_Option_Infallible_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_branch_body 'self_' type invariant] inv_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &v <- r0 ] s1)
      | s1 = [ &_ret <- Continue v ] s2
      | s2 = return {_ret} ]
    | bb3 = s0 [ s0 = [ &_7 <- None'0 ] s1 | s1 = [ &_ret <- Break _7 ] s2 | s2 = return {_ret} ] ]
    [ & _ret: t_ControlFlow_Option_Infallible_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & v: t_T = Any.any_l ()
    | & _7: t_Option_Infallible = Any.any_l () ])
    [ return (result: t_ControlFlow_Option_Infallible_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_branch_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_branch_body result type invariant] inv_ControlFlow_Option_Infallible_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Try_Option_T_branch_body ensures] match self_ with
        | Some v -> result = Continue v
        | None -> result = Break (None'0)
        end)}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Infallible = None'0 | Some'0 ()
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Option_Infallible (_1: t_Option_Infallible)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_Infallible [inv_Option_Infallible x]. inv_Option_Infallible x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Infallible f0
        end
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body_T
    (residual: t_Option_Infallible) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body 'residual' type invariant] inv_Option_Infallible residual}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- None ] s1 | s1 = return {_ret} ] ] [ & _ret: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_FromResidual_Option_Infallible_Option_T_from_residual_body ensures] result
      = None)}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_result_T_E_Try_Result_T_E_from_output_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  predicate inv_T (_1: t_T)
  
  predicate inv_E (_1: t_E)
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_from_output_body_T (output: t_T) (return (x: t_Result_T_E)) =
    {[@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body 'output' type invariant] inv_T output}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- Ok output ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Result_T_E = Any.any_l () | & output: t_T = output ])
    [ return (result: t_Result_T_E) ->
    {[@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body_T ensures] ([@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body result type invariant] inv_Result_T_E result)
      /\ ([@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_from_output_body ensures] result = Ok output)}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_result_T_E_Try_Result_T_E_branch_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  let rec elim_Err (_x: t_Result_T_E) (return (f0: t_E)) = any
    [ _k (f0: t_E) -> {Err f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Err] match _x with
        | Err _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Result_Infallible_E = Ok'0 () | Err'0 t_E
  
  type t_ControlFlow_Result_Infallible_E_T = Continue t_T | Break t_Result_Infallible_E
  
  let rec elim_Ok (_x: t_Result_T_E) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Ok f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Ok] match _x with
        | Ok _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_E (_1: t_E)
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Result_Infallible_E (_1: t_Result_Infallible_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_Infallible_E [inv_Result_Infallible_E x]. inv_Result_Infallible_E x
      = match x with
        | Ok'0 f0 -> inv_Infallible f0
        | Err'0 f0 -> inv_E f0
        end
  
  predicate inv_ControlFlow_Result_Infallible_E_T (_1: t_ControlFlow_Result_Infallible_E_T)
  
  axiom inv_axiom'1 [@rewrite]:
    forall x: t_ControlFlow_Result_Infallible_E_T [inv_ControlFlow_Result_Infallible_E_T x]. inv_ControlFlow_Result_Infallible_E_T x
      = match x with
        | Continue f0 -> inv_T f0
        | Break f0 -> inv_Result_Infallible_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_Try_Result_T_E_branch_body_T (self_: t_Result_T_E)
    (return (x: t_ControlFlow_Result_Infallible_E_T)) =
    {[@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body 'self_' type invariant] inv_Result_T_E self_}
    (! bb0
    [ bb0 = any [ br0 (x0: t_T) -> {self_ = Ok x0} (! bb4) | br1 (x0: t_E) -> {self_ = Err x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Err {self_} (fun (r0: t_E) -> [ &e <- r0 ] s1)
      | s1 = [ &_8 <- Err'0 e ] s2
      | s2 = [ &_ret <- Break _8 ] s3
      | s3 = return {_ret} ]
    | bb4 = s0
      [ s0 = elim_Ok {self_} (fun (r0: t_T) -> [ &v <- r0 ] s1)
      | s1 = [ &_ret <- Continue v ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_ControlFlow_Result_Infallible_E_T = Any.any_l ()
    | & self_: t_Result_T_E = self_
    | & v: t_T = Any.any_l ()
    | & e: t_E = Any.any_l ()
    | & _8: t_Result_Infallible_E = Any.any_l () ])
    [ return (result: t_ControlFlow_Result_Infallible_E_T) ->
    {[@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body_T ensures] ([@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body result type invariant] inv_ControlFlow_Result_Infallible_E_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_result_T_E_Try_Result_T_E_branch_body ensures] match self_ with
        | Ok v -> result = Continue v
        | Err e -> result = Break (Err'0 e)
        end)}
      (! return {result}) ]
end
module M_std__ops__extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_E
  
  type t_Result_Infallible_E = Ok () | Err t_E
  
  let rec elim_Err (_x: t_Result_Infallible_E) (return (f0: t_E)) = any
    [ _k (f0: t_E) -> {Err f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Err] match _x with
        | Err _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_F
  
  predicate inv_E (_1: t_E)
  
  predicate precondition_from (self: ()) (args: t_E)
  
  axiom precondition_fndef: forall args: t_E [precondition_from () args]. (let value = args in inv_E value)
      -> precondition_from () args
  
  predicate inv_F (_1: t_F)
  
  predicate postcondition_once_from (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef:
    forall args: t_E, res: t_F [postcondition_once_from () args res]. postcondition_once_from () args res
      -> (let value = args in inv_F res)
  
  let rec from_F (value: t_E) (return (x: t_F)) = {[@stop_split] [@expl:from requires] precondition_from () value}
    any
    [ return (result: t_F) -> {[@stop_split] [@expl:from ensures] postcondition_once_from () value result}
      (! return {result}) ]
  
  type t_T
  
  type t_Result_T_F = Ok'0 t_T | Err'0 t_F
  
  predicate inv_Infallible [@inline:trivial] (_1: ()) = false
  
  meta "rewrite_def" predicate inv_Infallible
  
  predicate inv_Result_Infallible_E (_1: t_Result_Infallible_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_Infallible_E [inv_Result_Infallible_E x]. inv_Result_Infallible_E x
      = match x with
        | Ok f0 -> inv_Infallible f0
        | Err f0 -> inv_E f0
        end
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Result_T_F (_1: t_Result_T_F)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_T_F [inv_Result_T_F x]. inv_Result_T_F x
      = match x with
        | Ok'0 f0 -> inv_T f0
        | Err'0 f0 -> inv_F f0
        end
  
  type tup2_Result_T_F_Result_Infallible_E = { f0: t_Result_T_F; f1: t_Result_Infallible_E }
  
  predicate resolve_from [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_from
  
  predicate postcondition_mut_from (self: ()) (args: t_E) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_E, res: t_F [postcondition_mut_from () args () res]. postcondition_mut_from () args () res
      -> (let value = args in inv_F res)
  
  function fn_mut_once_from (self: ()) (args: t_E) (res: t_F) : () = ()
  
  axiom fn_mut_once_from_spec: forall self: (), args: t_E, res: t_F. postcondition_once_from self args res
      = (exists res_state: (). postcondition_mut_from self args res_state res /\ resolve_from res_state)
  
  predicate hist_inv_from [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_from
  
  function hist_inv_trans_from (self: ()) (b: ()) (c: ()) : () = ()
  
  axiom hist_inv_trans_from_spec: forall self: (), b: (), c: (). hist_inv_from self b
      -> hist_inv_from b c -> hist_inv_from self c
  
  function hist_inv_refl_from (self: ()) : () = ()
  
  axiom hist_inv_refl_from_spec: forall self: (). hist_inv_from self self
  
  function postcondition_mut_hist_inv_from (self: ()) (args: t_E) (res_state: ()) (res: t_F) : () = ()
  
  axiom postcondition_mut_hist_inv_from_spec:
    forall self: (), args: t_E, res_state: (), res: t_F. postcondition_mut_from self args res_state res
      -> hist_inv_from self res_state
  
  function fn_hist_inv_from (self: ()) (res_state: ()) : () = ()
  
  axiom fn_hist_inv_from_spec: forall self: (), res_state: (). hist_inv_from self res_state = (self = res_state)
  
  predicate postcondition_from (self: ()) (args: t_E) (result: t_F)
  
  axiom postcondition_fndef'1:
    forall args: t_E, res: t_F [postcondition_from () args res]. postcondition_from () args res
      -> (let value = args in inv_F res)
  
  function fn_once_from (self: ()) (args: t_E) (res: t_F) : () = ()
  
  axiom fn_once_from_spec: forall self: (), args: t_E, res: t_F. postcondition_once_from self args res
      = (postcondition_from self args res /\ resolve_from self)
  
  function fn_mut_from (self: ()) (args: t_E) (res_state: ()) (res: t_F) : () = ()
  
  axiom fn_mut_from_spec:
    forall self: (), args: t_E, res_state: (), res: t_F. postcondition_mut_from self args res_state res
      = (postcondition_from self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body_T
    (residual: t_Result_Infallible_E) (return (x: t_Result_T_F)) =
    {[@stop_split] [@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body 'residual' type invariant] inv_Result_Infallible_E residual}
    (! bb0
    [ bb0 = s0
      [ s0 = elim_Err {residual} (fun (r0: t_E) -> [ &e <- r0 ] s1)
      | s1 = from_F {e} (fun (_x: t_F) -> [ &_5 <- _x ] s2)
      | s2 = [ &_ret <- Err'0 _5 ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Result_T_F = Any.any_l ()
    | & residual: t_Result_Infallible_E = residual
    | & e: t_E = Any.any_l ()
    | & _5: t_F = Any.any_l () ])
    [ return (result: t_Result_T_F) ->
    {[@stop_split] [@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body_T ensures] ([@stop_split] [@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body result type invariant] inv_Result_T_F result)
      /\ ([@stop_split] [@expl:extern_spec_core_result_T_E_F_FromResidual_Result_Infallible_E_Result_T_F_from_residual_body ensures] match { f0 = result;
                                                                                                                                             f1 = residual } with
        | {f0 = Err'0 result'0; f1 = Err residual'0} -> postcondition_from () residual'0 result'0
        | _ -> false
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_T_PartialEq_Option_T_eq_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type tup2_ref_Option_T_ref_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  let rec elim_Some (_x: t_Option_T) (return (f0'0: t_T)) = any
    [ _k (f0'0: t_T) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_ref_ref_T [@inline:trivial] (self: t_T) = inv_ref_T self
  
  meta "rewrite_def" predicate invariant_ref_ref_T
  
  predicate inv_ref_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_ref_T
  
  type t_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  function deep_model_ref_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_ref_T self
  
  meta "rewrite_def" function deep_model_ref_ref_T
  
  let rec eq_ref_T (self_: t_T) (rhs: t_T) (return (x: bool)) =
    {[@stop_split] [@expl:eq_ref_T requires] ([@stop_split] [@expl:eq 'self_' type invariant] inv_ref_ref_T self_)
    /\ ([@stop_split] [@expl:eq 'rhs' type invariant] inv_ref_ref_T rhs)}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:eq ensures] result
      = (deep_model_ref_ref_T self_ = deep_model_ref_ref_T rhs)}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0'0 -> inv_T f0'0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  type t_Option_DeepModelTy = None'0 | Some'0 t_DeepModelTy
  
  function deep_model_Option_T [@inline:trivial] (self: t_Option_T) : t_Option_DeepModelTy = match self with
      | Some t -> Some'0 (deep_model_T t)
      | None -> None'0
      end
  
  meta "rewrite_def" function deep_model_Option_T
  
  function deep_model_ref_Option_T [@inline:trivial] (self: t_Option_T) : t_Option_DeepModelTy =
    deep_model_Option_T self
  
  meta "rewrite_def" function deep_model_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_PartialEq_Option_T_eq_body_T (self_: t_Option_T) (rhs: t_Option_T) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_T_PartialEq_Option_T_eq_body_T requires] ([@stop_split] [@expl:extern_spec_T_PartialEq_Option_T_eq_body 'self_' type invariant] inv_ref_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_T_PartialEq_Option_T_eq_body 'rhs' type invariant] inv_ref_Option_T rhs)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- { f0 = self_; f1 = rhs } ] s1
      | s1 = any [ br0 -> {_6.f0 = None} (! bb2) | br1 (x0: t_T) -> {_6.f0 = Some x0} (! bb4) ] ]
    | bb4 = any [ br0 -> {_6.f1 = None} (! bb1) | br1 (x0: t_T) -> {_6.f1 = Some x0} (! bb6) ]
    | bb6 = s0
      [ s0 = elim_Some {_6.f0} (fun (r0: t_T) -> [ &x <- r0 ] s1)
      | s1 = elim_Some {_6.f1} (fun (r0: t_T) -> [ &y <- r0 ] s2)
      | s2 = eq_ref_T {x} {y} (fun (_x: bool) -> [ &_ret <- _x ] s3)
      | s3 = return {_ret} ]
    | bb2 = any [ br0 -> {_6.f1 = None} (! bb7) | br1 (x0: t_T) -> {_6.f1 = Some x0} (! bb1) ]
    | bb1 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ]
    | bb7 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: t_Option_T = self_
    | & rhs: t_Option_T = rhs
    | & _6: tup2_ref_Option_T_ref_Option_T = Any.any_l ()
    | & x: t_T = Any.any_l ()
    | & y: t_T = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_T_PartialEq_Option_T_eq_body ensures] result
      = (deep_model_ref_Option_T self_ = deep_model_ref_Option_T rhs)}
      (! return {result}) ]
end
module M_std__option__extern_spec_T_Clone_Option_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@stop_split] [@expl:clone requires] precondition_clone () self_}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:clone ensures] postcondition_once_clone () self_ result}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone_Option_T_clone_body_T (self_: t_Option_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_T_Clone_Option_T_clone_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &x <- r0 ] s1)
      | s1 = clone_T {x} (fun (_x: t_T) -> [ &_6 <- _x ] s2)
      | s2 = [ &_ret <- Some _6 ] s3
      | s3 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- None ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & x: t_T = Any.any_l ()
    | & _6: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_T_Clone_Option_T_clone_body_T ensures] ([@stop_split] [@expl:extern_spec_T_Clone_Option_T_clone_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_T_Clone_Option_T_clone_body ensures] match { f0 = self_; f1 = result } with
        | {f0 = None; f1 = None} -> true
        | {f0 = Some s; f1 = Some r} -> postcondition_clone () s r
        | _ -> false
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_is_some_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_is_some_body_T (self_: t_Option_T) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_some_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0 [ s0 = [ &_ret <- true ] s1 | s1 = return {_ret} ]
    | bb3 = s0 [ s0 = [ &_ret <- false ] s1 | s1 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self_: t_Option_T = self_ ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_some_body ensures] result
      = (self_ <> None)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_is_some_and_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct
  
  predicate inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (_1: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (self: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (args: t_T)
  
  predicate postcondition_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (self: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (args: t_T) (result: bool)
  
  let rec call_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct
    (self_: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (arg: t_T) (return (x: bool)) =
    {[@stop_split] [@expl:call_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct self_ arg)}
    any
    [ return (result: bool) ->
    {[@stop_split] [@expl:call_once ensures] postcondition_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct self_ arg result}
      (! return {result}) ]
  
  predicate resolve_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct (_1: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_is_some_and_body_T (self_: t_Option_T)
    (f: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_some_and_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_some_and_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_some_and_body 'f' type invariant] inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_some_and_body requires] match self_ with
      | None -> true
      | Some t -> precondition_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f t
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_13 <- t ] s2
      | s2 = call_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct {f} {_13}
          (fun (_x: bool) -> [ &_ret <- _x ] s3)
      | s3 = return {_ret} ]
    | bb3 = s0
      [ s0 = s1
        [ _ck -> (! {[@expl:type invariant] inv_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f}
          any) ]
      | s1 = -{resolve_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f}- s2
      | s2 = [ &_ret <- false ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct = f
    | & t: t_T = Any.any_l ()
    | & _13: t_T = Any.any_l () ])
    [ return (result: bool) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_some_and_body ensures] match self_ with
        | None -> result = false
        | Some t -> postcondition_once_impl_32_FnOnce_40_T_41__32__45__62__32_bool_32__43__32_Destruct f t result
        end}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_is_none_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  let rec is_some_T (self_: t_Option_T) (return (x: bool)) =
    {[@stop_split] [@expl:is_some 'self_' type invariant] inv_ref_Option_T self_}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:is_some ensures] result = (self_ <> None)} (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_is_none_body_T (self_: t_Option_T) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_none_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = s0
      [ s0 = is_some_T {self_} (fun (_x: bool) -> [ &_6 <- _x ] s1)
      | s1 = [ &_ret <- not _6 ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self_: t_Option_T = self_ | & _6: bool = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_is_none_body ensures] result
      = (self_ = None)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_as_ref_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Option_ref_T = None'0 | Some'0 t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_as_ref_body_T (self_: t_Option_T) (return (x: t_Option_ref_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_ref_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_ret <- Some'0 t ] s2 | s2 = return {_ret} ]
    | bb3 = s0 [ s0 = [ &_ret <- None'0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_ref_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_ref_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_ref_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_ref_body result type invariant] inv_Option_ref_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_ref_body ensures #0] self_ = None
        -> result = None'0)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_ref_body ensures #1] self_ = None
      \/ (exists r: t_T. result = Some'0 r /\ self_ = Some r))}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_as_mut_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  type t_Option_refmut_T = None'0 | Some'0 (MutBorrow.t t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  predicate inv_Option_refmut_T (_1: t_Option_refmut_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_refmut_T [inv_Option_refmut_T x]. inv_Option_refmut_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_refmut_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_as_mut_body_T (self_: MutBorrow.t t_Option_T)
    (return (x: t_Option_refmut_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_body 'self_' type invariant] inv_refmut_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb3) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 0}
              (fun (_bor: MutBorrow.t t_T) ->
                [ &t <- _bor ] -{inv_T _bor.final}-
                [ &self_ <- { self_ with current = Some _bor.final } ] s1)
            [ _ck -> (! {[@expl:type invariant] inv_T r0} any) ])
      | s1 = MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_10 <- _bor ] -{inv_T _bor.final}-
            [ &t <- { t with current = _bor.final } ] s2) [ _ck -> (! {[@expl:type invariant] inv_T t.current} any) ]
      | s2 = [ &_ret <- Some'0 _10 ] s3
      | s3 = s4 [ _ck -> (! {[@expl:type invariant] inv_refmut_T t} any) ]
      | s4 = -{resolve_refmut_T t}- s5
      | s5 = bb5 ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = [ &_ret <- None'0 ] s3
      | s3 = bb5 ]
    | bb5 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Option_refmut_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_Option_refmut_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_body result type invariant] inv_Option_refmut_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_body ensures #0] self_.current = None
        -> result = None'0 /\ self_.final = None)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_body ensures #1] self_.current = None
      \/ (exists r: MutBorrow.t t_T. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final)))}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_as_slice_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  let rec from_ref_T (s: t_T) (return (x: Slice64.slice t_T)) =
    {[@stop_split] [@expl:from_ref 's' type invariant] inv_ref_T s}
    any
    [ return (result: Slice64.slice t_T) ->
    {[@stop_split] [@expl:from_ref_T ensures] ([@stop_split] [@expl:from_ref result type invariant] inv_ref_slice_T result)
      /\ ([@stop_split] [@expl:from_ref ensures #0] Seq.length (Slice64.view result) = 1)
      /\ ([@stop_split] [@expl:from_ref ensures #1] Seq.get (Slice64.view result) 0 = s)}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_as_slice_body_T (self_: t_Option_T) (return (x: Slice64.slice t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_slice_body 'self_' type invariant] inv_ref_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = from_ref_T {t} (fun (_x: Slice64.slice t_T) -> [ &_10 <- _x ] s2)
      | s2 = [ &_4 <- _10 ] s3
      | s3 = bb6 ]
    | bb4 = s0
      [ s0 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array t_T) -> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = [ &_ret'0 <- _1 ] s2'0
          | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: Slice64.array t_T = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ]
        [ _const_ret (_const: Slice64.array t_T) -> [ &_12 <- _const ] s1 ]
      | s1 = [ &_7 <- _12 ] s2
      | s2 = [ &_4 <- _7 ] s3
      | s3 = bb6 ]
    | bb6 = s0 [ s0 = [ &_ret <- _4 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Slice64.slice t_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & _4: Slice64.slice t_T = Any.any_l ()
    | & _7: Slice64.array t_T = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _10: Slice64.slice t_T = Any.any_l ()
    | & _12: Slice64.array t_T = Any.any_l () ])
    [ return (result: Slice64.slice t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_slice_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_slice_body result type invariant] inv_ref_slice_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_slice_body ensures] match self_ with
        | None -> Seq.length (Slice64.view result) = 0
        | Some t -> Seq.length (Slice64.view result) = 1 /\ Seq.get (Slice64.view result) 0 = t
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_as_mut_slice_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.int.UInt64
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_refmut_slice_T [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv_slice_T self.current /\ inv_slice_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_slice_T
  
  predicate inv_refmut_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant_refmut_slice_T _1
  
  meta "rewrite_def" predicate inv_refmut_slice_T
  
  let rec from_mut_T (s: MutBorrow.t t_T) (return (x: MutBorrow.t (Slice64.slice t_T))) =
    {[@stop_split] [@expl:from_mut 's' type invariant] inv_refmut_T s}
    any
    [ return (result: MutBorrow.t (Slice64.slice t_T)) ->
    {[@stop_split] [@expl:from_mut_T ensures] ([@stop_split] [@expl:from_mut result type invariant] inv_refmut_slice_T result)
      /\ ([@stop_split] [@expl:from_mut ensures #0] Seq.length (Slice64.view result.current) = 1)
      /\ ([@stop_split] [@expl:from_mut ensures #1] Seq.get (Slice64.view result.current) 0 = s.current)
      /\ ([@stop_split] [@expl:from_mut ensures #2] Seq.length (Slice64.view result.final) = 1)
      /\ ([@stop_split] [@expl:from_mut ensures #3] Seq.get (Slice64.view result.final) 0 = s.final)}
      (! return {result}) ]
  
  predicate resolve_refmut_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_slice_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  predicate invariant_array_T_0 (self: Slice64.array t_T) =
    inv_Seq_T (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int (0: UInt64.t)
  
  predicate inv_array_T_0 [@inline:trivial] (_1: Slice64.array t_T) = invariant_array_T_0 _1
  
  meta "rewrite_def" predicate inv_array_T_0
  
  predicate invariant_refmut_array_T_0 [@inline:trivial] (self: MutBorrow.t (Slice64.array t_T)) =
    inv_array_T_0 self.current /\ inv_array_T_0 self.final
  
  meta "rewrite_def" predicate invariant_refmut_array_T_0
  
  predicate inv_refmut_array_T_0 [@inline:trivial] (_1: MutBorrow.t (Slice64.array t_T)) = invariant_refmut_array_T_0 _1
  
  meta "rewrite_def" predicate inv_refmut_array_T_0
  
  predicate resolve_refmut_array_T_0 [@inline:trivial] (_1: MutBorrow.t (Slice64.array t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_array_T_0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_as_mut_slice_body_T (self_: MutBorrow.t t_Option_T)
    (return (x: MutBorrow.t (Slice64.slice t_T))) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_slice_body 'self_' type invariant] inv_refmut_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb2) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 0}
              (fun (_bor: MutBorrow.t t_T) ->
                [ &t <- _bor ] -{inv_T _bor.final}-
                [ &self_ <- { self_ with current = Some _bor.final } ] s1)
            [ _ck -> (! {[@expl:type invariant] inv_T r0} any) ])
      | s1 = MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_12 <- _bor ] -{inv_T _bor.final}-
            [ &t <- { t with current = _bor.final } ] s2) [ _ck -> (! {[@expl:type invariant] inv_T t.current} any) ]
      | s2 = from_mut_T {_12} (fun (_x: MutBorrow.t (Slice64.slice t_T)) -> [ &_11 <- _x ] s3)
      | s3 = MutBorrow.borrow_final <Slice64.slice t_T> {_11.current} {MutBorrow.get_id _11}
          (fun (_bor: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_5 <- _bor ] -{inv_slice_T _bor.final}-
            [ &_11 <- { _11 with current = _bor.final } ] s4)
        [ _ck -> (! {[@expl:type invariant] inv_slice_T _11.current} any) ]
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_slice_T _11} any) ]
      | s5 = -{resolve_refmut_slice_T _11}- s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_T t} any) ]
      | s7 = -{resolve_refmut_T t}- s8
      | s8 = bb6 ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = bb0'0
        [ bb0'0 = s0'0
          [ s0'0 = any
            [ any_ (__arr_temp: Slice64.array t_T) -> (! -{Seq.length __arr_temp.Slice64.elts = 0}-
              [ &_1 <- __arr_temp ] s1'0) ]
          | s1'0 = MutBorrow.borrow_mut <Slice64.array t_T> {_1}
              (fun (_bor: MutBorrow.t (Slice64.array t_T)) ->
                [ &_ret'0 <- _bor ] -{inv_array_T_0 _bor.final}-
                [ &_1 <- _bor.final ] s2'0) [ _ck -> (! {[@expl:type invariant] inv_array_T_0 _1} any) ]
          | s2'0 = _const_ret {_ret'0} ] ]
        [ & _ret'0: MutBorrow.t (Slice64.array t_T) = Any.any_l () | & _1: Slice64.array t_T = Any.any_l () ]
        [ _const_ret (_const: MutBorrow.t (Slice64.array t_T)) -> [ &_13 <- _const ] s3 ]
      | s3 = MutBorrow.borrow_final <Slice64.array t_T> {_13.current} {MutBorrow.get_id _13}
          (fun (_bor: MutBorrow.t (Slice64.array t_T)) ->
            [ &_8 <- _bor ] -{inv_array_T_0 _bor.final}-
            [ &_13 <- { _13 with current = _bor.final } ] s4)
        [ _ck -> (! {[@expl:type invariant] inv_array_T_0 _13.current} any) ]
      | s4 = MutBorrow.borrow_final <Slice64.array t_T> {_8.current} {MutBorrow.get_id _8}
          (fun (_bor: MutBorrow.t (Slice64.array t_T)) ->
            [ &_7 <- _bor ] -{inv_array_T_0 _bor.final}-
            [ &_8 <- { _8 with current = _bor.final } ] s5)
        [ _ck -> (! {[@expl:type invariant] inv_array_T_0 _8.current} any) ]
      | s5 = [ &_5 <- _7 ] s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_array_T_0 _8} any) ]
      | s7 = -{resolve_refmut_array_T_0 _8}- s8
      | s8 = s9 [ _ck -> (! {[@expl:type invariant] inv_refmut_array_T_0 _13} any) ]
      | s9 = -{resolve_refmut_array_T_0 _13}- s10
      | s10 = bb6 ]
    | bb6 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice t_T> {_5.current} {MutBorrow.get_id _5}
          (fun (_bor: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_2 <- _bor ] -{inv_slice_T _bor.final}-
            [ &_5 <- { _5 with current = _bor.final } ] s1)
        [ _ck -> (! {[@expl:type invariant] inv_slice_T _5.current} any) ]
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_refmut_slice_T _5} any) ]
      | s2 = -{resolve_refmut_slice_T _5}- s3
      | s3 = MutBorrow.borrow_final <Slice64.slice t_T> {_2.current} {MutBorrow.get_id _2}
          (fun (_bor: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_ret <- _bor ] -{inv_slice_T _bor.final}-
            [ &_2 <- { _2 with current = _bor.final } ] s4)
        [ _ck -> (! {[@expl:type invariant] inv_slice_T _2.current} any) ]
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_slice_T _2} any) ]
      | s5 = -{resolve_refmut_slice_T _2}- s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s7 = -{resolve_refmut_Option_T self_}- s8
      | s8 = return {_ret} ] ]
    [ & _ret: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & _2: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _5: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _7: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & _8: MutBorrow.t (Slice64.array t_T) = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _11: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _12: MutBorrow.t t_T = Any.any_l ()
    | & _13: MutBorrow.t (Slice64.array t_T) = Any.any_l () ])
    [ return (result: MutBorrow.t (Slice64.slice t_T)) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_slice_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_slice_body result type invariant] inv_refmut_slice_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_mut_slice_body ensures] match self_.current with
        | None -> Seq.length (Slice64.view result.current) = 0
        | Some _ -> exists b: MutBorrow.t t_T. self_.current = Some (b.current)
          /\ self_.final = Some (b.final)
          /\ Seq.get (Slice64.view result.current) 0 = b.current
          /\ Seq.get (Slice64.view result.final) 0 = b.final
          /\ Seq.length (Slice64.view result.current) = 1 /\ Seq.length (Slice64.view result.final) = 1
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_expect_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_expect_body_T (self_: t_Option_T) (msg: string) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_expect_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_expect_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_expect_body requires] self_ <> None)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_ret <- t ] s2 | s2 = return {_ret} ]
    | bb4 = {false} any ] [ & _ret: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_expect_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_expect_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_expect_body ensures] Some result = self_)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_unwrap_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_unwrap_body_T (self_: t_Option_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_body requires] self_ <> None)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_ret <- t ] s2 | s2 = return {_ret} ]
    | bb4 = {false} any ] [ & _ret: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_body ensures] Some result = self_)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_unwrap_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_unwrap_or_body_T (self_: t_Option_T) (default: t_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_body 'default' type invariant] inv_T default)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_T default} any) ]
      | s1 = -{resolve_T default}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_ret <- t ] s4
      | s4 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- default ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & self_: t_Option_T = self_ | & default: t_T = default | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_body ensures #0] self_ = None
        -> result = default)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_body ensures #1] self_ = None
      \/ self_ = Some result /\ resolve_T default)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_unwrap_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_T)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_T)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_unwrap_or_else_body_T (self_: t_Option_T) (f: t_F) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_else_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_else_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_else_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_else_body requires] self_ = None
    -> precondition_F f ())}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_ret <- t ] s4
      | s4 = return {_ret} ]
    | bb4 = s0 [ s0 = call_once_F {f} {_13} (fun (_x: t_T) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _13: () = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_else_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_else_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_else_body ensures] match self_ with
        | None -> postcondition_once_F f () result
        | Some t -> result = t
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_unwrap_or_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@stop_split] [@expl:default requires] precondition_default () ()}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:default ensures] postcondition_once_default () () result}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut_default () args () res]. postcondition_mut_default () args () res
      -> (let () = args in inv_T res)
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_default () args res]. postcondition_default () args res
      -> (let () = args in inv_T res)
  
  function fn_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_unwrap_or_default_body_T (self_: t_Option_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_default_body 'self_' type invariant] inv_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb5) ]
    | bb5 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_ret <- t ] s2 | s2 = return {_ret} ]
    | bb4 = s0 [ s0 = default_T (fun (_x: t_T) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_default_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_default_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_default_body ensures #0] self_ = None
        -> postcondition_default () () result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_or_default_body ensures #1] self_ = None
      \/ self_ = Some result)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_unwrap_unchecked_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_unwrap_unchecked_body_T (self_: t_Option_T) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_unchecked_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_unchecked_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_unchecked_body requires] self_ <> None)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_ret <- t ] s2 | s2 = return {_ret} ]
    | bb4 = {false} any ] [ & _ret: t_T = Any.any_l () | & self_: t_Option_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_unchecked_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_unchecked_body result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_unwrap_unchecked_body ensures] Some result = self_)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_map_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_F
  
  type t_U
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_U)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_U) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_U result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  type t_Option_U = None'0 | Some'0 t_U
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_U f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_map_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_U)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb5) ]
    | bb5 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_14 <- t ] s2
      | s2 = call_once_F {f} {_14} (fun (_x: t_U) -> [ &_12 <- _x ] s3)
      | s3 = [ &_ret <- Some'0 _12 ] s4
      | s4 = return {_ret} ]
    | bb4 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = [ &_ret <- None'0 ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Option_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _12: t_U = Any.any_l ()
    | & _14: t_T = Any.any_l () ])
    [ return (result: t_Option_U) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_body result type invariant] inv_Option_U result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_body ensures] match self_ with
        | None -> result = None'0
        | Some t -> exists r: t_U. result = Some'0 r /\ postcondition_once_F f t r
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_inspect_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_tup1_ref_T [@inline:trivial] (_1: t_T) = inv_ref_T _1
  
  meta "rewrite_def" predicate inv_tup1_ref_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: ())
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: ())) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_ref_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: ()) -> {[@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result}
      (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_inspect_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_17 <- t ] s2
      | s2 = [ &_15 <- _17 ] s3
      | s3 = call_once_F {f} {_15} (fun (_x: ()) -> [ &_13 <- _x ] s4)
      | s4 = [ &_ret <- Some t ] s5
      | s5 = return {_ret} ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = [ &_ret <- None ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _13: () = Any.any_l ()
    | & _15: t_T = Any.any_l ()
    | & _17: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body ensures #0] result = self_)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_inspect_body ensures #1] match self_ with
        | None -> true
        | Some t -> postcondition_once_F f t ()
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_map_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_U
  
  predicate inv_U (_1: t_U)
  
  predicate resolve_U (_1: t_U)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_U)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_U) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_U result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_map_or_body_T (self_: t_Option_T) (default: t_U) (f: t_F)
    (return (x: t_U)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body 'default' type invariant] inv_U default)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_U default} any) ]
      | s1 = -{resolve_U default}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_14 <- t ] s4
      | s4 = call_once_F {f} {_14} (fun (_x: t_U) -> [ &_ret <- _x ] s5)
      | s5 = return {_ret} ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = [ &_ret <- default ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & default: t_U = default
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _14: t_T = Any.any_l () ])
    [ return (result: t_U) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body result type invariant] inv_U result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_body ensures] match self_ with
        | None -> result = default
        | Some t -> postcondition_once_F f t result
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_map_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_D
  
  predicate inv_D (_1: t_D)
  
  predicate resolve_D (_1: t_D)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_F
  
  type t_U
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_U)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_U) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_U result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate precondition_D (self: t_D) (args: ())
  
  predicate postcondition_once_D (self: t_D) (args: ()) (result: t_U)
  
  let rec call_once_D (self_: t_D) (arg: ()) (return (x: t_U)) =
    {[@stop_split] [@expl:call_once_D requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_D self_)
    /\ ([@stop_split] [@expl:call_once requires] precondition_D self_ arg)}
    any
    [ return (result: t_U) ->
    {[@stop_split] [@expl:call_once_D ensures] ([@stop_split] [@expl:call_once result type invariant] inv_U result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_D self_ arg result)}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_map_or_else_body_T (self_: t_Option_T) (default: t_D) (f: t_F)
    (return (x: t_U)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body 'default' type invariant] inv_D default)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body requires] match self_ with
      | None -> precondition_D default ()
      | Some t -> precondition_F f t
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_D default} any) ]
      | s1 = -{resolve_D default}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_17 <- t ] s4
      | s4 = call_once_F {f} {_17} (fun (_x: t_U) -> [ &_ret <- _x ] s5)
      | s5 = return {_ret} ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = call_once_D {default} {_14} (fun (_x: t_U) -> [ &_ret <- _x ] s3)
      | s3 = return {_ret} ] ]
    [ & _ret: t_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & default: t_D = default
    | & f: t_F = f
    | & _14: () = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & _17: t_T = Any.any_l () ])
    [ return (result: t_U) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body result type invariant] inv_U result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_map_or_else_body ensures] match self_ with
        | None -> postcondition_once_D default () result
        | Some t -> postcondition_once_F f t result
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_ok_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_E
  
  predicate inv_E (_1: t_E)
  
  predicate resolve_E (_1: t_E)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_ok_or_body_T (self_: t_Option_T) (err: t_E) (return (x: t_Result_T_E)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_body 'err' type invariant] inv_E err)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_E err} any) ]
      | s1 = -{resolve_E err}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_ret <- Ok t ] s4
      | s4 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- Err err ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Result_T_E = Any.any_l () | & self_: t_Option_T = self_ | & err: t_E = err | & t: t_T = Any.any_l () ])
    [ return (result: t_Result_T_E) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_body result type invariant] inv_Result_T_E result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_body ensures] match self_ with
        | None -> result = Err err
        | Some t -> result = Ok t /\ resolve_E err
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_ok_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate inv_E (_1: t_E)
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_E)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_E)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_E) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_E result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_ok_or_else_body_T (self_: t_Option_T) (err: t_F)
    (return (x: t_Result_T_E)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_else_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_else_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_else_body 'err' type invariant] inv_F err)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_else_body requires] self_ = None
    -> precondition_F err ())}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F err} any) ]
      | s1 = -{resolve_F err}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_ret <- Ok t ] s4
      | s4 = return {_ret} ]
    | bb4 = s0
      [ s0 = call_once_F {err} {_12} (fun (_x: t_E) -> [ &_10 <- _x ] s1)
      | s1 = [ &_ret <- Err _10 ] s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Result_T_E = Any.any_l ()
    | & self_: t_Option_T = self_
    | & err: t_F = err
    | & _10: t_E = Any.any_l ()
    | & _12: () = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Result_T_E) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_else_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_else_body result type invariant] inv_Result_T_E result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_ok_or_else_body ensures] match self_ with
        | None -> exists r: t_E. result = Err r /\ postcondition_once_F err () r
        | Some t -> result = Ok t
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_as_deref_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Target
  
  predicate precondition_deref (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_deref () args]. (let self_ = args in false)
      -> precondition_deref () args
  
  predicate inv_Target (_1: t_Target)
  
  predicate invariant_ref_Target [@inline:trivial] (self: t_Target) = inv_Target self
  
  meta "rewrite_def" predicate invariant_ref_Target
  
  predicate inv_ref_Target [@inline:trivial] (_1: t_Target) = invariant_ref_Target _1
  
  meta "rewrite_def" predicate inv_ref_Target
  
  predicate postcondition_once_deref (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_Target [postcondition_once_deref () args res]. postcondition_once_deref () args res
      -> (let self_ = args in inv_ref_Target res)
  
  let rec deref_T (self_: t_T) (return (x: t_Target)) =
    {[@stop_split] [@expl:deref requires] precondition_deref () self_}
    any
    [ return (result: t_Target) -> {[@stop_split] [@expl:deref ensures] postcondition_once_deref () self_ result}
      (! return {result}) ]
  
  type t_Option_ref_Target = None'0 | Some'0 t_Target
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_ref_Option_T [@inline:trivial] (self: t_Option_T) = inv_Option_T self
  
  meta "rewrite_def" predicate invariant_ref_Option_T
  
  predicate inv_ref_Option_T [@inline:trivial] (_1: t_Option_T) = invariant_ref_Option_T _1
  
  meta "rewrite_def" predicate inv_ref_Option_T
  
  predicate inv_Option_ref_Target (_1: t_Option_ref_Target)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_Target [inv_Option_ref_Target x]. inv_Option_ref_Target x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_ref_Target f0
        end
  
  type tup2_ref_Option_T_Option_ref_Target = { f0: t_Option_T; f1: t_Option_ref_Target }
  
  predicate resolve_deref [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_deref
  
  predicate postcondition_mut_deref (self: ()) (args: t_T) (result_state: ()) (result: t_Target)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_Target [postcondition_mut_deref () args () res]. postcondition_mut_deref () args () res
      -> (let self_ = args in inv_ref_Target res)
  
  function fn_mut_once_deref (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_mut_once_deref_spec: forall self: (), args: t_T, res: t_Target. postcondition_once_deref self args res
      = (exists res_state: (). postcondition_mut_deref self args res_state res /\ resolve_deref res_state)
  
  predicate hist_inv_deref [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_deref
  
  function hist_inv_trans_deref (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_deref_spec: forall self: (), b: (), c: (). hist_inv_deref self b
      -> hist_inv_deref b c -> hist_inv_deref self c
  
  function hist_inv_refl_deref (self: ()) : ()
  
  axiom hist_inv_refl_deref_spec: forall self: (). hist_inv_deref self self
  
  function postcondition_mut_hist_inv_deref (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom postcondition_mut_hist_inv_deref_spec:
    forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut_deref self args res_state res
      -> hist_inv_deref self res_state
  
  function fn_hist_inv_deref (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_deref_spec: forall self: (), res_state: (). hist_inv_deref self res_state = (self = res_state)
  
  predicate postcondition_deref (self: ()) (args: t_T) (result: t_Target)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_Target [postcondition_deref () args res]. postcondition_deref () args res
      -> (let self_ = args in inv_ref_Target res)
  
  function fn_once_deref (self: ()) (args: t_T) (res: t_Target) : ()
  
  axiom fn_once_deref_spec: forall self: (), args: t_T, res: t_Target. postcondition_once_deref self args res
      = (postcondition_deref self args res /\ resolve_deref self)
  
  function fn_mut_deref (self: ()) (args: t_T) (res_state: ()) (res: t_Target) : ()
  
  axiom fn_mut_deref_spec:
    forall self: (), args: t_T, res_state: (), res: t_Target. postcondition_mut_deref self args res_state res
      = (postcondition_deref self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_as_deref_body_T (self_: t_Option_T) (return (x: t_Option_ref_Target)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_body 'self_' type invariant] inv_ref_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_body requires] match self_ with
      | None -> true
      | Some x -> precondition_deref () x
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: t_T) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &x <- r0 ] s1)
      | s1 = [ &_11 <- x ] s2
      | s2 = deref_T {_11} (fun (_x: t_Target) -> [ &_9 <- _x ] s3)
      | s3 = [ &_ret <- Some'0 _9 ] s4
      | s4 = return {_ret} ]
    | bb3 = s0 [ s0 = [ &_ret <- None'0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_ref_Target = Any.any_l ()
    | & self_: t_Option_T = self_
    | & x: t_T = Any.any_l ()
    | & _9: t_Target = Any.any_l ()
    | & _11: t_T = Any.any_l () ])
    [ return (result: t_Option_ref_Target) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_body result type invariant] inv_Option_ref_Target result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_body ensures] match { f0 = self_;
                                                                                                 f1 = result } with
        | {f0 = None; f1 = None'0} -> true
        | {f0 = Some x; f1 = Some'0 r} -> postcondition_deref () x r
        | _ -> false
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_as_deref_mut_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  type t_Target
  
  predicate precondition_deref_mut (self: ()) (args: MutBorrow.t t_T)
  
  axiom precondition_fndef: forall args: MutBorrow.t t_T [precondition_deref_mut () args]. (let self_ = args in false)
      -> precondition_deref_mut () args
  
  predicate inv_Target (_1: t_Target)
  
  predicate invariant_refmut_Target [@inline:trivial] (self: MutBorrow.t t_Target) =
    inv_Target self.current /\ inv_Target self.final
  
  meta "rewrite_def" predicate invariant_refmut_Target
  
  predicate inv_refmut_Target [@inline:trivial] (_1: MutBorrow.t t_Target) = invariant_refmut_Target _1
  
  meta "rewrite_def" predicate inv_refmut_Target
  
  predicate postcondition_once_deref_mut (self: ()) (args: MutBorrow.t t_T) (result: MutBorrow.t t_Target)
  
  axiom postcondition_fndef:
    forall args: MutBorrow.t t_T, res: MutBorrow.t t_Target [postcondition_once_deref_mut () args res]. postcondition_once_deref_mut () args res
      -> (let self_ = args in inv_refmut_Target res)
  
  let rec deref_mut_T (self_: MutBorrow.t t_T) (return (x: MutBorrow.t t_Target)) =
    {[@stop_split] [@expl:deref_mut requires] precondition_deref_mut () self_}
    any
    [ return (result: MutBorrow.t t_Target) ->
    {[@stop_split] [@expl:deref_mut ensures] postcondition_once_deref_mut () self_ result}
      (! return {result}) ]
  
  type t_Option_refmut_Target = None'0 | Some'0 (MutBorrow.t t_Target)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate resolve_refmut_Target [@inline:trivial] (_1: MutBorrow.t t_Target) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Target
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  predicate inv_Option_refmut_Target (_1: t_Option_refmut_Target)
  
  axiom inv_axiom'0 [@rewrite]:
    forall x: t_Option_refmut_Target [inv_Option_refmut_Target x]. inv_Option_refmut_Target x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_refmut_Target f0
        end
  
  type tup3_Option_T_Option_T_Option_refmut_Target = { f0: t_Option_T; f1: t_Option_T; f2: t_Option_refmut_Target }
  
  predicate resolve_deref_mut [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_deref_mut
  
  predicate postcondition_mut_deref_mut (self: ()) (args: MutBorrow.t t_T) (result_state: ()) (result: MutBorrow.t t_Target)
  
  axiom postcondition_fndef'0:
    forall args: MutBorrow.t t_T, res: MutBorrow.t t_Target [postcondition_mut_deref_mut () args () res]. postcondition_mut_deref_mut () args () res
      -> (let self_ = args in inv_refmut_Target res)
  
  function fn_mut_once_deref_mut (self: ()) (args: MutBorrow.t t_T) (res: MutBorrow.t t_Target) : ()
  
  axiom fn_mut_once_deref_mut_spec:
    forall self: (), args: MutBorrow.t t_T, res: MutBorrow.t t_Target. postcondition_once_deref_mut self args res
      = (exists res_state: (). postcondition_mut_deref_mut self args res_state res /\ resolve_deref_mut res_state)
  
  predicate hist_inv_deref_mut [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_deref_mut
  
  function hist_inv_trans_deref_mut (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_deref_mut_spec: forall self: (), b: (), c: (). hist_inv_deref_mut self b
      -> hist_inv_deref_mut b c -> hist_inv_deref_mut self c
  
  function hist_inv_refl_deref_mut (self: ()) : ()
  
  axiom hist_inv_refl_deref_mut_spec: forall self: (). hist_inv_deref_mut self self
  
  function postcondition_mut_hist_inv_deref_mut (self: ()) (args: MutBorrow.t t_T) (res_state: ()) (res: MutBorrow.t t_Target) : ()
  
  axiom postcondition_mut_hist_inv_deref_mut_spec:
    forall self: (), args: MutBorrow.t t_T, res_state: (), res: MutBorrow.t t_Target. postcondition_mut_deref_mut self args res_state res
      -> hist_inv_deref_mut self res_state
  
  function fn_hist_inv_deref_mut (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_deref_mut_spec: forall self: (), res_state: (). hist_inv_deref_mut self res_state
      = (self = res_state)
  
  predicate postcondition_deref_mut (self: ()) (args: MutBorrow.t t_T) (result: MutBorrow.t t_Target)
  
  axiom postcondition_fndef'1:
    forall args: MutBorrow.t t_T, res: MutBorrow.t t_Target [postcondition_deref_mut () args res]. postcondition_deref_mut () args res
      -> (let self_ = args in inv_refmut_Target res)
  
  function fn_once_deref_mut (self: ()) (args: MutBorrow.t t_T) (res: MutBorrow.t t_Target) : ()
  
  axiom fn_once_deref_mut_spec:
    forall self: (), args: MutBorrow.t t_T, res: MutBorrow.t t_Target. postcondition_once_deref_mut self args res
      = (postcondition_deref_mut self args res /\ resolve_deref_mut self)
  
  function fn_mut_deref_mut (self: ()) (args: MutBorrow.t t_T) (res_state: ()) (res: MutBorrow.t t_Target) : ()
  
  axiom fn_mut_deref_mut_spec:
    forall self: (), args: MutBorrow.t t_T, res_state: (), res: MutBorrow.t t_Target. postcondition_mut_deref_mut self args res_state res
      = (postcondition_deref_mut self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_as_deref_mut_body_T (self_: MutBorrow.t t_Option_T)
    (return (x: t_Option_refmut_Target)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_mut_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_mut_body 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_mut_body requires] match self_.current with
      | None -> true
      | Some cur -> forall bor: MutBorrow.t t_T. bor.current = cur -> precondition_deref_mut () bor
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb3) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 0}
              (fun (_bor: MutBorrow.t t_T) ->
                [ &x <- _bor ] -{inv_T _bor.final}-
                [ &self_ <- { self_ with current = Some _bor.final } ] s1)
            [ _ck -> (! {[@expl:type invariant] inv_T r0} any) ])
      | s1 = MutBorrow.borrow_final <t_T> {x.current} {MutBorrow.get_id x}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_11 <- _bor ] -{inv_T _bor.final}-
            [ &x <- { x with current = _bor.final } ] s2) [ _ck -> (! {[@expl:type invariant] inv_T x.current} any) ]
      | s2 = MutBorrow.borrow_final <t_T> {_11.current} {MutBorrow.get_id _11}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_10 <- _bor ] -{inv_T _bor.final}-
            [ &_11 <- { _11 with current = _bor.final } ] s3)
        [ _ck -> (! {[@expl:type invariant] inv_T _11.current} any) ]
      | s3 = deref_mut_T {_10} (fun (_x: MutBorrow.t t_Target) -> [ &_9 <- _x ] s4)
      | s4 = MutBorrow.borrow_final <t_Target> {_9.current} {MutBorrow.get_id _9}
          (fun (_bor: MutBorrow.t t_Target) ->
            [ &_8 <- _bor ] -{inv_Target _bor.final}-
            [ &_9 <- { _9 with current = _bor.final } ] s5)
        [ _ck -> (! {[@expl:type invariant] inv_Target _9.current} any) ]
      | s5 = [ &_ret <- Some'0 _8 ] s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _11} any) ]
      | s7 = -{resolve_refmut_T _11}- s8
      | s8 = s9 [ _ck -> (! {[@expl:type invariant] inv_refmut_Target _9} any) ]
      | s9 = -{resolve_refmut_Target _9}- s10
      | s10 = s11 [ _ck -> (! {[@expl:type invariant] inv_refmut_T x} any) ]
      | s11 = -{resolve_refmut_T x}- s12
      | s12 = bb6 ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = [ &_ret <- None'0 ] s3
      | s3 = bb6 ]
    | bb6 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = return {_ret} ] ]
    [ & _ret: t_Option_refmut_Target = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & x: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_Target = Any.any_l ()
    | & _9: MutBorrow.t t_Target = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_Option_refmut_Target) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_mut_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_mut_body result type invariant] inv_Option_refmut_Target result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_as_deref_mut_body ensures] match { f0 = self_.current;
                                                                                                     f1 = self_.final;
                                                                                                     f2 = result } with
        | {f0 = None; f1 = None; f2 = None'0} -> true
        | {f0 = Some cur; f1 = Some fin; f2 = Some'0 r} -> exists bor: MutBorrow.t t_T. bor.current = cur
          /\ bor.final = fin /\ postcondition_deref_mut () bor r
        | _ -> false
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_and_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  type t_U
  
  type t_Option_U = None'0 | Some'0 t_U
  
  predicate inv_U (_1: t_U)
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_U f0
        end
  
  predicate resolve_U (_1: t_U)
  
  predicate resolve_Option_U (_1: t_Option_U)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Option_U [resolve_Option_U x]. resolve_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_U x0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_and_body_T (self_: t_Option_T) (optb: t_Option_U)
    (return (x: t_Option_U)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_body 'optb' type invariant] inv_Option_U optb)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Option_T self_} any) ]
      | s1 = -{resolve_Option_T self_}- s2
      | s2 = [ &_ret <- optb ] s3
      | s3 = return {_ret} ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Option_U optb} any) ]
      | s1 = -{resolve_Option_U optb}- s2
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_Option_T self_} any) ]
      | s3 = -{resolve_Option_T self_}- s4
      | s4 = [ &_ret <- None'0 ] s5
      | s5 = return {_ret} ] ]
    [ & _ret: t_Option_U = Any.any_l () | & self_: t_Option_T = self_ | & optb: t_Option_U = optb ])
    [ return (result: t_Option_U) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_body result type invariant] inv_Option_U result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_body ensures #0] self_ = None
        -> result = None'0 /\ resolve_Option_U optb)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_body ensures #1] self_ = None
      \/ result = optb /\ resolve_Option_T self_)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_and_then_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_F
  
  type t_U
  
  type t_Option_U = None'0 | Some'0 t_U
  
  predicate inv_F (_1: t_F)
  
  predicate inv_T (_1: t_T)
  
  predicate inv_tup1_T [@inline:trivial] (_1: t_T) = inv_T _1
  
  meta "rewrite_def" predicate inv_tup1_T
  
  predicate precondition_F (self: t_F) (args: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_U f0
        end
  
  predicate postcondition_once_F (self: t_F) (args: t_T) (result: t_Option_U)
  
  let rec call_once_F (self_: t_F) (arg: t_T) (return (x: t_Option_U)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_Option_U) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_Option_U result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  predicate resolve_F (_1: t_F)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_and_then_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_U)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_then_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_then_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_then_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_then_body requires] match self_ with
      | None -> true
      | Some t -> precondition_F f t
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_12 <- t ] s2
      | s2 = call_once_F {f} {_12} (fun (_x: t_Option_U) -> [ &_ret <- _x ] s3)
      | s3 = return {_ret} ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = [ &_ret <- None'0 ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Option_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & t: t_T = Any.any_l ()
    | & _12: t_T = Any.any_l () ])
    [ return (result: t_Option_U) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_then_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_then_body result type invariant] inv_Option_U result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_and_then_body ensures] match self_ with
        | None -> result = None'0
        | Some t -> postcondition_once_F f t result
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_filter_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_P
  
  predicate inv_P (_1: t_P)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_tup1_ref_T [@inline:trivial] (_1: t_T) = inv_ref_T _1
  
  meta "rewrite_def" predicate inv_tup1_ref_T
  
  predicate precondition_P (self: t_P) (args: t_T)
  
  predicate postcondition_once_P (self: t_P) (args: t_T) (result: bool)
  
  let rec call_once_P (self_: t_P) (arg: t_T) (return (x: bool)) =
    {[@stop_split] [@expl:call_once_P requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_P self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_ref_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_P self_ arg)}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:call_once ensures] postcondition_once_P self_ arg result}
      (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_P (_1: t_P)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_filter_body_T (self_: t_Option_T) (predicate': t_P)
    (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_filter_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_filter_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_filter_body 'predicate' type invariant] inv_P predicate')
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_filter_body requires] match self_ with
      | None -> true
      | Some t -> precondition_P predicate' t
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb2) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = [ &_15 <- t ] s2
      | s2 = [ &_13 <- _15 ] s3
      | s3 = call_once_P {predicate'} {_13} (fun (_x: bool) -> [ &_11 <- _x ] s4)
      | s4 = any [ br0 -> {_11 = false} (! bb8) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0 [ s0 = [ &_ret <- Some t ] s1 | s1 = return {_ret} ]
    | bb8 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_T t} any) ]
      | s1 = -{resolve_T t}- s2
      | s2 = [ &_ret <- None ] s3
      | s3 = return {_ret} ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_P predicate'} any) ]
      | s1 = -{resolve_P predicate'}- s2
      | s2 = [ &_ret <- None ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & predicate': t_P = predicate'
    | & t: t_T = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: t_T = Any.any_l ()
    | & _15: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_filter_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_filter_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_filter_body ensures] match self_ with
        | None -> result = None
        | Some t -> match result with
          | None -> postcondition_once_P predicate' t false /\ resolve_T t
          | Some r -> postcondition_once_P predicate' t true /\ r = t
          end
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_or_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_or_body_T (self_: t_Option_T) (optb: t_Option_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_body 'optb' type invariant] inv_Option_T optb)}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Option_T optb} any) ]
      | s1 = -{resolve_Option_T optb}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_ret <- Some t ] s4
      | s4 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- optb ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & optb: t_Option_T = optb
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_body ensures #0] self_ = None -> result = optb)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_body ensures #1] self_ = None
      \/ result = self_ /\ resolve_Option_T optb)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_or_else_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_Option_T)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_or_else_body_T (self_: t_Option_T) (f: t_F) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_else_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_else_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_else_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_else_body requires] self_ = None
    -> precondition_F f ())}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s3)
      | s3 = [ &_ret <- Some t ] s4
      | s4 = return {_ret} ]
    | bb4 = s0 [ s0 = call_once_F {f} {_11} (fun (_x: t_Option_T) -> [ &_ret <- _x ] s1) | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & f: t_F = f
    | & _11: () = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_else_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_else_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_or_else_body ensures] match self_ with
        | None -> postcondition_once_F f () result
        | Some t -> result = Some t
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_xor_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0'0 -> inv_T f0'0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (_x: t_Option_T) (return (f0'0: t_T)) = any
    [ _k (f0'0: t_T) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_xor_body_T (self_: t_Option_T) (optb: t_Option_T)
    (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_xor_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_xor_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_xor_body 'optb' type invariant] inv_Option_T optb)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- { f0 = self_; f1 = optb } ] s1
      | s1 = any [ br0 -> {_6.f0 = None} (! bb6) | br1 (x0: t_T) -> {_6.f0 = Some x0} (! bb4) ] ]
    | bb4 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Option_T _6.f1} any) ]
      | s1 = -{resolve_Option_T _6.f1}- s2
      | s2 = any [ br0 -> {_6.f1 = None} (! bb9) | br1 (x0: t_T) -> {_6.f1 = Some x0} (! bb24) ] ]
    | bb24 = s0
      [ s0 = s1
        [ _ck -> (! {[@expl:type invariant] match _6 with
            | {f0 = Some x} -> inv_T x
            | _ -> true
            end}
          any) ]
      | s1 = -{match _6 with
          | {f0 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    | bb9 = s0 [ s0 = elim_Some {_6.f0} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = bb10 ]
    | bb6 = any [ br0 -> {_6.f1 = None} (! bb23) | br1 (x0: t_T) -> {_6.f1 = Some x0} (! bb8) ]
    | bb23 = s0
      [ s0 = s1
        [ _ck -> (! {[@expl:type invariant] match _6 with
            | {f1 = Some x} -> inv_T x
            | _ -> true
            end}
          any) ]
      | s1 = -{match _6 with
          | {f1 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s2
      | s2 = bb3 ]
    | bb3 = s0 [ s0 = [ &_ret <- None ] s1 | s1 = return {_ret} ]
    | bb8 = s0 [ s0 = elim_Some {_6.f1} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = bb10 ]
    | bb10 = s0 [ s0 = [ &_ret <- Some t ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_T = self_
    | & optb: t_Option_T = optb
    | & _6: tup2_Option_T_Option_T = Any.any_l ()
    | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_xor_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_xor_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_xor_body ensures] match { f0 = self_; f1 = optb } with
        | {f0 = None; f1 = None} -> result = None
        | {f0 = Some t1; f1 = Some t2} -> result = None /\ resolve_T t1 /\ resolve_T t2
        | {f0 = Some t; f1 = None} -> result = Some t
        | {f0 = None; f1 = Some t} -> result = Some t
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_insert_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_insert_body_T (self_: MutBorrow.t t_Option_T) (value: t_T)
    (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_insert_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_insert_body 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_insert_body 'value' type invariant] inv_T value)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_9 <- Some value ] s1
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s2 = -{resolve_Option_T self_.current}- s3
      | s3 = [ &self_ <- { self_ with current = _9 } ] s4
      | s4 = any [ br0 -> {self_.current = None} (! bb6) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb7) ] ]
    | bb7 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 0}
              (fun (_bor: MutBorrow.t t_T) ->
                [ &v <- _bor ] -{inv_T _bor.final}-
                [ &self_ <- { self_ with current = Some _bor.final } ] s1)
            [ _ck -> (! {[@expl:type invariant] inv_T r0} any) ])
      | s1 = MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_11 <- _bor ] -{inv_T _bor.final}-
            [ &v <- { v with current = _bor.final } ] s2) [ _ck -> (! {[@expl:type invariant] inv_T v.current} any) ]
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_T v} any) ]
      | s3 = -{resolve_refmut_T v}- s4
      | s4 = MutBorrow.borrow_final <t_T> {_11.current} {MutBorrow.get_id _11}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_3 <- _bor ] -{inv_T _bor.final}-
            [ &_11 <- { _11 with current = _bor.final } ] s5)
        [ _ck -> (! {[@expl:type invariant] inv_T _11.current} any) ]
      | s5 = s6 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _11} any) ]
      | s6 = -{resolve_refmut_T _11}- s7
      | s7 = MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_ret <- _bor ] -{inv_T _bor.final}-
            [ &_3 <- { _3 with current = _bor.final } ] s8) [ _ck -> (! {[@expl:type invariant] inv_T _3.current} any) ]
      | s8 = s9 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _3} any) ]
      | s9 = -{resolve_refmut_T _3}- s10
      | s10 = s11 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s11 = -{resolve_refmut_Option_T self_}- s12
      | s12 = return {_ret} ]
    | bb6 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = {false} any ] ]
    [ & _ret: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & value: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option_T = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_insert_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_insert_body result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_insert_body ensures #0] match self_.current with
          | Some t -> resolve_T t
          | None -> true
          end)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_insert_body ensures #1] result.current = value
      /\ self_.final = Some (result.final))}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_get_or_insert_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_get_or_insert_body_T (self_: MutBorrow.t t_Option_T) (value: t_T)
    (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_body 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_body 'value' type invariant] inv_T value)}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb4) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_T value} any) ] | s1 = -{resolve_T value}- s2 | s2 = bb9 ]
    | bb4 = s0
      [ s0 = [ &_9 <- Some value ] s1
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s2 = -{resolve_Option_T self_.current}- s3
      | s3 = [ &self_ <- { self_ with current = _9 } ] s4
      | s4 = bb9 ]
    | bb9 = any [ br0 -> {self_.current = None} (! bb11) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb12) ]
    | bb12 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 0}
              (fun (_bor: MutBorrow.t t_T) ->
                [ &v <- _bor ] -{inv_T _bor.final}-
                [ &self_ <- { self_ with current = Some _bor.final } ] s1)
            [ _ck -> (! {[@expl:type invariant] inv_T r0} any) ])
      | s1 = MutBorrow.borrow_final <t_T> {v.current} {MutBorrow.get_id v}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_11 <- _bor ] -{inv_T _bor.final}-
            [ &v <- { v with current = _bor.final } ] s2) [ _ck -> (! {[@expl:type invariant] inv_T v.current} any) ]
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_T v} any) ]
      | s3 = -{resolve_refmut_T v}- s4
      | s4 = MutBorrow.borrow_final <t_T> {_11.current} {MutBorrow.get_id _11}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_3 <- _bor ] -{inv_T _bor.final}-
            [ &_11 <- { _11 with current = _bor.final } ] s5)
        [ _ck -> (! {[@expl:type invariant] inv_T _11.current} any) ]
      | s5 = s6 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _11} any) ]
      | s6 = -{resolve_refmut_T _11}- s7
      | s7 = MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_ret <- _bor ] -{inv_T _bor.final}-
            [ &_3 <- { _3 with current = _bor.final } ] s8) [ _ck -> (! {[@expl:type invariant] inv_T _3.current} any) ]
      | s8 = s9 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _3} any) ]
      | s9 = -{resolve_refmut_T _3}- s10
      | s10 = s11 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s11 = -{resolve_refmut_Option_T self_}- s12
      | s12 = return {_ret} ]
    | bb11 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = {false} any ] ]
    [ & _ret: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & value: t_T = value
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _9: t_Option_T = Any.any_l ()
    | & _11: MutBorrow.t t_T = Any.any_l ()
    | & v: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_body result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_body ensures] match self_.current with
        | None -> result.current = value /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final) /\ resolve_T value
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_get_or_insert_default_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  predicate precondition_default (self: ()) (args: ())
  
  axiom precondition_fndef: forall args: () [precondition_default () args]. (let () = args in true)
      -> precondition_default () args
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: (), res: t_T [postcondition_once_default () args res]. postcondition_once_default () args res
      -> (let () = args in inv_T res)
  
  let rec default_T (return (x: t_T)) = {[@stop_split] [@expl:default requires] precondition_default () ()}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:default ensures] postcondition_once_default () () result}
      (! return {result}) ]
  
  type t_Option_T = None | Some t_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_T (_1: t_T)
  
  let rec get_or_insert_T (self_: MutBorrow.t t_Option_T) (value: t_T) (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:get_or_insert_T requires] ([@stop_split] [@expl:get_or_insert 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:get_or_insert 'value' type invariant] inv_T value)}
    any
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:get_or_insert_T ensures] ([@stop_split] [@expl:get_or_insert result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:get_or_insert ensures] match self_.current with
        | None -> result.current = value /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final) /\ resolve_T value
        end)}
      (! return {result}) ]
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  predicate resolve_default [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_default
  
  predicate postcondition_mut_default (self: ()) (args: ()) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: (), res: t_T [postcondition_mut_default () args () res]. postcondition_mut_default () args () res
      -> (let () = args in inv_T res)
  
  function fn_mut_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_mut_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (exists res_state: (). postcondition_mut_default self args res_state res /\ resolve_default res_state)
  
  predicate hist_inv_default [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_default
  
  function hist_inv_trans_default (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_default_spec: forall self: (), b: (), c: (). hist_inv_default self b
      -> hist_inv_default b c -> hist_inv_default self c
  
  function hist_inv_refl_default (self: ()) : ()
  
  axiom hist_inv_refl_default_spec: forall self: (). hist_inv_default self self
  
  function postcondition_mut_hist_inv_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      -> hist_inv_default self res_state
  
  function fn_hist_inv_default (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_default_spec: forall self: (), res_state: (). hist_inv_default self res_state = (self = res_state)
  
  predicate postcondition_default (self: ()) (args: ()) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: (), res: t_T [postcondition_default () args res]. postcondition_default () args res
      -> (let () = args in inv_T res)
  
  function fn_once_default (self: ()) (args: ()) (res: t_T) : ()
  
  axiom fn_once_default_spec: forall self: (), args: (), res: t_T. postcondition_once_default self args res
      = (postcondition_default self args res /\ resolve_default self)
  
  function fn_mut_default (self: ()) (args: ()) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_default_spec:
    forall self: (), args: (), res_state: (), res: t_T. postcondition_mut_default self args res_state res
      = (postcondition_default self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_get_or_insert_default_body_T (self_: MutBorrow.t t_Option_T)
    (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_default_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_default_body 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_default_body requires] match self_ with
      | {current = None} -> precondition_default () ()
      | {current = Some _} -> true
      end)}
    (! bb0
    [ bb0 = s0
      [ s0 = default_T (fun (_x: t_T) -> [ &_9 <- _x ] s1)
      | s1 = MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_bor: MutBorrow.t t_Option_T) ->
            [ &_8 <- _bor ] -{inv_Option_T _bor.final}-
            [ &self_ <- { self_ with current = _bor.final } ] s2)
        [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s2 = get_or_insert_T {_8} {_9} (fun (_x: MutBorrow.t t_T) -> [ &_7 <- _x ] s3)
      | s3 = MutBorrow.borrow_final <t_T> {_7.current} {MutBorrow.get_id _7}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_2 <- _bor ] -{inv_T _bor.final}-
            [ &_7 <- { _7 with current = _bor.final } ] s4) [ _ck -> (! {[@expl:type invariant] inv_T _7.current} any) ]
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _7} any) ]
      | s5 = -{resolve_refmut_T _7}- s6
      | s6 = MutBorrow.borrow_final <t_T> {_2.current} {MutBorrow.get_id _2}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_ret <- _bor ] -{inv_T _bor.final}-
            [ &_2 <- { _2 with current = _bor.final } ] s7) [ _ck -> (! {[@expl:type invariant] inv_T _2.current} any) ]
      | s7 = s8 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _2} any) ]
      | s8 = -{resolve_refmut_T _2}- s9
      | s9 = s10 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s10 = -{resolve_refmut_Option_T self_}- s11
      | s11 = return {_ret} ] ]
    [ & _ret: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & _2: MutBorrow.t t_T = Any.any_l ()
    | & _7: MutBorrow.t t_T = Any.any_l ()
    | & _8: MutBorrow.t t_Option_T = Any.any_l ()
    | & _9: t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_default_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_default_body result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_default_body ensures] match self_.current with
        | None -> postcondition_default () () result.current /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final)
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_get_or_insert_with_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate resolve_F (_1: t_F)
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate precondition_F (self: t_F) (args: ())
  
  predicate postcondition_once_F (self: t_F) (args: ()) (result: t_T)
  
  let rec call_once_F (self_: t_F) (arg: ()) (return (x: t_T)) =
    {[@stop_split] [@expl:call_once_F requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_F self_)
    /\ ([@stop_split] [@expl:call_once requires] precondition_F self_ arg)}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:call_once_F ensures] ([@stop_split] [@expl:call_once result type invariant] inv_T result)
      /\ ([@stop_split] [@expl:call_once ensures] postcondition_once_F self_ arg result)}
      (! return {result}) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  type t_Option_refmut_T = None'0 | Some'0 (MutBorrow.t t_T)
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  predicate inv_Option_refmut_T (_1: t_Option_refmut_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_refmut_T [inv_Option_refmut_T x]. inv_Option_refmut_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_refmut_T f0
        end
  
  let rec as_mut_T (self_: MutBorrow.t t_Option_T) (return (x: t_Option_refmut_T)) =
    {[@stop_split] [@expl:as_mut 'self_' type invariant] inv_refmut_Option_T self_}
    any
    [ return (result: t_Option_refmut_T) ->
    {[@stop_split] [@expl:as_mut_T ensures] ([@stop_split] [@expl:as_mut result type invariant] inv_Option_refmut_T result)
      /\ ([@stop_split] [@expl:as_mut ensures #0] self_.current = None -> result = None'0 /\ self_.final = None)
      /\ ([@stop_split] [@expl:as_mut ensures #1] self_.current = None
      \/ (exists r: MutBorrow.t t_T. result = Some'0 r
        /\ self_.current = Some (r.current) /\ self_.final = Some (r.final)))}
      (! return {result}) ]
  
  let rec unwrap_refmut_T (self_: t_Option_refmut_T) (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:unwrap_refmut_T requires] ([@stop_split] [@expl:unwrap 'self_' type invariant] inv_Option_refmut_T self_)
    /\ ([@stop_split] [@expl:unwrap requires] self_ <> None'0)}
    any
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:unwrap_refmut_T ensures] ([@stop_split] [@expl:unwrap result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:unwrap ensures] Some'0 result = self_)}
      (! return {result}) ]
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_get_or_insert_with_body_T (self_: MutBorrow.t t_Option_T) (f: t_F)
    (return (x: MutBorrow.t t_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_with_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_with_body 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_with_body 'f' type invariant] inv_F f)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_with_body requires] self_.current = None
    -> precondition_F f ())}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb4) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_F f} any) ]
      | s1 = -{resolve_F f}- s2
      | s2 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            MutBorrow.borrow_final <t_T> {r0} {MutBorrow.inherit_id (MutBorrow.get_id self_) 0}
              (fun (_bor: MutBorrow.t t_T) ->
                [ &t <- _bor ] -{inv_T _bor.final}-
                [ &self_ <- { self_ with current = Some _bor.final } ] s3)
            [ _ck -> (! {[@expl:type invariant] inv_T r0} any) ])
      | s3 = MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_10 <- _bor ] -{inv_T _bor.final}-
            [ &t <- { t with current = _bor.final } ] s4) [ _ck -> (! {[@expl:type invariant] inv_T t.current} any) ]
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_T t} any) ]
      | s5 = -{resolve_refmut_T t}- s6
      | s6 = bb12 ]
    | bb4 = s0
      [ s0 = call_once_F {f} {_16} (fun (_x: t_T) -> [ &_14 <- _x ] s1)
      | s1 = [ &_13 <- Some _14 ] s2
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s3 = -{resolve_Option_T self_.current}- s4
      | s4 = [ &self_ <- { self_ with current = _13 } ] s5
      | s5 = MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_bor: MutBorrow.t t_Option_T) ->
            [ &_19 <- _bor ] -{inv_Option_T _bor.final}-
            [ &self_ <- { self_ with current = _bor.final } ] s6)
        [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s6 = as_mut_T {_19} (fun (_x: t_Option_refmut_T) -> [ &_18 <- _x ] s7)
      | s7 = unwrap_refmut_T {_18} (fun (_x: MutBorrow.t t_T) -> [ &_17 <- _x ] s8)
      | s8 = MutBorrow.borrow_final <t_T> {_17.current} {MutBorrow.get_id _17}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_12 <- _bor ] -{inv_T _bor.final}-
            [ &_17 <- { _17 with current = _bor.final } ] s9)
        [ _ck -> (! {[@expl:type invariant] inv_T _17.current} any) ]
      | s9 = s10 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _17} any) ]
      | s10 = -{resolve_refmut_T _17}- s11
      | s11 = MutBorrow.borrow_final <t_T> {_12.current} {MutBorrow.get_id _12}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_10 <- _bor ] -{inv_T _bor.final}-
            [ &_12 <- { _12 with current = _bor.final } ] s12)
        [ _ck -> (! {[@expl:type invariant] inv_T _12.current} any) ]
      | s12 = s13 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _12} any) ]
      | s13 = -{resolve_refmut_T _12}- s14
      | s14 = bb12 ]
    | bb12 = s0
      [ s0 = MutBorrow.borrow_final <t_T> {_10.current} {MutBorrow.get_id _10}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_3 <- _bor ] -{inv_T _bor.final}-
            [ &_10 <- { _10 with current = _bor.final } ] s1)
        [ _ck -> (! {[@expl:type invariant] inv_T _10.current} any) ]
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _10} any) ]
      | s2 = -{resolve_refmut_T _10}- s3
      | s3 = MutBorrow.borrow_final <t_T> {_3.current} {MutBorrow.get_id _3}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_ret <- _bor ] -{inv_T _bor.final}-
            [ &_3 <- { _3 with current = _bor.final } ] s4) [ _ck -> (! {[@expl:type invariant] inv_T _3.current} any) ]
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_T _3} any) ]
      | s5 = -{resolve_refmut_T _3}- s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s7 = -{resolve_refmut_Option_T self_}- s8
      | s8 = return {_ret} ] ]
    [ & _ret: MutBorrow.t t_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & f: t_F = f
    | & _3: MutBorrow.t t_T = Any.any_l ()
    | & _10: MutBorrow.t t_T = Any.any_l ()
    | & _12: MutBorrow.t t_T = Any.any_l ()
    | & _13: t_Option_T = Any.any_l ()
    | & _14: t_T = Any.any_l ()
    | & _16: () = Any.any_l ()
    | & _17: MutBorrow.t t_T = Any.any_l ()
    | & _18: t_Option_refmut_T = Any.any_l ()
    | & _19: MutBorrow.t t_Option_T = Any.any_l ()
    | & t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: MutBorrow.t t_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_with_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_with_body result type invariant] inv_refmut_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_get_or_insert_with_body ensures] match self_.current with
        | None -> postcondition_once_F f () result.current /\ self_.final = Some (result.final)
        | Some _ -> self_.current = Some (result.current) /\ self_.final = Some (result.final)
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_take_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  let rec replace_Option_T (dest: MutBorrow.t t_Option_T) (src: t_Option_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:replace_Option_T requires] ([@stop_split] [@expl:replace 'dest' type invariant] inv_refmut_Option_T dest)
    /\ ([@stop_split] [@expl:replace 'src' type invariant] inv_Option_T src)}
    any
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:replace_Option_T ensures] ([@stop_split] [@expl:replace result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:replace ensures #0] dest.final = src)
      /\ ([@stop_split] [@expl:replace ensures #1] result = dest.current)}
      (! return {result}) ]
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_take_body_T (self_: MutBorrow.t t_Option_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_body 'self_' type invariant] inv_refmut_Option_T self_}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_5 <- None ] s1
      | s1 = MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_bor: MutBorrow.t t_Option_T) ->
            [ &_4 <- _bor ] -{inv_Option_T _bor.final}-
            [ &self_ <- { self_ with current = _bor.final } ] s2)
        [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s2 = replace_Option_T {_4} {_5} (fun (_x: t_Option_T) -> [ &_ret <- _x ] s3)
      | s3 = s4 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s4 = -{resolve_refmut_Option_T self_}- s5
      | s5 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & _4: MutBorrow.t t_Option_T = Any.any_l ()
    | & _5: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_body ensures] result = self_.current
      /\ self_.final = None)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_take_if_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  type t_P
  
  predicate inv_P (_1: t_P)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate inv_tup1_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = inv_refmut_T _1
  
  meta "rewrite_def" predicate inv_tup1_refmut_T
  
  predicate precondition_P (self: t_P) (args: MutBorrow.t t_T)
  
  predicate postcondition_once_P (self: t_P) (args: MutBorrow.t t_T) (result: bool)
  
  let rec call_once_P (self_: t_P) (arg: MutBorrow.t t_T) (return (x: bool)) =
    {[@stop_split] [@expl:call_once_P requires] ([@stop_split] [@expl:call_once 'self_' type invariant] inv_P self_)
    /\ ([@stop_split] [@expl:call_once 'arg' type invariant] inv_tup1_refmut_T arg)
    /\ ([@stop_split] [@expl:call_once requires] precondition_P self_ arg)}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:call_once ensures] postcondition_once_P self_ arg result}
      (! return {result}) ]
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  let rec take_T (self_: MutBorrow.t t_Option_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:take 'self_' type invariant] inv_refmut_Option_T self_}
    any
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:take_T ensures] ([@stop_split] [@expl:take result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:take ensures] result = self_.current /\ self_.final = None)}
      (! return {result}) ]
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  predicate resolve_P (_1: t_P)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_take_if_body_T (self_: MutBorrow.t t_Option_T) (predicate': t_P)
    (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_if_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_if_body 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_if_body 'predicate' type invariant] inv_P predicate')
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_if_body requires] match self_.current with
      | None -> true
      | Some t -> forall b: MutBorrow.t t_T. inv_refmut_T b /\ b.current = t -> precondition_P predicate' b
      end)}
    (! bb0
    [ bb0 = any [ br0 -> {self_.current = None} (! bb2) | br1 (x0: t_T) -> {self_.current = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_.current}
          (fun (r0: t_T) ->
            MutBorrow.borrow_mut <t_T> {r0}
              (fun (_bor: MutBorrow.t t_T) ->
                [ &t <- _bor ] -{inv_T _bor.final}-
                [ &self_ <- { self_ with current = Some _bor.final } ] s1)
            [ _ck -> (! {[@expl:type invariant] inv_T r0} any) ])
      | s1 = MutBorrow.borrow_final <t_T> {t.current} {MutBorrow.get_id t}
          (fun (_bor: MutBorrow.t t_T) ->
            [ &_14 <- _bor ] -{inv_T _bor.final}-
            [ &t <- { t with current = _bor.final } ] s2) [ _ck -> (! {[@expl:type invariant] inv_T t.current} any) ]
      | s2 = [ &_13 <- _14 ] s3
      | s3 = call_once_P {predicate'} {_13} (fun (_x: bool) -> [ &_11 <- _x ] s4)
      | s4 = s5 [ _ck -> (! {[@expl:type invariant] inv_refmut_T t} any) ]
      | s5 = -{resolve_refmut_T t}- s6
      | s6 = any [ br0 -> {_11 = false} (! bb8) | br1 -> {_11} (! bb6) ] ]
    | bb6 = s0
      [ s0 = MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_bor: MutBorrow.t t_Option_T) ->
            [ &_15 <- _bor ] -{inv_Option_T _bor.final}-
            [ &self_ <- { self_ with current = _bor.final } ] s1)
        [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s1 = take_T {_15} (fun (_x: t_Option_T) -> [ &_ret <- _x ] s2)
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s3 = -{resolve_refmut_Option_T self_}- s4
      | s4 = return {_ret} ]
    | bb8 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s1 = -{resolve_refmut_Option_T self_}- s2
      | s2 = [ &_ret <- None ] s3
      | s3 = return {_ret} ]
    | bb2 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_P predicate'} any) ]
      | s1 = -{resolve_P predicate'}- s2
      | s2 = s3 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s3 = -{resolve_refmut_Option_T self_}- s4
      | s4 = [ &_ret <- None ] s5
      | s5 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & predicate': t_P = predicate'
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _11: bool = Any.any_l ()
    | & _13: MutBorrow.t t_T = Any.any_l ()
    | & _14: MutBorrow.t t_T = Any.any_l ()
    | & _15: MutBorrow.t t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_if_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_if_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_take_if_body ensures] match self_.current with
        | None -> result = None /\ self_.final = None
        | Some cur -> exists b: MutBorrow.t t_T, res: bool. inv_refmut_T b
          /\ cur = b.current
          /\ postcondition_once_P predicate' b res
          /\ (if res then
            self_.final = None /\ result = Some (b.final)
          else
            self_.final = Some (b.final) /\ result = None
          )
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_replace_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate invariant_refmut_Option_T [@inline:trivial] (self: MutBorrow.t t_Option_T) =
    inv_Option_T self.current /\ inv_Option_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Option_T
  
  predicate inv_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = invariant_refmut_Option_T _1
  
  meta "rewrite_def" predicate inv_refmut_Option_T
  
  let rec replace_Option_T (dest: MutBorrow.t t_Option_T) (src: t_Option_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:replace_Option_T requires] ([@stop_split] [@expl:replace 'dest' type invariant] inv_refmut_Option_T dest)
    /\ ([@stop_split] [@expl:replace 'src' type invariant] inv_Option_T src)}
    any
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:replace_Option_T ensures] ([@stop_split] [@expl:replace result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:replace ensures #0] dest.final = src)
      /\ ([@stop_split] [@expl:replace ensures #1] result = dest.current)}
      (! return {result}) ]
  
  predicate resolve_refmut_Option_T [@inline:trivial] (_1: MutBorrow.t t_Option_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_Option_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_replace_body_T (self_: MutBorrow.t t_Option_T) (value: t_T)
    (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_replace_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_replace_body 'self_' type invariant] inv_refmut_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_replace_body 'value' type invariant] inv_T value)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_7 <- Some value ] s1
      | s1 = MutBorrow.borrow_final <t_Option_T> {self_.current} {MutBorrow.get_id self_}
          (fun (_bor: MutBorrow.t t_Option_T) ->
            [ &_6 <- _bor ] -{inv_Option_T _bor.final}-
            [ &self_ <- { self_ with current = _bor.final } ] s2)
        [ _ck -> (! {[@expl:type invariant] inv_Option_T self_.current} any) ]
      | s2 = replace_Option_T {_6} {_7} (fun (_x: t_Option_T) -> [ &_ret <- _x ] s3)
      | s3 = s4 [ _ck -> (! {[@expl:type invariant] inv_refmut_Option_T self_} any) ]
      | s4 = -{resolve_refmut_Option_T self_}- s5
      | s5 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: MutBorrow.t t_Option_T = self_
    | & value: t_T = value
    | & _6: MutBorrow.t t_Option_T = Any.any_l ()
    | & _7: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_replace_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_replace_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_replace_body ensures] result = self_.current
      /\ self_.final = Some value)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_T_zip_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_U
  
  type t_Option_U = None'0 | Some'0 t_U
  
  type tup2_Option_T_Option_U = { f0: t_Option_T; f1: t_Option_U }
  
  predicate inv_U (_1: t_U)
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_U f0'0
        end
  
  predicate resolve_U (_1: t_U)
  
  predicate resolve_Option_U (_1: t_Option_U)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_U [resolve_Option_U x]. resolve_Option_U x
      = match x with
        | None'0 -> true
        | Some'0 x0 -> resolve_U x0
        end
  
  predicate inv_T (_1: t_T)
  
  predicate resolve_T (_1: t_T)
  
  type tup2_T_U = { f0'0: t_T; f1'0: t_U }
  
  type t_Option_tup2_T_U = None'1 | Some'1 tup2_T_U
  
  let rec elim_Some (_x: t_Option_T) (return (f0'1: t_T)) = any
    [ _k (f0'1: t_T) -> {Some f0'1 = _x} (! return {f0'1})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  let rec elim_Some'0 (_x: t_Option_U) (return (f0'1: t_U)) = any
    [ _k (f0'1: t_U) -> {Some'0 f0'1 = _x} (! return {f0'1})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some'0 _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0'1 -> inv_T f0'1
        end
  
  predicate inv_tup2_T_U [@inline:trivial] (_1: tup2_T_U) = inv_T _1.f0'0 /\ inv_U _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_T_U
  
  predicate inv_Option_tup2_T_U (_1: t_Option_tup2_T_U)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_tup2_T_U [inv_Option_tup2_T_U x]. inv_Option_tup2_T_U x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_tup2_T_U f0'1
        end
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom'0 [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_T_zip_body_T (self_: t_Option_T) (other: t_Option_U)
    (return (x: t_Option_tup2_T_U)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_zip_body_T requires] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_zip_body 'self_' type invariant] inv_Option_T self_)
    /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_zip_body 'other' type invariant] inv_Option_U other)}
    (! bb0
    [ bb0 = s0
      [ s0 = [ &_6 <- { f0 = self_; f1 = other } ] s1
      | s1 = any [ br0 -> {_6.f0 = None} (! bb25) | br1 (x0: t_T) -> {_6.f0 = Some x0} (! bb4) ] ]
    | bb25 = s0
      [ s0 = s1 [ _ck -> (! {[@expl:type invariant] inv_Option_U _6.f1} any) ]
      | s1 = -{resolve_Option_U _6.f1}- s2
      | s2 = s3
        [ _ck -> (! {[@expl:type invariant] match _6 with
            | {f0 = Some x} -> inv_T x
            | _ -> true
            end}
          any) ]
      | s3 = -{match _6 with
          | {f0 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    | bb4 = any [ br0 -> {_6.f1 = None'0} (! bb26) | br1 (x0: t_U) -> {_6.f1 = Some'0 x0} (! bb6) ]
    | bb26 = s0
      [ s0 = s1
        [ _ck -> (! {[@expl:type invariant] match _6 with
            | {f1 = Some'0 x} -> inv_U x
            | _ -> true
            end}
          any) ]
      | s1 = -{match _6 with
          | {f1 = Some'0 x} -> resolve_U x
          | _ -> true
          end}-
        s2
      | s2 = s3
        [ _ck -> (! {[@expl:type invariant] match _6 with
            | {f0 = Some x} -> inv_T x
            | _ -> true
            end}
          any) ]
      | s3 = -{match _6 with
          | {f0 = Some x} -> resolve_T x
          | _ -> true
          end}-
        s4
      | s4 = bb3 ]
    | bb3 = s0 [ s0 = [ &_ret <- None'1 ] s1 | s1 = return {_ret} ]
    | bb6 = s0
      [ s0 = elim_Some {_6.f0} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = elim_Some'0 {_6.f1} (fun (r0: t_U) -> [ &u <- r0 ] s2)
      | s2 = [ &_13 <- { f0'0 = t; f1'0 = u } ] s3
      | s3 = [ &_ret <- Some'1 _13 ] s4
      | s4 = return {_ret} ] ]
    [ & _ret: t_Option_tup2_T_U = Any.any_l ()
    | & self_: t_Option_T = self_
    | & other: t_Option_U = other
    | & _6: tup2_Option_T_Option_U = Any.any_l ()
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _13: tup2_T_U = Any.any_l () ])
    [ return (result: t_Option_tup2_T_U) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_T_zip_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_zip_body result type invariant] inv_Option_tup2_T_U result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_T_zip_body ensures] match { f0 = self_;
                                                                                            f1 = other } with
        | {f0 = None} -> result = None'1 /\ resolve_Option_U other
        | {f1 = None'0} -> result = None'1 /\ resolve_Option_T self_
        | {f0 = Some t; f1 = Some'0 u} -> result = Some'1 { f0'0 = t; f1'0 = u }
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_U_Option_tuple2_T_U_unzip_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  let rec elim_Some (_x: t_Option_tup2_T_U) (return (f0'0: tup2_T_U)) = any
    [ _k (f0'0: tup2_T_U) -> {Some f0'0 = _x} (! return {f0'0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_U (_1: t_U)
  
  predicate inv_tup2_T_U [@inline:trivial] (_1: tup2_T_U) = inv_T _1.f0 /\ inv_U _1.f1
  
  meta "rewrite_def" predicate inv_tup2_T_U
  
  predicate inv_Option_tup2_T_U (_1: t_Option_tup2_T_U)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_tup2_T_U [inv_Option_tup2_T_U x]. inv_Option_tup2_T_U x
      = match x with
        | None -> true
        | Some f0'1 -> inv_tup2_T_U f0'1
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0'1 -> inv_T f0'1
        end
  
  predicate inv_Option_U (_1: t_Option_U)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_U [inv_Option_U x]. inv_Option_U x
      = match x with
        | None'1 -> true
        | Some'1 f0'1 -> inv_U f0'1
        end
  
  predicate inv_tup2_Option_T_Option_U [@inline:trivial] (_1: tup2_Option_T_Option_U) =
    inv_Option_T _1.f0'0 /\ inv_Option_U _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_Option_T_Option_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_U_Option__tuple2_T_U_unzip_body_T (self_: t_Option_tup2_T_U)
    (return (x: tup2_Option_T_Option_U)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_U_Option__tuple2_T_U_unzip_body 'self_' type invariant] inv_Option_tup2_T_U self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb3) | br1 (x0: tup2_T_U) -> {self_ = Some x0} (! bb4) ]
    | bb4 = s0
      [ s0 = elim_Some {self_} (fun (r0: tup2_T_U) -> [ &t <- r0.f0 ] s1)
      | s1 = elim_Some {self_} (fun (r0: tup2_T_U) -> [ &u <- r0.f1 ] s2)
      | s2 = [ &_7 <- Some'0 t ] s3
      | s3 = [ &_9 <- Some'1 u ] s4
      | s4 = [ &_ret <- { f0'0 = _7; f1'0 = _9 } ] s5
      | s5 = return {_ret} ]
    | bb3 = s0
      [ s0 = [ &_11 <- None'0 ] s1
      | s1 = [ &_12 <- None'1 ] s2
      | s2 = [ &_ret <- { f0'0 = _11; f1'0 = _12 } ] s3
      | s3 = return {_ret} ] ]
    [ & _ret: tup2_Option_T_Option_U = Any.any_l ()
    | & self_: t_Option_tup2_T_U = self_
    | & t: t_T = Any.any_l ()
    | & u: t_U = Any.any_l ()
    | & _7: t_Option_T = Any.any_l ()
    | & _9: t_Option_U = Any.any_l ()
    | & _11: t_Option_T = Any.any_l ()
    | & _12: t_Option_U = Any.any_l () ])
    [ return (result: tup2_Option_T_Option_U) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_U_Option__tuple2_T_U_unzip_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_U_Option__tuple2_T_U_unzip_body result type invariant] inv_tup2_Option_T_Option_U result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_U_Option__tuple2_T_U_unzip_body ensures] match self_ with
        | None -> result = { f0'0 = None'0; f1'0 = None'1 }
        | Some {f0 = t; f1 = u} -> result = { f0'0 = Some'0 t; f1'0 = Some'1 u }
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_ref_T_copied_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_ref_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option__ref_T_copied_body_T (self_: t_Option_ref_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_copied_body 'self_' type invariant] inv_Option_ref_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1) | s1 = [ &_ret <- Some'0 t ] s2 | s2 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- None'0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l () | & self_: t_Option_ref_T = self_ | & t: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_copied_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_copied_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_copied_body ensures] match self_ with
        | None -> result = None'0
        | Some s -> result = Some'0 s
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_ref_T_cloned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  let rec elim_Some (_x: t_Option_ref_T) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@stop_split] [@expl:clone requires] precondition_clone () self_}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:clone ensures] postcondition_once_clone () self_ result}
      (! return {result}) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  type tup2_Option_ref_T_Option_T = { f0: t_Option_ref_T; f1: t_Option_T }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option__ref_T_cloned_body_T (self_: t_Option_ref_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_cloned_body 'self_' type invariant] inv_Option_ref_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_T) -> [ &t <- r0 ] s1)
      | s1 = clone_T {t} (fun (_x: t_T) -> [ &_6 <- _x ] s2)
      | s2 = [ &_ret <- Some'0 _6 ] s3
      | s3 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- None'0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_ref_T = self_
    | & t: t_T = Any.any_l ()
    | & _6: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_cloned_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_cloned_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option__ref_T_cloned_body ensures] match { f0 = self_;
                                                                                                    f1 = result } with
        | {f0 = None; f1 = None'0} -> true
        | {f0 = Some s; f1 = Some'0 r} -> postcondition_clone () s r
        | _ -> false
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_refmut_T_copied_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_refmut_T = None | Some (MutBorrow.t t_T)
  
  let rec elim_Some (_x: t_Option_refmut_T) (return (f0: MutBorrow.t t_T)) = any
    [ _k (f0: MutBorrow.t t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_Option_refmut_T (_1: t_Option_refmut_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_refmut_T [inv_Option_refmut_T x]. inv_Option_refmut_T x
      = match x with
        | None -> true
        | Some f0 -> inv_refmut_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option__refmut_T_copied_body_T (self_: t_Option_refmut_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_copied_body 'self_' type invariant] inv_Option_refmut_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: MutBorrow.t t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: MutBorrow.t t_T) -> [ &t <- r0 ] s1)
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_refmut_T t} any) ]
      | s2 = -{resolve_refmut_T t}- s3
      | s3 = [ &_ret <- Some'0 (t.current) ] s4
      | s4 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- None'0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l () | & self_: t_Option_refmut_T = self_ | & t: MutBorrow.t t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_copied_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_copied_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_copied_body ensures] match self_ with
        | None -> result = None'0
        | Some s -> result = Some'0 (s.current) /\ s.final = s.current
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_refmut_T_cloned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_refmut_T = None | Some (MutBorrow.t t_T)
  
  let rec elim_Some (_x: t_Option_refmut_T) (return (f0: MutBorrow.t t_T)) = any
    [ _k (f0: MutBorrow.t t_T) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate resolve_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_T
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate precondition_clone (self: ()) (args: t_T)
  
  axiom precondition_fndef: forall args: t_T [precondition_clone () args]. (let self_ = args in inv_ref_T self_)
      -> precondition_clone () args
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  let rec clone_T (self_: t_T) (return (x: t_T)) = {[@stop_split] [@expl:clone requires] precondition_clone () self_}
    any
    [ return (result: t_T) -> {[@stop_split] [@expl:clone ensures] postcondition_once_clone () self_ result}
      (! return {result}) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  predicate inv_Option_refmut_T (_1: t_Option_refmut_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_refmut_T [inv_Option_refmut_T x]. inv_Option_refmut_T x
      = match x with
        | None -> true
        | Some f0 -> inv_refmut_T f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  type tup2_Option_refmut_T_Option_T = { f0: t_Option_refmut_T; f1: t_Option_T }
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option__refmut_T_cloned_body_T (self_: t_Option_refmut_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_cloned_body 'self_' type invariant] inv_Option_refmut_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb4) | br1 (x0: MutBorrow.t t_T) -> {self_ = Some x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: MutBorrow.t t_T) -> [ &t <- r0 ] s1)
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_refmut_T t} any) ]
      | s2 = -{resolve_refmut_T t}- s3
      | s3 = clone_T {t.current} (fun (_x: t_T) -> [ &_6 <- _x ] s4)
      | s4 = [ &_ret <- Some'0 _6 ] s5
      | s5 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- None'0 ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l ()
    | & self_: t_Option_refmut_T = self_
    | & t: MutBorrow.t t_T = Any.any_l ()
    | & _6: t_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_cloned_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_cloned_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option__refmut_T_cloned_body ensures] match { f0 = self_;
                                                                                                       f1 = result } with
        | {f0 = None; f1 = None'0} -> true
        | {f0 = Some s; f1 = Some'0 r} -> postcondition_clone () s.current r /\ s.final = s.current
        | _ -> false
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_E_Option_Result_T_E_transpose_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_E
  
  type t_Result_T_E = Ok t_T | Err t_E
  
  type t_Option_Result_T_E = None | Some t_Result_T_E
  
  let rec elim_Some (_x: t_Option_Result_T_E) (return (f0: t_Result_T_E)) = any
    [ _k (f0: t_Result_T_E) -> {Some f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some _ -> true
        | _ -> false
        end}
      any) ]
  
  let rec elim_Err (_x: t_Result_T_E) (return (f0: t_E)) = any
    [ _k (f0: t_E) -> {Err f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Err] match _x with
        | Err _ -> true
        | _ -> false
        end}
      any) ]
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Result_Option_T_E = Ok'0 t_Option_T | Err'0 t_E
  
  let rec elim_Ok (_x: t_Result_T_E) (return (f0: t_T)) = any
    [ _k (f0: t_T) -> {Ok f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Ok] match _x with
        | Ok _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_E (_1: t_E)
  
  predicate inv_Result_T_E (_1: t_Result_T_E)
  
  axiom inv_axiom [@rewrite]: forall x: t_Result_T_E [inv_Result_T_E x]. inv_Result_T_E x
      = match x with
        | Ok f0 -> inv_T f0
        | Err f0 -> inv_E f0
        end
  
  predicate inv_Option_Result_T_E (_1: t_Option_Result_T_E)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Result_T_E [inv_Option_Result_T_E x]. inv_Option_Result_T_E x
      = match x with
        | None -> true
        | Some f0 -> inv_Result_T_E f0
        end
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'1 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_T f0
        end
  
  predicate inv_Result_Option_T_E (_1: t_Result_Option_T_E)
  
  axiom inv_axiom'2 [@rewrite]: forall x: t_Result_Option_T_E [inv_Result_Option_T_E x]. inv_Result_Option_T_E x
      = match x with
        | Ok'0 f0 -> inv_Option_T f0
        | Err'0 f0 -> inv_E f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_E_Option_Result_T_E_transpose_body_T (self_: t_Option_Result_T_E)
    (return (x: t_Result_Option_T_E)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_E_Option_Result_T_E_transpose_body 'self_' type invariant] inv_Option_Result_T_E self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None} (! bb7) | br1 (x0: t_Result_T_E) -> {self_ = Some x0} (! bb3) ]
    | bb3 = elim_Some {self_}
        (fun (r0: t_Result_T_E) ->
          any [ br0 (x0: t_T) -> {r0 = Ok x0} (! bb6) | br1 (x0: t_E) -> {r0 = Err x0} (! bb5) ])
    | bb5 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_Result_T_E) -> elim_Err {r0} (fun (r0'0: t_E) -> [ &err <- r0'0 ] s1))
      | s1 = [ &_ret <- Err'0 err ] s2
      | s2 = return {_ret} ]
    | bb6 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_Result_T_E) -> elim_Ok {r0} (fun (r0'0: t_T) -> [ &ok <- r0'0 ] s1))
      | s1 = [ &_8 <- Some'0 ok ] s2
      | s2 = [ &_ret <- Ok'0 _8 ] s3
      | s3 = return {_ret} ]
    | bb7 = s0 [ s0 = [ &_6 <- None'0 ] s1 | s1 = [ &_ret <- Ok'0 _6 ] s2 | s2 = return {_ret} ] ]
    [ & _ret: t_Result_Option_T_E = Any.any_l ()
    | & self_: t_Option_Result_T_E = self_
    | & _6: t_Option_T = Any.any_l ()
    | & ok: t_T = Any.any_l ()
    | & _8: t_Option_T = Any.any_l ()
    | & err: t_E = Any.any_l () ])
    [ return (result: t_Result_Option_T_E) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_E_Option_Result_T_E_transpose_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_E_Option_Result_T_E_transpose_body result type invariant] inv_Result_Option_T_E result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_E_Option_Result_T_E_transpose_body ensures] match self_ with
        | None -> result = Ok'0 (None'0)
        | Some (Ok ok) -> result = Ok'0 (Some'0 ok)
        | Some (Err err) -> result = Err'0 err
        end)}
      (! return {result}) ]
end
module M_std__option__extern_spec_core_option_T_Option_Option_T_flatten_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  let rec elim_Some (_x: t_Option_Option_T) (return (f0: t_Option_T)) = any
    [ _k (f0: t_Option_T) -> {Some'0 f0 = _x} (! return {f0})
    | _chk -> (! {[@expl:elim Some] match _x with
        | Some'0 _ -> true
        | _ -> false
        end}
      any) ]
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  predicate inv_Option_Option_T (_1: t_Option_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_Option_T [inv_Option_Option_T x]. inv_Option_Option_T x
      = match x with
        | None'0 -> true
        | Some'0 f0 -> inv_Option_T f0
        end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_core_option_T_Option_Option_T_flatten_body_T (self_: t_Option_Option_T) (return (x: t_Option_T)) =
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_Option_T_flatten_body 'self_' type invariant] inv_Option_Option_T self_}
    (! bb0
    [ bb0 = any [ br0 -> {self_ = None'0} (! bb4) | br1 (x0: t_Option_T) -> {self_ = Some'0 x0} (! bb3) ]
    | bb3 = s0
      [ s0 = elim_Some {self_} (fun (r0: t_Option_T) -> [ &opt <- r0 ] s1)
      | s1 = [ &_ret <- opt ] s2
      | s2 = return {_ret} ]
    | bb4 = s0 [ s0 = [ &_ret <- None ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Option_T = Any.any_l () | & self_: t_Option_Option_T = self_ | & opt: t_Option_T = Any.any_l () ])
    [ return (result: t_Option_T) ->
    {[@stop_split] [@expl:extern_spec_core_option_T_Option_Option_T_flatten_body_T ensures] ([@stop_split] [@expl:extern_spec_core_option_T_Option_Option_T_flatten_body result type invariant] inv_Option_T result)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_Option_T_flatten_body ensures #0] self_ = None'0
        -> result = None)
      /\ ([@stop_split] [@expl:extern_spec_core_option_T_Option_Option_T_flatten_body ensures #1] self_ = None'0
      \/ self_ = Some'0 result)}
      (! return {result}) ]
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_le_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate le_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_le_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_le_log_Option_T: [@stop_split] [@expl:cmp_le_log ensures] le_log_Option_T x y
    = (cmp_log_Option_T x y <> Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_lt_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate lt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_lt_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_lt_log_Option_T: [@stop_split] [@expl:cmp_lt_log ensures] lt_log_Option_T x y
    = (cmp_log_Option_T x y = Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_ge_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate ge_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_ge_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_ge_log_Option_T: [@stop_split] [@expl:cmp_ge_log ensures] ge_log_Option_T x y
    = (cmp_log_Option_T x y <> Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_gt_log (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate gt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function cmp_gt_log_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_cmp_gt_log_Option_T: [@stop_split] [@expl:cmp_gt_log ensures] gt_log_Option_T x y
    = (cmp_log_Option_T x y = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__refl (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  function refl_Option_T (x: t_Option_T) : ()
  
  goal vc_refl_Option_T: [@stop_split] [@expl:refl ensures] cmp_log_Option_T x x = Equal
end
module M_std__option__impl_OrdLogic_for_Option_T__trans (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  constant z : t_Option_T
  
  constant o : t_Ordering
  
  function trans_Option_T (x: t_Option_T) (y: t_Option_T) (z: t_Option_T) (o: t_Ordering) : ()
  
  goal vc_trans_Option_T: cmp_log_Option_T x y = o
    -> cmp_log_Option_T y z = o -> ([@stop_split] [@expl:trans ensures] cmp_log_Option_T x z = o)
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym1 (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function antisym1_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_antisym1_Option_T: cmp_log_Option_T x y = Less
    -> ([@stop_split] [@expl:antisym1 ensures] cmp_log_Option_T y x = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym2 (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function antisym2_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_antisym2_Option_T: cmp_log_Option_T x y = Greater
    -> ([@stop_split] [@expl:antisym2 ensures] cmp_log_Option_T y x = Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__eq_cmp (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant x : t_Option_T
  
  constant y : t_Option_T
  
  function eq_cmp_Option_T (x: t_Option_T) (y: t_Option_T) : ()
  
  goal vc_eq_cmp_Option_T: [@stop_split] [@expl:eq_cmp ensures] (x = y) = (cmp_log_Option_T x y = Equal)
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_refl (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T
  
  function produces_refl_IntoIter_T (self: t_IntoIter_T) : ()
  
  goal vc_produces_refl_IntoIter_T:
    [@stop_split] [@expl:produces_refl ensures] produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_trans (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T
  
  function produces_trans_IntoIter_T (a: t_IntoIter_T) (ab: Seq.seq t_T) (b: t_IntoIter_T) (bc: Seq.seq t_T) (c: t_IntoIter_T) : ()
  
  goal vc_produces_trans_IntoIter_T: produces_IntoIter_T a ab b
    -> produces_IntoIter_T b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T:
    [@stop_split] [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_refl (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_refmut_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_refmut_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut_T
  
  function produces_refl_IterMut_T (self: t_IterMut_T) : ()
  
  goal vc_produces_refl_IterMut_T:
    [@stop_split] [@expl:produces_refl ensures] produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_trans (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_refmut_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_refmut_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut_T
  
  constant ab : Seq.seq (MutBorrow.t t_T)
  
  constant b : t_IterMut_T
  
  constant bc : Seq.seq (MutBorrow.t t_T)
  
  constant c : t_IterMut_T
  
  function produces_trans_IterMut_T (a: t_IterMut_T) (ab: Seq.seq (MutBorrow.t t_T)) (b: t_IterMut_T) (bc: Seq.seq (MutBorrow.t t_T)) (c: t_IterMut_T) : ()
  
  goal vc_produces_trans_IterMut_T: produces_IterMut_T a ab b
    -> produces_IterMut_T b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_OptionExt_for_Option_T__unwrap_logic (* <std::option::Option<T> as std::option::OptionExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  predicate index_Mapping_T_bool [@inline:trivial] (self: Map.map t_T bool) (a: t_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_T_bool
  
  function such_that_T (p: Map.map t_T bool) : t_T
  
  axiom such_that_T_spec: forall p: Map.map t_T bool. (exists x: t_T. index_Mapping_T_bool p x)
      -> index_Mapping_T_bool p (such_that_T p)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Option_T
  
  function unwrap_Option_T (self: t_Option_T) : t_T
  
  goal vc_unwrap_Option_T: self <> None
    -> match self with
      | Some x -> true
      | None -> [@stop_split] [@expl:such_that requires] exists x: t_T. index_Mapping_T_bool (fun (__0: t_T) -> true) x
      end
end
module M_std__ptr__extern_spec_T_ptrconst_T_cast_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrconst_T_cast_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_6 <- Opaque.thin self_ ] s1 | s1 = [ &_ret <- _6 ] s2 | s2 = return {_ret} ] ]
    [ & _ret: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ | & _6: Opaque.ptr = Any.any_l () ])
    [ return (result: Opaque.ptr) -> {[@stop_split] [@expl:extern_spec_T__ptrconst_T_cast_body ensures] result
      = Opaque.thin self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrconst_T_is_aligned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use int.ComputerDivision
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  use int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_T : UInt64.t
  
  axiom align_of_T_spec: (0: UInt64.t) <> align_of_T
    /\ UInt64.bw_and align_of_T (UInt64.sub align_of_T (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_T_spec'0: ComputerDivision.mod size_of_T (UInt64.t'int align_of_T) = 0
  
  let rec align_of_T'0 (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:align_of ensures] result = align_of_T} (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  let rec is_aligned_to_T (self_: Opaque.ptr) (align: UInt64.t) (return (x: bool)) =
    {[@stop_split] [@expl:is_aligned_to requires] align <> (0: UInt64.t)
    /\ UInt64.bw_and align (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:is_aligned_to ensures] result = is_aligned_to_ptr_T self_ align}
      (! return {result}) ]
  
  predicate is_aligned_T [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_ptr_T ptr align_of_T
  
  meta "rewrite_def" predicate is_aligned_T
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrconst_T_is_aligned_body_T (self_: Opaque.ptr) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = align_of_T'0 (fun (_x: UInt64.t) -> [ &_7 <- _x ] s1)
      | s1 = is_aligned_to_T {self_} {_7} (fun (_x: bool) -> [ &_ret <- _x ] s2)
      | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self_: Opaque.ptr = self_ | & _7: UInt64.t = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_T__ptrconst_T_is_aligned_body ensures] result
      = is_aligned_ptr_T self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrconst_T_is_aligned_to_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64BW
  use creusot.prelude.Opaque
  use creusot.prelude.PtrBW
  use creusot.prelude.Any
  
  let rec is_power_of_two (self_: UInt64BW.t) (return (x: bool)) = any
    [ return (result: bool) -> {[@stop_split] [@expl:is_power_of_two ensures] result
      = (self_ <> (0: UInt64BW.t) /\ UInt64BW.bw_and self_ (UInt64BW.sub self_ (1: UInt64BW.t)) = (0: UInt64BW.t))}
      (! return {result}) ]
  
  let rec addr_T (self_: Opaque.ptr) (return (x: UInt64BW.t)) = any
    [ return (result: UInt64BW.t) -> {[@stop_split] [@expl:addr ensures] result = PtrBW.addr_logic_u64 self_}
      (! return {result}) ]
  
  type t_Arguments
  
  predicate inv_Arguments (_1: t_Arguments)
  
  let rec from_str (s: string) (return (x: t_Arguments)) = any
    [ return (result: t_Arguments) -> {[@stop_split] [@expl:from_str result type invariant] inv_Arguments result}
      (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64BW.t) =
    UInt64BW.bw_and (PtrBW.addr_logic_u64 self) (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrconst_T_is_aligned_to_body_T (self_: Opaque.ptr) (align: UInt64BW.t) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_T__ptrconst_T_is_aligned_to_body requires] align <> (0: UInt64BW.t)
    /\ UInt64BW.bw_and align (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = is_power_of_two {align} (fun (_x: bool) -> [ &_12 <- _x ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb3) | br1 -> {_12} (! bb2) ] ]
    | bb2 = s0
      [ s0 = addr_T {self_} (fun (_x: UInt64BW.t) -> [ &_19 <- _x ] s1)
      | s1 = UInt64BW.sub {align} {(1: UInt64BW.t)} (fun (_x: UInt64BW.t) -> [ &_21 <- _x ] s2)
      | s2 = [ &_18 <- UInt64BW.bw_and _19 _21 ] s3
      | s3 = [ &_ret <- _18 = (0: UInt64BW.t) ] s4
      | s4 = return {_ret} ]
    | bb3 = s0
      [ s0 = from_str {"is_aligned_to: align is not a power-of-two"} (fun (_x: t_Arguments) -> [ &_17 <- _x ] s1)
      | s1 = {false} any ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Opaque.ptr = self_
    | & align: UInt64BW.t = align
    | & _12: bool = Any.any_l ()
    | & _17: t_Arguments = Any.any_l ()
    | & _18: UInt64BW.t = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: UInt64BW.t = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_T__ptrconst_T_is_aligned_to_body ensures] result
      = is_aligned_to_ptr_T self_ align}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrmut_T_cast_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrmut_T_cast_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_6 <- Opaque.thin self_ ] s1 | s1 = [ &_ret <- _6 ] s2 | s2 = return {_ret} ] ]
    [ & _ret: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ | & _6: Opaque.ptr = Any.any_l () ])
    [ return (result: Opaque.ptr) -> {[@stop_split] [@expl:extern_spec_T__ptrmut_T_cast_body ensures] result
      = Opaque.thin self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrmut_T_is_aligned_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use int.ComputerDivision
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.prelude.Any
  use int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_T : UInt64.t
  
  axiom align_of_T_spec: (0: UInt64.t) <> align_of_T
    /\ UInt64.bw_and align_of_T (UInt64.sub align_of_T (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_T_spec'0: ComputerDivision.mod size_of_T (UInt64.t'int align_of_T) = 0
  
  let rec align_of_T'0 (return (x: UInt64.t)) = any
    [ return (result: UInt64.t) -> {[@stop_split] [@expl:align_of ensures] result = align_of_T} (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  let rec is_aligned_to_T (self_: Opaque.ptr) (align: UInt64.t) (return (x: bool)) =
    {[@stop_split] [@expl:is_aligned_to requires] align <> (0: UInt64.t)
    /\ UInt64.bw_and align (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)}
    any
    [ return (result: bool) -> {[@stop_split] [@expl:is_aligned_to ensures] result = is_aligned_to_ptr_T self_ align}
      (! return {result}) ]
  
  predicate is_aligned_to_ptr_T'0 (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  predicate is_aligned_T [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_ptr_T'0 ptr align_of_T
  
  meta "rewrite_def" predicate is_aligned_T
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrmut_T_is_aligned_body_T (self_: Opaque.ptr) (return (x: bool)) = (! bb0
    [ bb0 = s0
      [ s0 = align_of_T'0 (fun (_x: UInt64.t) -> [ &_7 <- _x ] s1)
      | s1 = is_aligned_to_T {self_} {_7} (fun (_x: bool) -> [ &_ret <- _x ] s2)
      | s2 = return {_ret} ] ]
    [ & _ret: bool = Any.any_l () | & self_: Opaque.ptr = self_ | & _7: UInt64.t = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_T__ptrmut_T_is_aligned_body ensures] result
      = is_aligned_ptr_T self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_ptrmut_T_is_aligned_to_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64BW
  use creusot.prelude.Opaque
  use creusot.prelude.PtrBW
  use creusot.prelude.Any
  
  let rec is_power_of_two (self_: UInt64BW.t) (return (x: bool)) = any
    [ return (result: bool) -> {[@stop_split] [@expl:is_power_of_two ensures] result
      = (self_ <> (0: UInt64BW.t) /\ UInt64BW.bw_and self_ (UInt64BW.sub self_ (1: UInt64BW.t)) = (0: UInt64BW.t))}
      (! return {result}) ]
  
  let rec addr_T (self_: Opaque.ptr) (return (x: UInt64BW.t)) = any
    [ return (result: UInt64BW.t) -> {[@stop_split] [@expl:addr ensures] result = PtrBW.addr_logic_u64 self_}
      (! return {result}) ]
  
  type t_Arguments
  
  predicate inv_Arguments (_1: t_Arguments)
  
  let rec from_str (s: string) (return (x: t_Arguments)) = any
    [ return (result: t_Arguments) -> {[@stop_split] [@expl:from_str result type invariant] inv_Arguments result}
      (! return {result}) ]
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64BW.t) =
    UInt64BW.bw_and (PtrBW.addr_logic_u64 self) (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T__ptrmut_T_is_aligned_to_body_T (self_: Opaque.ptr) (align: UInt64BW.t) (return (x: bool)) =
    {[@stop_split] [@expl:extern_spec_T__ptrmut_T_is_aligned_to_body requires] align <> (0: UInt64BW.t)
    /\ UInt64BW.bw_and align (UInt64BW.sub align (1: UInt64BW.t)) = (0: UInt64BW.t)}
    (! bb0
    [ bb0 = s0
      [ s0 = is_power_of_two {align} (fun (_x: bool) -> [ &_12 <- _x ] s1)
      | s1 = any [ br0 -> {_12 = false} (! bb3) | br1 -> {_12} (! bb2) ] ]
    | bb2 = s0
      [ s0 = addr_T {self_} (fun (_x: UInt64BW.t) -> [ &_19 <- _x ] s1)
      | s1 = UInt64BW.sub {align} {(1: UInt64BW.t)} (fun (_x: UInt64BW.t) -> [ &_21 <- _x ] s2)
      | s2 = [ &_18 <- UInt64BW.bw_and _19 _21 ] s3
      | s3 = [ &_ret <- _18 = (0: UInt64BW.t) ] s4
      | s4 = return {_ret} ]
    | bb3 = s0
      [ s0 = from_str {"is_aligned_to: align is not a power-of-two"} (fun (_x: t_Arguments) -> [ &_17 <- _x ] s1)
      | s1 = {false} any ] ]
    [ & _ret: bool = Any.any_l ()
    | & self_: Opaque.ptr = self_
    | & align: UInt64BW.t = align
    | & _12: bool = Any.any_l ()
    | & _17: t_Arguments = Any.any_l ()
    | & _18: UInt64BW.t = Any.any_l ()
    | & _19: UInt64BW.t = Any.any_l ()
    | & _21: UInt64BW.t = Any.any_l () ])
    [ return (result: bool) -> {[@stop_split] [@expl:extern_spec_T__ptrmut_T_is_aligned_to_body ensures] result
      = is_aligned_to_ptr_T self_ align}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_Clone_ptrmut_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone__ptrmut_T_clone_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ ])
    [ return (result: Opaque.ptr) -> {[@stop_split] [@expl:extern_spec_T_Clone__ptrmut_T_clone_body ensures] result
      = self_}
      (! return {result}) ]
end
module M_std__ptr__extern_spec_T_Clone_ptrconst_T_clone_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Any
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_Clone__ptrconst_T_clone_body_T (self_: Opaque.ptr) (return (x: Opaque.ptr)) = (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- self_ ] s1 | s1 = return {_ret} ] ]
    [ & _ret: Opaque.ptr = Any.any_l () | & self_: Opaque.ptr = self_ ])
    [ return (result: Opaque.ptr) -> {[@stop_split] [@expl:extern_spec_T_Clone__ptrconst_T_clone_body ensures] result
      = self_}
      (! return {result}) ]
end
module M_std__ptr__impl_Perm_ptr_T__new (* ghost::perm::Perm<*const T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use int.ComputerDivision
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_Perm_ptr_T
  
  type tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global = { f0: Opaque.ptr; f1: t_Perm_ptr_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ward_ptr_T (self: t_Perm_ptr_T) : Opaque.ptr
  
  predicate is_aligned_to_ptr_T (self: Opaque.ptr) (align: UInt64.t) =
    UInt64.bw_and (Ptr.addr_logic_u64 self) (UInt64.sub align (1: UInt64.t)) = (0: UInt64.t)
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant align_of_T : UInt64.t
  
  axiom align_of_T_spec: (0: UInt64.t) <> align_of_T
    /\ UInt64.bw_and align_of_T (UInt64.sub align_of_T (1: UInt64.t)) = (0: UInt64.t)
  
  axiom align_of_T_spec'0: ComputerDivision.mod size_of_T (UInt64.t'int align_of_T) = 0
  
  predicate is_aligned_T [@inline:trivial] (ptr: Opaque.ptr) = is_aligned_to_ptr_T ptr align_of_T
  
  meta "rewrite_def" predicate is_aligned_T
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  predicate ptr_is_aligned_opaque_T (self: t_Perm_ptr_T) = is_aligned_ptr_T (ward_ptr_T self)
  
  predicate metadata_matches_T [@inline:trivial] (_value: t_T) (_metadata: ()) = true
  
  meta "rewrite_def" predicate metadata_matches_T
  
  function val_ptr_T (self: t_Perm_ptr_T) : t_T
  
  function metadata_T (_1: Opaque.ptr) : ()
  
  function size_of_val_T [@inline:trivial] (val': t_T) : int = size_of_T
  
  meta "rewrite_def" function size_of_val_T
  
  axiom size_of_val_T_spec: forall val': t_T. 0 <= size_of_val_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Perm_ptr_T (self: t_Perm_ptr_T) =
    not is_null_ptr_T (ward_ptr_T self)
    /\ ptr_is_aligned_opaque_T self
    /\ metadata_matches_T (val_ptr_T self) (metadata_T (ward_ptr_T self))
    /\ size_of_val_T (val_ptr_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ward_ptr_T self)) + size_of_val_T (val_ptr_T self) <= UInt64.t'int const_MAX'0
    /\ inv_ref_T (val_ptr_T self)
  
  predicate inv_Perm_ptr_T (_1: t_Perm_ptr_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Perm_ptr_T [inv_Perm_ptr_T x]. inv_Perm_ptr_T x = invariant_Perm_ptr_T x
  
  predicate invariant_Box_Perm_ptr_T_Global (self: t_Perm_ptr_T) = inv_Perm_ptr_T self
  
  predicate inv_Box_Perm_ptr_T_Global [@inline:trivial] (_1: t_Perm_ptr_T) = invariant_Box_Perm_ptr_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_Perm_ptr_T_Global
  
  predicate invariant_Ghost_Box_Perm_ptr_T_Global [@inline:trivial] (self: t_Perm_ptr_T) =
    inv_Box_Perm_ptr_T_Global self
  
  meta "rewrite_def" predicate invariant_Ghost_Box_Perm_ptr_T_Global
  
  predicate inv_Ghost_Box_Perm_ptr_T_Global [@inline:trivial] (_1: t_Perm_ptr_T) =
    invariant_Ghost_Box_Perm_ptr_T_Global _1
  
  meta "rewrite_def" predicate inv_Ghost_Box_Perm_ptr_T_Global
  
  predicate inv_tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global [@inline:trivial] (_1: tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global) =
    inv_Ghost_Box_Perm_ptr_T_Global _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global
  
  let rec from_box_T (val': t_T) (return (x: tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global)) =
    {[@stop_split] [@expl:from_box 'val' type invariant] inv_Box_T_Global val'}
    any
    [ return (result: tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global) ->
    {[@stop_split] [@expl:from_box_T ensures] ([@stop_split] [@expl:from_box result type invariant] inv_tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global result)
      /\ ([@stop_split] [@expl:from_box ensures] ward_ptr_T result.f1 = result.f0 /\ val_ptr_T result.f1 = val')}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec new_T (v: t_T) (return (x: tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global)) =
    {[@stop_split] [@expl:new 'v' type invariant] inv_T v}
    (! bb0
    [ bb0 = s0
      [ s0 = from_box_T {v} (fun (_x: tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global) -> [ &_ret <- _x ] s1)
      | s1 = return {_ret} ] ] [ & _ret: tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global = Any.any_l () | & v: t_T = v ])
    [ return (result: tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global) ->
    {[@stop_split] [@expl:new_T ensures] ([@stop_split] [@expl:new result type invariant] inv_tup2_ptr_T_Ghost_Box_Perm_ptr_T_Global result)
      /\ ([@stop_split] [@expl:new ensures] ward_ptr_T result.f1 = result.f0 /\ val_ptr_T result.f1 = v)}
      (! return {result}) ]
end
module M_std__ptr__impl_Perm_ptr_T__drop (* ghost::perm::Perm<*const T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_Perm_ptr_T
  
  type t_T
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ward_ptr_T (self: t_Perm_ptr_T) : Opaque.ptr
  
  predicate is_aligned_T (ptr: Opaque.ptr)
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  predicate ptr_is_aligned_opaque_T (self: t_Perm_ptr_T) = is_aligned_ptr_T (ward_ptr_T self)
  
  type t_Metadata
  
  predicate metadata_matches_T (_value: t_T) (_metadata: t_Metadata)
  
  function val_ptr_T (self: t_Perm_ptr_T) : t_T
  
  function metadata_T (_1: Opaque.ptr) : t_Metadata
  
  function size_of_val_T (val': t_T) : int
  
  axiom size_of_val_T_spec: forall val': t_T. 0 <= size_of_val_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Perm_ptr_T (self: t_Perm_ptr_T) =
    not is_null_ptr_T (ward_ptr_T self)
    /\ ptr_is_aligned_opaque_T self
    /\ metadata_matches_T (val_ptr_T self) (metadata_T (ward_ptr_T self))
    /\ size_of_val_T (val_ptr_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ward_ptr_T self)) + size_of_val_T (val_ptr_T self) <= UInt64.t'int const_MAX'0
    /\ inv_ref_T (val_ptr_T self)
  
  predicate inv_Perm_ptr_T (_1: t_Perm_ptr_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Perm_ptr_T [inv_Perm_ptr_T x]. inv_Perm_ptr_T x = invariant_Perm_ptr_T x
  
  predicate invariant_Box_Perm_ptr_T_Global (self: t_Perm_ptr_T) = inv_Perm_ptr_T self
  
  predicate inv_Box_Perm_ptr_T_Global [@inline:trivial] (_1: t_Perm_ptr_T) = invariant_Box_Perm_ptr_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_Perm_ptr_T_Global
  
  predicate invariant_Ghost_Box_Perm_ptr_T_Global [@inline:trivial] (self: t_Perm_ptr_T) =
    inv_Box_Perm_ptr_T_Global self
  
  meta "rewrite_def" predicate invariant_Ghost_Box_Perm_ptr_T_Global
  
  predicate inv_Ghost_Box_Perm_ptr_T_Global [@inline:trivial] (_1: t_Perm_ptr_T) =
    invariant_Ghost_Box_Perm_ptr_T_Global _1
  
  meta "rewrite_def" predicate inv_Ghost_Box_Perm_ptr_T_Global
  
  predicate invariant_Box_T_Global (self: t_T) = inv_T self
  
  predicate inv_Box_T_Global [@inline:trivial] (_1: t_T) = invariant_Box_T_Global _1
  
  meta "rewrite_def" predicate inv_Box_T_Global
  
  let rec to_box_T (ptr: Opaque.ptr) (own: t_Perm_ptr_T) (return (x: t_T)) =
    {[@stop_split] [@expl:to_box_T requires] ([@stop_split] [@expl:to_box 'own' type invariant] inv_Ghost_Box_Perm_ptr_T_Global own)
    /\ ([@stop_split] [@expl:to_box requires] ptr = ward_ptr_T own)}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:to_box_T ensures] ([@stop_split] [@expl:to_box result type invariant] inv_Box_T_Global result)
      /\ ([@stop_split] [@expl:to_box ensures] result = val_ptr_T own)}
      (! return {result}) ]
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Box_T_Global [@inline:trivial] (_1: t_T) = resolve_T _1
  
  meta "rewrite_def" predicate resolve_Box_T_Global
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec drop_T (ptr: Opaque.ptr) (own: t_Perm_ptr_T) (return (x: ())) =
    {[@stop_split] [@expl:drop_T requires] ([@stop_split] [@expl:drop 'own' type invariant] inv_Ghost_Box_Perm_ptr_T_Global own)
    /\ ([@stop_split] [@expl:drop requires] ptr = ward_ptr_T own)}
    (! bb0
    [ bb0 = s0
      [ s0 = to_box_T {ptr} {own} (fun (_x: t_T) -> [ &_6 <- _x ] s1)
      | s1 = s2 [ _ck -> (! {[@expl:type invariant] inv_Box_T_Global _6} any) ]
      | s2 = -{resolve_Box_T_Global _6}- s3
      | s3 = return {_ret} ] ]
    [ & _ret: () = Any.any_l () | & ptr: Opaque.ptr = ptr | & own: t_Perm_ptr_T = own | & _6: t_T = Any.any_l () ])
    [ return (result: ()) -> (! return {result}) ]
end
module M_std__ptr__impl_Perm_ptr_T__ptr_is_aligned_lemma (* ghost::perm::Perm<*const T> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use int.Int
  
  type t_Perm_ptr_T
  
  predicate is_null_ptr_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ward_ptr_T (self: t_Perm_ptr_T) : Opaque.ptr
  
  predicate is_aligned_T (ptr: Opaque.ptr)
  
  predicate is_aligned_ptr_T [@inline:trivial] (self: Opaque.ptr) = is_aligned_T self
  
  meta "rewrite_def" predicate is_aligned_ptr_T
  
  predicate ptr_is_aligned_opaque_T (self: t_Perm_ptr_T) = is_aligned_ptr_T (ward_ptr_T self)
  
  type t_T
  
  type t_Metadata
  
  predicate metadata_matches_T (_value: t_T) (_metadata: t_Metadata)
  
  function val_ptr_T (self: t_Perm_ptr_T) : t_T
  
  function metadata_T (_1: Opaque.ptr) : t_Metadata
  
  function size_of_val_T (val': t_T) : int
  
  axiom size_of_val_T_spec: forall val': t_T. 0 <= size_of_val_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Perm_ptr_T (self: t_Perm_ptr_T) =
    not is_null_ptr_T (ward_ptr_T self)
    /\ ptr_is_aligned_opaque_T self
    /\ metadata_matches_T (val_ptr_T self) (metadata_T (ward_ptr_T self))
    /\ size_of_val_T (val_ptr_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ward_ptr_T self)) + size_of_val_T (val_ptr_T self) <= UInt64.t'int const_MAX'0
    /\ inv_ref_T (val_ptr_T self)
  
  predicate inv_Perm_ptr_T (_1: t_Perm_ptr_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Perm_ptr_T [inv_Perm_ptr_T x]. inv_Perm_ptr_T x = invariant_Perm_ptr_T x
  
  predicate invariant_ref_Perm_ptr_T [@inline:trivial] (self: t_Perm_ptr_T) = inv_Perm_ptr_T self
  
  meta "rewrite_def" predicate invariant_ref_Perm_ptr_T
  
  predicate inv_ref_Perm_ptr_T [@inline:trivial] (_1: t_Perm_ptr_T) = invariant_ref_Perm_ptr_T _1
  
  meta "rewrite_def" predicate inv_ref_Perm_ptr_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec ptr_is_aligned_lemma_T (self: t_Perm_ptr_T) (return (x: ())) =
    {[@stop_split] [@expl:ptr_is_aligned_lemma 'self' type invariant] inv_ref_Perm_ptr_T self}
    (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ])
    [ return (result: ()) -> {[@stop_split] [@expl:ptr_is_aligned_lemma ensures] is_aligned_ptr_T (ward_ptr_T self)}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_Range_T_legacy_Range_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Range_T = { start: t_T; end': t_T }
  
  type t_Range_T'0 = { start'0: t_T; end''0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Range_T (_1: t_Range_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range_T [inv_Range_T x]. inv_Range_T x = (inv_T x.start /\ inv_T x.end')
  
  predicate inv_Range_T'0 (_1: t_Range_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Range_T'0 [inv_Range_T'0 x]. inv_Range_T'0 x
      = (inv_T x.start'0 /\ inv_T x.end''0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_Range_T_legacy_Range_T_from_body_T (value: t_Range_T) (return (x: t_Range_T'0)) =
    {[@stop_split] [@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body 'value' type invariant] inv_Range_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { start'0 = value.start; end''0 = value.end' } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Range_T'0 = Any.any_l () | & value: t_Range_T = value ])
    [ return (result: t_Range_T'0) ->
    {[@stop_split] [@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body_T ensures] ([@stop_split] [@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body result type invariant] inv_Range_T'0 result)
      /\ ([@stop_split] [@expl:extern_spec_T_From_Range_T_legacy_Range_T_from_body ensures] result
      = { start'0 = value.start; end''0 = value.end' })}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_legacy_Range_T_Range_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_Range_T = { start: t_T; end': t_T }
  
  type t_Range_T'0 = { start'0: t_T; end''0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_Range_T (_1: t_Range_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Range_T [inv_Range_T x]. inv_Range_T x = (inv_T x.start /\ inv_T x.end')
  
  predicate inv_Range_T'0 (_1: t_Range_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Range_T'0 [inv_Range_T'0 x]. inv_Range_T'0 x
      = (inv_T x.start'0 /\ inv_T x.end''0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_legacy_Range_T_Range_T_from_body_T (value: t_Range_T) (return (x: t_Range_T'0)) =
    {[@stop_split] [@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body 'value' type invariant] inv_Range_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { start'0 = value.start; end''0 = value.end' } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_Range_T'0 = Any.any_l () | & value: t_Range_T = value ])
    [ return (result: t_Range_T'0) ->
    {[@stop_split] [@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body_T ensures] ([@stop_split] [@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body result type invariant] inv_Range_T'0 result)
      /\ ([@stop_split] [@expl:extern_spec_T_From_legacy_Range_T_Range_T_from_body ensures] result
      = { start'0 = value.start; end''0 = value.end' })}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeFrom_T = { start: t_T }
  
  type t_RangeFrom_T'0 = { start'0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_RangeFrom_T (_1: t_RangeFrom_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeFrom_T [inv_RangeFrom_T x]. inv_RangeFrom_T x = inv_T x.start
  
  predicate inv_RangeFrom_T'0 (_1: t_RangeFrom_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_RangeFrom_T'0 [inv_RangeFrom_T'0 x]. inv_RangeFrom_T'0 x = inv_T x.start'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body_T (value: t_RangeFrom_T)
    (return (x: t_RangeFrom_T'0)) =
    {[@stop_split] [@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body 'value' type invariant] inv_RangeFrom_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { start'0 = value.start } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_RangeFrom_T'0 = Any.any_l () | & value: t_RangeFrom_T = value ])
    [ return (result: t_RangeFrom_T'0) ->
    {[@stop_split] [@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body_T ensures] ([@stop_split] [@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body result type invariant] inv_RangeFrom_T'0 result)
      /\ ([@stop_split] [@expl:extern_spec_T_From_RangeFrom_T_legacy_RangeFrom_T_from_body ensures] result
      = { start'0 = value.start })}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeFrom_T = { start: t_T }
  
  type t_RangeFrom_T'0 = { start'0: t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate inv_RangeFrom_T (_1: t_RangeFrom_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeFrom_T [inv_RangeFrom_T x]. inv_RangeFrom_T x = inv_T x.start
  
  predicate inv_RangeFrom_T'0 (_1: t_RangeFrom_T'0)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_RangeFrom_T'0 [inv_RangeFrom_T'0 x]. inv_RangeFrom_T'0 x = inv_T x.start'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body_T (value: t_RangeFrom_T)
    (return (x: t_RangeFrom_T'0)) =
    {[@stop_split] [@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body 'value' type invariant] inv_RangeFrom_T value}
    (! bb0
    [ bb0 = s0 [ s0 = [ &_ret <- { start'0 = value.start } ] s1 | s1 = return {_ret} ] ]
    [ & _ret: t_RangeFrom_T'0 = Any.any_l () | & value: t_RangeFrom_T = value ])
    [ return (result: t_RangeFrom_T'0) ->
    {[@stop_split] [@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body_T ensures] ([@stop_split] [@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body result type invariant] inv_RangeFrom_T'0 result)
      /\ ([@stop_split] [@expl:extern_spec_T_From_legacy_RangeFrom_T_RangeFrom_T_from_body ensures] result
      = { start'0 = value.start })}
      (! return {result}) ]
end
module M_std__range__extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_T
  
  type t_RangeInclusive_T = { start: t_T; last: t_T }
  
  type t_RangeInclusive_T'0
  
  predicate inv_T (_1: t_T)
  
  predicate inv_RangeInclusive_T (_1: t_RangeInclusive_T'0)
  
  function start_log_RangeInclusive_T (self: t_RangeInclusive_T'0) : t_T
  
  function end_log_RangeInclusive_T (self: t_RangeInclusive_T'0) : t_T
  
  type t_DeepModelTy
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_DeepModelTy (self: t_DeepModelTy) (other: t_DeepModelTy) : t_Ordering
  
  function eq_cmp_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom eq_cmp_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. (x = y) = (cmp_log_DeepModelTy x y = Equal)
  
  function antisym2_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym2_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Greater
      -> cmp_log_DeepModelTy y x = Less
  
  function antisym1_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom antisym1_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. cmp_log_DeepModelTy x y = Less
      -> cmp_log_DeepModelTy y x = Greater
  
  function trans_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) (z: t_DeepModelTy) (o: t_Ordering) : ()
  
  axiom trans_DeepModelTy_spec:
    forall x: t_DeepModelTy, y: t_DeepModelTy, z: t_DeepModelTy, o: t_Ordering. cmp_log_DeepModelTy x y = o
      -> cmp_log_DeepModelTy y z = o -> cmp_log_DeepModelTy x z = o
  
  function refl_DeepModelTy (x: t_DeepModelTy) : ()
  
  axiom refl_DeepModelTy_spec: forall x: t_DeepModelTy. cmp_log_DeepModelTy x x = Equal
  
  predicate gt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_gt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_gt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. gt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Greater)
  
  predicate ge_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_ge_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_ge_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. ge_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Less)
  
  predicate lt_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_lt_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_lt_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. lt_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y = Less)
  
  predicate le_log_DeepModelTy (self: t_DeepModelTy) (o: t_DeepModelTy)
  
  function cmp_le_log_DeepModelTy (x: t_DeepModelTy) (y: t_DeepModelTy) : ()
  
  axiom cmp_le_log_DeepModelTy_spec: forall x: t_DeepModelTy, y: t_DeepModelTy. le_log_DeepModelTy x y
      = (cmp_log_DeepModelTy x y <> Greater)
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate is_empty_log_RangeInclusive_T (self: t_RangeInclusive_T'0)
  
  axiom is_empty_log_RangeInclusive_T_spec: forall self: t_RangeInclusive_T'0. not is_empty_log_RangeInclusive_T self
      -> le_log_DeepModelTy (deep_model_T (start_log_RangeInclusive_T self)) (deep_model_T (end_log_RangeInclusive_T self))
  
  let rec new_T (start'0: t_T) (end': t_T) (return (x: t_RangeInclusive_T'0)) =
    {[@stop_split] [@expl:new_T requires] ([@stop_split] [@expl:new 'start' type invariant] inv_T start'0)
    /\ ([@stop_split] [@expl:new 'end' type invariant] inv_T end')}
    any
    [ return (result: t_RangeInclusive_T'0) ->
    {[@stop_split] [@expl:new_T ensures] ([@stop_split] [@expl:new result type invariant] inv_RangeInclusive_T result)
      /\ ([@stop_split] [@expl:new ensures #0] start_log_RangeInclusive_T result = start'0)
      /\ ([@stop_split] [@expl:new ensures #1] end_log_RangeInclusive_T result = end')
      /\ ([@stop_split] [@expl:new ensures #2] le_log_DeepModelTy (deep_model_T start'0) (deep_model_T end')
      -> not is_empty_log_RangeInclusive_T result)}
      (! return {result}) ]
  
  predicate inv_RangeInclusive_T'0 (_1: t_RangeInclusive_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_RangeInclusive_T [inv_RangeInclusive_T'0 x]. inv_RangeInclusive_T'0 x
      = (inv_T x.start /\ inv_T x.last)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body_T (value: t_RangeInclusive_T)
    (return (x: t_RangeInclusive_T'0)) =
    {[@stop_split] [@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body 'value' type invariant] inv_RangeInclusive_T'0 value}
    (! bb0
    [ bb0 = s0
      [ s0 = new_T {value.start} {value.last} (fun (_x: t_RangeInclusive_T'0) -> [ &_ret <- _x ] s1)
      | s1 = return {_ret} ] ] [ & _ret: t_RangeInclusive_T'0 = Any.any_l () | & value: t_RangeInclusive_T = value ])
    [ return (result: t_RangeInclusive_T'0) ->
    {[@stop_split] [@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body_T ensures] ([@stop_split] [@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body result type invariant] inv_RangeInclusive_T result)
      /\ ([@stop_split] [@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #0] start_log_RangeInclusive_T result
        = value.start)
      /\ ([@stop_split] [@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #1] end_log_RangeInclusive_T result
        = value.last)
      /\ ([@stop_split] [@expl:extern_spec_T_From_RangeInclusive_T_legacy_RangeInclusive_T_from_body ensures #2] le_log_DeepModelTy (deep_model_T value.start) (deep_model_T value.last)
      -> not is_empty_log_RangeInclusive_T result)}
      (! return {result}) ]
end
module M_std__rc__extern_spec_T_A_Deref_Rc_T_A_deref_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Rc_T_A
  
  type t_T
  
  predicate inv_Rc_T_A (_1: t_Rc_T_A)
  
  predicate invariant_ref_Rc_T_A [@inline:trivial] (self: t_Rc_T_A) = inv_Rc_T_A self
  
  meta "rewrite_def" predicate invariant_ref_Rc_T_A
  
  predicate inv_ref_Rc_T_A [@inline:trivial] (_1: t_Rc_T_A) = invariant_ref_Rc_T_A _1
  
  meta "rewrite_def" predicate inv_ref_Rc_T_A
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  function view_Rc_T_A (self: t_Rc_T_A) : t_T
  
  let rec as_ref_Rc_T_A (self_: t_Rc_T_A) (return (x: t_T)) =
    {[@stop_split] [@expl:as_ref 'self_' type invariant] inv_ref_Rc_T_A self_}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:as_ref_Rc_T_A ensures] ([@stop_split] [@expl:as_ref result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:as_ref ensures] result = view_Rc_T_A self_)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_A_Deref_Rc_T_A_deref_body_T (self_: t_Rc_T_A) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_T_A_Deref_Rc_T_A_deref_body 'self_' type invariant] inv_ref_Rc_T_A self_}
    (! bb0
    [ bb0 = s0
      [ s0 = as_ref_Rc_T_A {self_} (fun (_x: t_T) -> [ &_4 <- _x ] s1)
      | s1 = [ &_ret <- _4 ] s2
      | s2 = return {_ret} ] ] [ & _ret: t_T = Any.any_l () | & self_: t_Rc_T_A = self_ | & _4: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_T_A_Deref_Rc_T_A_deref_body_T ensures] ([@stop_split] [@expl:extern_spec_T_A_Deref_Rc_T_A_deref_body result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:extern_spec_T_A_Deref_Rc_T_A_deref_body ensures] result = view_Rc_T_A self_)}
      (! return {result}) ]
end
module M_std__slice__impl_SliceExt_for_slice_T__as_ptr_perm (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use creusot.prelude.Opaque
  use seq.Seq
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  type t_Perm_ptr_slice_T
  
  type tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T = { f0: Opaque.ptr; f1: t_Perm_ptr_slice_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ward_ptr_slice_T (self: t_Perm_ptr_slice_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_Perm_ptr_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function val_ptr_slice_T (self: t_Perm_ptr_slice_T) : Slice64.slice t_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_Perm_ptr_slice_T (self: t_Perm_ptr_slice_T) =
    not is_null_ptr_slice_T (ward_ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_ptr_slice_T self) (metadata_slice_T (ward_ptr_slice_T self))
    /\ size_of_val_slice_T (val_ptr_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ward_ptr_slice_T self)) + size_of_val_slice_T (val_ptr_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T (val_ptr_slice_T self)
  
  predicate inv_Perm_ptr_slice_T (_1: t_Perm_ptr_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Perm_ptr_slice_T [inv_Perm_ptr_slice_T x]. inv_Perm_ptr_slice_T x
      = invariant_Perm_ptr_slice_T x
  
  predicate invariant_ref_Perm_ptr_slice_T [@inline:trivial] (self: t_Perm_ptr_slice_T) = inv_Perm_ptr_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_Perm_ptr_slice_T
  
  predicate inv_ref_Perm_ptr_slice_T [@inline:trivial] (_1: t_Perm_ptr_slice_T) = invariant_ref_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_Perm_ptr_slice_T
  
  predicate invariant_Ghost_ref_Perm_ptr_slice_T [@inline:trivial] (self: t_Perm_ptr_slice_T) =
    inv_ref_Perm_ptr_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_Perm_ptr_slice_T
  
  predicate inv_Ghost_ref_Perm_ptr_slice_T [@inline:trivial] (_1: t_Perm_ptr_slice_T) =
    invariant_Ghost_ref_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_Perm_ptr_slice_T
  
  predicate inv_tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T [@inline:trivial] (_1: tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T) =
    inv_Ghost_ref_Perm_ptr_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T
  
  let rec from_ref_slice_T (r: Slice64.slice t_T) (return (x: tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T)) =
    {[@stop_split] [@expl:from_ref 'r' type invariant] inv_ref_slice_T r}
    any
    [ return (result: tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T) ->
    {[@stop_split] [@expl:from_ref_slice_T ensures] ([@stop_split] [@expl:from_ref result type invariant] inv_tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T result)
      /\ ([@stop_split] [@expl:from_ref ensures #0] ward_ptr_slice_T result.f1 = result.f0)
      /\ ([@stop_split] [@expl:from_ref ensures #1] val_ptr_slice_T result.f1 = r)}
      (! return {result}) ]
  
  type tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T = { f0'0: Opaque.ptr; f1'0: t_Perm_ptr_slice_T }
  
  predicate inv_tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T) =
    inv_Ghost_ref_Perm_ptr_slice_T _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_ptr_perm_slice_T (self: Slice64.slice t_T) (return (x: tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T)) =
    {[@stop_split] [@expl:as_ptr_perm 'self' type invariant] inv_ref_slice_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = from_ref_slice_T {self} (fun (_x: tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T) -> [ &_9 <- _x ] s1)
      | s1 = [ &ptr <- _9.f0 ] s2
      | s2 = [ &own <- _9.f1 ] s3
      | s3 = [ &_11 <- Opaque.thin ptr ] s4
      | s4 = [ &_ret <- { f0'0 = _11; f1'0 = own } ] s5
      | s5 = return {_ret} ] ]
    [ & _ret: tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T = Any.any_l ()
    | & self: Slice64.slice t_T = self
    | & ptr: Opaque.ptr = Any.any_l ()
    | & own: t_Perm_ptr_slice_T = Any.any_l ()
    | & _9: tup2_ptr_slice_T_Ghost_ref_Perm_ptr_slice_T = Any.any_l ()
    | & _11: Opaque.ptr = Any.any_l () ])
    [ return (result: tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T) ->
    {[@stop_split] [@expl:as_ptr_perm_slice_T ensures] ([@stop_split] [@expl:as_ptr_perm result type invariant] inv_tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T result)
      /\ ([@stop_split] [@expl:as_ptr_perm ensures #0] result.f0'0 = Opaque.thin (ward_ptr_slice_T result.f1'0))
      /\ ([@stop_split] [@expl:as_ptr_perm ensures #1] self = val_ptr_slice_T result.f1'0)}
      (! return {result}) ]
end
module M_std__slice__impl_SliceExt_for_slice_T__as_mut_ptr_perm (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use creusot.prelude.Any
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  type t_Perm_ptr_slice_T
  
  type tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T = { f0: Opaque.ptr; f1: MutBorrow.t t_Perm_ptr_slice_T }
  
  predicate invariant_refmut_slice_T [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv_slice_T self.current /\ inv_slice_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_slice_T
  
  predicate inv_refmut_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant_refmut_slice_T _1
  
  meta "rewrite_def" predicate inv_refmut_slice_T
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ward_ptr_slice_T (self: t_Perm_ptr_slice_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_Perm_ptr_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function val_ptr_slice_T (self: t_Perm_ptr_slice_T) : Slice64.slice t_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  predicate invariant_Perm_ptr_slice_T (self: t_Perm_ptr_slice_T) =
    not is_null_ptr_slice_T (ward_ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_ptr_slice_T self) (metadata_slice_T (ward_ptr_slice_T self))
    /\ size_of_val_slice_T (val_ptr_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ward_ptr_slice_T self)) + size_of_val_slice_T (val_ptr_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T (val_ptr_slice_T self)
  
  predicate inv_Perm_ptr_slice_T (_1: t_Perm_ptr_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Perm_ptr_slice_T [inv_Perm_ptr_slice_T x]. inv_Perm_ptr_slice_T x
      = invariant_Perm_ptr_slice_T x
  
  predicate invariant_refmut_Perm_ptr_slice_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_slice_T) =
    inv_Perm_ptr_slice_T self.current /\ inv_Perm_ptr_slice_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Perm_ptr_slice_T
  
  predicate inv_refmut_Perm_ptr_slice_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_slice_T) =
    invariant_refmut_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_refmut_Perm_ptr_slice_T
  
  predicate invariant_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_slice_T) =
    inv_refmut_Perm_ptr_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_Perm_ptr_slice_T
  
  predicate inv_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_slice_T) =
    invariant_Ghost_refmut_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_Perm_ptr_slice_T
  
  predicate inv_tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (_1: tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T) =
    inv_Ghost_refmut_Perm_ptr_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T
  
  let rec from_mut_slice_T (r: MutBorrow.t (Slice64.slice t_T))
    (return (x: tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T)) =
    {[@stop_split] [@expl:from_mut 'r' type invariant] inv_refmut_slice_T r}
    any
    [ return (result: tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T) ->
    {[@stop_split] [@expl:from_mut_slice_T ensures] ([@stop_split] [@expl:from_mut result type invariant] inv_tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T result)
      /\ ([@stop_split] [@expl:from_mut ensures #0] ward_ptr_slice_T result.f1.current = result.f0)
      /\ ([@stop_split] [@expl:from_mut ensures #1] val_ptr_slice_T result.f1.current = r.current)
      /\ ([@stop_split] [@expl:from_mut ensures #2] val_ptr_slice_T result.f1.final = r.final)}
      (! return {result}) ]
  
  type tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T = { f0'0: Opaque.ptr; f1'0: MutBorrow.t t_Perm_ptr_slice_T }
  
  predicate resolve_refmut_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = _1.final = _1.current
  
  meta "rewrite_def" predicate resolve_refmut_slice_T
  
  predicate inv_tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T) =
    inv_Ghost_refmut_Perm_ptr_slice_T _1.f1'0
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T
  
  function fin_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_slice_T) : t_Perm_ptr_slice_T
   = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_Perm_ptr_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec as_mut_ptr_perm_slice_T (self: MutBorrow.t (Slice64.slice t_T))
    (return (x: tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T)) =
    {[@stop_split] [@expl:as_mut_ptr_perm 'self' type invariant] inv_refmut_slice_T self}
    (! bb0
    [ bb0 = s0
      [ s0 = MutBorrow.borrow_final <Slice64.slice t_T> {self.current} {MutBorrow.get_id self}
          (fun (_bor: MutBorrow.t (Slice64.slice t_T)) ->
            [ &_12 <- _bor ] -{inv_slice_T _bor.final}-
            [ &self <- { self with current = _bor.final } ] s1)
        [ _ck -> (! {[@expl:type invariant] inv_slice_T self.current} any) ]
      | s1 = from_mut_slice_T {_12} (fun (_x: tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T) -> [ &_11 <- _x ] s2)
      | s2 = [ &ptr <- _11.f0 ] s3
      | s3 = [ &own <- _11.f1 ] s4
      | s4 = [ &_13 <- Opaque.thin ptr ] s5
      | s5 = [ &_ret <- { f0'0 = _13; f1'0 = own } ] s6
      | s6 = s7 [ _ck -> (! {[@expl:type invariant] inv_refmut_slice_T self} any) ]
      | s7 = -{resolve_refmut_slice_T self}- s8
      | s8 = return {_ret} ] ]
    [ & _ret: tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T = Any.any_l ()
    | & self: MutBorrow.t (Slice64.slice t_T) = self
    | & ptr: Opaque.ptr = Any.any_l ()
    | & own: MutBorrow.t t_Perm_ptr_slice_T = Any.any_l ()
    | & _11: tup2_ptr_slice_T_Ghost_refmut_Perm_ptr_slice_T = Any.any_l ()
    | & _12: MutBorrow.t (Slice64.slice t_T) = Any.any_l ()
    | & _13: Opaque.ptr = Any.any_l () ])
    [ return (result: tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T) ->
    {[@stop_split] [@expl:as_mut_ptr_perm_slice_T ensures] ([@stop_split] [@expl:as_mut_ptr_perm result type invariant] inv_tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T result)
      /\ ([@stop_split] [@expl:as_mut_ptr_perm ensures #0] result.f0'0
        = Opaque.thin (ward_ptr_slice_T result.f1'0.current))
      /\ ([@stop_split] [@expl:as_mut_ptr_perm ensures #1] self.current = val_ptr_slice_T result.f1'0.current)
      /\ ([@stop_split] [@expl:as_mut_ptr_perm ensures #2] self.final
      = val_ptr_slice_T (fin_Ghost_refmut_Perm_ptr_slice_T result.f1'0))}
      (! return {result}) ]
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T:
    [@stop_split] [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_refl (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut_T
  
  function produces_refl_IterMut_T (self: t_IterMut_T) : ()
  
  goal vc_produces_refl_IterMut_T:
    [@stop_split] [@expl:produces_refl ensures] produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_trans (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut_T
  
  constant ab : Seq.seq (MutBorrow.t t_T)
  
  constant b : t_IterMut_T
  
  constant bc : Seq.seq (MutBorrow.t t_T)
  
  constant c : t_IterMut_T
  
  function produces_trans_IterMut_T (a: t_IterMut_T) (ab: Seq.seq (MutBorrow.t t_T)) (b: t_IterMut_T) (bc: Seq.seq (MutBorrow.t t_T)) (c: t_IterMut_T) : ()
  
  goal vc_produces_trans_IterMut_T: produces_IterMut_T a ab b
    -> produces_IterMut_T b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_refl (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T_A
  
  function produces_refl_IntoIter_T_A (self: t_IntoIter_T_A) : ()
  
  goal vc_produces_refl_IntoIter_T_A:
    [@stop_split] [@expl:produces_refl ensures] produces_IntoIter_T_A self (Seq.empty: Seq.seq t_T) self
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_trans (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T_A
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T_A
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T_A
  
  function produces_trans_IntoIter_T_A (a: t_IntoIter_T_A) (ab: Seq.seq t_T) (b: t_IntoIter_T_A) (bc: Seq.seq t_T) (c: t_IntoIter_T_A) : ()
  
  goal vc_produces_trans_IntoIter_T_A: produces_IntoIter_T_A a ab b
    -> produces_IntoIter_T_A b bc c
    -> ([@stop_split] [@expl:produces_trans ensures] produces_IntoIter_T_A a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V_A__produces_refl (* <std::collections::hash_map::IntoIter<K, V, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IntoIter_K_V_A
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V_A (self: t_IntoIter_K_V_A) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V_A [@inline:trivial] (self: t_IntoIter_K_V_A) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V_A) =
    len_DeepModelTy (view_IntoIter_K_V_A self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V_A o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V_A self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V_A o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_K_V_A
  
  function produces_refl_IntoIter_K_V_A (self: t_IntoIter_K_V_A) : ()
  
  goal vc_produces_refl_IntoIter_K_V_A:
    [@stop_split] [@expl:produces_refl ensures] produces_IntoIter_K_V_A self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V_A__produces_trans (* <std::collections::hash_map::IntoIter<K, V, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IntoIter_K_V_A
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V_A (self: t_IntoIter_K_V_A) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V_A [@inline:trivial] (self: t_IntoIter_K_V_A) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V_A) =
    len_DeepModelTy (view_IntoIter_K_V_A self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V_A o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V_A self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V_A o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_K_V_A
  
  constant ab : Seq.seq tup2_K_V
  
  constant b : t_IntoIter_K_V_A
  
  constant bc : Seq.seq tup2_K_V
  
  constant c : t_IntoIter_K_V_A
  
  function produces_trans_IntoIter_K_V_A (a: t_IntoIter_K_V_A) (ab: Seq.seq tup2_K_V) (b: t_IntoIter_K_V_A) (bc: Seq.seq tup2_K_V) (c: t_IntoIter_K_V_A) : ()
  
  goal vc_produces_trans_IntoIter_K_V_A: produces_IntoIter_K_V_A a ab b
    -> produces_IntoIter_K_V_A b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@stop_split] [@expl:produces_trans ensures] produces_IntoIter_K_V_A a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_refl (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_K_V
  
  function produces_refl_Iter_K_V (self: t_Iter_K_V) : ()
  
  goal vc_produces_refl_Iter_K_V:
    [@stop_split] [@expl:produces_refl ensures] produces_Iter_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_trans (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_K_V
  
  constant ab : Seq.seq tup2_ref_K_ref_V
  
  constant b : t_Iter_K_V
  
  constant bc : Seq.seq tup2_ref_K_ref_V
  
  constant c : t_Iter_K_V
  
  function produces_trans_Iter_K_V (a: t_Iter_K_V) (ab: Seq.seq tup2_ref_K_ref_V) (b: t_Iter_K_V) (bc: Seq.seq tup2_ref_K_ref_V) (c: t_Iter_K_V) : ()
  
  goal vc_produces_trans_Iter_K_V: produces_Iter_K_V a ab b
    -> produces_Iter_K_V b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@stop_split] [@expl:produces_trans ensures] produces_Iter_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_refl (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_refmut_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_refmut_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_refmut_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_refmut_V
  
  predicate contains_tup2_ref_K_refmut_V (self: Seq.seq tup2_ref_K_refmut_V) (x: tup2_ref_K_refmut_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_refmut_V = None | Some (MutBorrow.t t_V)
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : Map.map t_DeepModelTy t_Option_refmut_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_refmut_V) (k: t_DeepModelTy) : t_Option_refmut_V
   = Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_refmut_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_refmut_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_refmut_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_refmut_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IterMut_K_V
  
  function produces_refl_IterMut_K_V (self: t_IterMut_K_V) : ()
  
  goal vc_produces_refl_IterMut_K_V:
    [@stop_split] [@expl:produces_refl ensures] produces_IterMut_K_V self (Seq.empty: Seq.seq tup2_ref_K_refmut_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_trans (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_refmut_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_refmut_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_refmut_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_refmut_V
  
  predicate contains_tup2_ref_K_refmut_V (self: Seq.seq tup2_ref_K_refmut_V) (x: tup2_ref_K_refmut_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_refmut_V = None | Some (MutBorrow.t t_V)
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : Map.map t_DeepModelTy t_Option_refmut_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_refmut_V) (k: t_DeepModelTy) : t_Option_refmut_V
   = Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_refmut_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_refmut_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_refmut_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_refmut_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IterMut_K_V
  
  constant ab : Seq.seq tup2_ref_K_refmut_V
  
  constant b : t_IterMut_K_V
  
  constant bc : Seq.seq tup2_ref_K_refmut_V
  
  constant c : t_IterMut_K_V
  
  function produces_trans_IterMut_K_V (a: t_IterMut_K_V) (ab: Seq.seq tup2_ref_K_refmut_V) (b: t_IterMut_K_V) (bc: Seq.seq tup2_ref_K_refmut_V) (c: t_IterMut_K_V) : ()
  
  goal vc_produces_trans_IterMut_K_V: produces_IterMut_K_V a ab b
    -> produces_IterMut_K_V b bc c
    -> (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@stop_split] [@expl:produces_trans ensures] produces_IterMut_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__set_produces_trans
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_I
  
  type t_T
  
  type t_DeepModelTy
  
  function view_I (self: t_I) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_I) (visited: Seq.seq t_T) (end': t_I) =
    Fset.cardinal (view_I start) = Seq.length visited + Fset.cardinal (view_I end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_I start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1) \/ contains_DeepModelTy (view_I end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_I start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_I end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_I end') x
        -> contains_DeepModelTy (view_I start) x /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  constant concat_contains_T: () = ()
  
  axiom concat_contains_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a b) x
        = contains_T a x
      \/ contains_T b x
  
  type t_Option_T = None | Some t_T
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_I
  
  constant ab : Seq.seq t_T
  
  constant b : t_I
  
  constant bc : Seq.seq t_T
  
  constant c : t_I
  
  function set_produces_trans_T (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  goal vc_set_produces_trans_T: set_produces_T a ab b
    -> set_produces_T b bc c
    -> ([@stop_split] [@expl:concat_contains ensures] forall a'0: Seq.seq t_T, b'0: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a'0 b'0) x
          = contains_T a'0 x
        \/ contains_T b'0 x)
    -> (let _ = concat_contains_T in (forall i: int, x: t_T. Seq.length ab <= i /\ get_T (Seq.(++) ab bc) i = Some x
        -> contains_T bc x)
    && (forall i: int. 0 <= i /\ i < Seq.length bc -> Seq.get bc i = Seq.get (Seq.(++) ab bc) (Seq.length ab + i))
    && ([@stop_split] [@expl:set_produces_trans ensures] set_produces_T a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T_Global__produces_refl (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_IntoIter_T_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T_Global (self: t_IntoIter_T_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T_Global) (visited: Seq.seq t_T) (end': t_IntoIter_T_Global) =
    Fset.cardinal (view_IntoIter_T_Global start) = Seq.length visited + Fset.cardinal (view_IntoIter_T_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T_Global end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T_Global end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global end') x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T_Global (self: t_IntoIter_T_Global) (visited: Seq.seq t_T) (o: t_IntoIter_T_Global) =
    set_produces_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_IntoIter_T_Global
  
  function produces_refl_IntoIter_T_Global (self: t_IntoIter_T_Global) : ()
  
  goal vc_produces_refl_IntoIter_T_Global:
    [@stop_split] [@expl:produces_refl ensures] produces_IntoIter_T_Global self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T_Global__produces_trans (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_IntoIter_T_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T_Global (self: t_IntoIter_T_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T_Global) (visited: Seq.seq t_T) (end': t_IntoIter_T_Global) =
    Fset.cardinal (view_IntoIter_T_Global start) = Seq.length visited + Fset.cardinal (view_IntoIter_T_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T_Global end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T_Global end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global end') x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T_Global (self: t_IntoIter_T_Global) (visited: Seq.seq t_T) (o: t_IntoIter_T_Global) =
    set_produces_T self visited o
  
  constant concat_contains_T: () = ()
  
  axiom concat_contains_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_T (Seq.(++) a b) x
        = contains_T a x
      \/ contains_T b x
  
  function set_produces_trans_T (a: t_IntoIter_T_Global) (ab: Seq.seq t_T) (b: t_IntoIter_T_Global) (bc: Seq.seq t_T) (c: t_IntoIter_T_Global) : ()
   = let _ = concat_contains_T in ()
  
  axiom set_produces_trans_T_spec:
    forall a: t_IntoIter_T_Global, ab: Seq.seq t_T, b: t_IntoIter_T_Global, bc: Seq.seq t_T, c: t_IntoIter_T_Global. set_produces_T a ab b
      -> set_produces_T b bc c -> set_produces_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_IntoIter_T_Global
  
  constant ab : Seq.seq t_T
  
  constant b : t_IntoIter_T_Global
  
  constant bc : Seq.seq t_T
  
  constant c : t_IntoIter_T_Global
  
  function produces_trans_IntoIter_T_Global (a: t_IntoIter_T_Global) (ab: Seq.seq t_T) (b: t_IntoIter_T_Global) (bc: Seq.seq t_T) (c: t_IntoIter_T_Global) : ()
  
  goal vc_produces_trans_IntoIter_T_Global: produces_IntoIter_T_Global a ab b
    -> produces_IntoIter_T_Global b bc c
    -> ([@stop_split] [@expl:set_produces_trans requires] ([@stop_split] [@expl:set_produces_trans requires #0] set_produces_T a ab b)
      /\ ([@stop_split] [@expl:set_produces_trans requires #1] set_produces_T b bc c))
    /\ (([@stop_split] [@expl:set_produces_trans ensures] set_produces_T a (Seq.(++) ab bc) c)
    -> (let _ = set_produces_trans_T a ab b bc c in [@stop_split] [@expl:produces_trans ensures] produces_IntoIter_T_Global a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T:
    [@stop_split] [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  constant concat_contains_ref_T: () = ()
  
  axiom concat_contains_ref_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_ref_T (Seq.(++) a b) x
        = contains_ref_T a x
      \/ contains_ref_T b x
  
  function set_produces_trans_ref_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : () =
    let _ = concat_contains_ref_T in ()
  
  axiom set_produces_trans_ref_T_spec:
    forall a: t_Iter_T, ab: Seq.seq t_T, b: t_Iter_T, bc: Seq.seq t_T, c: t_Iter_T. set_produces_ref_T a ab b
      -> set_produces_ref_T b bc c -> set_produces_ref_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c
    -> ([@stop_split] [@expl:set_produces_trans requires] ([@stop_split] [@expl:set_produces_trans requires #0] set_produces_ref_T a ab b)
      /\ ([@stop_split] [@expl:set_produces_trans requires #1] set_produces_ref_T b bc c))
    /\ (([@stop_split] [@expl:set_produces_trans ensures] set_produces_ref_T a (Seq.(++) ab bc) c)
    -> (let _ = set_produces_trans_ref_T a ab b bc c in [@stop_split] [@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S_Global__produces_refl (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Intersection_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S_Global (self: t_Intersection_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (end': t_Intersection_T_S_Global) =
    Fset.cardinal (view_Intersection_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Intersection_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global end') x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S_Global (self: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (o: t_Intersection_T_S_Global) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Intersection_T_S_Global
  
  function produces_refl_Intersection_T_S_Global (self: t_Intersection_T_S_Global) : ()
  
  goal vc_produces_refl_Intersection_T_S_Global:
    [@stop_split] [@expl:produces_refl ensures] produces_Intersection_T_S_Global self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S_Global__produces_trans (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Intersection_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S_Global (self: t_Intersection_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (end': t_Intersection_T_S_Global) =
    Fset.cardinal (view_Intersection_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Intersection_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global end') x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S_Global (self: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (o: t_Intersection_T_S_Global) =
    set_produces_ref_T self visited o
  
  constant concat_contains_ref_T: () = ()
  
  axiom concat_contains_ref_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_ref_T (Seq.(++) a b) x
        = contains_ref_T a x
      \/ contains_ref_T b x
  
  function set_produces_trans_ref_T (a: t_Intersection_T_S_Global) (ab: Seq.seq t_T) (b: t_Intersection_T_S_Global) (bc: Seq.seq t_T) (c: t_Intersection_T_S_Global) : ()
   = let _ = concat_contains_ref_T in ()
  
  axiom set_produces_trans_ref_T_spec:
    forall a: t_Intersection_T_S_Global, ab: Seq.seq t_T, b: t_Intersection_T_S_Global, bc: Seq.seq t_T, c: t_Intersection_T_S_Global. set_produces_ref_T a ab b
      -> set_produces_ref_T b bc c -> set_produces_ref_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Intersection_T_S_Global
  
  constant ab : Seq.seq t_T
  
  constant b : t_Intersection_T_S_Global
  
  constant bc : Seq.seq t_T
  
  constant c : t_Intersection_T_S_Global
  
  function produces_trans_Intersection_T_S_Global (a: t_Intersection_T_S_Global) (ab: Seq.seq t_T) (b: t_Intersection_T_S_Global) (bc: Seq.seq t_T) (c: t_Intersection_T_S_Global) : ()
  
  goal vc_produces_trans_Intersection_T_S_Global: produces_Intersection_T_S_Global a ab b
    -> produces_Intersection_T_S_Global b bc c
    -> ([@stop_split] [@expl:set_produces_trans requires] ([@stop_split] [@expl:set_produces_trans requires #0] set_produces_ref_T a ab b)
      /\ ([@stop_split] [@expl:set_produces_trans requires #1] set_produces_ref_T b bc c))
    /\ (([@stop_split] [@expl:set_produces_trans ensures] set_produces_ref_T a (Seq.(++) ab bc) c)
    -> (let _ = set_produces_trans_ref_T a ab b bc c in [@stop_split] [@expl:produces_trans ensures] produces_Intersection_T_S_Global a (Seq.(++) ab bc) c))
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S_Global__produces_refl (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Difference_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S_Global (self: t_Difference_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S_Global) (visited: Seq.seq t_T) (end': t_Difference_T_S_Global) =
    Fset.cardinal (view_Difference_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Difference_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global end') x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S_Global (self: t_Difference_T_S_Global) (visited: Seq.seq t_T) (o: t_Difference_T_S_Global) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Difference_T_S_Global
  
  function produces_refl_Difference_T_S_Global (self: t_Difference_T_S_Global) : ()
  
  goal vc_produces_refl_Difference_T_S_Global:
    [@stop_split] [@expl:produces_refl ensures] produces_Difference_T_S_Global self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S_Global__produces_trans (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Difference_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S_Global (self: t_Difference_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S_Global) (visited: Seq.seq t_T) (end': t_Difference_T_S_Global) =
    Fset.cardinal (view_Difference_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Difference_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global end') x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S_Global (self: t_Difference_T_S_Global) (visited: Seq.seq t_T) (o: t_Difference_T_S_Global) =
    set_produces_ref_T self visited o
  
  constant concat_contains_ref_T: () = ()
  
  axiom concat_contains_ref_T_spec: forall a: Seq.seq t_T, b: Seq.seq t_T, x: t_T. contains_ref_T (Seq.(++) a b) x
        = contains_ref_T a x
      \/ contains_ref_T b x
  
  function set_produces_trans_ref_T (a: t_Difference_T_S_Global) (ab: Seq.seq t_T) (b: t_Difference_T_S_Global) (bc: Seq.seq t_T) (c: t_Difference_T_S_Global) : ()
   = let _ = concat_contains_ref_T in ()
  
  axiom set_produces_trans_ref_T_spec:
    forall a: t_Difference_T_S_Global, ab: Seq.seq t_T, b: t_Difference_T_S_Global, bc: Seq.seq t_T, c: t_Difference_T_S_Global. set_produces_ref_T a ab b
      -> set_produces_ref_T b bc c -> set_produces_ref_T a (Seq.(++) ab bc) c
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Difference_T_S_Global
  
  constant ab : Seq.seq t_T
  
  constant b : t_Difference_T_S_Global
  
  constant bc : Seq.seq t_T
  
  constant c : t_Difference_T_S_Global
  
  function produces_trans_Difference_T_S_Global (a: t_Difference_T_S_Global) (ab: Seq.seq t_T) (b: t_Difference_T_S_Global) (bc: Seq.seq t_T) (c: t_Difference_T_S_Global) : ()
  
  goal vc_produces_trans_Difference_T_S_Global: produces_Difference_T_S_Global a ab b
    -> produces_Difference_T_S_Global b bc c
    -> ([@stop_split] [@expl:set_produces_trans requires] ([@stop_split] [@expl:set_produces_trans requires #0] set_produces_ref_T a ab b)
      /\ ([@stop_split] [@expl:set_produces_trans requires #1] set_produces_ref_T b bc c))
    /\ (([@stop_split] [@expl:set_produces_trans ensures] set_produces_ref_T a (Seq.(++) ab bc) c)
    -> (let _ = set_produces_trans_ref_T a ab b bc c in [@stop_split] [@expl:produces_trans ensures] produces_Difference_T_S_Global a (Seq.(++) ab bc) c))
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_refl (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant self : t_Iter_T
  
  function produces_refl_Iter_T (self: t_Iter_T) : ()
  
  goal vc_produces_refl_Iter_T:
    [@stop_split] [@expl:produces_refl ensures] produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_trans (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  constant a : t_Iter_T
  
  constant ab : Seq.seq t_T
  
  constant b : t_Iter_T
  
  constant bc : Seq.seq t_T
  
  constant c : t_Iter_T
  
  function produces_trans_Iter_T (a: t_Iter_T) (ab: Seq.seq t_T) (b: t_Iter_T) (bc: Seq.seq t_T) (c: t_Iter_T) : ()
  
  goal vc_produces_trans_Iter_T: produces_Iter_T a ab b
    -> produces_Iter_T b bc c -> ([@stop_split] [@expl:produces_trans ensures] produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__io__extern_spec_std_io_print_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Arguments
  
  predicate inv_Arguments (_1: t_Arguments)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_io__print_body (args: t_Arguments) (return (x: ())) =
    {[@stop_split] [@expl:extern_spec_std_io__print_body 'args' type invariant] inv_Arguments args}
    (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_std__io__extern_spec_std_io_eprint_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Arguments
  
  predicate inv_Arguments (_1: t_Arguments)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_std_io__eprint_body (args: t_Arguments) (return (x: ())) =
    {[@stop_split] [@expl:extern_spec_std_io__eprint_body 'args' type invariant] inv_Arguments args}
    (! bb0
    [ bb0 = return {_ret} ] [ & _ret: () = Any.any_l () ]) [ return (result: ()) -> (! return {result}) ]
end
module M_std__sync__extern_spec_T_A_Deref_Arc_T_A_deref_body
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Any
  
  type t_Arc_T_A
  
  type t_T
  
  predicate inv_Arc_T_A (_1: t_Arc_T_A)
  
  predicate invariant_ref_Arc_T_A [@inline:trivial] (self: t_Arc_T_A) = inv_Arc_T_A self
  
  meta "rewrite_def" predicate invariant_ref_Arc_T_A
  
  predicate inv_ref_Arc_T_A [@inline:trivial] (_1: t_Arc_T_A) = invariant_ref_Arc_T_A _1
  
  meta "rewrite_def" predicate inv_ref_Arc_T_A
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  function view_Arc_T_A (self: t_Arc_T_A) : t_T
  
  let rec as_ref_Arc_T_A (self_: t_Arc_T_A) (return (x: t_T)) =
    {[@stop_split] [@expl:as_ref 'self_' type invariant] inv_ref_Arc_T_A self_}
    any
    [ return (result: t_T) ->
    {[@stop_split] [@expl:as_ref_Arc_T_A ensures] ([@stop_split] [@expl:as_ref result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:as_ref ensures] result = view_Arc_T_A self_)}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  let rec extern_spec_T_A_Deref_Arc_T_A_deref_body_T (self_: t_Arc_T_A) (return (x: t_T)) =
    {[@stop_split] [@expl:extern_spec_T_A_Deref_Arc_T_A_deref_body 'self_' type invariant] inv_ref_Arc_T_A self_}
    (! bb0
    [ bb0 = s0
      [ s0 = as_ref_Arc_T_A {self_} (fun (_x: t_T) -> [ &_4 <- _x ] s1)
      | s1 = [ &_ret <- _4 ] s2
      | s2 = return {_ret} ] ] [ & _ret: t_T = Any.any_l () | & self_: t_Arc_T_A = self_ | & _4: t_T = Any.any_l () ])
    [ return (result: t_T) ->
    {[@stop_split] [@expl:extern_spec_T_A_Deref_Arc_T_A_deref_body_T ensures] ([@stop_split] [@expl:extern_spec_T_A_Deref_Arc_T_A_deref_body result type invariant] inv_ref_T result)
      /\ ([@stop_split] [@expl:extern_spec_T_A_Deref_Arc_T_A_deref_body ensures] result = view_Arc_T_A self_)}
      (! return {result}) ]
end
module M_ghost__fn_ghost__impl_Clone_for_FnGhostWrapper_F__clone__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_ref_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) = inv_FnGhostWrapper_F self
  
  meta "rewrite_def" predicate invariant_ref_FnGhostWrapper_F
  
  predicate inv_ref_FnGhostWrapper_F [@inline:trivial] (_1: t_FnGhostWrapper_F) = invariant_ref_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_ref_FnGhostWrapper_F
  
  predicate postcondition_once_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef:
    forall args: t_F, res: t_F [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_F res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_F) (result_state: ()) (result: t_F)
  
  axiom postcondition_fndef'0:
    forall args: t_F, res: t_F [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_F res)
  
  function fn_mut_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_F) (result: t_F)
  
  axiom postcondition_fndef'1:
    forall args: t_F, res: t_F [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_F res)
  
  function fn_once_clone (self: ()) (args: t_F) (res: t_F) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_F, res: t_F. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_F) (res_state: ()) (res: t_F) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_F, res_state: (), res: t_F. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate invariant_ref_F [@inline:trivial] (self: t_F) = inv_F self
  
  meta "rewrite_def" predicate invariant_ref_F
  
  predicate inv_ref_F [@inline:trivial] (_1: t_F) = invariant_ref_F _1
  
  meta "rewrite_def" predicate inv_ref_F
  
  predicate precondition_clone (self: ()) (args: t_F)
  
  axiom precondition_fndef: forall args: t_F [precondition_clone () args]. (let self_ = args in inv_ref_F self_)
      -> precondition_clone () args
  
  let rec clone_F (self_: t_F) (return (x: t_F)) = {[@stop_split] [@expl:clone requires] precondition_clone () self_}
    any
    [ return (result: t_F) -> {[@stop_split] [@expl:clone ensures] postcondition_once_clone () self_ result}
      (! return {result}) ]
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper_F. inv_ref_FnGhostWrapper_F self_
      -> inv_ref_FnGhostWrapper_F self_
      /\ (forall result: t_FnGhostWrapper_F. inv_FnGhostWrapper_F result /\ postcondition_clone () self_.f0 result.f0
        -> inv_FnGhostWrapper_F result)
end
module M_ghost__impl_Clone_for_Ghost_T__clone__refines (* <ghost::Ghost<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Ghost_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_Ghost_T
  
  predicate inv_Ghost_T [@inline:trivial] (_1: t_T) = invariant_Ghost_T _1
  
  meta "rewrite_def" predicate inv_Ghost_T
  
  predicate invariant_ref_Ghost_T [@inline:trivial] (self: t_T) = inv_Ghost_T self
  
  meta "rewrite_def" predicate invariant_ref_Ghost_T
  
  predicate inv_ref_Ghost_T [@inline:trivial] (_1: t_T) = invariant_ref_Ghost_T _1
  
  meta "rewrite_def" predicate inv_ref_Ghost_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_T. inv_ref_Ghost_T self_
      -> inv_ref_Ghost_T self_ /\ (forall result: t_T. inv_Ghost_T result /\ result = self_ -> inv_Ghost_T result)
end
module M_logic__fmap__impl_Clone_for_FMap_K_V__clone__refines (* <logic::fmap::FMap<K, V> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_ref_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) = inv_FMap_K_V self
  
  meta "rewrite_def" predicate invariant_ref_FMap_K_V
  
  predicate inv_ref_FMap_K_V [@inline:trivial] (_1: t_FMap_K_V) = invariant_ref_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_ref_FMap_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FMap_K_V. inv_ref_FMap_K_V self_
      -> inv_ref_FMap_K_V self_
      /\ (forall result: t_FMap_K_V. inv_FMap_K_V result /\ result = self_ -> inv_FMap_K_V result)
end
module M_logic__fset__impl_Clone_for_FSet_T__clone__refines (* <logic::fset::FSet<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_FSet_T [@inline:trivial] (self: Fset.fset t_T) = forall x: t_T. contains_T self x -> inv_T x
  
  meta "rewrite_def" predicate invariant_FSet_T
  
  predicate inv_FSet_T [@inline:trivial] (_1: Fset.fset t_T) = invariant_FSet_T _1
  
  meta "rewrite_def" predicate inv_FSet_T
  
  predicate invariant_ref_FSet_T [@inline:trivial] (self: Fset.fset t_T) = inv_FSet_T self
  
  meta "rewrite_def" predicate invariant_ref_FSet_T
  
  predicate inv_ref_FSet_T [@inline:trivial] (_1: Fset.fset t_T) = invariant_ref_FSet_T _1
  
  meta "rewrite_def" predicate inv_ref_FSet_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: Fset.fset t_T. inv_ref_FSet_T self_
      -> inv_ref_FSet_T self_
      /\ (forall result: Fset.fset t_T. inv_FSet_T result /\ result = self_ -> inv_FSet_T result)
end
module M_logic__seq__impl_Clone_for_Seq_T__clone__refines (* <logic::seq::Seq<T> as std::clone::Clone> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: Seq.seq t_T. inv_ref_Seq_T self_
      -> inv_ref_Seq_T self_ /\ (forall result: Seq.seq t_T. inv_Seq_T result /\ result = self_ -> inv_Seq_T result)
end
module M_ghost__fn_ghost__impl_FnOnce_for_FnGhostWrapper_F__call_once__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::FnOnce<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  predicate precondition_F (self: t_F) (args: t_I)
  
  predicate precondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) =
    precondition_F self.f0 args
  
  meta "rewrite_def" predicate precondition_FnGhostWrapper_F
  
  type t_Output
  
  predicate inv_Output (_1: t_Output)
  
  predicate postcondition_once_F (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition_once_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) (result: t_Output) =
    postcondition_once_F self.f0 args result
  
  meta "rewrite_def" predicate postcondition_once_FnGhostWrapper_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper_F. forall arg: t_I. inv_FnGhostWrapper_F self_
          /\ inv_I arg /\ precondition_FnGhostWrapper_F self_ arg
        -> inv_FnGhostWrapper_F self_
        /\ inv_I arg
        /\ precondition_FnGhostWrapper_F self_ arg
        /\ (forall result: t_Output. inv_Output result /\ postcondition_once_FnGhostWrapper_F self_ arg result
          -> inv_Output result /\ postcondition_once_FnGhostWrapper_F self_ arg result)
end
module M_ghost__fn_ghost__impl_FnMut_for_FnGhostWrapper_F__call_mut__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::FnMut<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_refmut_FnGhostWrapper_F [@inline:trivial] (self: MutBorrow.t t_FnGhostWrapper_F) =
    inv_FnGhostWrapper_F self.current /\ inv_FnGhostWrapper_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_FnGhostWrapper_F
  
  predicate inv_refmut_FnGhostWrapper_F [@inline:trivial] (_1: MutBorrow.t t_FnGhostWrapper_F) =
    invariant_refmut_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_refmut_FnGhostWrapper_F
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  predicate precondition_F (self: t_F) (args: t_I)
  
  predicate precondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) =
    precondition_F self.f0 args
  
  meta "rewrite_def" predicate precondition_FnGhostWrapper_F
  
  type t_Output
  
  predicate inv_Output (_1: t_Output)
  
  predicate postcondition_mut_F (self: t_F) (args: t_I) (result_state: t_F) (result: t_Output)
  
  predicate postcondition_mut_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) (result_state: t_FnGhostWrapper_F) (result: t_Output) =
    postcondition_mut_F self.f0 args result_state.f0 result
  
  meta "rewrite_def" predicate postcondition_mut_FnGhostWrapper_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_FnGhostWrapper_F. forall arg: t_I. inv_refmut_FnGhostWrapper_F self_
          /\ inv_I arg /\ precondition_FnGhostWrapper_F self_.current arg
        -> inv_refmut_FnGhostWrapper_F self_
        /\ inv_I arg
        /\ precondition_FnGhostWrapper_F self_.current arg
        /\ (forall result: t_Output. inv_Output result
            /\ postcondition_mut_FnGhostWrapper_F self_.current arg self_.final result
          -> inv_Output result /\ postcondition_mut_FnGhostWrapper_F self_.current arg self_.final result)
end
module M_ghost__fn_ghost__impl_Fn_for_FnGhostWrapper_F__call__refines (* <ghost::fn_ghost::FnGhostWrapper<F> as std::ops::Fn<I>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_FnGhostWrapper_F = { f0: t_F }
  
  predicate inv_F (_1: t_F)
  
  predicate inv_FnGhostWrapper_F (_1: t_FnGhostWrapper_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_FnGhostWrapper_F [inv_FnGhostWrapper_F x]. inv_FnGhostWrapper_F x = inv_F x.f0
  
  predicate invariant_ref_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) = inv_FnGhostWrapper_F self
  
  meta "rewrite_def" predicate invariant_ref_FnGhostWrapper_F
  
  predicate inv_ref_FnGhostWrapper_F [@inline:trivial] (_1: t_FnGhostWrapper_F) = invariant_ref_FnGhostWrapper_F _1
  
  meta "rewrite_def" predicate inv_ref_FnGhostWrapper_F
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  predicate precondition_F (self: t_F) (args: t_I)
  
  predicate precondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) =
    precondition_F self.f0 args
  
  meta "rewrite_def" predicate precondition_FnGhostWrapper_F
  
  type t_Output
  
  predicate inv_Output (_1: t_Output)
  
  predicate postcondition_F (self: t_F) (args: t_I) (result: t_Output)
  
  predicate postcondition_FnGhostWrapper_F [@inline:trivial] (self: t_FnGhostWrapper_F) (args: t_I) (result: t_Output) =
    postcondition_F self.f0 args result
  
  meta "rewrite_def" predicate postcondition_FnGhostWrapper_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_FnGhostWrapper_F. forall arg: t_I. inv_ref_FnGhostWrapper_F self_
          /\ inv_I arg /\ precondition_FnGhostWrapper_F self_ arg
        -> inv_ref_FnGhostWrapper_F self_
        /\ inv_I arg
        /\ precondition_FnGhostWrapper_F self_ arg
        /\ (forall result: t_Output. inv_Output result /\ postcondition_FnGhostWrapper_F self_ arg result
          -> inv_Output result /\ postcondition_FnGhostWrapper_F self_ arg result)
end
module M_ghost__invariant__impl_Plain_for_Namespace__into_ghost__refines (* <ghost::invariant::Namespace as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: t_Namespace. forall result: t_Namespace. result = snap -> result = snap
end
module M_ghost__impl_Plain_for_bool__into_ghost__refines (* <bool as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: bool. forall result: bool. result = snap -> result = snap
end
module M_ghost__impl_Plain_for_ptr_T__into_ghost__refines (* <*const T as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Opaque.ptr. forall result: Opaque.ptr. result = snap -> result = snap
end
module M_ghost__impl_Plain_for_ptr_T_0__into_ghost__refines (* <*mut T as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Opaque.ptr. forall result: Opaque.ptr. result = snap -> result = snap
end
module M_logic__id__impl_Plain_for_Id__into_ghost__refines (* <logic::id::Id as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: t_Id. forall result: t_Id. result = snap -> result = snap
end
module M_logic__int__impl_Plain_for_Int__into_ghost__refines (* <logic::int::Int as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: int. forall result: int. result = snap -> result = snap
end
module M_logic__seq__impl_Plain_for_Seq_T__into_ghost__refines (* <logic::seq::Seq<T> as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_Ghost_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_Ghost_Seq_T
  
  predicate inv_Ghost_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Ghost_Seq_T _1
  
  meta "rewrite_def" predicate inv_Ghost_Seq_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Seq.seq t_T. forall result: Seq.seq t_T. inv_Ghost_Seq_T result /\ result = snap
        -> inv_Ghost_Seq_T result /\ result = snap
end
module M_std__char__impl_Plain_for_char__into_ghost__refines (* <char as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Char.t. forall result: Char.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_u8__into_ghost__refines (* <u8 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: UInt8.t. forall result: UInt8.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_u16__into_ghost__refines (* <u16 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: UInt16.t. forall result: UInt16.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_u32__into_ghost__refines (* <u32 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: UInt32.t. forall result: UInt32.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_u64__into_ghost__refines (* <u64 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: UInt64.t. forall result: UInt64.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_u128__into_ghost__refines (* <u128 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: UInt128.t. forall result: UInt128.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_usize__into_ghost__refines (* <usize as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: UInt64.t. forall result: UInt64.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_i8__into_ghost__refines (* <i8 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Int8.t. forall result: Int8.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_i16__into_ghost__refines (* <i16 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Int16.t. forall result: Int16.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_i32__into_ghost__refines (* <i32 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Int32.t. forall result: Int32.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_i64__into_ghost__refines (* <i64 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Int64.t. forall result: Int64.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_i128__into_ghost__refines (* <i128 as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Int128.t. forall result: Int128.t. result = snap -> result = snap
end
module M_std__num__impl_Plain_for_isize__into_ghost__refines (* <isize as ghost::Plain> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall snap: Int64.t. forall result: Int64.t. result = snap -> result = snap
end
module M_ghost__perm__impl_Resolve_for_Perm_C__resolve_coherence__refines (* <ghost::perm::Perm<C> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Perm_C
  
  predicate inv_Perm_C (_1: t_Perm_C)
  
  predicate structural_resolve_Perm_C (_1: t_Perm_C)
  
  type t_Value
  
  predicate resolve_ref_Value [@inline:trivial] (_1: t_Value) = true
  
  meta "rewrite_def" predicate resolve_ref_Value
  
  function val_C (self: t_Perm_C) : t_Value
  
  predicate resolve_Perm_C [@inline:trivial] (self: t_Perm_C) = resolve_ref_Value (val_C self)
  
  meta "rewrite_def" predicate resolve_Perm_C
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Perm_C. inv_Perm_C self /\ structural_resolve_Perm_C self
      -> inv_Perm_C self
      /\ structural_resolve_Perm_C self /\ (forall result: (). resolve_Perm_C self -> resolve_Perm_C self)
end
module M_invariant__impl_Resolve_for_Subset_T__resolve_coherence__refines (* <invariant::Subset<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_T
  
  predicate inv_Subset_T [@inline:trivial] (_1: t_Subset_T) = true
  
  meta "rewrite_def" predicate inv_Subset_T
  
  predicate structural_resolve_Subset_T (_1: t_Subset_T)
  
  type t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate invariant_T (self: t_T)
  
  function inner_T (self: t_Subset_T) : t_T
  
  axiom inner_T_spec: forall self: t_Subset_T. invariant_T (inner_T self)
  
  predicate resolve_Subset_T [@inline:trivial] (self: t_Subset_T) = resolve_T (inner_T self)
  
  meta "rewrite_def" predicate resolve_Subset_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Subset_T. inv_Subset_T self /\ structural_resolve_Subset_T self
      -> structural_resolve_Subset_T self /\ (forall result: (). resolve_Subset_T self -> resolve_Subset_T self)
end
module M_logic__fmap__impl_Resolve_for_FMap_K_V__resolve_coherence__refines (* <logic::fmap::FMap<K, V> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate structural_resolve_FMap_K_V (_1: t_FMap_K_V)
  
  predicate resolve_K (_1: t_K)
  
  predicate resolve_V (_1: t_V)
  
  predicate resolve_FMap_K_V (self: t_FMap_K_V) =
    forall k: t_K, v: t_V. get_K self k = Some v -> resolve_K k /\ resolve_V v
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. inv_FMap_K_V self /\ structural_resolve_FMap_K_V self
      -> structural_resolve_FMap_K_V self /\ (forall result: (). resolve_FMap_K_V self -> resolve_FMap_K_V self)
end
module M_logic__fset__impl_Resolve_for_FSet_T__resolve_coherence__refines (* <logic::fset::FSet<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use set.Fset
  
  type t_T
  
  predicate contains_T [@inline:trivial] (self: Fset.fset t_T) (e: t_T) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_FSet_T [@inline:trivial] (self: Fset.fset t_T) = forall x: t_T. contains_T self x -> inv_T x
  
  meta "rewrite_def" predicate invariant_FSet_T
  
  predicate inv_FSet_T [@inline:trivial] (_1: Fset.fset t_T) = invariant_FSet_T _1
  
  meta "rewrite_def" predicate inv_FSet_T
  
  predicate structural_resolve_FSet_T (_1: Fset.fset t_T)
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_FSet_T (self: Fset.fset t_T) = forall x: t_T. contains_T self x -> resolve_T x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Fset.fset t_T. inv_FSet_T self /\ structural_resolve_FSet_T self
      -> structural_resolve_FSet_T self /\ (forall result: (). resolve_FSet_T self -> resolve_FSet_T self)
end
module M_logic__seq__impl_Resolve_for_Seq_T__resolve_coherence__refines (* <logic::seq::Seq<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate structural_resolve_Seq_T (_1: Seq.seq t_T)
  
  type t_Option_T = None | Some t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  predicate resolve_Seq_T (self: Seq.seq t_T) = forall i: int. resolve_Option_T (get_T self i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Seq.seq t_T. inv_Seq_T self /\ structural_resolve_Seq_T self
      -> structural_resolve_Seq_T self /\ (forall result: (). resolve_Seq_T self -> resolve_Seq_T self)
end
module M_logic__seq__impl_Resolve_for_SeqIter_T__resolve_coherence__refines (* <logic::seq::SeqIter<T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  type t_Option_T = None | Some t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_Option_T (_1: t_Option_T)
  
  axiom resolve_axiom [@rewrite]: forall x: t_Option_T [resolve_Option_T x]. resolve_Option_T x
      = match x with
        | None -> true
        | Some x0 -> resolve_T x0
        end
  
  function get_T (self: Seq.seq t_T) (ix: int) : t_Option_T = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  predicate resolve_Seq_T (self: Seq.seq t_T) = forall i: int. resolve_Option_T (get_T self i)
  
  predicate resolve_Seq_T'0 (_1: Seq.seq t_T)
  
  axiom resolve_axiom'0: forall x: Seq.seq t_T [resolve_Seq_T'0 x]. resolve_Seq_T'0 x -> resolve_Seq_T x
  
  predicate structural_resolve_SeqIter_T (_1: t_SeqIter_T) = resolve_Seq_T'0 _1.inner
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate resolve_SeqIter_T [@inline:trivial] (self: t_SeqIter_T) = resolve_Seq_T'0 (view_SeqIter_T self)
  
  meta "rewrite_def" predicate resolve_SeqIter_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIter_T. inv_SeqIter_T self /\ structural_resolve_SeqIter_T self
      -> structural_resolve_SeqIter_T self /\ (forall result: (). resolve_SeqIter_T self -> resolve_SeqIter_T self)
end
module M_resolve__impl_Resolve_for_ref_T__resolve_coherence__refines (* <&'a T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate structural_resolve_ref_T (_1: t_T) = true
  
  predicate resolve_ref_T (self: t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_T. inv_ref_T self /\ structural_resolve_ref_T self
      -> (forall result: (). resolve_ref_T self -> resolve_ref_T self)
end
module M_resolve__impl_Resolve_for_refmut_T__resolve_coherence__refines (* <&'a mut T as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_refmut_T [@inline:trivial] (self: MutBorrow.t t_T) = inv_T self.current /\ inv_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_T
  
  predicate inv_refmut_T [@inline:trivial] (_1: MutBorrow.t t_T) = invariant_refmut_T _1
  
  meta "rewrite_def" predicate inv_refmut_T
  
  predicate structural_resolve_refmut_T (_1: MutBorrow.t t_T) = _1.final = _1.current
  
  predicate resolve_refmut_T (self: MutBorrow.t t_T) = true
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_T. inv_refmut_T self /\ structural_resolve_refmut_T self
      -> (forall result: (). resolve_refmut_T self -> resolve_refmut_T self)
end
module M_std__array__impl_Resolve_for_array_T_n__resolve_coherence__refines (* <[T; N] as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  constant const_N : UInt64.t
  
  predicate invariant_array_T_n (self: Slice64.array t_T) =
    inv_Seq_T (Slice64.view self) /\ Seq.length (Slice64.view self) = UInt64.t'int const_N
  
  predicate inv_array_T_n [@inline:trivial] (_1: Slice64.array t_T) = invariant_array_T_n _1
  
  meta "rewrite_def" predicate inv_array_T_n
  
  predicate structural_resolve_array_T_n (_1: Slice64.array t_T)
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_array_T_n [@inline:trivial] (self: Slice64.array t_T) =
    forall i: int. 0 <= i /\ i < UInt64.t'int const_N -> resolve_T (Seq.get (Slice64.view self) i)
  
  meta "rewrite_def" predicate resolve_array_T_n
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.array t_T. inv_array_T_n self /\ structural_resolve_array_T_n self
      -> structural_resolve_array_T_n self /\ (forall result: (). resolve_array_T_n self -> resolve_array_T_n self)
end
module M_std__boxed__impl_Resolve_for_Box_T_A__resolve_coherence__refines (* <std::boxed::Box<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_Box_T_A (self: t_T) = inv_T self
  
  predicate inv_Box_T_A [@inline:trivial] (_1: t_T) = invariant_Box_T_A _1
  
  meta "rewrite_def" predicate inv_Box_T_A
  
  predicate resolve_T (_1: t_T)
  
  predicate structural_resolve_Box_T_A (_1: t_T) = resolve_T _1
  
  predicate resolve_Box_T_A [@inline:trivial] (self: t_T) = true
  
  meta "rewrite_def" predicate resolve_Box_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_T. inv_Box_T_A self /\ structural_resolve_Box_T_A self
      -> structural_resolve_Box_T_A self /\ (forall result: (). resolve_Box_T_A self -> resolve_Box_T_A self)
end
module M_std__iter__cloned__impl_Resolve_for_Cloned_I__resolve_coherence__refines (* <std::iter::Cloned<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Cloned_I
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate invariant_Cloned_I [@inline:trivial] (self: t_Cloned_I) = inv_I (iter_Cloned_I self)
  
  meta "rewrite_def" predicate invariant_Cloned_I
  
  predicate inv_Cloned_I (_1: t_Cloned_I)
  
  axiom inv_axiom: forall x: t_Cloned_I [inv_Cloned_I x]. inv_Cloned_I x -> invariant_Cloned_I x
  
  predicate structural_resolve_Cloned_I (_1: t_Cloned_I)
  
  predicate resolve_I (_1: t_I)
  
  predicate resolve_Cloned_I [@inline:trivial] (self: t_Cloned_I) = resolve_I (iter_Cloned_I self)
  
  meta "rewrite_def" predicate resolve_Cloned_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Cloned_I. inv_Cloned_I self /\ structural_resolve_Cloned_I self
      -> structural_resolve_Cloned_I self /\ (forall result: (). resolve_Cloned_I self -> resolve_Cloned_I self)
end
module M_std__iter__copied__impl_Resolve_for_Copied_I__resolve_coherence__refines (* <std::iter::Copied<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Copied_I
  
  type t_I
  
  predicate inv_I (_1: t_I)
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate invariant_Copied_I [@inline:trivial] (self: t_Copied_I) = inv_I (iter_Copied_I self)
  
  meta "rewrite_def" predicate invariant_Copied_I
  
  predicate inv_Copied_I (_1: t_Copied_I)
  
  axiom inv_axiom: forall x: t_Copied_I [inv_Copied_I x]. inv_Copied_I x -> invariant_Copied_I x
  
  predicate structural_resolve_Copied_I (_1: t_Copied_I)
  
  predicate resolve_I (_1: t_I)
  
  predicate resolve_Copied_I [@inline:trivial] (self: t_Copied_I) = resolve_I (iter_Copied_I self)
  
  meta "rewrite_def" predicate resolve_Copied_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Copied_I. inv_Copied_I self /\ structural_resolve_Copied_I self
      -> structural_resolve_Copied_I self /\ (forall result: (). resolve_Copied_I self -> resolve_Copied_I self)
end
module M_std__iter__enumerate__impl_Resolve_for_Enumerate_I__resolve_coherence__refines (* <std::iter::Enumerate<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Enumerate_I
  
  predicate inv_Enumerate_I (_1: t_Enumerate_I)
  
  predicate structural_resolve_Enumerate_I (_1: t_Enumerate_I)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate resolve_Enumerate_I [@inline:trivial] (self: t_Enumerate_I) = resolve_I (iter_Enumerate_I self)
  
  meta "rewrite_def" predicate resolve_Enumerate_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Enumerate_I. inv_Enumerate_I self /\ structural_resolve_Enumerate_I self
      -> structural_resolve_Enumerate_I self
      /\ (forall result: (). resolve_Enumerate_I self -> resolve_Enumerate_I self)
end
module M_std__iter__map__impl_Resolve_for_Map_I_F__resolve_coherence__refines (* <std::iter::Map<I, F> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Map_I_F
  
  predicate inv_Map_I_F (_1: t_Map_I_F)
  
  predicate structural_resolve_Map_I_F (_1: t_Map_I_F)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  type t_F
  
  predicate resolve_F (_1: t_F)
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  predicate resolve_Map_I_F [@inline:trivial] (self: t_Map_I_F) =
    resolve_I (iter_Map_I_F self) /\ resolve_F (func_Map_I_F self)
  
  meta "rewrite_def" predicate resolve_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map_I_F. inv_Map_I_F self /\ structural_resolve_Map_I_F self
      -> structural_resolve_Map_I_F self /\ (forall result: (). resolve_Map_I_F self -> resolve_Map_I_F self)
end
module M_std__iter__skip__impl_Resolve_for_Skip_I__resolve_coherence__refines (* <std::iter::Skip<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Skip_I
  
  predicate inv_Skip_I (_1: t_Skip_I)
  
  predicate structural_resolve_Skip_I (_1: t_Skip_I)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Skip_I [@inline:trivial] (self: t_Skip_I) = resolve_I (iter_Skip_I self)
  
  meta "rewrite_def" predicate resolve_Skip_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Skip_I. inv_Skip_I self /\ structural_resolve_Skip_I self
      -> structural_resolve_Skip_I self /\ (forall result: (). resolve_Skip_I self -> resolve_Skip_I self)
end
module M_std__iter__take__impl_Resolve_for_Take_I__resolve_coherence__refines (* <std::iter::Take<I> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Take_I
  
  predicate inv_Take_I (_1: t_Take_I)
  
  predicate structural_resolve_Take_I (_1: t_Take_I)
  
  type t_I
  
  predicate resolve_I (_1: t_I)
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate resolve_Take_I [@inline:trivial] (self: t_Take_I) = resolve_I (iter_Take_I self)
  
  meta "rewrite_def" predicate resolve_Take_I
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Take_I. inv_Take_I self /\ structural_resolve_Take_I self
      -> structural_resolve_Take_I self /\ (forall result: (). resolve_Take_I self -> resolve_Take_I self)
end
module M_std__slice__impl_Resolve_for_slice_T__resolve_coherence__refines (* <[T] as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate structural_resolve_slice_T (_1: Slice64.slice t_T)
  
  predicate resolve_T (_1: t_T)
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  predicate resolve_slice_T [@inline:trivial] (self: Slice64.slice t_T) =
    forall i: int. 0 <= i /\ i < Seq.length (Slice64.view self) -> resolve_T (index_slice_T self i)
  
  meta "rewrite_def" predicate resolve_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.slice t_T. inv_slice_T self /\ structural_resolve_slice_T self
      -> structural_resolve_slice_T self /\ (forall result: (). resolve_slice_T self -> resolve_slice_T self)
end
module M_std__slice__impl_Resolve_for_IterMut_T__resolve_coherence__refines (* <std::slice::IterMut<'a, T> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  
  type t_IterMut_T
  
  predicate inv_IterMut_T (_1: t_IterMut_T)
  
  predicate structural_resolve_IterMut_T (_1: t_IterMut_T)
  
  type t_T
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate resolve_IterMut_T [@inline:trivial] (self: t_IterMut_T) =
    (view_IterMut_T self).current = (view_IterMut_T self).final
  
  meta "rewrite_def" predicate resolve_IterMut_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IterMut_T. inv_IterMut_T self /\ structural_resolve_IterMut_T self
      -> structural_resolve_IterMut_T self /\ (forall result: (). resolve_IterMut_T self -> resolve_IterMut_T self)
end
module M_std__vec__impl_Resolve_for_Vec_T_A__resolve_coherence__refines (* <std::vec::Vec<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Vec_T_A
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_Vec_T_A (self: t_Vec_T_A) : Seq.seq t_T
  
  axiom view_Vec_T_A_spec: forall self: t_Vec_T_A. Seq.length (view_Vec_T_A self) <= UInt64.t'int const_MAX
  
  predicate invariant_Vec_T_A (self: t_Vec_T_A) = inv_Seq_T (view_Vec_T_A self)
  
  predicate inv_Vec_T_A (_1: t_Vec_T_A)
  
  axiom inv_axiom: forall x: t_Vec_T_A [inv_Vec_T_A x]. inv_Vec_T_A x -> invariant_Vec_T_A x
  
  predicate structural_resolve_Vec_T_A (_1: t_Vec_T_A)
  
  predicate resolve_T (_1: t_T)
  
  function index_Vec_T_A [@inline:trivial] (self: t_Vec_T_A) (ix: int) : t_T = Seq.get (view_Vec_T_A self) ix
  
  meta "rewrite_def" function index_Vec_T_A
  
  predicate resolve_Vec_T_A [@inline:trivial] (self: t_Vec_T_A) =
    forall i: int. 0 <= i /\ i < Seq.length (view_Vec_T_A self) -> resolve_T (index_Vec_T_A self i)
  
  meta "rewrite_def" predicate resolve_Vec_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Vec_T_A. inv_Vec_T_A self /\ structural_resolve_Vec_T_A self
      -> structural_resolve_Vec_T_A self /\ (forall result: (). resolve_Vec_T_A self -> resolve_Vec_T_A self)
end
module M_std__vec__impl_Resolve_for_IntoIter_T_A__resolve_coherence__refines (* <std::vec::IntoIter<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_IntoIter_T_A
  
  predicate inv_IntoIter_T_A (_1: t_IntoIter_T_A)
  
  predicate structural_resolve_IntoIter_T_A (_1: t_IntoIter_T_A)
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate resolve_T (_1: t_T)
  
  predicate resolve_IntoIter_T_A [@inline:trivial] (self: t_IntoIter_T_A) =
    forall i: int. 0 <= i /\ i < Seq.length (view_IntoIter_T_A self) -> resolve_T (Seq.get (view_IntoIter_T_A self) i)
  
  meta "rewrite_def" predicate resolve_IntoIter_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T_A. inv_IntoIter_T_A self /\ structural_resolve_IntoIter_T_A self
      -> structural_resolve_IntoIter_T_A self
      /\ (forall result: (). resolve_IntoIter_T_A self -> resolve_IntoIter_T_A self)
end
module M_std__deque__impl_Resolve_for_VecDeque_T_A__resolve_coherence__refines (* <std::collections::VecDeque<T, A> as resolve::Resolve> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_VecDeque_T_A
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function view_VecDeque_T_A (self: t_VecDeque_T_A) : Seq.seq t_T
  
  axiom view_VecDeque_T_A_spec: forall self: t_VecDeque_T_A. Seq.length (view_VecDeque_T_A self)
      <= UInt64.t'int const_MAX
  
  predicate invariant_VecDeque_T_A (self: t_VecDeque_T_A) = inv_Seq_T (view_VecDeque_T_A self)
  
  predicate inv_VecDeque_T_A (_1: t_VecDeque_T_A)
  
  axiom inv_axiom: forall x: t_VecDeque_T_A [inv_VecDeque_T_A x]. inv_VecDeque_T_A x -> invariant_VecDeque_T_A x
  
  predicate structural_resolve_VecDeque_T_A (_1: t_VecDeque_T_A)
  
  predicate resolve_T (_1: t_T)
  
  function index_VecDeque_T_A [@inline:trivial] (self: t_VecDeque_T_A) (ix: int) : t_T =
    Seq.get (view_VecDeque_T_A self) ix
  
  meta "rewrite_def" function index_VecDeque_T_A
  
  predicate resolve_VecDeque_T_A [@inline:trivial] (self: t_VecDeque_T_A) =
    forall i: int. 0 <= i /\ i < Seq.length (view_VecDeque_T_A self) -> resolve_T (index_VecDeque_T_A self i)
  
  meta "rewrite_def" predicate resolve_VecDeque_T_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_VecDeque_T_A. inv_VecDeque_T_A self /\ structural_resolve_VecDeque_T_A self
      -> structural_resolve_VecDeque_T_A self
      /\ (forall result: (). resolve_VecDeque_T_A self -> resolve_VecDeque_T_A self)
end
module M_invariant__impl_PartialEq_for_Subset_T__eq__refines (* <invariant::Subset<T> as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_T
  
  type t_DeepModelTy
  
  type t_T
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate invariant_T (self: t_T)
  
  function inner_T (self: t_Subset_T) : t_T
  
  axiom inner_T_spec: forall self: t_Subset_T. invariant_T (inner_T self)
  
  function deep_model_Subset_T [@inline:trivial] (self: t_Subset_T) : t_DeepModelTy = deep_model_T (inner_T self)
  
  meta "rewrite_def" function deep_model_Subset_T
  
  function deep_model_ref_Subset_T [@inline:trivial] (self: t_Subset_T) : t_DeepModelTy = deep_model_Subset_T self
  
  meta "rewrite_def" function deep_model_ref_Subset_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Subset_T. forall rhs: t_Subset_T. forall result: bool. result
            = (deep_model_ref_Subset_T self_ = deep_model_ref_Subset_T rhs)
          -> result = (deep_model_ref_Subset_T self_ = deep_model_ref_Subset_T rhs)
end
module M_logic__id__impl_PartialEq_for_Id__eq__refines (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Id
  
  function deep_model_Id [@inline:trivial] (self: t_Id) : t_Id = self
  
  meta "rewrite_def" function deep_model_Id
  
  function deep_model_ref_Id [@inline:trivial] (self: t_Id) : t_Id = deep_model_Id self
  
  meta "rewrite_def" function deep_model_ref_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Id. forall rhs: t_Id. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model_ref_Id self_ = deep_model_ref_Id rhs)
end
module M_logic__id__impl_PartialEq_for_Id__ne__refines (* <logic::id::Id as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Id
  
  function deep_model_Id [@inline:trivial] (self: t_Id) : t_Id = self
  
  meta "rewrite_def" function deep_model_Id
  
  function deep_model_ref_Id [@inline:trivial] (self: t_Id) : t_Id = deep_model_Id self
  
  meta "rewrite_def" function deep_model_ref_Id
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_Id. forall rhs: t_Id. forall result: bool. result <> (self_ = rhs)
          -> result = (deep_model_ref_Id self_ <> deep_model_ref_Id rhs)
end
module M_logic__int__impl_PartialEq_for_Int__eq__refines (* <logic::int::Int as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall rhs: int. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model_ref_Int self_ = deep_model_ref_Int rhs)
end
module M_peano__impl_PartialEq_for_PeanoInt__eq__refines (* <peano::PeanoInt as std::cmp::PartialEq> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: bool. result = (self_ = rhs)
          -> result = (deep_model_ref_PeanoInt self_ = deep_model_ref_PeanoInt rhs)
end
module M_logic__fmap__impl_Iterator_for_FMap_K_V__next__refines (* <logic::fmap::FMap<K, V> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use map.Map
  use seq.Seq
  use map.Const
  use int.Int
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  predicate inv_K (_1: t_K)
  
  predicate inv_V (_1: t_V)
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function unwrap_Option_V (self: t_Option_V) : t_V = match self with
      | Some x -> x
      | None -> such_that_V (fun (__0: t_V) -> true)
      end
  
  function lookup_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_V = unwrap_Option_V (get_K self k)
  
  meta "rewrite_def" function lookup_K
  
  function index_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) (key: t_K) : t_V = lookup_K self key
  
  meta "rewrite_def" function index_FMap_K_V
  
  predicate invariant_FMap_K_V [@inline:trivial] (self: t_FMap_K_V) =
    forall k: t_K. contains_K self k -> inv_K k /\ inv_V (index_FMap_K_V self k)
  
  meta "rewrite_def" predicate invariant_FMap_K_V
  
  predicate inv_FMap_K_V (_1: t_FMap_K_V)
  
  axiom inv_axiom [@rewrite]: forall x: t_FMap_K_V [inv_FMap_K_V x]. inv_FMap_K_V x = invariant_FMap_K_V x
  
  predicate invariant_refmut_FMap_K_V [@inline:trivial] (self: MutBorrow.t t_FMap_K_V) =
    inv_FMap_K_V self.current /\ inv_FMap_K_V self.final
  
  meta "rewrite_def" predicate invariant_refmut_FMap_K_V
  
  predicate inv_refmut_FMap_K_V [@inline:trivial] (_1: MutBorrow.t t_FMap_K_V) = invariant_refmut_FMap_K_V _1
  
  meta "rewrite_def" predicate inv_refmut_FMap_K_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None'0 | Some'0 tup2_K_V
  
  predicate inv_tup2_K_V [@inline:trivial] (_1: tup2_K_V) = inv_K _1.f0 /\ inv_V _1.f1
  
  meta "rewrite_def" predicate inv_tup2_K_V
  
  predicate inv_Option_tup2_K_V (_1: t_Option_tup2_K_V)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_tup2_K_V [inv_Option_tup2_K_V x]. inv_Option_tup2_K_V x
      = match x with
        | None'0 -> true
        | Some'0 f0'0 -> inv_tup2_K_V f0'0
        end
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some'0 (Seq.get self ix)
    else
      None'0
  
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMap_K_V (self: t_FMap_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMap_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some'0 { f0 = k; f1 = v }
        -> not contains_K o k /\ get_K self k = Some v)
    /\ len_K self = Seq.length visited + len_K o
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K o k = get_K self k)
  
  function produces_trans_FMap_K_V (a: t_FMap_K_V) (ab: Seq.seq tup2_K_V) (b: t_FMap_K_V) (bc: Seq.seq tup2_K_V) (c: t_FMap_K_V) : ()
   = let ac = Seq.(++) ab bc in ()
  
  axiom produces_trans_FMap_K_V_spec:
    forall a: t_FMap_K_V, ab: Seq.seq tup2_K_V, b: t_FMap_K_V, bc: Seq.seq tup2_K_V, c: t_FMap_K_V. produces_FMap_K_V a ab b
      -> produces_FMap_K_V b bc c -> produces_FMap_K_V a (Seq.(++) ab bc) c
  
  function produces_refl_FMap_K_V (self: t_FMap_K_V) : () = ()
  
  axiom produces_refl_FMap_K_V_spec: forall self: t_FMap_K_V. produces_FMap_K_V self (Seq.empty: Seq.seq tup2_K_V) self
  
  predicate ext_eq_K (self: t_FMap_K_V) (other: t_FMap_K_V) = forall k: t_K. get_K self k = get_K other k
  
  axiom ext_eq_K_spec: forall self: t_FMap_K_V, other: t_FMap_K_V. ext_eq_K self other = (self = other)
  
  constant empty_K : t_FMap_K_V
  
  axiom empty_K_spec: len_K empty_K = 0
  
  axiom empty_K_spec'0: to_mapping_K empty_K = Const.const (None)
  
  predicate is_empty_K (self: t_FMap_K_V) = ext_eq_K self empty_K
  
  predicate completed_FMap_K_V (self: MutBorrow.t t_FMap_K_V) = is_empty_K self.current
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. to_mapping_K (insert_K self k v)
      = Map.set (to_mapping_K self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_FMap_K_V. inv_refmut_FMap_K_V self_
      -> inv_refmut_FMap_K_V self_
      /\ (forall result: t_Option_tup2_K_V. inv_Option_tup2_K_V result
          /\ match result with
            | None'0 -> completed_FMap_K_V self_
            | Some'0 {f0 = k; f1 = v} -> produces_FMap_K_V self_.current (Seq.singleton { f0 = k; f1 = v }) self_.final
            /\ self_.current = insert_K self_.final k v
            end
        -> inv_Option_tup2_K_V result
        /\ match result with
          | None'0 -> completed_FMap_K_V self_
          | Some'0 v -> produces_FMap_K_V self_.current (Seq.singleton v) self_.final
          end)
end
module M_logic__seq__impl_Iterator_for_SeqIter_T__next__refines (* <logic::seq::SeqIter<T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use int.Int
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate inv_SeqIter_T (_1: t_SeqIter_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIter_T [inv_SeqIter_T x]. inv_SeqIter_T x = inv_Seq_T x.inner
  
  predicate invariant_refmut_SeqIter_T [@inline:trivial] (self: MutBorrow.t t_SeqIter_T) =
    inv_SeqIter_T self.current /\ inv_SeqIter_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_SeqIter_T
  
  predicate inv_refmut_SeqIter_T [@inline:trivial] (_1: MutBorrow.t t_SeqIter_T) = invariant_refmut_SeqIter_T _1
  
  meta "rewrite_def" predicate inv_refmut_SeqIter_T
  
  type t_Option_T = None | Some t_T
  
  predicate inv_Option_T (_1: t_Option_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_T [inv_Option_T x]. inv_Option_T x
      = match x with
        | None -> true
        | Some f0 -> inv_T f0
        end
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  function produces_trans_SeqIter_T (a: t_SeqIter_T) (ab: Seq.seq t_T) (b: t_SeqIter_T) (bc: Seq.seq t_T) (c: t_SeqIter_T) : ()
   = ()
  
  axiom produces_trans_SeqIter_T_spec:
    forall a: t_SeqIter_T, ab: Seq.seq t_T, b: t_SeqIter_T, bc: Seq.seq t_T, c: t_SeqIter_T. produces_SeqIter_T a ab b
      -> produces_SeqIter_T b bc c -> produces_SeqIter_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIter_T (self: t_SeqIter_T) : () = ()
  
  axiom produces_refl_SeqIter_T_spec: forall self: t_SeqIter_T. produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIter_T (self: MutBorrow.t t_SeqIter_T) = view_SeqIter_T self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_SeqIter_T. inv_refmut_SeqIter_T self_
      -> inv_refmut_SeqIter_T self_
      /\ (forall result: t_Option_T. inv_Option_T result
          /\ match result with
            | None -> completed_SeqIter_T self_
            | Some v -> produces_SeqIter_T self_.current (Seq.singleton v) self_.final
            end
        -> inv_Option_T result
        /\ match result with
          | None -> completed_SeqIter_T self_
          | Some v -> produces_SeqIter_T self_.current (Seq.singleton v) self_.final
          end)
end
module M_logic__seq__impl_Iterator_for_SeqIterRef_T__next__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use int.Int
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  predicate invariant_SeqIterRef_T (self: t_SeqIterRef_T) = 0 <= self.index /\ self.index <= Seq.length self.inner
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_ref_Seq_T [@inline:trivial] (self: Seq.seq t_T) = inv_Seq_T self
  
  meta "rewrite_def" predicate invariant_ref_Seq_T
  
  predicate inv_ref_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_ref_Seq_T _1
  
  meta "rewrite_def" predicate inv_ref_Seq_T
  
  predicate inv_SeqIterRef_T (_1: t_SeqIterRef_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_SeqIterRef_T [inv_SeqIterRef_T x]. inv_SeqIterRef_T x
      = (invariant_SeqIterRef_T x /\ inv_ref_Seq_T x.inner)
  
  predicate invariant_refmut_SeqIterRef_T [@inline:trivial] (self: MutBorrow.t t_SeqIterRef_T) =
    inv_SeqIterRef_T self.current /\ inv_SeqIterRef_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_SeqIterRef_T
  
  predicate inv_refmut_SeqIterRef_T [@inline:trivial] (_1: MutBorrow.t t_SeqIterRef_T) =
    invariant_refmut_SeqIterRef_T _1
  
  meta "rewrite_def" predicate inv_refmut_SeqIterRef_T
  
  type t_Option_ref_T = None | Some t_T
  
  predicate inv_Option_ref_T (_1: t_Option_ref_T)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_ref_T [inv_Option_ref_T x]. inv_Option_ref_T x
      = match x with
        | None -> true
        | Some f0 -> inv_ref_T f0
        end
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  function produces_trans_SeqIterRef_T (a: t_SeqIterRef_T) (ab: Seq.seq t_T) (b: t_SeqIterRef_T) (bc: Seq.seq t_T) (c: t_SeqIterRef_T) : ()
   = ()
  
  axiom produces_trans_SeqIterRef_T_spec:
    forall a: t_SeqIterRef_T, ab: Seq.seq t_T, b: t_SeqIterRef_T, bc: Seq.seq t_T, c: t_SeqIterRef_T. produces_SeqIterRef_T a ab b
      -> produces_SeqIterRef_T b bc c -> produces_SeqIterRef_T a (Seq.(++) ab bc) c
  
  function produces_refl_SeqIterRef_T (self: t_SeqIterRef_T) : () = ()
  
  axiom produces_refl_SeqIterRef_T_spec:
    forall self: t_SeqIterRef_T. produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
  
  predicate completed_SeqIterRef_T (self: MutBorrow.t t_SeqIterRef_T) =
    view_SeqIterRef_T self.current = (Seq.empty: Seq.seq t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_SeqIterRef_T. inv_refmut_SeqIterRef_T self_
      -> inv_refmut_SeqIterRef_T self_
      /\ (forall result: t_Option_ref_T. inv_Option_ref_T result
          /\ match result with
            | None -> completed_SeqIterRef_T self_
            | Some v -> produces_SeqIterRef_T self_.current (Seq.singleton v) self_.final
            end
        -> inv_Option_ref_T result
        /\ match result with
          | None -> completed_SeqIterRef_T self_
          | Some v -> produces_SeqIterRef_T self_.current (Seq.singleton v) self_.final
          end)
end
module M_std__iter__map_inv__impl_Iterator_for_MapInv_I_F__next__refines (* <std::iter::map_inv::MapInv<I, F> as std::iter::Iterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate inv_Item (_1: t_Item)
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate precondition_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item)
  
  predicate next_precondition_I [@inline:trivial] (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall e: t_Item, i: t_I. inv_Item e /\ produces_I iter'0 (Seq.singleton e) i
      -> precondition_F func'0 { f0 = e; f1 = produced'0 }
  
  meta "rewrite_def" predicate next_precondition_I
  
  type t_B
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate invariant_Seq_Item [@inline:trivial] (self: Seq.seq t_Item) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_Item (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_Item
  
  predicate inv_Seq_Item [@inline:trivial] (_1: Seq.seq t_Item) = invariant_Seq_Item _1
  
  meta "rewrite_def" predicate inv_Seq_Item
  
  predicate inv_F (_1: t_F)
  
  predicate invariant_refmut_F [@inline:trivial] (self: MutBorrow.t t_F) = inv_F self.current /\ inv_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_F
  
  predicate inv_refmut_F [@inline:trivial] (_1: MutBorrow.t t_F) = invariant_refmut_F _1
  
  meta "rewrite_def" predicate inv_refmut_F
  
  predicate preservation_I [@inline:trivial] (iter'0: t_I) (func'0: t_F) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc s e1 }
  
  meta "rewrite_def" predicate preservation_I
  
  predicate reinitialize_I [@inline:trivial] =
    forall iter'0: MutBorrow.t t_I, func'0: t_F. completed_I iter'0
      -> next_precondition_I iter'0.final func'0 (Seq.empty: Seq.seq t_Item) /\ preservation_I iter'0.final func'0
  
  meta "rewrite_def" predicate reinitialize_I
  
  predicate preservation_inv_I (iter'0: t_I) (func'0: t_F) (produced'0: Seq.seq t_Item) =
    forall s: Seq.seq t_Item, e1: t_Item, e2: t_Item, f: MutBorrow.t t_F, b: t_B, i: t_I. hist_inv_F func'0 f.current
      -> inv_Seq_Item s /\ inv_Item e1 /\ inv_Item e2 /\ inv_refmut_F f
      -> produces_I iter'0 (Seq.snoc (Seq.snoc s e1) e2) i
      -> postcondition_mut_F f.current { f0 = e1; f1 = Seq.(++) produced'0 s } f.final b
      -> precondition_F f.final { f0 = e2; f1 = Seq.snoc (Seq.(++) produced'0 s) e1 }
  
  axiom preservation_inv_I_spec: forall iter'0: t_I, func'0: t_F, produced'0: Seq.seq t_Item. produced'0
        = (Seq.empty: Seq.seq t_Item) -> preservation_inv_I iter'0 func'0 produced'0 = preservation_I iter'0 func'0
  
  predicate invariant_MapInv_I_F (self: t_MapInv_I_F) =
    reinitialize_I
    /\ preservation_inv_I self.iter self.func self.produced /\ next_precondition_I self.iter self.func self.produced
  
  predicate inv_I (_1: t_I)
  
  predicate inv_MapInv_I_F (_1: t_MapInv_I_F)
  
  axiom inv_axiom [@rewrite]: forall x: t_MapInv_I_F [inv_MapInv_I_F x]. inv_MapInv_I_F x
      = (invariant_MapInv_I_F x /\ inv_I x.iter /\ inv_F x.func)
  
  predicate invariant_refmut_MapInv_I_F [@inline:trivial] (self: MutBorrow.t t_MapInv_I_F) =
    inv_MapInv_I_F self.current /\ inv_MapInv_I_F self.final
  
  meta "rewrite_def" predicate invariant_refmut_MapInv_I_F
  
  predicate inv_refmut_MapInv_I_F [@inline:trivial] (_1: MutBorrow.t t_MapInv_I_F) = invariant_refmut_MapInv_I_F _1
  
  meta "rewrite_def" predicate inv_refmut_MapInv_I_F
  
  type t_Option_B = None | Some t_B
  
  predicate inv_B (_1: t_B)
  
  predicate inv_Option_B (_1: t_Option_B)
  
  axiom inv_axiom'0 [@rewrite]: forall x: t_Option_B [inv_Option_B x]. inv_Option_B x
      = match x with
        | None -> true
        | Some f0'0 -> inv_B f0'0
        end
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  function produces_trans_MapInv_I_F (a: t_MapInv_I_F) (ab: Seq.seq t_B) (b: t_MapInv_I_F) (bc: Seq.seq t_B) (c: t_MapInv_I_F) : ()
   = ()
  
  axiom produces_trans_MapInv_I_F_spec:
    forall a: t_MapInv_I_F, ab: Seq.seq t_B, b: t_MapInv_I_F, bc: Seq.seq t_B, c: t_MapInv_I_F. produces_MapInv_I_F a ab b
      -> produces_MapInv_I_F b bc c -> produces_MapInv_I_F a (Seq.(++) ab bc) c
  
  function produces_refl_MapInv_I_F (self: t_MapInv_I_F) : () = ()
  
  axiom produces_refl_MapInv_I_F_spec: forall self: t_MapInv_I_F. produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
  
  predicate completed_MapInv_I_F (self: MutBorrow.t t_MapInv_I_F) =
    self.final.produced = (Seq.empty: Seq.seq t_Item)
    /\ completed_I (MutBorrow.borrow_logic self.current.iter self.final.iter (MutBorrow.inherit_id (MutBorrow.get_id self) 0))
    /\ self.current.func = self.final.func
  
  predicate produces_one_I (self: t_MapInv_I_F) (visited: t_B) (succ: t_MapInv_I_F) =
    exists f: MutBorrow.t t_F, e: t_Item. f.current = self.func
      /\ f.final = succ.func
      /\ produces_I self.iter (Seq.singleton e) succ.iter
      /\ succ.produced = Seq.snoc self.produced e
      /\ postcondition_mut_F f.current { f0 = e; f1 = self.produced } f.final visited
  
  axiom produces_one_I_spec:
    forall self: t_MapInv_I_F, visited: t_B, succ: t_MapInv_I_F. produces_one_I self visited succ
      = produces_MapInv_I_F self (Seq.singleton visited) succ
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: MutBorrow.t t_MapInv_I_F. inv_refmut_MapInv_I_F self_
      -> inv_refmut_MapInv_I_F self_
      /\ (forall result: t_Option_B. inv_Option_B result
          /\ match result with
            | None -> completed_MapInv_I_F self_
            | Some v -> produces_one_I self_.current v self_.final
            end
        -> inv_Option_B result
        /\ match result with
          | None -> completed_MapInv_I_F self_
          | Some v -> produces_MapInv_I_F self_.current (Seq.singleton v) self_.final
          end)
end
module M_logic__fmap__impl_IteratorSpec_for_FMap_K_V__produces_refl__refines (* <logic::fmap::FMap<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMap_K_V (self: t_FMap_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMap_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K o k /\ get_K self k = Some'0 v)
    /\ len_K self = Seq.length visited + len_K o
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K o k = get_K self k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall result: (). produces_FMap_K_V self (Seq.empty: Seq.seq tup2_K_V) self
        -> produces_FMap_K_V self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_logic__fmap__impl_IteratorSpec_for_FMap_K_V__produces_trans__refines (* <logic::fmap::FMap<K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_tup2_K_V = None | Some tup2_K_V
  
  function get_tup2_K_V (self: Seq.seq tup2_K_V) (ix: int) : t_Option_tup2_K_V = if 0 <= ix /\ ix < Seq.length self then
      Some (Seq.get self ix)
    else
      None
  
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None'0
  
  meta "rewrite_def" predicate contains_K
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate produces_FMap_K_V (self: t_FMap_K_V) (visited: Seq.seq tup2_K_V) (o: t_FMap_K_V) =
    (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited
        -> (Seq.get visited i).f0 <> (Seq.get visited j).f0)
    /\ (forall k: t_K, v: t_V, i: int. get_tup2_K_V visited i = Some { f0 = k; f1 = v }
        -> not contains_K o k /\ get_K self k = Some'0 v)
    /\ len_K self = Seq.length visited + len_K o
    /\ (forall k: t_K. (forall i: int. 0 <= i /\ i < Seq.length visited -> (Seq.get visited i).f0 <> k)
      -> get_K o k = get_K self k)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMap_K_V. forall ab: Seq.seq tup2_K_V. forall b: t_FMap_K_V. forall bc: Seq.seq tup2_K_V. forall c: t_FMap_K_V. produces_FMap_K_V a ab b
                /\ produces_FMap_K_V b bc c
              -> produces_FMap_K_V a ab b
              /\ produces_FMap_K_V b bc c
              /\ (forall result: (). produces_FMap_K_V a (Seq.(++) ab bc) c -> produces_FMap_K_V a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_trans__refines (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_SeqIter_T. forall ab: Seq.seq t_T. forall b: t_SeqIter_T. forall bc: Seq.seq t_T. forall c: t_SeqIter_T. produces_SeqIter_T a ab b
                /\ produces_SeqIter_T b bc c
              -> produces_SeqIter_T a ab b
              /\ produces_SeqIter_T b bc c
              /\ (forall result: (). produces_SeqIter_T a (Seq.(++) ab bc) c -> produces_SeqIter_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IteratorSpec_for_SeqIter_T__produces_refl__refines (* <logic::seq::SeqIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIter_T = { inner: Seq.seq t_T }
  
  function view_SeqIter_T (self: t_SeqIter_T) : Seq.seq t_T = self.inner
  
  predicate produces_SeqIter_T (self: t_SeqIter_T) (visited: Seq.seq t_T) (o: t_SeqIter_T) =
    view_SeqIter_T self = Seq.(++) visited (view_SeqIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIter_T. forall result: (). produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_SeqIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_trans__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_SeqIterRef_T. forall ab: Seq.seq t_T. forall b: t_SeqIterRef_T. forall bc: Seq.seq t_T. forall c: t_SeqIterRef_T. produces_SeqIterRef_T a ab b
                /\ produces_SeqIterRef_T b bc c
              -> produces_SeqIterRef_T a ab b
              /\ produces_SeqIterRef_T b bc c
              /\ (forall result: (). produces_SeqIterRef_T a (Seq.(++) ab bc) c
                -> produces_SeqIterRef_T a (Seq.(++) ab bc) c)
end
module M_logic__seq__impl_IteratorSpec_for_SeqIterRef_T__produces_refl__refines (* <logic::seq::SeqIterRef<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_T
  
  type t_SeqIterRef_T = { inner: Seq.seq t_T; index: int }
  
  function view_SeqIterRef_T (self: t_SeqIterRef_T) : Seq.seq t_T =
    Seq.([..]) self.inner self.index (Seq.length self.inner)
  
  predicate produces_SeqIterRef_T (self: t_SeqIterRef_T) (visited: Seq.seq t_T) (o: t_SeqIterRef_T) =
    let visited'0 = visited in view_SeqIterRef_T self = Seq.(++) visited'0 (view_SeqIterRef_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SeqIterRef_T. forall result: (). produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
        -> produces_SeqIterRef_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_trans__refines (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T. forall ab: Seq.seq t_T. forall b: t_IntoIter_T. forall bc: Seq.seq t_T. forall c: t_IntoIter_T. produces_IntoIter_T a ab b
                /\ produces_IntoIter_T b bc c
              -> produces_IntoIter_T a ab b
              /\ produces_IntoIter_T b bc c
              /\ (forall result: (). produces_IntoIter_T a (Seq.(++) ab bc) c
                -> produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__array__impl_IteratorSpec_for_IntoIter_T__produces_refl__refines (* <std::array::IntoIter<T, N> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : Seq.seq t_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    view_IntoIter_T self = Seq.(++) visited (view_IntoIter_T o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T. forall result: (). produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_trans__refines (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Cloned_I. forall ab: Seq.seq t_T. forall b: t_Cloned_I. forall bc: Seq.seq t_T. forall c: t_Cloned_I. produces_Cloned_I a ab b
                /\ produces_Cloned_I b bc c
              -> produces_Cloned_I a ab b
              /\ produces_Cloned_I b bc c
              /\ (forall result: (). produces_Cloned_I a (Seq.(++) ab bc) c -> produces_Cloned_I a (Seq.(++) ab bc) c)
end
module M_std__iter__cloned__impl_IteratorSpec_for_Cloned_I__produces_refl__refines (* <std::iter::Cloned<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Cloned_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Cloned_I (self: t_Cloned_I) : t_I
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  predicate produces_Cloned_I (self: t_Cloned_I) (visited: Seq.seq t_T) (o: t_Cloned_I) =
    exists s: Seq.seq t_T. produces_I (iter_Cloned_I self) s (iter_Cloned_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> postcondition_clone () (Seq.get s i) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Cloned_I. forall result: (). produces_Cloned_I self (Seq.empty: Seq.seq t_T) self
        -> produces_Cloned_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_trans__refines (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Copied_I. forall ab: Seq.seq t_T. forall b: t_Copied_I. forall bc: Seq.seq t_T. forall c: t_Copied_I. produces_Copied_I a ab b
                /\ produces_Copied_I b bc c
              -> produces_Copied_I a ab b
              /\ produces_Copied_I b bc c
              /\ (forall result: (). produces_Copied_I a (Seq.(++) ab bc) c -> produces_Copied_I a (Seq.(++) ab bc) c)
end
module M_std__iter__copied__impl_IteratorSpec_for_Copied_I__produces_refl__refines (* <std::iter::Copied<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Copied_I
  
  type t_T
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_T) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_T) (b: t_I) (bc: Seq.seq t_T) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_T, b: t_I, bc: Seq.seq t_T, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_T) self
  
  function iter_Copied_I (self: t_Copied_I) : t_I
  
  predicate produces_Copied_I (self: t_Copied_I) (visited: Seq.seq t_T) (o: t_Copied_I) =
    exists s: Seq.seq t_T. produces_I (iter_Copied_I self) s (iter_Copied_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> Seq.get visited i = Seq.get s i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Copied_I. forall result: (). produces_Copied_I self (Seq.empty: Seq.seq t_T) self
        -> produces_Copied_I self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_trans__refines (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Empty_T. forall ab: Seq.seq t_T. forall b: t_Empty_T. forall bc: Seq.seq t_T. forall c: t_Empty_T. produces_Empty_T a ab b
                /\ produces_Empty_T b bc c
              -> produces_Empty_T a ab b
              /\ produces_Empty_T b bc c
              /\ (forall result: (). produces_Empty_T a (Seq.(++) ab bc) c -> produces_Empty_T a (Seq.(++) ab bc) c)
end
module M_std__iter__empty__impl_IteratorSpec_for_Empty_T__produces_refl__refines (* <std::iter::Empty<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Empty_T
  
  type t_T
  
  predicate produces_Empty_T (self: t_Empty_T) (visited: Seq.seq t_T) (o: t_Empty_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Empty_T. forall result: (). produces_Empty_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Empty_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_trans__refines (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Enumerate_I. forall ab: Seq.seq tup2_usize_Item. forall b: t_Enumerate_I. forall bc: Seq.seq tup2_usize_Item. forall c: t_Enumerate_I. produces_Enumerate_I a ab b
                /\ produces_Enumerate_I b bc c
              -> produces_Enumerate_I a ab b
              /\ produces_Enumerate_I b bc c
              /\ (forall result: (). produces_Enumerate_I a (Seq.(++) ab bc) c
                -> produces_Enumerate_I a (Seq.(++) ab bc) c)
end
module M_std__iter__enumerate__impl_IteratorSpec_for_Enumerate_I__produces_refl__refines (* <std::iter::Enumerate<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use seq.Seq
  use int.Int
  
  type t_Enumerate_I
  
  type t_Item
  
  type tup2_usize_Item = { f0: UInt64.t; f1: t_Item }
  
  function n_Enumerate_I (self: t_Enumerate_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Enumerate_I (self: t_Enumerate_I) : t_I
  
  predicate produces_Enumerate_I (self: t_Enumerate_I) (visited: Seq.seq tup2_usize_Item) (o: t_Enumerate_I) =
    Seq.length visited = UInt64.t'int (n_Enumerate_I o) - UInt64.t'int (n_Enumerate_I self)
    /\ (exists s: Seq.seq t_Item. produces_I (iter_Enumerate_I self) s (iter_Enumerate_I o)
      /\ Seq.length visited = Seq.length s
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> UInt64.t'int (Seq.get visited i).f0 = UInt64.t'int (n_Enumerate_I self) + i
        /\ (Seq.get visited i).f1 = Seq.get s i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Enumerate_I. forall result: (). produces_Enumerate_I self (Seq.empty: Seq.seq tup2_usize_Item) self
        -> produces_Enumerate_I self (Seq.empty: Seq.seq tup2_usize_Item) self
end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_trans__refines (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_Item (_1: t_Item)
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) =
    forall f: t_F, i: t_Item. inv_F f /\ inv_ref_Item i -> precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Filter_I_F. forall ab: Seq.seq t_Item. forall b: t_Filter_I_F. forall bc: Seq.seq t_Item. forall c: t_Filter_I_F. produces_Filter_I_F a ab b
                /\ produces_Filter_I_F b bc c
              -> produces_Filter_I_F a ab b
              /\ produces_Filter_I_F b bc c
              /\ (forall result: (). produces_Filter_I_F a (Seq.(++) ab bc) c
                -> produces_Filter_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__filter__impl_IteratorSpec_for_Filter_I_F__produces_refl__refines (* <std::iter::Filter<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Filter_I_F
  
  type t_Item
  
  type t_F
  
  predicate inv_F (_1: t_F)
  
  predicate inv_Item (_1: t_Item)
  
  predicate invariant_ref_Item [@inline:trivial] (self: t_Item) = inv_Item self
  
  meta "rewrite_def" predicate invariant_ref_Item
  
  predicate inv_ref_Item [@inline:trivial] (_1: t_Item) = invariant_ref_Item _1
  
  meta "rewrite_def" predicate inv_ref_Item
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_ref_Item (_1: t_F) =
    forall f: t_F, i: t_Item. inv_F f /\ inv_ref_Item i -> precondition_F f i
  
  function func_Filter_I_F (self: t_Filter_I_F) : t_F
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: bool)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: bool)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: bool) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: bool. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: bool) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: bool. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_ref_Item (_1: t_F) = forall f: t_F, g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_ref_Item (_1: t_F) =
    forall f1: t_F, f2: t_F, i: t_Item. not (postcondition_mut_F f1 i f2 true /\ postcondition_mut_F f1 i f2 false)
  
  predicate private_invariant_I (f: t_Filter_I_F) =
    no_precondition_ref_Item (func_Filter_I_F f)
    /\ immutable_ref_Item (func_Filter_I_F f) /\ precise_ref_Item (func_Filter_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Filter_I_F (self: t_Filter_I_F) : t_I
  
  predicate produces_Filter_I_F (self: t_Filter_I_F) (visited: Seq.seq t_Item) (succ: t_Filter_I_F) =
    private_invariant_I self
    -> hist_inv_F (func_Filter_I_F self) (func_Filter_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_Filter_I_F self) s (iter_Filter_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> Seq.get visited i = Seq.get s (Map.get f i))
      /\ (forall i: int. 0 <= i /\ i < Seq.length s
        -> (exists j: int. 0 <= j /\ j < Seq.length visited /\ Map.get f j = i)
        = postcondition_mut_F (func_Filter_I_F self) (Seq.get s i) (func_Filter_I_F self) true))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Filter_I_F. forall result: (). produces_Filter_I_F self (Seq.empty: Seq.seq t_Item) self
        -> produces_Filter_I_F self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_refl__refines (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate inv_Item (_1: t_Item)
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. inv_Item i -> precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FilterMap_I_F. forall result: (). produces_FilterMap_I_F self (Seq.empty: Seq.seq t_B) self
        -> produces_FilterMap_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__filter_map__impl_IteratorSpec_for_FilterMap_I_F__produces_trans__refines (* <std::iter::FilterMap<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_FilterMap_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate inv_Item (_1: t_Item)
  
  predicate precondition_F (self: t_F) (args: t_Item)
  
  predicate no_precondition_Item (f: t_F) = forall i: t_Item. inv_Item i -> precondition_F f i
  
  function func_FilterMap_I_F (self: t_FilterMap_I_F) : t_F
  
  type t_Option_B = None | Some t_B
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_Option_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_Option_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_Option_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_Option_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_Option_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_Option_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate immutable_Item (f: t_F) = forall g: t_F. hist_inv_F f g -> f = g
  
  predicate precise_Item (f1: t_F) =
    forall f2: t_F, i: t_Item. not ((exists b: t_B. postcondition_mut_F f1 i f2 (Some b))
      /\ postcondition_mut_F f1 i f2 (None))
  
  predicate private_invariant_B (f: t_FilterMap_I_F) =
    no_precondition_Item (func_FilterMap_I_F f)
    /\ immutable_Item (func_FilterMap_I_F f) /\ precise_Item (func_FilterMap_I_F f)
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_FilterMap_I_F (self: t_FilterMap_I_F) : t_I
  
  predicate produces_FilterMap_I_F (self: t_FilterMap_I_F) (visited: Seq.seq t_B) (succ: t_FilterMap_I_F) =
    private_invariant_B self
    -> hist_inv_F (func_FilterMap_I_F self) (func_FilterMap_I_F succ)
    /\ (exists s: Seq.seq t_Item, f: Map.map int int. produces_I (iter_FilterMap_I_F self) s (iter_FilterMap_I_F succ)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited -> 0 <= Map.get f i /\ Map.get f i < Seq.length s)
      /\ (forall i: int, j: int. 0 <= i /\ i < j /\ j < Seq.length visited -> Map.get f i < Map.get f j)
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s (Map.get f i)) (func_FilterMap_I_F self) (Some (Seq.get visited i)))
      /\ (forall j: int. 0 <= j /\ j < Seq.length s
        -> (not (exists i: int. 0 <= i /\ i < Seq.length visited /\ Map.get f i = j))
        = postcondition_mut_F (func_FilterMap_I_F self) (Seq.get s j) (func_FilterMap_I_F self) (None)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FilterMap_I_F. forall ab: Seq.seq t_B. forall b: t_FilterMap_I_F. forall bc: Seq.seq t_B. forall c: t_FilterMap_I_F. produces_FilterMap_I_F a ab b
                /\ produces_FilterMap_I_F b bc c
              -> produces_FilterMap_I_F a ab b
              /\ produces_FilterMap_I_F b bc c
              /\ (forall result: (). produces_FilterMap_I_F a (Seq.(++) ab bc) c
                -> produces_FilterMap_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_refl__refines (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Fuse_I. forall result: (). produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__fuse__impl_IteratorSpec_for_Fuse_I__produces_trans__refines (* <std::iter::Fuse<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Fuse_I. forall ab: Seq.seq t_Item. forall b: t_Fuse_I. forall bc: Seq.seq t_Item. forall c: t_Fuse_I. produces_Fuse_I a ab b
                /\ produces_Fuse_I b bc c
              -> produces_Fuse_I a ab b
              /\ produces_Fuse_I b bc c
              /\ (forall result: (). produces_Fuse_I a (Seq.(++) ab bc) c -> produces_Fuse_I a (Seq.(++) ab bc) c)
end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_trans__refines (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Map_I_F. forall ab: Seq.seq t_B. forall b: t_Map_I_F. forall bc: Seq.seq t_B. forall c: t_Map_I_F. produces_Map_I_F a ab b
                /\ produces_Map_I_F b bc c
              -> produces_Map_I_F a ab b
              /\ produces_Map_I_F b bc c
              /\ (forall result: (). produces_Map_I_F a (Seq.(++) ab bc) c -> produces_Map_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__map__impl_IteratorSpec_for_Map_I_F__produces_refl__refines (* <std::iter::Map<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_Map_I_F
  
  type t_B
  
  type t_F
  
  type t_Item
  
  predicate postcondition_once_F (self: t_F) (args: t_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: t_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec: forall self: t_F, args: t_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: t_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: t_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  function func_Map_I_F (self: t_Map_I_F) : t_F
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Map_I_F (self: t_Map_I_F) : t_I
  
  predicate produces_Map_I_F [@inline:trivial] (self: t_Map_I_F) (visited: Seq.seq t_B) (succ: t_Map_I_F) =
    hist_inv_F (func_Map_I_F self) (func_Map_I_F succ)
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item [produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)]. Seq.length s
          = Seq.length visited
        /\ produces_I (iter_Map_I_F self) s (iter_Map_I_F succ)
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            func_Map_I_F self = func_Map_I_F succ
          else
            (Seq.get fs 0).current = func_Map_I_F self
            /\ (Seq.get fs (Seq.length visited - 1)).final = func_Map_I_F succ
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F (func_Map_I_F self) (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current (Seq.get s i) (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_Map_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Map_I_F. forall result: (). produces_Map_I_F self (Seq.empty: Seq.seq t_B) self
        -> produces_Map_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_refl__refines (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_MapInv_I_F. forall result: (). produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
        -> produces_MapInv_I_F self (Seq.empty: Seq.seq t_B) self
end
module M_std__iter__map_inv__impl_IteratorSpec_for_MapInv_I_F__produces_trans__refines (* <std::iter::map_inv::MapInv<I, F> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  use int.Int
  
  type t_I
  
  type t_F
  
  type t_Item
  
  type t_MapInv_I_F = { iter: t_I; func: t_F; produced: Seq.seq t_Item }
  
  type t_B
  
  type tup2_Item_Snapshot_Seq_Item = { f0: t_Item; f1: Seq.seq t_Item }
  
  predicate postcondition_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result: t_B)
  
  predicate resolve_F (_1: t_F)
  
  predicate postcondition_mut_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (result_state: t_F) (result: t_B)
  
  function fn_mut_once_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res: t_B) : ()
  
  axiom fn_mut_once_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res: t_B. postcondition_once_F self args res
      = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  function hist_inv_trans_F (self: t_F) (b: t_F) (c: t_F) : ()
  
  axiom hist_inv_trans_F_spec: forall self: t_F, b: t_F, c: t_F. hist_inv_F self b
      -> hist_inv_F b c -> hist_inv_F self c
  
  function hist_inv_refl_F (self: t_F) : ()
  
  axiom hist_inv_refl_F_spec: forall self: t_F. hist_inv_F self self
  
  function postcondition_mut_hist_inv_F (self: t_F) (args: tup2_Item_Snapshot_Seq_Item) (res_state: t_F) (res: t_B) : ()
  
  axiom postcondition_mut_hist_inv_F_spec:
    forall self: t_F, args: tup2_Item_Snapshot_Seq_Item, res_state: t_F, res: t_B. postcondition_mut_F self args res_state res
      -> hist_inv_F self res_state
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_MapInv_I_F [@inline:trivial] (self: t_MapInv_I_F) (visited: Seq.seq t_B) (succ: t_MapInv_I_F) =
    hist_inv_F self.func succ.func
    /\ (exists fs: Seq.seq (MutBorrow.t t_F). Seq.length fs = Seq.length visited
      /\ (exists s: Seq.seq t_Item. Seq.length s = Seq.length visited
        /\ produces_I self.iter s succ.iter
        /\ succ.produced = Seq.(++) self.produced s
        /\ (forall i: int. 1 <= i /\ i < Seq.length fs -> (Seq.get fs (i - 1)).final = (Seq.get fs i).current)
        /\ (if Seq.length visited = 0 then
            self.func = succ.func
          else
            (Seq.get fs 0).current = self.func /\ (Seq.get fs (Seq.length visited - 1)).final = succ.func
          )
        /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> hist_inv_F self.func (Seq.get fs i).current
          /\ postcondition_mut_F (Seq.get fs i).current { f0 = Seq.get s i;
                                                          f1 = Seq.(++) self.produced (Seq.([..]) s 0 i) } (Seq.get fs i).final (Seq.get visited i))))
  
  meta "rewrite_def" predicate produces_MapInv_I_F
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_MapInv_I_F. forall ab: Seq.seq t_B. forall b: t_MapInv_I_F. forall bc: Seq.seq t_B. forall c: t_MapInv_I_F. produces_MapInv_I_F a ab b
                /\ produces_MapInv_I_F b bc c
              -> produces_MapInv_I_F a ab b
              /\ produces_MapInv_I_F b bc c
              /\ (forall result: (). produces_MapInv_I_F a (Seq.(++) ab bc) c
                -> produces_MapInv_I_F a (Seq.(++) ab bc) c)
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_trans__refines (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Once_T. forall ab: Seq.seq t_T. forall b: t_Once_T. forall bc: Seq.seq t_T. forall c: t_Once_T. produces_Once_T a ab b
                /\ produces_Once_T b bc c
              -> produces_Once_T a ab b
              /\ produces_Once_T b bc c
              /\ (forall result: (). produces_Once_T a (Seq.(++) ab bc) c -> produces_Once_T a (Seq.(++) ab bc) c)
end
module M_std__iter__once__impl_IteratorSpec_for_Once_T__produces_refl__refines (* <std::iter::Once<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Once_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_Once_T (self: t_Once_T) : t_Option_T
  
  predicate produces_Once_T (self: t_Once_T) (visited: Seq.seq t_T) (o: t_Once_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Once_T self = Some e /\ visited = Seq.singleton e /\ view_Once_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Once_T. forall result: (). produces_Once_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Once_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_refl__refines (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Range_Idx. forall result: (). produces_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_IteratorSpec_for_Range_Idx__produces_trans__refines (* <std::ops::Range<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.end' = o.end'
    /\ deep_model_Idx self.start <= deep_model_Idx o.start
    /\ (Seq.length visited > 0 -> deep_model_Idx o.start <= deep_model_Idx o.end')
    /\ Seq.length visited = deep_model_Idx o.start - deep_model_Idx self.start
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.start + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Range_Idx. forall ab: Seq.seq t_Idx. forall b: t_Range_Idx. forall bc: Seq.seq t_Idx. forall c: t_Range_Idx. produces_Range_Idx a ab b
                /\ produces_Range_Idx b bc c
              -> produces_Range_Idx a ab b
              /\ produces_Range_Idx b bc c
              /\ (forall result: (). produces_Range_Idx a (Seq.(++) ab bc) c -> produces_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_trans__refines (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_RangeInclusive_Idx. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive_Idx. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive_Idx. produces_RangeInclusive_Idx a ab b
                /\ produces_RangeInclusive_Idx b bc c
              -> produces_RangeInclusive_Idx a ab b
              /\ produces_RangeInclusive_Idx b bc c
              /\ (forall result: (). produces_RangeInclusive_Idx a (Seq.(++) ab bc) c
                -> produces_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_IteratorSpec_for_RangeInclusive_Idx__produces_refl__refines (* <std::ops::RangeInclusive<Idx> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ end_log_RangeInclusive_Idx self = end_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (start_log_RangeInclusive_Idx self) + i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_RangeInclusive_Idx. forall result: (). produces_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_refl__refines (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Repeat_T. forall result: (). produces_Repeat_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Repeat_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__iter__repeat__impl_IteratorSpec_for_Repeat_T__produces_trans__refines (* <std::iter::Repeat<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Repeat_T
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate postcondition_once_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef:
    forall args: t_T, res: t_T [postcondition_once_clone () args res]. postcondition_once_clone () args res
      -> (let self_ = args in inv_T res)
  
  predicate resolve_clone [@inline:trivial] (_1: ()) = true
  
  meta "rewrite_def" predicate resolve_clone
  
  predicate postcondition_mut_clone (self: ()) (args: t_T) (result_state: ()) (result: t_T)
  
  axiom postcondition_fndef'0:
    forall args: t_T, res: t_T [postcondition_mut_clone () args () res]. postcondition_mut_clone () args () res
      -> (let self_ = args in inv_T res)
  
  function fn_mut_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_mut_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (exists res_state: (). postcondition_mut_clone self args res_state res /\ resolve_clone res_state)
  
  predicate hist_inv_clone [@inline:trivial] (self: ()) (result_state: ()) = true
  
  meta "rewrite_def" predicate hist_inv_clone
  
  function hist_inv_trans_clone (self: ()) (b: ()) (c: ()) : ()
  
  axiom hist_inv_trans_clone_spec: forall self: (), b: (), c: (). hist_inv_clone self b
      -> hist_inv_clone b c -> hist_inv_clone self c
  
  function hist_inv_refl_clone (self: ()) : ()
  
  axiom hist_inv_refl_clone_spec: forall self: (). hist_inv_clone self self
  
  function postcondition_mut_hist_inv_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom postcondition_mut_hist_inv_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      -> hist_inv_clone self res_state
  
  function fn_hist_inv_clone (self: ()) (res_state: ()) : ()
  
  axiom fn_hist_inv_clone_spec: forall self: (), res_state: (). hist_inv_clone self res_state = (self = res_state)
  
  predicate postcondition_clone (self: ()) (args: t_T) (result: t_T)
  
  axiom postcondition_fndef'1:
    forall args: t_T, res: t_T [postcondition_clone () args res]. postcondition_clone () args res
      -> (let self_ = args in inv_T res)
  
  function fn_once_clone (self: ()) (args: t_T) (res: t_T) : ()
  
  axiom fn_once_clone_spec: forall self: (), args: t_T, res: t_T. postcondition_once_clone self args res
      = (postcondition_clone self args res /\ resolve_clone self)
  
  function fn_mut_clone (self: ()) (args: t_T) (res_state: ()) (res: t_T) : ()
  
  axiom fn_mut_clone_spec:
    forall self: (), args: t_T, res_state: (), res: t_T. postcondition_mut_clone self args res_state res
      = (postcondition_clone self args res /\ self = res_state)
  
  function view_Repeat_T (self: t_Repeat_T) : t_T
  
  predicate produces_Repeat_T (self: t_Repeat_T) (visited: Seq.seq t_T) (o: t_Repeat_T) =
    self = o
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> postcondition_clone () (view_Repeat_T self) (Seq.get visited i))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Repeat_T. forall ab: Seq.seq t_T. forall b: t_Repeat_T. forall bc: Seq.seq t_T. forall c: t_Repeat_T. produces_Repeat_T a ab b
                /\ produces_Repeat_T b bc c
              -> produces_Repeat_T a ab b
              /\ produces_Repeat_T b bc c
              /\ (forall result: (). produces_Repeat_T a (Seq.(++) ab bc) c -> produces_Repeat_T a (Seq.(++) ab bc) c)
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_refl__refines (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Rev_I. forall result: (). produces_Rev_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Rev_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__rev__impl_IteratorSpec_for_Rev_I__produces_trans__refines (* <std::iter::Rev<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Rev_I
  
  type t_Item
  
  type t_I
  
  predicate produces_back_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_back_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_back_trans_I_spec:
    forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_back_I a ab b
      -> produces_back_I b bc c -> produces_back_I a (Seq.(++) ab bc) c
  
  function produces_back_refl_I (self: t_I) : ()
  
  axiom produces_back_refl_I_spec: forall self: t_I. produces_back_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Rev_I (self: t_Rev_I) : t_I
  
  predicate produces_Rev_I (self: t_Rev_I) (visited: Seq.seq t_Item) (o: t_Rev_I) =
    produces_back_I (iter_Rev_I self) visited (iter_Rev_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Rev_I. forall ab: Seq.seq t_Item. forall b: t_Rev_I. forall bc: Seq.seq t_Item. forall c: t_Rev_I. produces_Rev_I a ab b
                /\ produces_Rev_I b bc c
              -> produces_Rev_I a ab b
              /\ produces_Rev_I b bc c
              /\ (forall result: (). produces_Rev_I a (Seq.(++) ab bc) c -> produces_Rev_I a (Seq.(++) ab bc) c)
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_trans__refines (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Skip_I. forall ab: Seq.seq t_Item. forall b: t_Skip_I. forall bc: Seq.seq t_Item. forall c: t_Skip_I. produces_Skip_I a ab b
                /\ produces_Skip_I b bc c
              -> produces_Skip_I a ab b
              /\ produces_Skip_I b bc c
              /\ (forall result: (). produces_Skip_I a (Seq.(++) ab bc) c -> produces_Skip_I a (Seq.(++) ab bc) c)
end
module M_std__iter__skip__impl_IteratorSpec_for_Skip_I__produces_refl__refines (* <std::iter::Skip<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Skip_I
  
  type t_Item
  
  function n_Skip_I (self: t_Skip_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Skip_I (self: t_Skip_I) : t_I
  
  predicate resolve_Item (_1: t_Item)
  
  predicate produces_Skip_I (self: t_Skip_I) (visited: Seq.seq t_Item) (o: t_Skip_I) =
    visited = (Seq.empty: Seq.seq t_Item) /\ self = o
    \/ UInt64.t'int (n_Skip_I o) = 0
    /\ Seq.length visited > 0
    /\ (exists s: Seq.seq t_Item. Seq.length s = UInt64.t'int (n_Skip_I self)
      /\ produces_I (iter_Skip_I self) (Seq.(++) s visited) (iter_Skip_I o)
      /\ (forall i: int. 0 <= i /\ i < Seq.length s -> resolve_Item (Seq.get s i)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Skip_I. forall result: (). produces_Skip_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Skip_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_trans__refines (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Take_I. forall ab: Seq.seq t_Item. forall b: t_Take_I. forall bc: Seq.seq t_Item. forall c: t_Take_I. produces_Take_I a ab b
                /\ produces_Take_I b bc c
              -> produces_Take_I a ab b
              /\ produces_Take_I b bc c
              /\ (forall result: (). produces_Take_I a (Seq.(++) ab bc) c -> produces_Take_I a (Seq.(++) ab bc) c)
end
module M_std__iter__take__impl_IteratorSpec_for_Take_I__produces_refl__refines (* <std::iter::Take<I> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.int.UInt64
  use int.Int
  
  type t_Take_I
  
  type t_Item
  
  function n_Take_I (self: t_Take_I) : UInt64.t
  
  type t_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  function iter_Take_I (self: t_Take_I) : t_I
  
  predicate produces_Take_I (self: t_Take_I) (visited: Seq.seq t_Item) (o: t_Take_I) =
    UInt64.t'int (n_Take_I self) = UInt64.t'int (n_Take_I o) + Seq.length visited
    /\ produces_I (iter_Take_I self) visited (iter_Take_I o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Take_I. forall result: (). produces_Take_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_Take_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_refl__refines (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Zip_A_B. forall result: (). produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
        -> produces_Zip_A_B self (Seq.empty: Seq.seq tup2_Item_Item) self
end
module M_std__iter__zip__impl_IteratorSpec_for_Zip_A_B__produces_trans__refines (* <std::iter::Zip<A, B> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Zip_A_B
  
  type t_Item
  
  type t_Item'0
  
  type tup2_Item_Item = { f0: t_Item; f1: t_Item'0 }
  
  type t_A
  
  predicate produces_A (self: t_A) (visited: Seq.seq t_Item) (o: t_A)
  
  function produces_trans_A (a: t_A) (ab: Seq.seq t_Item) (b: t_A) (bc: Seq.seq t_Item) (c: t_A) : ()
  
  axiom produces_trans_A_spec: forall a: t_A, ab: Seq.seq t_Item, b: t_A, bc: Seq.seq t_Item, c: t_A. produces_A a ab b
      -> produces_A b bc c -> produces_A a (Seq.(++) ab bc) c
  
  function produces_refl_A (self: t_A) : ()
  
  axiom produces_refl_A_spec: forall self: t_A. produces_A self (Seq.empty: Seq.seq t_Item) self
  
  function itera_Zip_A_B (self: t_Zip_A_B) : t_A
  
  type t_B
  
  predicate produces_B (self: t_B) (visited: Seq.seq t_Item'0) (o: t_B)
  
  function produces_trans_B (a: t_B) (ab: Seq.seq t_Item'0) (b: t_B) (bc: Seq.seq t_Item'0) (c: t_B) : ()
  
  axiom produces_trans_B_spec:
    forall a: t_B, ab: Seq.seq t_Item'0, b: t_B, bc: Seq.seq t_Item'0, c: t_B. produces_B a ab b
      -> produces_B b bc c -> produces_B a (Seq.(++) ab bc) c
  
  function produces_refl_B (self: t_B) : ()
  
  axiom produces_refl_B_spec: forall self: t_B. produces_B self (Seq.empty: Seq.seq t_Item'0) self
  
  function iterb_Zip_A_B (self: t_Zip_A_B) : t_B
  
  predicate produces_Zip_A_B (self: t_Zip_A_B) (visited: Seq.seq tup2_Item_Item) (o: t_Zip_A_B) =
    exists p1: Seq.seq t_Item, p2: Seq.seq t_Item'0. Seq.length p1 = Seq.length p2
      /\ Seq.length p2 = Seq.length visited
      /\ (forall i: int. 0 <= i /\ i < Seq.length visited
          -> Seq.get visited i = { f0 = Seq.get p1 i; f1 = Seq.get p2 i })
      /\ produces_A (itera_Zip_A_B self) p1 (itera_Zip_A_B o) /\ produces_B (iterb_Zip_A_B self) p2 (iterb_Zip_A_B o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Zip_A_B. forall ab: Seq.seq tup2_Item_Item. forall b: t_Zip_A_B. forall bc: Seq.seq tup2_Item_Item. forall c: t_Zip_A_B. produces_Zip_A_B a ab b
                /\ produces_Zip_A_B b bc c
              -> produces_Zip_A_B a ab b
              /\ produces_Zip_A_B b bc c
              /\ (forall result: (). produces_Zip_A_B a (Seq.(++) ab bc) c -> produces_Zip_A_B a (Seq.(++) ab bc) c)
end
module M_std__iter__impl_IteratorSpec_for_refmut_I__produces_refl__refines (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_refmut_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t t_I. forall result: (). produces_refmut_I self (Seq.empty: Seq.seq t_Item) self
        -> produces_refmut_I self (Seq.empty: Seq.seq t_Item) self
end
module M_std__iter__impl_IteratorSpec_for_refmut_I__produces_trans__refines (* <&mut I as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_I
  
  type t_Item
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_refmut_I (self: MutBorrow.t t_I) (visited: Seq.seq t_Item) (o: MutBorrow.t t_I) =
    produces_I self.current visited o.current /\ self.final = o.final
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: MutBorrow.t t_I. forall ab: Seq.seq t_Item. forall b: MutBorrow.t t_I. forall bc: Seq.seq t_Item. forall c: MutBorrow.t t_I. produces_refmut_I a ab b
                /\ produces_refmut_I b bc c
              -> produces_refmut_I a ab b
              /\ produces_refmut_I b bc c
              /\ (forall result: (). produces_refmut_I a (Seq.(++) ab bc) c -> produces_refmut_I a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_trans__refines (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T. forall ab: Seq.seq t_T. forall b: t_IntoIter_T. forall bc: Seq.seq t_T. forall c: t_IntoIter_T. produces_IntoIter_T a ab b
                /\ produces_IntoIter_T b bc c
              -> produces_IntoIter_T a ab b
              /\ produces_IntoIter_T b bc c
              /\ (forall result: (). produces_IntoIter_T a (Seq.(++) ab bc) c
                -> produces_IntoIter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_IntoIter_T__produces_refl__refines (* <std::option::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function view_IntoIter_T (self: t_IntoIter_T) : t_Option_T
  
  predicate produces_IntoIter_T (self: t_IntoIter_T) (visited: Seq.seq t_T) (o: t_IntoIter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_IntoIter_T self = Some e /\ visited = Seq.singleton e /\ view_IntoIter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T. forall result: (). produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T a ab b
                /\ produces_Iter_T b bc c
              -> produces_Iter_T a ab b
              /\ produces_Iter_T b bc c
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__option__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::option::Iter<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_Iter_T
  
  type t_T
  
  type t_Option_ref_T = None | Some t_T
  
  function view_Iter_T (self: t_Iter_T) : t_Option_ref_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) =
    visited = (Seq.empty: Seq.seq t_T) /\ self = o
    \/ (exists e: t_T. view_Iter_T self = Some e /\ visited = Seq.singleton e /\ view_Iter_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_refl__refines (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_refmut_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_refmut_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IterMut_T. forall result: (). produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
        -> produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__option__impl_IteratorSpec_for_IterMut_T__produces_trans__refines (* <std::option::IterMut<'_, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  
  type t_IterMut_T
  
  type t_T
  
  type t_Option_refmut_T = None | Some (MutBorrow.t t_T)
  
  function view_IterMut_T (self: t_IterMut_T) : t_Option_refmut_T
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (o: t_IterMut_T) =
    visited = (Seq.empty: Seq.seq (MutBorrow.t t_T)) /\ self = o
    \/ (exists e: MutBorrow.t t_T. view_IterMut_T self = Some e /\ visited = Seq.singleton e /\ view_IterMut_T o = None)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut_T. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut_T. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut_T. produces_IterMut_T a ab b
                /\ produces_IterMut_T b bc c
              -> produces_IterMut_T a ab b
              /\ produces_IterMut_T b bc c
              /\ (forall result: (). produces_IterMut_T a (Seq.(++) ab bc) c -> produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T a ab b
                /\ produces_Iter_T b bc c
              -> produces_Iter_T a ab b
              /\ produces_Iter_T b bc c
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__slice__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::slice::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_trans__refines (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut_T. forall ab: Seq.seq (MutBorrow.t t_T). forall b: t_IterMut_T. forall bc: Seq.seq (MutBorrow.t t_T). forall c: t_IterMut_T. produces_IterMut_T a ab b
                /\ produces_IterMut_T b bc c
              -> produces_IterMut_T a ab b
              /\ produces_IterMut_T b bc c
              /\ (forall result: (). produces_IterMut_T a (Seq.(++) ab bc) c -> produces_IterMut_T a (Seq.(++) ab bc) c)
end
module M_std__slice__impl_IteratorSpec_for_IterMut_T__produces_refl__refines (* <std::slice::IterMut<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_IterMut_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_mut_seq_slice_T (self: MutBorrow.t (Slice64.slice t_T)) : Seq.seq (MutBorrow.t t_T)
  
  axiom to_mut_seq_slice_T_spec: forall self: MutBorrow.t (Slice64.slice t_T). Seq.length (to_mut_seq_slice_T self)
      = Seq.length (Slice64.view self.current)
  
  axiom to_mut_seq_slice_T_spec'0: forall self: MutBorrow.t (Slice64.slice t_T). forall i: int. 0 <= i
          /\ i < Seq.length (to_mut_seq_slice_T self)
        -> Seq.get (to_mut_seq_slice_T self) i
        = MutBorrow.borrow_logic (index_slice_T self.current i) (index_slice_T self.final i) (MutBorrow.inherit_id (MutBorrow.get_id self) i)
  
  function view_IterMut_T (self: t_IterMut_T) : MutBorrow.t (Slice64.slice t_T)
  
  axiom view_IterMut_T_spec: forall self: t_IterMut_T. Seq.length (Slice64.view (view_IterMut_T self).final)
      = Seq.length (Slice64.view (view_IterMut_T self).current)
  
  predicate produces_IterMut_T (self: t_IterMut_T) (visited: Seq.seq (MutBorrow.t t_T)) (tl: t_IterMut_T) =
    to_mut_seq_slice_T (view_IterMut_T self) = Seq.(++) visited (to_mut_seq_slice_T (view_IterMut_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IterMut_T. forall result: (). produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
        -> produces_IterMut_T self (Seq.empty: Seq.seq (MutBorrow.t t_T)) self
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_trans__refines (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T_A. forall ab: Seq.seq t_T. forall b: t_IntoIter_T_A. forall bc: Seq.seq t_T. forall c: t_IntoIter_T_A. produces_IntoIter_T_A a ab b
                /\ produces_IntoIter_T_A b bc c
              -> produces_IntoIter_T_A a ab b
              /\ produces_IntoIter_T_A b bc c
              /\ (forall result: (). produces_IntoIter_T_A a (Seq.(++) ab bc) c
                -> produces_IntoIter_T_A a (Seq.(++) ab bc) c)
end
module M_std__vec__impl_IteratorSpec_for_IntoIter_T_A__produces_refl__refines (* <std::vec::IntoIter<T, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  
  type t_IntoIter_T_A
  
  type t_T
  
  function view_IntoIter_T_A (self: t_IntoIter_T_A) : Seq.seq t_T
  
  predicate produces_IntoIter_T_A (self: t_IntoIter_T_A) (visited: Seq.seq t_T) (rhs: t_IntoIter_T_A) =
    view_IntoIter_T_A self = Seq.(++) visited (view_IntoIter_T_A rhs)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_IntoIter_T_A. forall result: (). produces_IntoIter_T_A self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T_A self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V_A__produces_refl__refines (* <std::collections::hash_map::IntoIter<K, V, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IntoIter_K_V_A
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V_A (self: t_IntoIter_K_V_A) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V_A [@inline:trivial] (self: t_IntoIter_K_V_A) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V_A) =
    len_DeepModelTy (view_IntoIter_K_V_A self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V_A o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V_A self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V_A o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IntoIter_K_V_A. forall result: (). produces_IntoIter_K_V_A self (Seq.empty: Seq.seq tup2_K_V) self
        -> produces_IntoIter_K_V_A self (Seq.empty: Seq.seq tup2_K_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IntoIter_K_V_A__produces_trans__refines (* <std::collections::hash_map::IntoIter<K, V, A> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IntoIter_K_V_A
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_IntoIter_K_V_A (self: t_IntoIter_K_V_A) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_K_V (self: Seq.seq tup2_K_V) (x: tup2_K_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  predicate produces_IntoIter_K_V_A [@inline:trivial] (self: t_IntoIter_K_V_A) (visited: Seq.seq tup2_K_V) (o: t_IntoIter_K_V_A) =
    len_DeepModelTy (view_IntoIter_K_V_A self) = Seq.length visited + len_DeepModelTy (view_IntoIter_K_V_A o)
    /\ (forall k: t_K, v: t_V. contains_tup2_K_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IntoIter_K_V_A self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IntoIter_K_V_A o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v
        -> get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_K k2 = k /\ contains_tup2_K_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_IntoIter_K_V_A self) k = Some v
        -> (exists k1: t_K. deep_model_K k1 = k /\ contains_tup2_K_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IntoIter_K_V_A o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited /\ deep_model_K (Seq.get visited i1).f0 = deep_model_K (Seq.get visited i2).f0
      -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IntoIter_K_V_A
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_K_V_A. forall ab: Seq.seq tup2_K_V. forall b: t_IntoIter_K_V_A. forall bc: Seq.seq tup2_K_V. forall c: t_IntoIter_K_V_A. produces_IntoIter_K_V_A a ab b
                /\ produces_IntoIter_K_V_A b bc c
              -> produces_IntoIter_K_V_A a ab b
              /\ produces_IntoIter_K_V_A b bc c
              /\ (forall result: (). produces_IntoIter_K_V_A a (Seq.(++) ab bc) c
                -> produces_IntoIter_K_V_A a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_refl__refines (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Iter_K_V. forall result: (). produces_Iter_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
        -> produces_Iter_K_V self (Seq.empty: Seq.seq tup2_ref_K_ref_V) self
end
module M_std__collections__hash_map__impl_IteratorSpec_for_Iter_K_V__produces_trans__refines (* <std::collections::hash_map::Iter<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_Iter_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_ref_V = { f0: t_K; f1: t_V }
  
  type t_FMap_DeepModelTy_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_V. len_DeepModelTy self >= 0
  
  function view_Iter_K_V (self: t_Iter_K_V) : t_FMap_DeepModelTy_V
  
  predicate contains_tup2_ref_K_ref_V (self: Seq.seq tup2_ref_K_ref_V) (x: tup2_ref_K_ref_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_V) : Map.map t_DeepModelTy t_Option_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_V) (k: t_DeepModelTy) : t_Option_V =
    Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_Iter_K_V [@inline:trivial] (self: t_Iter_K_V) (visited: Seq.seq tup2_ref_K_ref_V) (o: t_Iter_K_V) =
    len_DeepModelTy (view_Iter_K_V self) = Seq.length visited + len_DeepModelTy (view_Iter_K_V o)
    /\ (forall k: t_K, v: t_V. contains_tup2_ref_K_ref_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_Iter_K_V self) (deep_model_ref_K k) = Some v
        /\ get_DeepModelTy (view_Iter_K_V o) (deep_model_ref_K k) = None)
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V o) k = Some v
        -> get_DeepModelTy (view_Iter_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: t_V. get_DeepModelTy (view_Iter_K_V self) k = Some v
        -> (exists k2: t_K. deep_model_ref_K k2 = k /\ contains_tup2_ref_K_ref_V visited { f0 = k2; f1 = v })
        \/ get_DeepModelTy (view_Iter_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_Iter_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_K_V. forall ab: Seq.seq tup2_ref_K_ref_V. forall b: t_Iter_K_V. forall bc: Seq.seq tup2_ref_K_ref_V. forall c: t_Iter_K_V. produces_Iter_K_V a ab b
                /\ produces_Iter_K_V b bc c
              -> produces_Iter_K_V a ab b
              /\ produces_Iter_K_V b bc c
              /\ (forall result: (). produces_Iter_K_V a (Seq.(++) ab bc) c -> produces_Iter_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_trans__refines (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_refmut_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_refmut_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_refmut_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_refmut_V
  
  predicate contains_tup2_ref_K_refmut_V (self: Seq.seq tup2_ref_K_refmut_V) (x: tup2_ref_K_refmut_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_refmut_V = None | Some (MutBorrow.t t_V)
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : Map.map t_DeepModelTy t_Option_refmut_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_refmut_V) (k: t_DeepModelTy) : t_Option_refmut_V
   = Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_refmut_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_refmut_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_refmut_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_refmut_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IterMut_K_V. forall ab: Seq.seq tup2_ref_K_refmut_V. forall b: t_IterMut_K_V. forall bc: Seq.seq tup2_ref_K_refmut_V. forall c: t_IterMut_K_V. produces_IterMut_K_V a ab b
                /\ produces_IterMut_K_V b bc c
              -> produces_IterMut_K_V a ab b
              /\ produces_IterMut_K_V b bc c
              /\ (forall result: (). produces_IterMut_K_V a (Seq.(++) ab bc) c
                -> produces_IterMut_K_V a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_map__impl_IteratorSpec_for_IterMut_K_V__produces_refl__refines (* <std::collections::hash_map::IterMut<'a, K, V> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use seq.Seq
  use map.Map
  use int.Int
  
  type t_IterMut_K_V
  
  type t_K
  
  type t_V
  
  type tup2_ref_K_refmut_V = { f0: t_K; f1: MutBorrow.t t_V }
  
  type t_FMap_DeepModelTy_refmut_V
  
  function len_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : int
  
  axiom len_DeepModelTy_spec: forall self: t_FMap_DeepModelTy_refmut_V. len_DeepModelTy self >= 0
  
  function view_IterMut_K_V (self: t_IterMut_K_V) : t_FMap_DeepModelTy_refmut_V
  
  predicate contains_tup2_ref_K_refmut_V (self: Seq.seq tup2_ref_K_refmut_V) (x: tup2_ref_K_refmut_V) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  type t_DeepModelTy
  
  type t_Option_refmut_V = None | Some (MutBorrow.t t_V)
  
  function to_mapping_DeepModelTy (self: t_FMap_DeepModelTy_refmut_V) : Map.map t_DeepModelTy t_Option_refmut_V
  
  function get_DeepModelTy [@inline:trivial] (self: t_FMap_DeepModelTy_refmut_V) (k: t_DeepModelTy) : t_Option_refmut_V
   = Map.get (to_mapping_DeepModelTy self) k
  
  meta "rewrite_def" function get_DeepModelTy
  
  function deep_model_K (self: t_K) : t_DeepModelTy
  
  function deep_model_ref_K [@inline:trivial] (self: t_K) : t_DeepModelTy = deep_model_K self
  
  meta "rewrite_def" function deep_model_ref_K
  
  predicate produces_IterMut_K_V [@inline:trivial] (self: t_IterMut_K_V) (visited: Seq.seq tup2_ref_K_refmut_V) (o: t_IterMut_K_V) =
    len_DeepModelTy (view_IterMut_K_V self) = Seq.length visited + len_DeepModelTy (view_IterMut_K_V o)
    /\ (forall k: t_K, v: MutBorrow.t t_V. contains_tup2_ref_K_refmut_V visited { f0 = k; f1 = v }
        -> get_DeepModelTy (view_IterMut_K_V self) (deep_model_K k) = Some v
        /\ get_DeepModelTy (view_IterMut_K_V o) (deep_model_K k) = None)
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V o) k = Some v
        -> get_DeepModelTy (view_IterMut_K_V self) k = Some v
        /\ not (exists k2: t_K, v2: MutBorrow.t t_V. deep_model_ref_K k2 = k
          /\ contains_tup2_ref_K_refmut_V visited { f0 = k2; f1 = v2 }))
    /\ (forall k: t_DeepModelTy, v: MutBorrow.t t_V. get_DeepModelTy (view_IterMut_K_V self) k = Some v
        -> (exists k1: t_K. deep_model_ref_K k1 = k /\ contains_tup2_ref_K_refmut_V visited { f0 = k1; f1 = v })
        \/ get_DeepModelTy (view_IterMut_K_V o) k = Some v)
    /\ (forall i1: int, i2: int. 0 <= i1
        /\ i1 < Seq.length visited
        /\ 0 <= i2
        /\ i2 < Seq.length visited
        /\ deep_model_ref_K (Seq.get visited i1).f0 = deep_model_ref_K (Seq.get visited i2).f0 -> i1 = i2)
  
  meta "rewrite_def" predicate produces_IterMut_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IterMut_K_V. forall result: (). produces_IterMut_K_V self (Seq.empty: Seq.seq tup2_ref_K_refmut_V) self
        -> produces_IterMut_K_V self (Seq.empty: Seq.seq tup2_ref_K_refmut_V) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T_Global__produces_refl__refines (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_IntoIter_T_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T_Global (self: t_IntoIter_T_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T_Global) (visited: Seq.seq t_T) (end': t_IntoIter_T_Global) =
    Fset.cardinal (view_IntoIter_T_Global start) = Seq.length visited + Fset.cardinal (view_IntoIter_T_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T_Global end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T_Global end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global end') x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T_Global (self: t_IntoIter_T_Global) (visited: Seq.seq t_T) (o: t_IntoIter_T_Global) =
    set_produces_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_IntoIter_T_Global. forall result: (). produces_IntoIter_T_Global self (Seq.empty: Seq.seq t_T) self
        -> produces_IntoIter_T_Global self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_IntoIter_T_Global__produces_trans__refines (* <std::collections::hash_set::IntoIter<T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_IntoIter_T_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_IntoIter_T_Global (self: t_IntoIter_T_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  predicate contains_T (self: Seq.seq t_T) (x: t_T) = exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_T (start: t_IntoIter_T_Global) (visited: Seq.seq t_T) (end': t_IntoIter_T_Global) =
    Fset.cardinal (view_IntoIter_T_Global start) = Seq.length visited + Fset.cardinal (view_IntoIter_T_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global start) x
        -> (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1)
        \/ contains_DeepModelTy (view_IntoIter_T_Global end') x)
    /\ (forall x: t_T. contains_T visited x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) (deep_model_T x)
        /\ not contains_DeepModelTy (view_IntoIter_T_Global end') (deep_model_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_IntoIter_T_Global end') x
        -> contains_DeepModelTy (view_IntoIter_T_Global start) x
        /\ not (exists x1: t_T. deep_model_T x1 = x /\ contains_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j /\ j < Seq.length visited /\ deep_model_T (Seq.get visited i) = deep_model_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_IntoIter_T_Global (self: t_IntoIter_T_Global) (visited: Seq.seq t_T) (o: t_IntoIter_T_Global) =
    set_produces_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_IntoIter_T_Global. forall ab: Seq.seq t_T. forall b: t_IntoIter_T_Global. forall bc: Seq.seq t_T. forall c: t_IntoIter_T_Global. produces_IntoIter_T_Global a ab b
                /\ produces_IntoIter_T_Global b bc c
              -> produces_IntoIter_T_Global a ab b
              /\ produces_IntoIter_T_Global b bc c
              /\ (forall result: (). produces_IntoIter_T_Global a (Seq.(++) ab bc) c
                -> produces_IntoIter_T_Global a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::collections::hash_set::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Iter_T (self: t_Iter_T) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Iter_T) (visited: Seq.seq t_T) (end': t_Iter_T) =
    Fset.cardinal (view_Iter_T start) = Seq.length visited + Fset.cardinal (view_Iter_T end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Iter_T end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Iter_T start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Iter_T end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Iter_T end') x
        -> contains_DeepModelTy (view_Iter_T start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (o: t_Iter_T) = set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T a ab b
                /\ produces_Iter_T b bc c
              -> produces_Iter_T a ab b
              /\ produces_Iter_T b bc c
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S_Global__produces_refl__refines (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Intersection_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S_Global (self: t_Intersection_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (end': t_Intersection_T_S_Global) =
    Fset.cardinal (view_Intersection_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Intersection_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global end') x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S_Global (self: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (o: t_Intersection_T_S_Global) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Intersection_T_S_Global. forall result: (). produces_Intersection_T_S_Global self (Seq.empty: Seq.seq t_T) self
        -> produces_Intersection_T_S_Global self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Intersection_T_S_Global__produces_trans__refines (* <std::collections::hash_set::Intersection<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Intersection_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Intersection_T_S_Global (self: t_Intersection_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (end': t_Intersection_T_S_Global) =
    Fset.cardinal (view_Intersection_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Intersection_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Intersection_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Intersection_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Intersection_T_S_Global end') x
        -> contains_DeepModelTy (view_Intersection_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Intersection_T_S_Global (self: t_Intersection_T_S_Global) (visited: Seq.seq t_T) (o: t_Intersection_T_S_Global) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Intersection_T_S_Global. forall ab: Seq.seq t_T. forall b: t_Intersection_T_S_Global. forall bc: Seq.seq t_T. forall c: t_Intersection_T_S_Global. produces_Intersection_T_S_Global a ab b
                /\ produces_Intersection_T_S_Global b bc c
              -> produces_Intersection_T_S_Global a ab b
              /\ produces_Intersection_T_S_Global b bc c
              /\ (forall result: (). produces_Intersection_T_S_Global a (Seq.(++) ab bc) c
                -> produces_Intersection_T_S_Global a (Seq.(++) ab bc) c)
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S_Global__produces_refl__refines (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Difference_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S_Global (self: t_Difference_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S_Global) (visited: Seq.seq t_T) (end': t_Difference_T_S_Global) =
    Fset.cardinal (view_Difference_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Difference_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global end') x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S_Global (self: t_Difference_T_S_Global) (visited: Seq.seq t_T) (o: t_Difference_T_S_Global) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Difference_T_S_Global. forall result: (). produces_Difference_T_S_Global self (Seq.empty: Seq.seq t_T) self
        -> produces_Difference_T_S_Global self (Seq.empty: Seq.seq t_T) self
end
module M_std__collections__hash_set__impl_IteratorSpec_for_Difference_T_S_Global__produces_trans__refines (* <std::collections::hash_set::Difference<'a, T, S> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use set.Fset
  use int.Int
  
  type t_Difference_T_S_Global
  
  type t_T
  
  type t_DeepModelTy
  
  function view_Difference_T_S_Global (self: t_Difference_T_S_Global) : Fset.fset t_DeepModelTy
  
  predicate contains_DeepModelTy [@inline:trivial] (self: Fset.fset t_DeepModelTy) (e: t_DeepModelTy) = Fset.mem e self
  
  meta "rewrite_def" predicate contains_DeepModelTy
  
  function deep_model_T (self: t_T) : t_DeepModelTy
  
  function deep_model_ref_T [@inline:trivial] (self: t_T) : t_DeepModelTy = deep_model_T self
  
  meta "rewrite_def" function deep_model_ref_T
  
  predicate contains_ref_T (self: Seq.seq t_T) (x: t_T) =
    exists i: int. 0 <= i /\ i < Seq.length self /\ Seq.get self i = x
  
  predicate set_produces_ref_T (start: t_Difference_T_S_Global) (visited: Seq.seq t_T) (end': t_Difference_T_S_Global) =
    Fset.cardinal (view_Difference_T_S_Global start)
      = Seq.length visited + Fset.cardinal (view_Difference_T_S_Global end')
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global start) x
        -> (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1)
        \/ contains_DeepModelTy (view_Difference_T_S_Global end') x)
    /\ (forall x: t_T. contains_ref_T visited x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) (deep_model_ref_T x)
        /\ not contains_DeepModelTy (view_Difference_T_S_Global end') (deep_model_ref_T x))
    /\ (forall x: t_DeepModelTy. contains_DeepModelTy (view_Difference_T_S_Global end') x
        -> contains_DeepModelTy (view_Difference_T_S_Global start) x
        /\ not (exists x1: t_T. deep_model_ref_T x1 = x /\ contains_ref_T visited x1))
    /\ (forall i: int, j: int. 0 <= i
        /\ i < Seq.length visited
        /\ 0 <= j
        /\ j < Seq.length visited /\ deep_model_ref_T (Seq.get visited i) = deep_model_ref_T (Seq.get visited j)
      -> i = j)
  
  predicate produces_Difference_T_S_Global (self: t_Difference_T_S_Global) (visited: Seq.seq t_T) (o: t_Difference_T_S_Global) =
    set_produces_ref_T self visited o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Difference_T_S_Global. forall ab: Seq.seq t_T. forall b: t_Difference_T_S_Global. forall bc: Seq.seq t_T. forall c: t_Difference_T_S_Global. produces_Difference_T_S_Global a ab b
                /\ produces_Difference_T_S_Global b bc c
              -> produces_Difference_T_S_Global a ab b
              /\ produces_Difference_T_S_Global b bc c
              /\ (forall result: (). produces_Difference_T_S_Global a (Seq.(++) ab bc) c
                -> produces_Difference_T_S_Global a (Seq.(++) ab bc) c)
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_trans__refines (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Iter_T. forall ab: Seq.seq t_T. forall b: t_Iter_T. forall bc: Seq.seq t_T. forall c: t_Iter_T. produces_Iter_T a ab b
                /\ produces_Iter_T b bc c
              -> produces_Iter_T a ab b
              /\ produces_Iter_T b bc c
              /\ (forall result: (). produces_Iter_T a (Seq.(++) ab bc) c -> produces_Iter_T a (Seq.(++) ab bc) c)
end
module M_std__deque__impl_IteratorSpec_for_Iter_T__produces_refl__refines (* <std::collections::vec_deque::Iter<'a, T> as std::iter::IteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.slice.Slice64
  use int.Int
  
  type t_Iter_T
  
  type t_T
  
  function index_slice_T [@inline:trivial] (self: Slice64.slice t_T) (ix: int) : t_T = Seq.get (Slice64.view self) ix
  
  meta "rewrite_def" function index_slice_T
  
  function to_ref_seq_slice_T (self: Slice64.slice t_T) : Seq.seq t_T
  
  axiom to_ref_seq_slice_T_spec: forall self: Slice64.slice t_T. Seq.length (to_ref_seq_slice_T self)
      = Seq.length (Slice64.view self)
  
  axiom to_ref_seq_slice_T_spec'0: forall self: Slice64.slice t_T. forall i: int. 0 <= i
          /\ i < Seq.length (to_ref_seq_slice_T self) -> Seq.get (to_ref_seq_slice_T self) i = index_slice_T self i
  
  function view_Iter_T (self: t_Iter_T) : Slice64.slice t_T
  
  predicate produces_Iter_T (self: t_Iter_T) (visited: Seq.seq t_T) (tl: t_Iter_T) =
    to_ref_seq_slice_T (view_Iter_T self) = Seq.(++) visited (to_ref_seq_slice_T (view_Iter_T tl))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Iter_T. forall result: (). produces_Iter_T self (Seq.empty: Seq.seq t_T) self
        -> produces_Iter_T self (Seq.empty: Seq.seq t_T) self
end
module M_logic__int__impl_PartialOrd_for_Int__le__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ <= other)
          -> result = (deep_model_ref_Int self_ <= deep_model_ref_Int other)
end
module M_logic__int__impl_PartialOrd_for_Int__lt__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ < other)
          -> result = (deep_model_ref_Int self_ < deep_model_ref_Int other)
end
module M_logic__int__impl_PartialOrd_for_Int__gt__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ > other)
          -> result = (deep_model_ref_Int self_ > deep_model_ref_Int other)
end
module M_logic__int__impl_PartialOrd_for_Int__partial_cmp__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall rhs: int. forall result: t_Option_Ordering. result
            = Some (cmp_log_Int self_ rhs) -> result = Some (cmp_log_Int (deep_model_Int self_) (deep_model_Int rhs))
end
module M_logic__int__impl_PartialOrd_for_Int__ge__refines (* <logic::int::Int as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  function deep_model_Int [@inline:trivial] (self: int) : int = self
  
  meta "rewrite_def" function deep_model_Int
  
  function deep_model_ref_Int [@inline:trivial] (self: int) : int = deep_model_Int self
  
  meta "rewrite_def" function deep_model_ref_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: int. forall other: int. forall result: bool. result = (self_ >= other)
          -> result = (deep_model_ref_Int self_ >= deep_model_ref_Int other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__ge__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.ge (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.ge (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__le__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.le (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.le (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__gt__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.gt (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.gt (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__lt__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  type t_PeanoInt = { f0: UInt64.t }
  
  function view_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function view_PeanoInt
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  function deep_model_ref_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = deep_model_PeanoInt self
  
  meta "rewrite_def" function deep_model_ref_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall other: t_PeanoInt. forall result: bool. result
            = UInt64.lt (view_PeanoInt self_) (view_PeanoInt other)
          -> result = UInt64.lt (deep_model_ref_PeanoInt self_) (deep_model_ref_PeanoInt other)
end
module M_peano__impl_PartialOrd_for_PeanoInt__partial_cmp__refines (* <peano::PeanoInt as std::cmp::PartialOrd> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  type t_Option_Ordering = None | Some t_Ordering
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Option_Ordering. result
            = Some (cmp_log_PeanoInt self_ rhs)
          -> result = Some (cmp_log_u64 (deep_model_PeanoInt self_) (deep_model_PeanoInt rhs))
end
module M_logic__int__impl_InhabitedInvariant_for_NatInner__inhabits__refines (* <logic::int::NatInner as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_NatInner = { f0: int }
  
  predicate invariant_NatInner (self: t_NatInner) = self.f0 >= 0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_NatInner. invariant_NatInner result -> invariant_NatInner result
end
module M_logic__ra__view__impl_InhabitedInvariant_for_ViewInner_R__inhabits__refines (* <logic::ra::view::ViewInner<R> as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_ViewInner_R. invariant_ViewInner_R result -> invariant_ViewInner_R result
end
module M_logic__real__impl_InhabitedInvariant_for_PositiveRealInner__inhabits__refines (* <logic::real::PositiveRealInner as invariant::InhabitedInvariant> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveRealInner = { f0: Real.real }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0 (FromInt.from_int 0)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_PositiveRealInner. invariant_PositiveRealInner result
      -> invariant_PositiveRealInner result
end
module M_logic__ord__impl_OrdLogic_for_ref_T__refl__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall result: (). cmp_log_ref_T x x = Equal -> cmp_log_ref_T x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_ge_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate ge_log_ref_T (self: t_T) (other: t_T) = ge_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). ge_log_ref_T x y = (cmp_log_ref_T x y <> Less)
          -> ge_log_ref_T x y = (cmp_log_ref_T x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__eq_cmp__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). (x = y) = (cmp_log_ref_T x y = Equal)
          -> (x = y) = (cmp_log_ref_T x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_le_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate le_log_ref_T (self: t_T) (other: t_T) = le_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). le_log_ref_T x y = (cmp_log_ref_T x y <> Greater)
          -> le_log_ref_T x y = (cmp_log_ref_T x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_lt_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate lt_log_ref_T (self: t_T) (other: t_T) = lt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). lt_log_ref_T x y = (cmp_log_ref_T x y = Less)
          -> lt_log_ref_T x y = (cmp_log_ref_T x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym1__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. cmp_log_ref_T x y = Less
        -> cmp_log_ref_T x y = Less /\ (forall result: (). cmp_log_ref_T y x = Greater -> cmp_log_ref_T y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__antisym2__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. cmp_log_ref_T x y = Greater
        -> cmp_log_ref_T x y = Greater /\ (forall result: (). cmp_log_ref_T y x = Less -> cmp_log_ref_T y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__trans__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall z: t_T. forall o: t_Ordering. cmp_log_ref_T x y = o
              /\ cmp_log_ref_T y z = o
            -> cmp_log_ref_T x y = o
            /\ cmp_log_ref_T y z = o /\ (forall result: (). cmp_log_ref_T x z = o -> cmp_log_ref_T x z = o)
end
module M_logic__ord__impl_OrdLogic_for_ref_T__cmp_gt_log__refines (* <&T as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  predicate gt_log_ref_T (self: t_T) (other: t_T) = gt_log_T self other
  
  function cmp_log_ref_T (self: t_T) (o: t_T) : t_Ordering = cmp_log_T self o
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_T. forall y: t_T. forall result: (). gt_log_ref_T x y = (cmp_log_ref_T x y = Greater)
          -> gt_log_ref_T x y = (cmp_log_ref_T x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__eq_cmp__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x = y) = (cmp_log_Int x y = Equal)
          -> (x = y) = (cmp_log_Int x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym1__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. cmp_log_Int x y = Less
        -> cmp_log_Int x y = Less /\ (forall result: (). cmp_log_Int y x = Greater -> cmp_log_Int y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_gt_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x > y) = (cmp_log_Int x y = Greater)
          -> (x > y) = (cmp_log_Int x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_le_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x <= y) = (cmp_log_Int x y <> Greater)
          -> (x <= y) = (cmp_log_Int x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_lt_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x < y) = (cmp_log_Int x y = Less)
          -> (x < y) = (cmp_log_Int x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__refl__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall result: (). cmp_log_Int x x = Equal -> cmp_log_Int x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_Int__antisym2__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. cmp_log_Int x y = Greater
        -> cmp_log_Int x y = Greater /\ (forall result: (). cmp_log_Int y x = Less -> cmp_log_Int y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_Int__trans__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall z: int. forall o: t_Ordering. cmp_log_Int x y = o
              /\ cmp_log_Int y z = o
            -> cmp_log_Int x y = o
            /\ cmp_log_Int y z = o /\ (forall result: (). cmp_log_Int x z = o -> cmp_log_Int x z = o)
end
module M_logic__ord__impl_OrdLogic_for_Int__cmp_ge_log__refines (* <logic::int::Int as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Int (self: int) (o: int) : t_Ordering = if self < o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: int. forall y: int. forall result: (). (x >= y) = (cmp_log_Int x y <> Less)
          -> (x >= y) = (cmp_log_Int x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__eq_cmp__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). (x = y) = (cmp_log_u8 x y = Equal)
          -> (x = y) = (cmp_log_u8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_gt_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.gt x y = (cmp_log_u8 x y = Greater)
          -> UInt8.gt x y = (cmp_log_u8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__refl__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall result: (). cmp_log_u8 x x = Equal -> cmp_log_u8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym2__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. cmp_log_u8 x y = Greater
        -> cmp_log_u8 x y = Greater /\ (forall result: (). cmp_log_u8 y x = Less -> cmp_log_u8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_ge_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.ge x y = (cmp_log_u8 x y <> Less)
          -> UInt8.ge x y = (cmp_log_u8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__trans__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall z: UInt8.t. forall o: t_Ordering. cmp_log_u8 x y = o
              /\ cmp_log_u8 y z = o
            -> cmp_log_u8 x y = o /\ cmp_log_u8 y z = o /\ (forall result: (). cmp_log_u8 x z = o -> cmp_log_u8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_le_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.le x y = (cmp_log_u8 x y <> Greater)
          -> UInt8.le x y = (cmp_log_u8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u8__cmp_lt_log__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. forall result: (). UInt8.lt x y = (cmp_log_u8 x y = Less)
          -> UInt8.lt x y = (cmp_log_u8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u8__antisym1__refines (* <u8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt8.t. forall y: UInt8.t. cmp_log_u8 x y = Less
        -> cmp_log_u8 x y = Less /\ (forall result: (). cmp_log_u8 y x = Greater -> cmp_log_u8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym2__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. cmp_log_u16 x y = Greater
        -> cmp_log_u16 x y = Greater /\ (forall result: (). cmp_log_u16 y x = Less -> cmp_log_u16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_ge_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.ge x y = (cmp_log_u16 x y <> Less)
          -> UInt16.ge x y = (cmp_log_u16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_gt_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.gt x y = (cmp_log_u16 x y = Greater)
          -> UInt16.gt x y = (cmp_log_u16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__eq_cmp__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). (x = y) = (cmp_log_u16 x y = Equal)
          -> (x = y) = (cmp_log_u16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_le_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.le x y = (cmp_log_u16 x y <> Greater)
          -> UInt16.le x y = (cmp_log_u16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__cmp_lt_log__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall result: (). UInt16.lt x y = (cmp_log_u16 x y = Less)
          -> UInt16.lt x y = (cmp_log_u16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u16__antisym1__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. cmp_log_u16 x y = Less
        -> cmp_log_u16 x y = Less /\ (forall result: (). cmp_log_u16 y x = Greater -> cmp_log_u16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u16__trans__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall y: UInt16.t. forall z: UInt16.t. forall o: t_Ordering. cmp_log_u16 x y = o
              /\ cmp_log_u16 y z = o
            -> cmp_log_u16 x y = o
            /\ cmp_log_u16 y z = o /\ (forall result: (). cmp_log_u16 x z = o -> cmp_log_u16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u16__refl__refines (* <u16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt16.t. forall result: (). cmp_log_u16 x x = Equal -> cmp_log_u16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u32__trans__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall z: UInt32.t. forall o: t_Ordering. cmp_log_u32 x y = o
              /\ cmp_log_u32 y z = o
            -> cmp_log_u32 x y = o
            /\ cmp_log_u32 y z = o /\ (forall result: (). cmp_log_u32 x z = o -> cmp_log_u32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_gt_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.gt x y = (cmp_log_u32 x y = Greater)
          -> UInt32.gt x y = (cmp_log_u32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym1__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. cmp_log_u32 x y = Less
        -> cmp_log_u32 x y = Less /\ (forall result: (). cmp_log_u32 y x = Greater -> cmp_log_u32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_lt_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.lt x y = (cmp_log_u32 x y = Less)
          -> UInt32.lt x y = (cmp_log_u32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_le_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.le x y = (cmp_log_u32 x y <> Greater)
          -> UInt32.le x y = (cmp_log_u32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u32__antisym2__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. cmp_log_u32 x y = Greater
        -> cmp_log_u32 x y = Greater /\ (forall result: (). cmp_log_u32 y x = Less -> cmp_log_u32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__cmp_ge_log__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). UInt32.ge x y = (cmp_log_u32 x y <> Less)
          -> UInt32.ge x y = (cmp_log_u32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u32__refl__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall result: (). cmp_log_u32 x x = Equal -> cmp_log_u32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u32__eq_cmp__refines (* <u32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt32.t. forall y: UInt32.t. forall result: (). (x = y) = (cmp_log_u32 x y = Equal)
          -> (x = y) = (cmp_log_u32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u64__eq_cmp__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log_u64 x y = Equal)
          -> (x = y) = (cmp_log_u64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_le_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y = (cmp_log_u64 x y <> Greater)
          -> UInt64.le x y = (cmp_log_u64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_gt_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y = (cmp_log_u64 x y = Greater)
          -> UInt64.gt x y = (cmp_log_u64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_lt_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y = (cmp_log_u64 x y = Less)
          -> UInt64.lt x y = (cmp_log_u64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__refl__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall result: (). cmp_log_u64 x x = Equal -> cmp_log_u64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u64__cmp_ge_log__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y = (cmp_log_u64 x y <> Less)
          -> UInt64.ge x y = (cmp_log_u64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym2__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_u64 x y = Greater
        -> cmp_log_u64 x y = Greater /\ (forall result: (). cmp_log_u64 y x = Less -> cmp_log_u64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u64__trans__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log_u64 x y = o
              /\ cmp_log_u64 y z = o
            -> cmp_log_u64 x y = o
            /\ cmp_log_u64 y z = o /\ (forall result: (). cmp_log_u64 x z = o -> cmp_log_u64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u64__antisym1__refines (* <u64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_u64 x y = Less
        -> cmp_log_u64 x y = Less /\ (forall result: (). cmp_log_u64 y x = Greater -> cmp_log_u64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__refl__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall result: (). cmp_log_u128 x x = Equal -> cmp_log_u128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_gt_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.gt x y
            = (cmp_log_u128 x y = Greater) -> UInt128.gt x y = (cmp_log_u128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym2__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. cmp_log_u128 x y = Greater
        -> cmp_log_u128 x y = Greater /\ (forall result: (). cmp_log_u128 y x = Less -> cmp_log_u128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__antisym1__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. cmp_log_u128 x y = Less
        -> cmp_log_u128 x y = Less /\ (forall result: (). cmp_log_u128 y x = Greater -> cmp_log_u128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__trans__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall z: UInt128.t. forall o: t_Ordering. cmp_log_u128 x y
                = o
              /\ cmp_log_u128 y z = o
            -> cmp_log_u128 x y = o
            /\ cmp_log_u128 y z = o /\ (forall result: (). cmp_log_u128 x z = o -> cmp_log_u128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_le_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.le x y
            = (cmp_log_u128 x y <> Greater) -> UInt128.le x y = (cmp_log_u128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_ge_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.ge x y = (cmp_log_u128 x y <> Less)
          -> UInt128.ge x y = (cmp_log_u128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__cmp_lt_log__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). UInt128.lt x y = (cmp_log_u128 x y = Less)
          -> UInt128.lt x y = (cmp_log_u128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_u128__eq_cmp__refines (* <u128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt128.t. forall y: UInt128.t. forall result: (). (x = y) = (cmp_log_u128 x y = Equal)
          -> (x = y) = (cmp_log_u128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym1__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_usize x y = Less
        -> cmp_log_usize x y = Less /\ (forall result: (). cmp_log_usize y x = Greater -> cmp_log_usize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_le_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.le x y
            = (cmp_log_usize x y <> Greater) -> UInt64.le x y = (cmp_log_usize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__antisym2__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. cmp_log_usize x y = Greater
        -> cmp_log_usize x y = Greater /\ (forall result: (). cmp_log_usize y x = Less -> cmp_log_usize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__eq_cmp__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). (x = y) = (cmp_log_usize x y = Equal)
          -> (x = y) = (cmp_log_usize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_gt_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.gt x y = (cmp_log_usize x y = Greater)
          -> UInt64.gt x y = (cmp_log_usize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_usize__trans__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall z: UInt64.t. forall o: t_Ordering. cmp_log_usize x y = o
              /\ cmp_log_usize y z = o
            -> cmp_log_usize x y = o
            /\ cmp_log_usize y z = o /\ (forall result: (). cmp_log_usize x z = o -> cmp_log_usize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_lt_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.lt x y = (cmp_log_usize x y = Less)
          -> UInt64.lt x y = (cmp_log_usize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__cmp_ge_log__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall y: UInt64.t. forall result: (). UInt64.ge x y = (cmp_log_usize x y <> Less)
          -> UInt64.ge x y = (cmp_log_usize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_usize__refl__refines (* <usize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: UInt64.t. forall result: (). cmp_log_usize x x = Equal -> cmp_log_usize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i8__refl__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall result: (). cmp_log_i8 x x = Equal -> cmp_log_i8 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_ge_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.ge x y = (cmp_log_i8 x y <> Less)
          -> Int8.ge x y = (cmp_log_i8 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__trans__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall z: Int8.t. forall o: t_Ordering. cmp_log_i8 x y = o
              /\ cmp_log_i8 y z = o
            -> cmp_log_i8 x y = o /\ cmp_log_i8 y z = o /\ (forall result: (). cmp_log_i8 x z = o -> cmp_log_i8 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_gt_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.gt x y = (cmp_log_i8 x y = Greater)
          -> Int8.gt x y = (cmp_log_i8 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym1__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. cmp_log_i8 x y = Less
        -> cmp_log_i8 x y = Less /\ (forall result: (). cmp_log_i8 y x = Greater -> cmp_log_i8 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i8__antisym2__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. cmp_log_i8 x y = Greater
        -> cmp_log_i8 x y = Greater /\ (forall result: (). cmp_log_i8 y x = Less -> cmp_log_i8 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__eq_cmp__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). (x = y) = (cmp_log_i8 x y = Equal)
          -> (x = y) = (cmp_log_i8 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_lt_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.lt x y = (cmp_log_i8 x y = Less)
          -> Int8.lt x y = (cmp_log_i8 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i8__cmp_le_log__refines (* <i8 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int8.t. forall y: Int8.t. forall result: (). Int8.le x y = (cmp_log_i8 x y <> Greater)
          -> Int8.le x y = (cmp_log_i8 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__trans__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall z: Int16.t. forall o: t_Ordering. cmp_log_i16 x y = o
              /\ cmp_log_i16 y z = o
            -> cmp_log_i16 x y = o
            /\ cmp_log_i16 y z = o /\ (forall result: (). cmp_log_i16 x z = o -> cmp_log_i16 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i16__eq_cmp__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). (x = y) = (cmp_log_i16 x y = Equal)
          -> (x = y) = (cmp_log_i16 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_gt_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.gt x y = (cmp_log_i16 x y = Greater)
          -> Int16.gt x y = (cmp_log_i16 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym1__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. cmp_log_i16 x y = Less
        -> cmp_log_i16 x y = Less /\ (forall result: (). cmp_log_i16 y x = Greater -> cmp_log_i16 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_le_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.le x y = (cmp_log_i16 x y <> Greater)
          -> Int16.le x y = (cmp_log_i16 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i16__antisym2__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. cmp_log_i16 x y = Greater
        -> cmp_log_i16 x y = Greater /\ (forall result: (). cmp_log_i16 y x = Less -> cmp_log_i16 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_lt_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.lt x y = (cmp_log_i16 x y = Less)
          -> Int16.lt x y = (cmp_log_i16 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__cmp_ge_log__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall y: Int16.t. forall result: (). Int16.ge x y = (cmp_log_i16 x y <> Less)
          -> Int16.ge x y = (cmp_log_i16 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i16__refl__refines (* <i16 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int16.t. forall result: (). cmp_log_i16 x x = Equal -> cmp_log_i16 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_lt_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.lt x y = (cmp_log_i32 x y = Less)
          -> Int32.lt x y = (cmp_log_i32 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_ge_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.ge x y = (cmp_log_i32 x y <> Less)
          -> Int32.ge x y = (cmp_log_i32 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_le_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.le x y = (cmp_log_i32 x y <> Greater)
          -> Int32.le x y = (cmp_log_i32 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__trans__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall z: Int32.t. forall o: t_Ordering. cmp_log_i32 x y = o
              /\ cmp_log_i32 y z = o
            -> cmp_log_i32 x y = o
            /\ cmp_log_i32 y z = o /\ (forall result: (). cmp_log_i32 x z = o -> cmp_log_i32 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i32__refl__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall result: (). cmp_log_i32 x x = Equal -> cmp_log_i32 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i32__cmp_gt_log__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). Int32.gt x y = (cmp_log_i32 x y = Greater)
          -> Int32.gt x y = (cmp_log_i32 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__eq_cmp__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. forall result: (). (x = y) = (cmp_log_i32 x y = Equal)
          -> (x = y) = (cmp_log_i32 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym1__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. cmp_log_i32 x y = Less
        -> cmp_log_i32 x y = Less /\ (forall result: (). cmp_log_i32 y x = Greater -> cmp_log_i32 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i32__antisym2__refines (* <i32 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int32.t. forall y: Int32.t. cmp_log_i32 x y = Greater
        -> cmp_log_i32 x y = Greater /\ (forall result: (). cmp_log_i32 y x = Less -> cmp_log_i32 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__refl__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall result: (). cmp_log_i64 x x = Equal -> cmp_log_i64 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i64__trans__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log_i64 x y = o
              /\ cmp_log_i64 y z = o
            -> cmp_log_i64 x y = o
            /\ cmp_log_i64 y z = o /\ (forall result: (). cmp_log_i64 x z = o -> cmp_log_i64 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_le_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y = (cmp_log_i64 x y <> Greater)
          -> Int64.le x y = (cmp_log_i64 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_ge_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log_i64 x y <> Less)
          -> Int64.ge x y = (cmp_log_i64 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_gt_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y = (cmp_log_i64 x y = Greater)
          -> Int64.gt x y = (cmp_log_i64 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i64__eq_cmp__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log_i64 x y = Equal)
          -> (x = y) = (cmp_log_i64 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i64__cmp_lt_log__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log_i64 x y = Less)
          -> Int64.lt x y = (cmp_log_i64 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym2__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_i64 x y = Greater
        -> cmp_log_i64 x y = Greater /\ (forall result: (). cmp_log_i64 y x = Less -> cmp_log_i64 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i64__antisym1__refines (* <i64 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_i64 x y = Less
        -> cmp_log_i64 x y = Less /\ (forall result: (). cmp_log_i64 y x = Greater -> cmp_log_i64 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__trans__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall z: Int128.t. forall o: t_Ordering. cmp_log_i128 x y = o
              /\ cmp_log_i128 y z = o
            -> cmp_log_i128 x y = o
            /\ cmp_log_i128 y z = o /\ (forall result: (). cmp_log_i128 x z = o -> cmp_log_i128 x z = o)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_lt_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.lt x y = (cmp_log_i128 x y = Less)
          -> Int128.lt x y = (cmp_log_i128 x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_le_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.le x y = (cmp_log_i128 x y <> Greater)
          -> Int128.le x y = (cmp_log_i128 x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym2__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. cmp_log_i128 x y = Greater
        -> cmp_log_i128 x y = Greater /\ (forall result: (). cmp_log_i128 y x = Less -> cmp_log_i128 y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__eq_cmp__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). (x = y) = (cmp_log_i128 x y = Equal)
          -> (x = y) = (cmp_log_i128 x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_i128__refl__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall result: (). cmp_log_i128 x x = Equal -> cmp_log_i128 x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_gt_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.gt x y = (cmp_log_i128 x y = Greater)
          -> Int128.gt x y = (cmp_log_i128 x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_i128__cmp_ge_log__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. forall result: (). Int128.ge x y = (cmp_log_i128 x y <> Less)
          -> Int128.ge x y = (cmp_log_i128 x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_i128__antisym1__refines (* <i128 as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int128.t. forall y: Int128.t. cmp_log_i128 x y = Less
        -> cmp_log_i128 x y = Less /\ (forall result: (). cmp_log_i128 y x = Greater -> cmp_log_i128 y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym1__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_isize x y = Less
        -> cmp_log_isize x y = Less /\ (forall result: (). cmp_log_isize y x = Greater -> cmp_log_isize y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__eq_cmp__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). (x = y) = (cmp_log_isize x y = Equal)
          -> (x = y) = (cmp_log_isize x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_ge_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.ge x y = (cmp_log_isize x y <> Less)
          -> Int64.ge x y = (cmp_log_isize x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_lt_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.lt x y = (cmp_log_isize x y = Less)
          -> Int64.lt x y = (cmp_log_isize x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_gt_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.gt x y = (cmp_log_isize x y = Greater)
          -> Int64.gt x y = (cmp_log_isize x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__refl__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall result: (). cmp_log_isize x x = Equal -> cmp_log_isize x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_isize__antisym2__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. cmp_log_isize x y = Greater
        -> cmp_log_isize x y = Greater /\ (forall result: (). cmp_log_isize y x = Less -> cmp_log_isize y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_isize__cmp_le_log__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall result: (). Int64.le x y = (cmp_log_isize x y <> Greater)
          -> Int64.le x y = (cmp_log_isize x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_isize__trans__refines (* <isize as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Int64.t. forall y: Int64.t. forall z: Int64.t. forall o: t_Ordering. cmp_log_isize x y = o
              /\ cmp_log_isize y z = o
            -> cmp_log_isize x y = o
            /\ cmp_log_isize y z = o /\ (forall result: (). cmp_log_isize x z = o -> cmp_log_isize x z = o)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_le_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.le x y = (cmp_log_char x y <> Greater)
          -> Char.le x y = (cmp_log_char x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__trans__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall z: Char.t. forall o: t_Ordering. cmp_log_char x y = o
              /\ cmp_log_char y z = o
            -> cmp_log_char x y = o
            /\ cmp_log_char y z = o /\ (forall result: (). cmp_log_char x z = o -> cmp_log_char x z = o)
end
module M_logic__ord__impl_OrdLogic_for_char__eq_cmp__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). (x = y) = (cmp_log_char x y = Equal)
          -> (x = y) = (cmp_log_char x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_gt_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.gt x y = (cmp_log_char x y = Greater)
          -> Char.gt x y = (cmp_log_char x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_ge_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.ge x y = (cmp_log_char x y <> Less)
          -> Char.ge x y = (cmp_log_char x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_char__cmp_lt_log__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. forall result: (). Char.lt x y = (cmp_log_char x y = Less)
          -> Char.lt x y = (cmp_log_char x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__antisym2__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. cmp_log_char x y = Greater
        -> cmp_log_char x y = Greater /\ (forall result: (). cmp_log_char y x = Less -> cmp_log_char y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_char__refl__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall result: (). cmp_log_char x x = Equal -> cmp_log_char x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_char__antisym1__refines (* <char as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Char
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_char (self: Char.t) (o: Char.t) : t_Ordering = if Char.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Char.t. forall y: Char.t. cmp_log_char x y = Less
        -> cmp_log_char x y = Less /\ (forall result: (). cmp_log_char y x = Greater -> cmp_log_char y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_le_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.le x y = (cmp_log_bool x y <> Greater)
          -> Bool.le x y = (cmp_log_bool x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_lt_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.lt x y = (cmp_log_bool x y = Less)
          -> Bool.lt x y = (cmp_log_bool x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__trans__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall z: bool. forall o: t_Ordering. cmp_log_bool x y = o
              /\ cmp_log_bool y z = o
            -> cmp_log_bool x y = o
            /\ cmp_log_bool y z = o /\ (forall result: (). cmp_log_bool x z = o -> cmp_log_bool x z = o)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym1__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. cmp_log_bool x y = Less
        -> cmp_log_bool x y = Less /\ (forall result: (). cmp_log_bool y x = Greater -> cmp_log_bool y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_gt_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.gt x y = (cmp_log_bool x y = Greater)
          -> Bool.gt x y = (cmp_log_bool x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_bool__antisym2__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. cmp_log_bool x y = Greater
        -> cmp_log_bool x y = Greater /\ (forall result: (). cmp_log_bool y x = Less -> cmp_log_bool y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_bool__refl__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall result: (). cmp_log_bool x x = Equal -> cmp_log_bool x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_bool__eq_cmp__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). (x = y) = (cmp_log_bool x y = Equal)
          -> (x = y) = (cmp_log_bool x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_bool__cmp_ge_log__refines (* <bool as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Bool
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_bool (self: bool) (o: bool) : t_Ordering = if Bool.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: bool. forall y: bool. forall result: (). Bool.ge x y = (cmp_log_bool x y <> Less)
          -> Bool.ge x y = (cmp_log_bool x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__eq_cmp__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). (x = y) = (cmp_log_tup2_A_B x y = Equal)
          -> (x = y) = (cmp_log_tup2_A_B x y = Equal)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_ge_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate ge_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ ge_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). ge_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y <> Less) -> ge_log_tup2_A_B x y = (cmp_log_tup2_A_B x y <> Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__refl__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall result: (). cmp_log_tup2_A_B x x = Equal -> cmp_log_tup2_A_B x x = Equal
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_le_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate le_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ le_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). le_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y <> Greater) -> le_log_tup2_A_B x y = (cmp_log_tup2_A_B x y <> Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym2__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. cmp_log_tup2_A_B x y = Greater
        -> cmp_log_tup2_A_B x y = Greater
        /\ (forall result: (). cmp_log_tup2_A_B y x = Less -> cmp_log_tup2_A_B y x = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_gt_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate gt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ gt_log_B self.f1 o.f1 \/ gt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). gt_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y = Greater) -> gt_log_tup2_A_B x y = (cmp_log_tup2_A_B x y = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__cmp_lt_log__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  predicate lt_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) =
    self.f0 = o.f0 /\ lt_log_B self.f1 o.f1 \/ lt_log_A self.f0 o.f0
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall result: (). lt_log_tup2_A_B x y
            = (cmp_log_tup2_A_B x y = Less) -> lt_log_tup2_A_B x y = (cmp_log_tup2_A_B x y = Less)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__antisym1__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. cmp_log_tup2_A_B x y = Less
        -> cmp_log_tup2_A_B x y = Less
        /\ (forall result: (). cmp_log_tup2_A_B y x = Greater -> cmp_log_tup2_A_B y x = Greater)
end
module M_logic__ord__impl_OrdLogic_for_tup2_A_B__trans__refines (* <(A, B) as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_A
  
  type t_B
  
  type tup2_A_B = { f0: t_A; f1: t_B }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_A (self: t_A) (other: t_A) : t_Ordering
  
  function eq_cmp_A (x: t_A) (y: t_A) : ()
  
  axiom eq_cmp_A_spec: forall x: t_A, y: t_A. (x = y) = (cmp_log_A x y = Equal)
  
  function antisym2_A (x: t_A) (y: t_A) : ()
  
  axiom antisym2_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Greater -> cmp_log_A y x = Less
  
  function antisym1_A (x: t_A) (y: t_A) : ()
  
  axiom antisym1_A_spec: forall x: t_A, y: t_A. cmp_log_A x y = Less -> cmp_log_A y x = Greater
  
  function trans_A (x: t_A) (y: t_A) (z: t_A) (o: t_Ordering) : ()
  
  axiom trans_A_spec: forall x: t_A, y: t_A, z: t_A, o: t_Ordering. cmp_log_A x y = o
      -> cmp_log_A y z = o -> cmp_log_A x z = o
  
  function refl_A (x: t_A) : ()
  
  axiom refl_A_spec: forall x: t_A. cmp_log_A x x = Equal
  
  predicate gt_log_A (self: t_A) (o: t_A)
  
  function cmp_gt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_gt_log_A_spec: forall x: t_A, y: t_A. gt_log_A x y = (cmp_log_A x y = Greater)
  
  predicate ge_log_A (self: t_A) (o: t_A)
  
  function cmp_ge_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_ge_log_A_spec: forall x: t_A, y: t_A. ge_log_A x y = (cmp_log_A x y <> Less)
  
  predicate lt_log_A (self: t_A) (o: t_A)
  
  function cmp_lt_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_lt_log_A_spec: forall x: t_A, y: t_A. lt_log_A x y = (cmp_log_A x y = Less)
  
  predicate le_log_A (self: t_A) (o: t_A)
  
  function cmp_le_log_A (x: t_A) (y: t_A) : ()
  
  axiom cmp_le_log_A_spec: forall x: t_A, y: t_A. le_log_A x y = (cmp_log_A x y <> Greater)
  
  function cmp_log_B (self: t_B) (other: t_B) : t_Ordering
  
  function eq_cmp_B (x: t_B) (y: t_B) : ()
  
  axiom eq_cmp_B_spec: forall x: t_B, y: t_B. (x = y) = (cmp_log_B x y = Equal)
  
  function antisym2_B (x: t_B) (y: t_B) : ()
  
  axiom antisym2_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Greater -> cmp_log_B y x = Less
  
  function antisym1_B (x: t_B) (y: t_B) : ()
  
  axiom antisym1_B_spec: forall x: t_B, y: t_B. cmp_log_B x y = Less -> cmp_log_B y x = Greater
  
  function trans_B (x: t_B) (y: t_B) (z: t_B) (o: t_Ordering) : ()
  
  axiom trans_B_spec: forall x: t_B, y: t_B, z: t_B, o: t_Ordering. cmp_log_B x y = o
      -> cmp_log_B y z = o -> cmp_log_B x z = o
  
  function refl_B (x: t_B) : ()
  
  axiom refl_B_spec: forall x: t_B. cmp_log_B x x = Equal
  
  predicate gt_log_B (self: t_B) (o: t_B)
  
  function cmp_gt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_gt_log_B_spec: forall x: t_B, y: t_B. gt_log_B x y = (cmp_log_B x y = Greater)
  
  predicate ge_log_B (self: t_B) (o: t_B)
  
  function cmp_ge_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_ge_log_B_spec: forall x: t_B, y: t_B. ge_log_B x y = (cmp_log_B x y <> Less)
  
  predicate lt_log_B (self: t_B) (o: t_B)
  
  function cmp_lt_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_lt_log_B_spec: forall x: t_B, y: t_B. lt_log_B x y = (cmp_log_B x y = Less)
  
  predicate le_log_B (self: t_B) (o: t_B)
  
  function cmp_le_log_B (x: t_B) (y: t_B) : ()
  
  axiom cmp_le_log_B_spec: forall x: t_B, y: t_B. le_log_B x y = (cmp_log_B x y <> Greater)
  
  function cmp_log_tup2_A_B (self: tup2_A_B) (o: tup2_A_B) : t_Ordering = let r = cmp_log_A self.f0 o.f0 in if r
    = Equal then
      cmp_log_B self.f1 o.f1
    else
      r
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: tup2_A_B. forall y: tup2_A_B. forall z: tup2_A_B. forall o: t_Ordering. cmp_log_tup2_A_B x y
                = o
              /\ cmp_log_tup2_A_B y z = o
            -> cmp_log_tup2_A_B x y = o
            /\ cmp_log_tup2_A_B y z = o /\ (forall result: (). cmp_log_tup2_A_B x z = o -> cmp_log_tup2_A_B x z = o)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_le_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(<=) x y
            = (cmp_log_Real x y <> Greater) -> Real.(<=) x y = (cmp_log_Real x y <> Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__eq_cmp__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). (x = y) = (cmp_log_Real x y = Equal)
          -> (x = y) = (cmp_log_Real x y = Equal)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym2__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. cmp_log_Real x y = Greater
        -> cmp_log_Real x y = Greater /\ (forall result: (). cmp_log_Real y x = Less -> cmp_log_Real y x = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__trans__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall z: Real.real. forall o: t_Ordering. cmp_log_Real x y
                = o
              /\ cmp_log_Real y z = o
            -> cmp_log_Real x y = o
            /\ cmp_log_Real y z = o /\ (forall result: (). cmp_log_Real x z = o -> cmp_log_Real x z = o)
end
module M_logic__real__impl_OrdLogic_for_Real__refl__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall result: (). cmp_log_Real x x = Equal -> cmp_log_Real x x = Equal
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_gt_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(>) x y = (cmp_log_Real x y = Greater)
          -> Real.(>) x y = (cmp_log_Real x y = Greater)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_lt_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(<) x y = (cmp_log_Real x y = Less)
          -> Real.(<) x y = (cmp_log_Real x y = Less)
end
module M_logic__real__impl_OrdLogic_for_Real__cmp_ge_log__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. forall result: (). Real.(>=) x y = (cmp_log_Real x y <> Less)
          -> Real.(>=) x y = (cmp_log_Real x y <> Less)
end
module M_logic__real__impl_OrdLogic_for_Real__antisym1__refines (* <logic::real::Real as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: Real.real. forall y: Real.real. cmp_log_Real x y = Less
        -> cmp_log_Real x y = Less /\ (forall result: (). cmp_log_Real y x = Greater -> cmp_log_Real y x = Greater)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_gt_log__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate gt_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(>) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall y: t_PositiveReal. forall result: (). gt_log_PositiveReal x y
            = (cmp_log_PositiveReal x y = Greater) -> gt_log_PositiveReal x y = (cmp_log_PositiveReal x y = Greater)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__refl__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall result: (). cmp_log_PositiveReal x x = Equal
        -> cmp_log_PositiveReal x x = Equal
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__eq_cmp__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall y: t_PositiveReal. forall result: (). (x = y)
            = (cmp_log_PositiveReal x y = Equal) -> (x = y) = (cmp_log_PositiveReal x y = Equal)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__antisym2__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall y: t_PositiveReal. cmp_log_PositiveReal x y = Greater
        -> cmp_log_PositiveReal x y = Greater
        /\ (forall result: (). cmp_log_PositiveReal y x = Less -> cmp_log_PositiveReal y x = Less)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_le_log__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate le_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(<=) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall y: t_PositiveReal. forall result: (). le_log_PositiveReal x y
            = (cmp_log_PositiveReal x y <> Greater) -> le_log_PositiveReal x y = (cmp_log_PositiveReal x y <> Greater)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_lt_log__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate lt_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(<) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall y: t_PositiveReal. forall result: (). lt_log_PositiveReal x y
            = (cmp_log_PositiveReal x y = Less) -> lt_log_PositiveReal x y = (cmp_log_PositiveReal x y = Less)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__antisym1__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall y: t_PositiveReal. cmp_log_PositiveReal x y = Less
        -> cmp_log_PositiveReal x y = Less
        /\ (forall result: (). cmp_log_PositiveReal y x = Greater -> cmp_log_PositiveReal y x = Greater)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__trans__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall x: t_PositiveReal. forall y: t_PositiveReal. forall z: t_PositiveReal. forall o: t_Ordering. cmp_log_PositiveReal x y
                = o
              /\ cmp_log_PositiveReal y z = o
            -> cmp_log_PositiveReal x y = o
            /\ cmp_log_PositiveReal y z = o
            /\ (forall result: (). cmp_log_PositiveReal x z = o -> cmp_log_PositiveReal x z = o)
end
module M_logic__real__impl_OrdLogic_for_PositiveReal__cmp_ge_log__refines (* <logic::real::PositiveReal as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_Subset_PositiveRealInner
  
  type t_PositiveReal = { f0: t_Subset_PositiveRealInner }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : () = ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : () = ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : () = ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  type t_PositiveRealInner = { f0'0: Real.real }
  
  predicate invariant_PositiveRealInner (self: t_PositiveRealInner) = Real.(>) self.f0'0 (FromInt.from_int 0)
  
  function inner_PositiveRealInner (self: t_Subset_PositiveRealInner) : t_PositiveRealInner
  
  axiom inner_PositiveRealInner_spec:
    forall self: t_Subset_PositiveRealInner. invariant_PositiveRealInner (inner_PositiveRealInner self)
  
  function to_real (self: t_PositiveReal) : Real.real = (inner_PositiveRealInner self.f0).f0'0
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  predicate ge_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) = Real.(>=) (to_real self) (to_real o)
  
  function cmp_log_PositiveReal (self: t_PositiveReal) (o: t_PositiveReal) : t_Ordering =
    cmp_log_Real (to_real self) (to_real o)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PositiveReal. forall y: t_PositiveReal. forall result: (). ge_log_PositiveReal x y
            = (cmp_log_PositiveReal x y <> Less) -> ge_log_PositiveReal x y = (cmp_log_PositiveReal x y <> Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym1__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log_PeanoInt x y = Less
        -> cmp_log_PeanoInt x y = Less
        /\ (forall result: (). cmp_log_PeanoInt y x = Greater -> cmp_log_PeanoInt y x = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_ge_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). ge_log_PeanoInt x y
            = (cmp_log_PeanoInt x y <> Less) -> ge_log_PeanoInt x y = (cmp_log_PeanoInt x y <> Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__refl__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall result: (). cmp_log_PeanoInt x x = Equal -> cmp_log_PeanoInt x x = Equal
end
module M_peano__impl_OrdLogic_for_PeanoInt__eq_cmp__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). (x = y) = (cmp_log_PeanoInt x y = Equal)
          -> (x = y) = (cmp_log_PeanoInt x y = Equal)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_gt_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). gt_log_PeanoInt x y
            = (cmp_log_PeanoInt x y = Greater) -> gt_log_PeanoInt x y = (cmp_log_PeanoInt x y = Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_le_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). le_log_PeanoInt x y
            = (cmp_log_PeanoInt x y <> Greater) -> le_log_PeanoInt x y = (cmp_log_PeanoInt x y <> Greater)
end
module M_peano__impl_OrdLogic_for_PeanoInt__cmp_lt_log__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. forall result: (). lt_log_PeanoInt x y
            = (cmp_log_PeanoInt x y = Less) -> lt_log_PeanoInt x y = (cmp_log_PeanoInt x y = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__antisym2__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_PeanoInt. forall y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
        -> cmp_log_PeanoInt x y = Greater
        /\ (forall result: (). cmp_log_PeanoInt y x = Less -> cmp_log_PeanoInt y x = Less)
end
module M_peano__impl_OrdLogic_for_PeanoInt__trans__refines (* <peano::PeanoInt as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall x: t_PeanoInt. forall y: t_PeanoInt. forall z: t_PeanoInt. forall o: t_Ordering. cmp_log_PeanoInt x y = o
              /\ cmp_log_PeanoInt y z = o
            -> cmp_log_PeanoInt x y = o
            /\ cmp_log_PeanoInt y z = o /\ (forall result: (). cmp_log_PeanoInt x z = o -> cmp_log_PeanoInt x z = o)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_gt_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate gt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). gt_log_Reverse_T x y
            = (cmp_log_Reverse_T x y = Greater) -> gt_log_Reverse_T x y = (cmp_log_Reverse_T x y = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_ge_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate ge_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). ge_log_Reverse_T x y
            = (cmp_log_Reverse_T x y <> Less) -> ge_log_Reverse_T x y = (cmp_log_Reverse_T x y <> Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__eq_cmp__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). (x = y)
            = (cmp_log_Reverse_T x y = Equal) -> (x = y) = (cmp_log_Reverse_T x y = Equal)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_lt_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate lt_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). lt_log_Reverse_T x y
            = (cmp_log_Reverse_T x y = Less) -> lt_log_Reverse_T x y = (cmp_log_Reverse_T x y = Less)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__cmp_le_log__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  predicate le_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) = cmp_log_Reverse_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. forall result: (). le_log_Reverse_T x y
            = (cmp_log_Reverse_T x y <> Greater) -> le_log_Reverse_T x y = (cmp_log_Reverse_T x y <> Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__refl__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall result: (). cmp_log_Reverse_T x x = Equal -> cmp_log_Reverse_T x x = Equal
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym1__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. cmp_log_Reverse_T x y = Less
        -> cmp_log_Reverse_T x y = Less
        /\ (forall result: (). cmp_log_Reverse_T y x = Greater -> cmp_log_Reverse_T y x = Greater)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__trans__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall x: t_Reverse_T. forall y: t_Reverse_T. forall z: t_Reverse_T. forall o: t_Ordering. cmp_log_Reverse_T x y = o
              /\ cmp_log_Reverse_T y z = o
            -> cmp_log_Reverse_T x y = o
            /\ cmp_log_Reverse_T y z = o /\ (forall result: (). cmp_log_Reverse_T x z = o -> cmp_log_Reverse_T x z = o)
end
module M_std__cmp__impl_OrdLogic_for_Reverse_T__antisym2__refines (* <std::cmp::Reverse<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Reverse_T = { f0: t_T }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Reverse_T (self: t_Reverse_T) (o: t_Reverse_T) : t_Ordering = match cmp_log_T self.f0 o.f0 with
      | Equal -> Equal
      | Less -> Greater
      | Greater -> Less
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Reverse_T. forall y: t_Reverse_T. cmp_log_Reverse_T x y = Greater
        -> cmp_log_Reverse_T x y = Greater
        /\ (forall result: (). cmp_log_Reverse_T y x = Less -> cmp_log_Reverse_T y x = Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_lt_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate lt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). lt_log_Option_T x y
            = (cmp_log_Option_T x y = Less) -> lt_log_Option_T x y = (cmp_log_Option_T x y = Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__trans__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall x: t_Option_T. forall y: t_Option_T. forall z: t_Option_T. forall o: t_Ordering. cmp_log_Option_T x y = o
              /\ cmp_log_Option_T y z = o
            -> cmp_log_Option_T x y = o
            /\ cmp_log_Option_T y z = o /\ (forall result: (). cmp_log_Option_T x z = o -> cmp_log_Option_T x z = o)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_ge_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate ge_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Less
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). ge_log_Option_T x y
            = (cmp_log_Option_T x y <> Less) -> ge_log_Option_T x y = (cmp_log_Option_T x y <> Less)
end
module M_std__option__impl_OrdLogic_for_Option_T__eq_cmp__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). (x = y) = (cmp_log_Option_T x y = Equal)
          -> (x = y) = (cmp_log_Option_T x y = Equal)
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym1__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. cmp_log_Option_T x y = Less
        -> cmp_log_Option_T x y = Less
        /\ (forall result: (). cmp_log_Option_T y x = Greater -> cmp_log_Option_T y x = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_le_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate le_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o <> Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). le_log_Option_T x y
            = (cmp_log_Option_T x y <> Greater) -> le_log_Option_T x y = (cmp_log_Option_T x y <> Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__cmp_gt_log__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  predicate gt_log_Option_T (self: t_Option_T) (o: t_Option_T) = cmp_log_Option_T self o = Greater
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. forall result: (). gt_log_Option_T x y
            = (cmp_log_Option_T x y = Greater) -> gt_log_Option_T x y = (cmp_log_Option_T x y = Greater)
end
module M_std__option__impl_OrdLogic_for_Option_T__refl__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall result: (). cmp_log_Option_T x x = Equal -> cmp_log_Option_T x x = Equal
end
module M_std__option__impl_OrdLogic_for_Option_T__antisym2__refines (* <std::option::Option<T> as logic::ord::OrdLogic> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Ordering = Less | Equal | Greater
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function cmp_log_T (self: t_T) (other: t_T) : t_Ordering
  
  function eq_cmp_T (x: t_T) (y: t_T) : ()
  
  axiom eq_cmp_T_spec: forall x: t_T, y: t_T. (x = y) = (cmp_log_T x y = Equal)
  
  function antisym2_T (x: t_T) (y: t_T) : ()
  
  axiom antisym2_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Greater -> cmp_log_T y x = Less
  
  function antisym1_T (x: t_T) (y: t_T) : ()
  
  axiom antisym1_T_spec: forall x: t_T, y: t_T. cmp_log_T x y = Less -> cmp_log_T y x = Greater
  
  function trans_T (x: t_T) (y: t_T) (z: t_T) (o: t_Ordering) : ()
  
  axiom trans_T_spec: forall x: t_T, y: t_T, z: t_T, o: t_Ordering. cmp_log_T x y = o
      -> cmp_log_T y z = o -> cmp_log_T x z = o
  
  function refl_T (x: t_T) : ()
  
  axiom refl_T_spec: forall x: t_T. cmp_log_T x x = Equal
  
  predicate gt_log_T (self: t_T) (o: t_T)
  
  function cmp_gt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_gt_log_T_spec: forall x: t_T, y: t_T. gt_log_T x y = (cmp_log_T x y = Greater)
  
  predicate ge_log_T (self: t_T) (o: t_T)
  
  function cmp_ge_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_ge_log_T_spec: forall x: t_T, y: t_T. ge_log_T x y = (cmp_log_T x y <> Less)
  
  predicate lt_log_T (self: t_T) (o: t_T)
  
  function cmp_lt_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_lt_log_T_spec: forall x: t_T, y: t_T. lt_log_T x y = (cmp_log_T x y = Less)
  
  predicate le_log_T (self: t_T) (o: t_T)
  
  function cmp_le_log_T (x: t_T) (y: t_T) : ()
  
  axiom cmp_le_log_T_spec: forall x: t_T, y: t_T. le_log_T x y = (cmp_log_T x y <> Greater)
  
  function cmp_log_Option_T (self: t_Option_T) (o: t_Option_T) : t_Ordering = match { f0 = self; f1 = o } with
      | {f0 = None; f1 = None} -> Equal
      | {f0 = None; f1 = Some _} -> Less
      | {f0 = Some _; f1 = None} -> Greater
      | {f0 = Some x; f1 = Some y} -> cmp_log_T x y
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall x: t_Option_T. forall y: t_Option_T. cmp_log_Option_T x y = Greater
        -> cmp_log_Option_T x y = Greater
        /\ (forall result: (). cmp_log_Option_T y x = Less -> cmp_log_Option_T y x = Less)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core_idemp__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function core_Ag_T (self: t_Ag_T) : t_Option_Ag_T = Some self
  
  predicate index_Mapping_Ag_T_bool [@inline:trivial] (self: Map.map t_Ag_T bool) (a: t_Ag_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Ag_T_bool
  
  function such_that_Ag_T (p: Map.map t_Ag_T bool) : t_Ag_T
  
  axiom such_that_Ag_T_spec: forall p: Map.map t_Ag_T bool. (exists x: t_Ag_T. index_Mapping_Ag_T_bool p x)
      -> index_Mapping_Ag_T_bool p (such_that_Ag_T p)
  
  function unwrap_Option_Ag_T (self: t_Option_Ag_T) : t_Ag_T = match self with
      | Some x -> x
      | None -> such_that_Ag_T (fun (__0: t_Ag_T) -> true)
      end
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag_T. core_Ag_T self <> None
      -> (forall result: (). (let c = unwrap_Option_Ag_T (core_Ag_T self) in op_Ag_T c c = Some c)
          /\ op_Ag_T (unwrap_Option_Ag_T (core_Ag_T self)) self = Some self
        -> (let c = unwrap_Option_Ag_T (core_Ag_T self) in op_Ag_T c c = Some c)
        /\ op_Ag_T (unwrap_Option_Ag_T (core_Ag_T self)) self = Some self)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__commutative__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Ag_T. forall b: t_Ag_T. forall result: (). op_Ag_T a b = op_Ag_T b a
          -> op_Ag_T a b = op_Ag_T b a
end
module M_logic__ra__agree__impl_RA_for_Ag_T__core_is_maximal_idemp__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  function core_Ag_T (self: t_Ag_T) : t_Option_Ag_T = Some self
  
  function factor_Ag_T (self: t_Ag_T) (factor: t_Ag_T) : t_Option_Ag_T = op_Ag_T self factor
  
  axiom factor_Ag_T_spec: forall self: t_Ag_T, factor: t_Ag_T. match factor_Ag_T self factor with
        | Some c -> op_Ag_T factor c = Some self
        | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
        end
  
  predicate incl_Ag_T (self: t_Ag_T) (other: t_Ag_T) = factor_Ag_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag_T. forall i: t_Ag_T. op_Ag_T i i = Some i /\ op_Ag_T i self = Some self
        -> op_Ag_T i i = Some i
        /\ op_Ag_T i self = Some self
        /\ (forall result: (). match core_Ag_T self with
              | Some c -> incl_Ag_T i c
              | None -> false
              end
          -> match core_Ag_T self with
            | Some c -> incl_Ag_T i c
            | None -> false
            end)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__associative__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function and_then_Option_Ag_T (self: t_Option_Ag_T) (f: Map.map t_Ag_T t_Option_Ag_T) : t_Option_Ag_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Ag_T. forall b: t_Ag_T. forall c: t_Ag_T. forall result: (). and_then_Option_Ag_T (op_Ag_T a b) (fun (ab: t_Ag_T) -> op_Ag_T ab c)
              = and_then_Option_Ag_T (op_Ag_T b c) (fun (bc: t_Ag_T) -> op_Ag_T a bc)
            -> and_then_Option_Ag_T (op_Ag_T a b) (fun (ab: t_Ag_T) -> op_Ag_T ab c)
            = and_then_Option_Ag_T (op_Ag_T b c) (fun (bc: t_Ag_T) -> op_Ag_T a bc)
end
module M_logic__ra__agree__impl_RA_for_Ag_T__factor__refines (* <logic::ra::agree::Ag<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Ag_T = { f0: t_T }
  
  type t_Option_Ag_T = None | Some t_Ag_T
  
  function op_Ag_T (self: t_Ag_T) (other: t_Ag_T) : t_Option_Ag_T = if self.f0 = other.f0 then Some self else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Ag_T. forall factor: t_Ag_T. forall result: t_Option_Ag_T. match result with
              | Some c -> op_Ag_T factor c = Some self
              | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
              end
          -> match result with
            | Some c -> op_Ag_T factor c = Some self
            | None -> forall c: t_Ag_T. op_Ag_T factor c <> Some self
            end
end
module M_logic__ra__excl__impl_RA_for_Excl_T__factor__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl_T. forall factor: t_Excl_T. forall result: t_Option_Excl_T. match result with
              | Some c -> op_Excl_T factor c = Some self
              | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
              end
          -> match result with
            | Some c -> op_Excl_T factor c = Some self
            | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
            end
end
module M_logic__ra__excl__impl_RA_for_Excl_T__commutative__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Excl_T. forall b: t_Excl_T. forall result: (). op_Excl_T a b = op_Excl_T b a
          -> op_Excl_T a b = op_Excl_T b a
end
module M_logic__ra__excl__impl_RA_for_Excl_T__associative__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function and_then_Option_Excl_T (self: t_Option_Excl_T) (f: Map.map t_Excl_T t_Option_Excl_T) : t_Option_Excl_T =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Excl_T. forall b: t_Excl_T. forall c: t_Excl_T. forall result: (). and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
              = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
            -> and_then_Option_Excl_T (op_Excl_T a b) (fun (ab: t_Excl_T) -> op_Excl_T ab c)
            = and_then_Option_Excl_T (op_Excl_T b c) (fun (bc: t_Excl_T) -> op_Excl_T a bc)
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core_idemp__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function core_Excl_T (self: t_Excl_T) : t_Option_Excl_T = None
  
  predicate index_Mapping_Excl_T_bool [@inline:trivial] (self: Map.map t_Excl_T bool) (a: t_Excl_T) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Excl_T_bool
  
  function such_that_Excl_T (p: Map.map t_Excl_T bool) : t_Excl_T
  
  axiom such_that_Excl_T_spec: forall p: Map.map t_Excl_T bool. (exists x: t_Excl_T. index_Mapping_Excl_T_bool p x)
      -> index_Mapping_Excl_T_bool p (such_that_Excl_T p)
  
  function unwrap_Option_Excl_T (self: t_Option_Excl_T) : t_Excl_T = match self with
      | Some x -> x
      | None -> such_that_Excl_T (fun (__0: t_Excl_T) -> true)
      end
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl_T. core_Excl_T self <> None
      -> core_Excl_T self <> None
      /\ (forall result: (). (let c = unwrap_Option_Excl_T (core_Excl_T self) in op_Excl_T c c = Some c)
          /\ op_Excl_T (unwrap_Option_Excl_T (core_Excl_T self)) self = Some self
        -> (let c = unwrap_Option_Excl_T (core_Excl_T self) in op_Excl_T c c = Some c)
        /\ op_Excl_T (unwrap_Option_Excl_T (core_Excl_T self)) self = Some self)
end
module M_logic__ra__excl__impl_RA_for_Excl_T__core_is_maximal_idemp__refines (* <logic::ra::excl::Excl<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Excl_T = { f0: t_T }
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function core_Excl_T (self: t_Excl_T) : t_Option_Excl_T = None
  
  function factor_Excl_T (self: t_Excl_T) (factor: t_Excl_T) : t_Option_Excl_T = None
  
  axiom factor_Excl_T_spec: forall self: t_Excl_T, factor: t_Excl_T. match factor_Excl_T self factor with
        | Some c -> op_Excl_T factor c = Some self
        | None -> forall c: t_Excl_T. op_Excl_T factor c <> Some self
        end
  
  predicate incl_Excl_T (self: t_Excl_T) (other: t_Excl_T) = factor_Excl_T other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Excl_T. forall i: t_Excl_T. op_Excl_T i i = Some i /\ op_Excl_T i self = Some self
        -> op_Excl_T i i = Some i
        /\ op_Excl_T i self = Some self
        /\ (forall result: (). match core_Excl_T self with
              | Some c -> incl_Excl_T i c
              | None -> false
              end
          -> match core_Excl_T self with
            | Some c -> incl_Excl_T i c
            | None -> false
            end)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core_idemp__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_K
  
  type t_V
  
  type tup2_K_V = { f0: t_K; f1: t_V }
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0 = k; f1 = v }
          end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1 = v} = __0 in core_V v))
  
  predicate index_Mapping_FMap_K_V_bool [@inline:trivial] (self: Map.map t_FMap_K_V bool) (a: t_FMap_K_V) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_FMap_K_V_bool
  
  function such_that_FMap_K_V (p: Map.map t_FMap_K_V bool) : t_FMap_K_V
  
  axiom such_that_FMap_K_V_spec:
    forall p: Map.map t_FMap_K_V bool. (exists x: t_FMap_K_V. index_Mapping_FMap_K_V_bool p x)
      -> index_Mapping_FMap_K_V_bool p (such_that_FMap_K_V p)
  
  function unwrap_Option_FMap_K_V (self: t_Option_FMap_K_V) : t_FMap_K_V = match self with
      | Some x -> x
      | None -> such_that_FMap_K_V (fun (__0: t_FMap_K_V) -> true)
      end
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0'0: t_Option_V; f1'0: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type tup2_V_V = { f0'1: t_V; f1'1: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'0 = get_K self k;
                                                                                                                         f1'0 = get_K m k } with
          | {f0'0 = None'0; f1'0 = y} -> get_K (merge_K self m f) k = y
          | {f0'0 = x; f1'0 = None'0} -> get_K (merge_K self m f) k = x
          | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'1 = x; f1'1 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'1 = x; f1'1 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. core_FMap_K_V self <> None
      -> core_FMap_K_V self <> None
      /\ (forall result: (). (let c = unwrap_Option_FMap_K_V (core_FMap_K_V self) in op_FMap_K_V c c = Some c)
          /\ op_FMap_K_V (unwrap_Option_FMap_K_V (core_FMap_K_V self)) self = Some self
        -> (let c = unwrap_Option_FMap_K_V (core_FMap_K_V self) in op_FMap_K_V c c = Some c)
        /\ op_FMap_K_V (unwrap_Option_FMap_K_V (core_FMap_K_V self)) self = Some self)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__associative__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  function and_then_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_FMap_K_V
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_FMap_K_V. forall b: t_FMap_K_V. forall c: t_FMap_K_V. forall result: (). and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
              = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
            -> and_then_Option_FMap_K_V (op_FMap_K_V a b) (fun (ab: t_FMap_K_V) -> op_FMap_K_V ab c)
            = and_then_Option_FMap_K_V (op_FMap_K_V b c) (fun (bc: t_FMap_K_V) -> op_FMap_K_V a bc)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__factor__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall factor: t_FMap_K_V. forall result: t_Option_FMap_K_V. match result with
              | Some c -> op_FMap_K_V factor c = Some self
              | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
              end
          -> match result with
            | Some c -> op_FMap_K_V factor c = Some self
            | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
            end
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__core_is_maximal_idemp__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v))
  
  function and_then_Option_Option_V (self: t_Option_Option_V) (f: Map.map t_Option_V t_Option_Option_V) : t_Option_Option_V
   = match self with
      | None'1 -> None'1
      | Some'1 x -> Map.get f x
      end
  
  function associative_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : ()
  
  axiom associative_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V. and_then_Option_Option_V (op_Option_V a b) (fun (ab: t_Option_V) -> op_Option_V ab c)
      = and_then_Option_Option_V (op_Option_V b c) (fun (bc: t_Option_V) -> op_Option_V a bc)
  
  function factor_Option_V (self: t_Option_V) (factor: t_Option_V) : t_Option_Option_V = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None'0} -> Some'1 x
      | {f0 = None'0} -> None'1
      | {f0 = Some'0 x; f1 = Some'0 y} -> match factor_V x y with
        | Some'0 z -> Some'1 (Some'0 z)
        | None'0 -> if x = y then Some'1 (None'0) else None'1
        end
      end
  
  axiom factor_Option_V_spec: forall self: t_Option_V, factor: t_Option_V. match factor_Option_V self factor with
        | Some'1 c -> op_Option_V factor c = Some'1 self
        | None'1 -> forall c: t_Option_V. op_Option_V factor c <> Some'1 self
        end
  
  predicate incl_Option_V (self: t_Option_V) (other: t_Option_V) = factor_Option_V other self <> None'1
  
  function incl_transitive_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) : () = ()
  
  axiom incl_transitive_Option_V_spec: forall a: t_Option_V, b: t_Option_V, c: t_Option_V. incl_Option_V a b
      -> incl_Option_V b c -> incl_Option_V a c
  
  function associative_some_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) (ab: t_Option_V) (bc: t_Option_V) : ()
   = let _ = associative_Option_V a b c in ()
  
  axiom associative_some_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V, ab: t_Option_V, bc: t_Option_V. op_Option_V a b = Some'1 ab
      -> op_Option_V b c = Some'1 bc -> op_Option_V a bc = op_Option_V ab c
  
  function associative_none_Option_V (a: t_Option_V) (b: t_Option_V) (c: t_Option_V) (bc: t_Option_V) : () =
    let _ = associative_Option_V a b c in ()
  
  axiom associative_none_Option_V_spec:
    forall a: t_Option_V, b: t_Option_V, c: t_Option_V, bc: t_Option_V. op_Option_V a b = None'1
      -> op_Option_V b c = Some'1 bc -> op_Option_V a bc = None'1
  
  function incl_op_Option_V (self: t_Option_V) (other: t_Option_V) (comb: t_Option_V) : () = ()
  
  axiom incl_op_Option_V_spec: forall self: t_Option_V, other: t_Option_V, comb: t_Option_V. op_Option_V self other
        = Some'1 comb -> incl_Option_V self comb
  
  function factor_FMap_K_V (self: t_FMap_K_V) (factor: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. incl_Option_V (get_K factor k) (get_K self k) then
      let res = filter_map_K self (fun (__0: tup2_K_V) -> let {f0'1 = k; f1'1 = vo} = __0 in match factor_Option_V (Some'0 vo) (get_K factor k) with
        | Some'1 r -> r
        | None'1 -> None'0
        end) in Some res
    else
      None
  
  
  axiom factor_FMap_K_V_spec: forall self: t_FMap_K_V, factor: t_FMap_K_V. match factor_FMap_K_V self factor with
        | Some c -> op_FMap_K_V factor c = Some self
        | None -> forall c: t_FMap_K_V. op_FMap_K_V factor c <> Some self
        end
  
  predicate incl_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) = factor_FMap_K_V other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall i: t_FMap_K_V. op_FMap_K_V i i = Some i
          /\ op_FMap_K_V i self = Some self
        -> op_FMap_K_V i i = Some i
        /\ op_FMap_K_V i self = Some self
        /\ (forall result: (). match core_FMap_K_V self with
              | Some c -> incl_FMap_K_V i c
              | None -> false
              end
          -> match core_FMap_K_V self with
            | Some c -> incl_FMap_K_V i c
            | None -> false
            end)
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__commutative__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_FMap_K_V. forall b: t_FMap_K_V. forall result: (). op_FMap_K_V a b = op_FMap_K_V b a
          -> op_FMap_K_V a b = op_FMap_K_V b a
end
module M_logic__ra__fmap__impl_RA_for_FMap_K_V__eq__refines (* <logic::fmap::FMap<K, V> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_FMap_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall other: t_FMap_K_V. forall result: bool. result = (self = other)
          -> result = (self = other)
end
module M_logic__ra__int__impl_RA_for_Int__core_idemp__refines (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  predicate index_Mapping_Int_bool [@inline:trivial] (self: Map.map int bool) (a: int) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Int_bool
  
  function such_that_Int (p: Map.map int bool) : int
  
  axiom such_that_Int_spec: forall p: Map.map int bool. (exists x: int. index_Mapping_Int_bool p x)
      -> index_Mapping_Int_bool p (such_that_Int p)
  
  function unwrap_Option_Int (self: t_Option_Int) : int = match self with
      | Some x -> x
      | None -> such_that_Int (fun (__0: int) -> true)
      end
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: int. core_Int self <> None
      -> (forall result: (). (let c = unwrap_Option_Int (core_Int self) in op_Int c c = Some c)
          /\ op_Int (unwrap_Option_Int (core_Int self)) self = Some self
        -> (let c = unwrap_Option_Int (core_Int self) in op_Int c c = Some c)
        /\ op_Int (unwrap_Option_Int (core_Int self)) self = Some self)
end
module M_logic__ra__int__impl_RA_for_Int__core_is_maximal_idemp__refines (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  function factor_Int [@inline:trivial] (self: int) (factor: int) : t_Option_Int = Some (self - factor)
  
  meta "rewrite_def" function factor_Int
  
  axiom factor_Int_spec: forall self: int, factor: int. match factor_Int self factor with
        | Some c -> op_Int factor c = Some self
        | None -> false
        end
  
  predicate incl_Int (self: int) (other: int) = factor_Int other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: int. forall i: int. op_Int i i = Some i /\ op_Int i self = Some self
        -> op_Int i i = Some i
        /\ op_Int i self = Some self
        /\ (forall result: (). match core_Int self with
              | Some c -> incl_Int i c
              | None -> false
              end
          -> match core_Int self with
            | Some c -> incl_Int i c
            | None -> false
            end)
end
module M_logic__ra__int__impl_RA_for_Int__commutative__refines (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: int. forall b: int. forall result: (). op_Int a b = op_Int b a -> op_Int a b = op_Int b a
end
module M_logic__ra__int__impl_RA_for_Int__associative__refines (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function and_then_Option_Int (self: t_Option_Int) (f: Map.map int t_Option_Int) : t_Option_Int = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: int. forall b: int. forall c: int. forall result: (). and_then_Option_Int (op_Int a b) (fun (ab: int) -> op_Int ab c)
              = and_then_Option_Int (op_Int b c) (fun (bc: int) -> op_Int a bc)
            -> and_then_Option_Int (op_Int a b) (fun (ab: int) -> op_Int ab c)
            = and_then_Option_Int (op_Int b c) (fun (bc: int) -> op_Int a bc)
end
module M_logic__ra__int__impl_RA_for_Int__factor__refines (* <logic::int::Int as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: int. forall factor: int. forall result: t_Option_Int. match result with
              | Some c -> op_Int factor c = Some self
              | None -> false
              end
          -> match result with
            | Some c -> op_Int factor c = Some self
            | None -> forall c: int. op_Int factor c <> Some self
            end
end
module M_logic__ra__nat__impl_RA_for_Nat__factor__refines (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Nat. forall factor: t_Nat. forall result: t_Option_Nat. match result with
              | Some c -> op_Nat factor c = Some self
              | None -> forall c: t_Nat. op_Nat factor c <> Some self
              end
          -> match result with
            | Some c -> op_Nat factor c = Some self
            | None -> forall c: t_Nat. op_Nat factor c <> Some self
            end
end
module M_logic__ra__nat__impl_RA_for_Nat__core_is_maximal_idemp__refines (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  function factor_Nat [@inline:trivial] (self: t_Nat) (factor: t_Nat) : t_Option_Nat = if to_int self
    >= to_int factor then
      Some (new (to_int self - to_int factor))
    else
      None
  
  
  meta "rewrite_def" function factor_Nat
  
  axiom factor_Nat_spec: forall self: t_Nat, factor: t_Nat. match factor_Nat self factor with
        | Some c -> op_Nat factor c = Some self
        | None -> forall c: t_Nat. op_Nat factor c <> Some self
        end
  
  predicate incl_Nat (self: t_Nat) (other: t_Nat) = factor_Nat other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Nat. forall i: t_Nat. op_Nat i i = Some i /\ op_Nat i self = Some self
        -> op_Nat i i = Some i
        /\ op_Nat i self = Some self
        /\ (forall result: (). match core_Nat self with
              | Some c -> incl_Nat i c
              | None -> false
              end
          -> match core_Nat self with
            | Some c -> incl_Nat i c
            | None -> false
            end)
end
module M_logic__ra__nat__impl_RA_for_Nat__associative__refines (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function and_then_Option_Nat (self: t_Option_Nat) (f: Map.map t_Nat t_Option_Nat) : t_Option_Nat = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Nat. forall b: t_Nat. forall c: t_Nat. forall result: (). and_then_Option_Nat (op_Nat a b) (fun (ab: t_Nat) -> op_Nat ab c)
              = and_then_Option_Nat (op_Nat b c) (fun (bc: t_Nat) -> op_Nat a bc)
            -> and_then_Option_Nat (op_Nat a b) (fun (ab: t_Nat) -> op_Nat ab c)
            = and_then_Option_Nat (op_Nat b c) (fun (bc: t_Nat) -> op_Nat a bc)
end
module M_logic__ra__nat__impl_RA_for_Nat__eq__refines (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Nat
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Nat. forall other: t_Nat. forall result: bool. result = (self = other)
          -> result = (self = other)
end
module M_logic__ra__nat__impl_RA_for_Nat__core_idemp__refines (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  predicate index_Mapping_Nat_bool [@inline:trivial] (self: Map.map t_Nat bool) (a: t_Nat) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Nat_bool
  
  function such_that_Nat (p: Map.map t_Nat bool) : t_Nat
  
  axiom such_that_Nat_spec: forall p: Map.map t_Nat bool. (exists x: t_Nat. index_Mapping_Nat_bool p x)
      -> index_Mapping_Nat_bool p (such_that_Nat p)
  
  function unwrap_Option_Nat (self: t_Option_Nat) : t_Nat = match self with
      | Some x -> x
      | None -> such_that_Nat (fun (__0: t_Nat) -> true)
      end
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Nat. core_Nat self <> None
      -> (forall result: (). (let c = unwrap_Option_Nat (core_Nat self) in op_Nat c c = Some c)
          /\ op_Nat (unwrap_Option_Nat (core_Nat self)) self = Some self
        -> (let c = unwrap_Option_Nat (core_Nat self) in op_Nat c c = Some c)
        /\ op_Nat (unwrap_Option_Nat (core_Nat self)) self = Some self)
end
module M_logic__ra__nat__impl_RA_for_Nat__commutative__refines (* <logic::int::Nat as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Nat. forall b: t_Nat. forall result: (). op_Nat a b = op_Nat b a -> op_Nat a b = op_Nat b a
end
module M_logic__ra__option__impl_RA_for_Option_T__core_idemp__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  predicate index_Mapping_Option_T_bool [@inline:trivial] (self: Map.map t_Option_T bool) (a: t_Option_T) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Option_T_bool
  
  function such_that_Option_T (p: Map.map t_Option_T bool) : t_Option_T
  
  axiom such_that_Option_T_spec:
    forall p: Map.map t_Option_T bool. (exists x: t_Option_T. index_Mapping_Option_T_bool p x)
      -> index_Mapping_Option_T_bool p (such_that_Option_T p)
  
  function unwrap_Option_Option_T (self: t_Option_Option_T) : t_Option_T = match self with
      | Some'0 x -> x
      | None'0 -> such_that_Option_T (fun (__0: t_Option_T) -> true)
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. core_Option_T self <> None'0
      -> core_Option_T self <> None'0
      /\ (forall result: (). (let c = unwrap_Option_Option_T (core_Option_T self) in op_Option_T c c = Some'0 c)
          /\ op_Option_T (unwrap_Option_Option_T (core_Option_T self)) self = Some'0 self
        -> (let c = unwrap_Option_Option_T (core_Option_T self) in op_Option_T c c = Some'0 c)
        /\ op_Option_T (unwrap_Option_Option_T (core_Option_T self)) self = Some'0 self)
end
module M_logic__ra__option__impl_RA_for_Option_T__associative__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  function and_then_Option_Option_T (self: t_Option_Option_T) (f: Map.map t_Option_T t_Option_Option_T) : t_Option_Option_T
   = match self with
      | None'0 -> None'0
      | Some'0 x -> Map.get f x
      end
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Option_T. forall b: t_Option_T. forall c: t_Option_T. forall result: (). and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
              = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
            -> and_then_Option_Option_T (op_Option_T a b) (fun (ab: t_Option_T) -> op_Option_T ab c)
            = and_then_Option_Option_T (op_Option_T b c) (fun (bc: t_Option_T) -> op_Option_T a bc)
end
module M_logic__ra__option__impl_RA_for_Option_T__factor__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall factor: t_Option_T. forall result: t_Option_Option_T. match result with
              | Some'0 c -> op_Option_T factor c = Some'0 self
              | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
              end
          -> match result with
            | Some'0 c -> op_Option_T factor c = Some'0 self
            | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
            end
end
module M_logic__ra__option__impl_RA_for_Option_T__core_is_maximal_idemp__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  function factor_Option_T (self: t_Option_T) (factor: t_Option_T) : t_Option_Option_T = match { f0 = self;
                                                                                                 f1 = factor } with
      | {f0 = x; f1 = None} -> Some'0 x
      | {f0 = None} -> None'0
      | {f0 = Some x; f1 = Some y} -> match factor_T x y with
        | Some z -> Some'0 (Some z)
        | None -> if x = y then Some'0 (None) else None'0
        end
      end
  
  axiom factor_Option_T_spec: forall self: t_Option_T, factor: t_Option_T. match factor_Option_T self factor with
        | Some'0 c -> op_Option_T factor c = Some'0 self
        | None'0 -> forall c: t_Option_T. op_Option_T factor c <> Some'0 self
        end
  
  predicate incl_Option_T (self: t_Option_T) (other: t_Option_T) = factor_Option_T other self <> None'0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall i: t_Option_T. op_Option_T i i = Some'0 i
          /\ op_Option_T i self = Some'0 self
        -> op_Option_T i i = Some'0 i
        /\ op_Option_T i self = Some'0 self
        /\ (forall result: (). match core_Option_T self with
              | Some'0 c -> incl_Option_T i c
              | None'0 -> false
              end
          -> match core_Option_T self with
            | Some'0 c -> incl_Option_T i c
            | None'0 -> false
            end)
end
module M_logic__ra__option__impl_RA_for_Option_T__eq__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall other: t_Option_T. forall result: bool. result = (self = other)
          -> result = (self = other)
end
module M_logic__ra__option__impl_RA_for_Option_T__commutative__refines (* <std::option::Option<T> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall b: t_Option_T. forall result: (). op_Option_T a b = op_Option_T b a
          -> op_Option_T a b = op_Option_T b a
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__commutative__refines (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_PositiveReal. forall b: t_PositiveReal. forall result: (). op_PositiveReal a b
            = op_PositiveReal b a -> op_PositiveReal a b = op_PositiveReal b a
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__factor__refines (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_PositiveReal. forall factor: t_PositiveReal. forall result: t_Option_PositiveReal. match result with
              | Some c -> op_PositiveReal factor c = Some self
              | None -> forall c: t_PositiveReal. op_PositiveReal factor c <> Some self
              end
          -> match result with
            | Some c -> op_PositiveReal factor c = Some self
            | None -> forall c: t_PositiveReal. op_PositiveReal factor c <> Some self
            end
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__associative__refines (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  function and_then_Option_PositiveReal (self: t_Option_PositiveReal) (f: Map.map t_PositiveReal t_Option_PositiveReal) : t_Option_PositiveReal
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_PositiveReal. forall b: t_PositiveReal. forall c: t_PositiveReal. forall result: (). and_then_Option_PositiveReal (op_PositiveReal a b) (fun (ab: t_PositiveReal) -> op_PositiveReal ab c)
              = and_then_Option_PositiveReal (op_PositiveReal b c) (fun (bc: t_PositiveReal) -> op_PositiveReal a bc)
            -> and_then_Option_PositiveReal (op_PositiveReal a b) (fun (ab: t_PositiveReal) -> op_PositiveReal ab c)
            = and_then_Option_PositiveReal (op_PositiveReal b c) (fun (bc: t_PositiveReal) -> op_PositiveReal a bc)
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__core_idemp__refines (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  function core_PositiveReal [@inline:trivial] (self: t_PositiveReal) : t_Option_PositiveReal = None
  
  meta "rewrite_def" function core_PositiveReal
  
  predicate index_Mapping_PositiveReal_bool [@inline:trivial] (self: Map.map t_PositiveReal bool) (a: t_PositiveReal) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_PositiveReal_bool
  
  function such_that_PositiveReal (p: Map.map t_PositiveReal bool) : t_PositiveReal
  
  axiom such_that_PositiveReal_spec:
    forall p: Map.map t_PositiveReal bool. (exists x: t_PositiveReal. index_Mapping_PositiveReal_bool p x)
      -> index_Mapping_PositiveReal_bool p (such_that_PositiveReal p)
  
  function unwrap_Option_PositiveReal (self: t_Option_PositiveReal) : t_PositiveReal = match self with
      | Some x -> x
      | None -> such_that_PositiveReal (fun (__0: t_PositiveReal) -> true)
      end
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_PositiveReal. core_PositiveReal self <> None
      -> core_PositiveReal self <> None
      /\ (forall result: (). (let c = unwrap_Option_PositiveReal (core_PositiveReal self) in op_PositiveReal c c
            = Some c)
          /\ op_PositiveReal (unwrap_Option_PositiveReal (core_PositiveReal self)) self = Some self
        -> (let c = unwrap_Option_PositiveReal (core_PositiveReal self) in op_PositiveReal c c = Some c)
        /\ op_PositiveReal (unwrap_Option_PositiveReal (core_PositiveReal self)) self = Some self)
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__core_is_maximal_idemp__refines (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use real.Real
  use real.FromInt
  
  type t_PositiveReal
  
  type t_Option_PositiveReal = None | Some t_PositiveReal
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_Real (self: Real.real) (o: Real.real) : t_Ordering = if Real.(<) self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_Real (x: Real.real) (y: Real.real) : ()
  
  axiom eq_cmp_Real_spec: forall x: Real.real, y: Real.real. (x = y) = (cmp_log_Real x y = Equal)
  
  function antisym2_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym2_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Greater -> cmp_log_Real y x = Less
  
  function antisym1_Real (x: Real.real) (y: Real.real) : ()
  
  axiom antisym1_Real_spec: forall x: Real.real, y: Real.real. cmp_log_Real x y = Less -> cmp_log_Real y x = Greater
  
  function trans_Real (x: Real.real) (y: Real.real) (z: Real.real) (o: t_Ordering) : ()
  
  axiom trans_Real_spec: forall x: Real.real, y: Real.real, z: Real.real, o: t_Ordering. cmp_log_Real x y = o
      -> cmp_log_Real y z = o -> cmp_log_Real x z = o
  
  function refl_Real (x: Real.real) : ()
  
  axiom refl_Real_spec: forall x: Real.real. cmp_log_Real x x = Equal
  
  function cmp_gt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_gt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>) x y = (cmp_log_Real x y = Greater)
  
  function cmp_ge_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_ge_log_Real_spec: forall x: Real.real, y: Real.real. Real.(>=) x y = (cmp_log_Real x y <> Less)
  
  function cmp_lt_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_lt_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<) x y = (cmp_log_Real x y = Less)
  
  function cmp_le_log_Real (x: Real.real) (y: Real.real) : ()
  
  axiom cmp_le_log_Real_spec: forall x: Real.real, y: Real.real. Real.(<=) x y = (cmp_log_Real x y <> Greater)
  
  function to_real (self: t_PositiveReal) : Real.real
  
  axiom to_real_spec: forall self: t_PositiveReal. Real.(>) (to_real self) (FromInt.from_int 0)
  
  function add_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) : t_PositiveReal
  
  axiom add_PositiveReal_spec: forall self: t_PositiveReal, other: t_PositiveReal. to_real (add_PositiveReal self other)
      = Real.(+) (to_real self) (to_real other)
  
  function op_PositiveReal [@inline:trivial] (self: t_PositiveReal) (other: t_PositiveReal) : t_Option_PositiveReal =
    Some (add_PositiveReal self other)
  
  meta "rewrite_def" function op_PositiveReal
  
  function core_PositiveReal [@inline:trivial] (self: t_PositiveReal) : t_Option_PositiveReal = None
  
  meta "rewrite_def" function core_PositiveReal
  
  function new (n: Real.real) : t_PositiveReal
  
  axiom new_spec: forall n: Real.real. Real.(>) n (FromInt.from_int 0) -> to_real (new n) = n
  
  function factor_PositiveReal [@inline:trivial] (self: t_PositiveReal) (factor: t_PositiveReal) : t_Option_PositiveReal
   = if Real.(>) (to_real self) (to_real factor) then Some (new (Real.(-) (to_real self) (to_real factor))) else None
  
  meta "rewrite_def" function factor_PositiveReal
  
  axiom factor_PositiveReal_spec:
    forall self: t_PositiveReal, factor: t_PositiveReal. match factor_PositiveReal self factor with
        | Some c -> op_PositiveReal factor c = Some self
        | None -> forall c: t_PositiveReal. op_PositiveReal factor c <> Some self
        end
  
  predicate incl_PositiveReal (self: t_PositiveReal) (other: t_PositiveReal) = factor_PositiveReal other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_PositiveReal. forall i: t_PositiveReal. op_PositiveReal i i = Some i
          /\ op_PositiveReal i self = Some self
        -> op_PositiveReal i i = Some i
        /\ op_PositiveReal i self = Some self
        /\ (forall result: (). match core_PositiveReal self with
              | Some c -> incl_PositiveReal i c
              | None -> false
              end
          -> match core_PositiveReal self with
            | Some c -> incl_PositiveReal i c
            | None -> false
            end)
end
module M_logic__ra__positive_real__impl_RA_for_PositiveReal__eq__refines (* <logic::real::PositiveReal as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_PositiveReal
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_PositiveReal. forall other: t_PositiveReal. forall result: bool. result = (self = other)
          -> result = (self = other)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__factor__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall factor: tup2_T_U. forall result: t_Option_tup2_T_U. match result with
              | Some c -> op_tup2_T_U factor c = Some self
              | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
              end
          -> match result with
            | Some c -> op_tup2_T_U factor c = Some self
            | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
            end
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core_is_maximal_idemp__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function core_T (self: t_T) : t_Option_T
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  function factor_tup2_T_U (self: tup2_T_U) (factor: tup2_T_U) : t_Option_tup2_T_U =
    match { f0'0 = factor_T self.f0 factor.f0; f1'0 = factor_U self.f1 factor.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  axiom factor_tup2_T_U_spec: forall self: tup2_T_U, factor: tup2_T_U. match factor_tup2_T_U self factor with
        | Some c -> op_tup2_T_U factor c = Some self
        | None -> forall c: tup2_T_U. op_tup2_T_U factor c <> Some self
        end
  
  predicate incl_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) = factor_tup2_T_U other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall i: tup2_T_U. op_tup2_T_U i i = Some i /\ op_tup2_T_U i self = Some self
        -> op_tup2_T_U i i = Some i
        /\ op_tup2_T_U i self = Some self
        /\ (forall result: (). match core_tup2_T_U self with
              | Some c -> incl_tup2_T_U i c
              | None -> false
              end
          -> match core_tup2_T_U self with
            | Some c -> incl_tup2_T_U i c
            | None -> false
            end)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__eq__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall other: tup2_T_U. forall result: bool. result = (self = other)
          -> result = (self = other)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__associative__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  function and_then_Option_tup2_T_U (self: t_Option_tup2_T_U) (f: Map.map tup2_T_U t_Option_tup2_T_U) : t_Option_tup2_T_U
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: tup2_T_U. forall b: tup2_T_U. forall c: tup2_T_U. forall result: (). and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
              = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
            -> and_then_Option_tup2_T_U (op_tup2_T_U a b) (fun (ab: tup2_T_U) -> op_tup2_T_U ab c)
            = and_then_Option_tup2_T_U (op_tup2_T_U b c) (fun (bc: tup2_T_U) -> op_tup2_T_U a bc)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__core_idemp__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function core_T (self: t_T) : t_Option_T
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  predicate index_Mapping_tup2_T_U_bool [@inline:trivial] (self: Map.map tup2_T_U bool) (a: tup2_T_U) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_T_U_bool
  
  function such_that_tup2_T_U (p: Map.map tup2_T_U bool) : tup2_T_U
  
  axiom such_that_tup2_T_U_spec: forall p: Map.map tup2_T_U bool. (exists x: tup2_T_U. index_Mapping_tup2_T_U_bool p x)
      -> index_Mapping_tup2_T_U_bool p (such_that_tup2_T_U p)
  
  function unwrap_Option_tup2_T_U (self: t_Option_tup2_T_U) : tup2_T_U = match self with
      | Some x -> x
      | None -> such_that_tup2_T_U (fun (__0: tup2_T_U) -> true)
      end
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. core_tup2_T_U self <> None
      -> core_tup2_T_U self <> None
      /\ (forall result: (). (let c = unwrap_Option_tup2_T_U (core_tup2_T_U self) in op_tup2_T_U c c = Some c)
          /\ op_tup2_T_U (unwrap_Option_tup2_T_U (core_tup2_T_U self)) self = Some self
        -> (let c = unwrap_Option_tup2_T_U (core_tup2_T_U self) in op_tup2_T_U c c = Some c)
        /\ op_tup2_T_U (unwrap_Option_tup2_T_U (core_tup2_T_U self)) self = Some self)
end
module M_logic__ra__prod__impl_RA_for_tup2_T_U__commutative__refines (* <(T, U) as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: tup2_T_U. forall b: tup2_T_U. forall result: (). op_tup2_T_U a b = op_tup2_T_U b a
          -> op_tup2_T_U a b = op_tup2_T_U b a
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__associative__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  function and_then_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Sum_R1_R2
   = match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Sum_R1_R2. forall b: t_Sum_R1_R2. forall c: t_Sum_R1_R2. forall result: (). and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
              = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
            -> and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 a b) (fun (ab: t_Sum_R1_R2) -> op_Sum_R1_R2 ab c)
            = and_then_Option_Sum_R1_R2 (op_Sum_R1_R2 b c) (fun (bc: t_Sum_R1_R2) -> op_Sum_R1_R2 a bc)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__commutative__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Sum_R1_R2. forall b: t_Sum_R1_R2. forall result: (). op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
          -> op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core_idemp__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  function core_R1 (self: t_R1) : t_Option_R1
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function core_R2 (self: t_R2) : t_Option_R2
  
  function core_Sum_R1_R2 (self: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | Left x -> map_Option_R1 (core_R1 x) (fun (l: t_R1) -> Left l)
      | Right x -> map_Option_R2 (core_R2 x) (fun (r: t_R2) -> Right r)
      end
  
  predicate index_Mapping_Sum_R1_R2_bool [@inline:trivial] (self: Map.map t_Sum_R1_R2 bool) (a: t_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_Sum_R1_R2_bool
  
  function such_that_Sum_R1_R2 (p: Map.map t_Sum_R1_R2 bool) : t_Sum_R1_R2
  
  axiom such_that_Sum_R1_R2_spec:
    forall p: Map.map t_Sum_R1_R2 bool. (exists x: t_Sum_R1_R2. index_Mapping_Sum_R1_R2_bool p x)
      -> index_Mapping_Sum_R1_R2_bool p (such_that_Sum_R1_R2 p)
  
  function unwrap_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) : t_Sum_R1_R2 = match self with
      | Some x -> x
      | None -> such_that_Sum_R1_R2 (fun (__0: t_Sum_R1_R2) -> true)
      end
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum_R1_R2. core_Sum_R1_R2 self <> None
      -> core_Sum_R1_R2 self <> None
      /\ (forall result: (). (let c = unwrap_Option_Sum_R1_R2 (core_Sum_R1_R2 self) in op_Sum_R1_R2 c c = Some c)
          /\ op_Sum_R1_R2 (unwrap_Option_Sum_R1_R2 (core_Sum_R1_R2 self)) self = Some self
        -> (let c = unwrap_Option_Sum_R1_R2 (core_Sum_R1_R2 self) in op_Sum_R1_R2 c c = Some c)
        /\ op_Sum_R1_R2 (unwrap_Option_Sum_R1_R2 (core_Sum_R1_R2 self)) self = Some self)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__eq__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum_R1_R2. forall other: t_Sum_R1_R2. forall result: bool. result = (self = other)
          -> result = (self = other)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__core_is_maximal_idemp__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function core_R1 (self: t_R1) : t_Option_R1
  
  function core_R2 (self: t_R2) : t_Option_R2
  
  function core_Sum_R1_R2 (self: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | Left x -> map_Option_R1 (core_R1 x) (fun (l: t_R1) -> Left l)
      | Right x -> map_Option_R2 (core_R2 x) (fun (r: t_R2) -> Right r)
      end
  
  function factor_Sum_R1_R2 (self: t_Sum_R1_R2) (factor: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                     f1 = factor } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (factor_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (factor_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  axiom factor_Sum_R1_R2_spec: forall self: t_Sum_R1_R2, factor: t_Sum_R1_R2. match factor_Sum_R1_R2 self factor with
        | Some c -> op_Sum_R1_R2 factor c = Some self
        | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
        end
  
  predicate incl_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) = factor_Sum_R1_R2 other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Sum_R1_R2. forall i: t_Sum_R1_R2. op_Sum_R1_R2 i i = Some i
          /\ op_Sum_R1_R2 i self = Some self
        -> op_Sum_R1_R2 i i = Some i
        /\ op_Sum_R1_R2 i self = Some self
        /\ (forall result: (). match core_Sum_R1_R2 self with
              | Some c -> incl_Sum_R1_R2 i c
              | None -> false
              end
          -> match core_Sum_R1_R2 self with
            | Some c -> incl_Sum_R1_R2 i c
            | None -> false
            end)
end
module M_logic__ra__sum__impl_RA_for_Sum_R1_R2__factor__refines (* <logic::ra::sum::Sum<R1, R2> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0: t_Sum_R1_R2; f1: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0 = self;
                                                                                                f1 = other } with
      | {f0 = Left x; f1 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0 = Right x; f1 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Sum_R1_R2. forall factor: t_Sum_R1_R2. forall result: t_Option_Sum_R1_R2. match result with
              | Some c -> op_Sum_R1_R2 factor c = Some self
              | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
              end
          -> match result with
            | Some c -> op_Sum_R1_R2 factor c = Some self
            | None -> forall c: t_Sum_R1_R2. op_Sum_R1_R2 factor c <> Some self
            end
end
module M_logic__ra__view__impl_RA_for_View_R__commutative__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_View_R. forall b: t_View_R. forall result: (). op_View_R a b = op_View_R b a
          -> op_View_R a b = op_View_R b a
end
module M_logic__ra__view__impl_RA_for_View_R__core_idemp__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Auth
  
  type t_Option_Auth = None'0 | Some'0 t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'1 | Some'1 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'1 c -> op_Frag factor c = Some'1 self
        | None'1 -> forall c: t_Frag. op_Frag factor c <> Some'1 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'1
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'1 ab -> op_Frag b c = Some'1 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'1
      -> op_Frag b c = Some'1 bc -> op_Frag a bc = None'1
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'1 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'1 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'1 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'0) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'0) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  predicate index_Mapping_View_R_bool [@inline:trivial] (self: Map.map t_View_R bool) (a: t_View_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_View_R_bool
  
  function such_that_View_R (p: Map.map t_View_R bool) : t_View_R
  
  axiom such_that_View_R_spec: forall p: Map.map t_View_R bool. (exists x: t_View_R. index_Mapping_View_R_bool p x)
      -> index_Mapping_View_R_bool p (such_that_View_R p)
  
  function unwrap_Option_View_R (self: t_Option_View_R) : t_View_R = match self with
      | Some x -> x
      | None -> such_that_View_R (fun (__0: t_View_R) -> true)
      end
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'1 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'0; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'0} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'1 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. core_View_R self <> None
      -> core_View_R self <> None
      /\ (forall result: (). (let c = unwrap_Option_View_R (core_View_R self) in op_View_R c c = Some c)
          /\ op_View_R (unwrap_Option_View_R (core_View_R self)) self = Some self
        -> (let c = unwrap_Option_View_R (core_View_R self) in op_View_R c c = Some c)
        /\ op_View_R (unwrap_Option_View_R (core_View_R self)) self = Some self)
end
module M_logic__ra__view__impl_RA_for_View_R__associative__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  function and_then_Option_View_R (self: t_Option_View_R) (f: Map.map t_View_R t_Option_View_R) : t_Option_View_R =
    match self with
      | None -> None
      | Some x -> Map.get f x
      end
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_View_R. forall b: t_View_R. forall c: t_View_R. forall result: (). and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
              = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
            -> and_then_Option_View_R (op_View_R a b) (fun (ab: t_View_R) -> op_View_R ab c)
            = and_then_Option_View_R (op_View_R b c) (fun (bc: t_View_R) -> op_View_R a bc)
end
module M_logic__ra__view__impl_RA_for_View_R__eq__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall other: t_View_R. forall result: bool. result = (self = other)
          -> result = (self = other)
end
module M_logic__ra__view__impl_RA_for_View_R__core_is_maximal_idemp__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  function factor_View_R (self: t_View_R) (factor: t_View_R) : t_Option_View_R =
    match factor_Frag (frag_R self) (frag_R factor) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R factor } with
        | {f0'0 = Some'1 a; f1'0 = None'1} -> Some (new_R (Some'1 a) f)
        | {f0'0 = a1; f1'0 = a2} -> if a1 = a2 then Some (new_frag_R f) else None
        end
      | None'0 -> None
      end
  
  axiom factor_View_R_spec: forall self: t_View_R, factor: t_View_R. match factor_View_R self factor with
        | Some c -> op_View_R factor c = Some self
        | None -> forall c: t_View_R. op_View_R factor c <> Some self
        end
  
  predicate incl_View_R (self: t_View_R) (other: t_View_R) = factor_View_R other self <> None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall i: t_View_R. op_View_R i i = Some i /\ op_View_R i self = Some self
        -> op_View_R i i = Some i
        /\ op_View_R i self = Some self
        /\ (forall result: (). match core_View_R self with
              | Some c -> incl_View_R i c
              | None -> false
              end
          -> match core_View_R self with
            | Some c -> incl_View_R i c
            | None -> false
            end)
end
module M_logic__ra__view__impl_RA_for_View_R__factor__refines (* <logic::ra::view::View<R> as logic::ra::RA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall factor: t_View_R. forall result: t_Option_View_R. match result with
              | Some c -> op_View_R factor c = Some self
              | None -> forall c: t_View_R. op_View_R factor c <> Some self
              end
          -> match result with
            | Some c -> op_View_R factor c = Some self
            | None -> forall c: t_View_R. op_View_R factor c <> Some self
            end
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_none__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall f: t_T. rel_AuthViewRel_T a f
        -> (forall result: (). rel_AuthViewRel_T (None) f -> rel_AuthViewRel_T (None) f)
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_unit__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  function core_T (self: t_T) : t_Option_T
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. core_T self = Some (core_total_T self)
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some x
  
  constant unit_core_T : ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T : ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall result: (). rel_AuthViewRel_T a unit_T -> rel_AuthViewRel_T a unit_T
end
module M_logic__ra__auth__impl_ViewRel_for_AuthViewRel_T__rel_mono__refines (* <logic::ra::auth::AuthViewRel<T> as logic::ra::view::ViewRel> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  predicate rel_AuthViewRel_T (a: t_Option_T) (f: t_T) =
    match a with
      | Some a'0 -> incl_T f a'0
      | None -> true
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall a: t_Option_T. forall f1: t_T. forall f2: t_T. rel_AuthViewRel_T a f1 /\ incl_T f2 f1
          -> rel_AuthViewRel_T a f1
          /\ incl_T f2 f1 /\ (forall result: (). rel_AuthViewRel_T a f2 -> rel_AuthViewRel_T a f2)
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__update__refines (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_AuthUpdate_U = { f0: t_U }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  predicate premise_AuthUpdate_U [@inline:trivial] (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_AuthUpdate_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_AuthUpdate_U. forall from: t_View_AuthViewRel_R. forall ch: (). premise_AuthUpdate_U self from
          -> premise_AuthUpdate_U self from
end
module M_logic__ra__auth__impl_Update_for_AuthUpdate_U__frame_preserving__refines (* <logic::ra::auth::AuthUpdate<U> as logic::ra::update::Update<logic::ra::view::View<logic::ra::auth::AuthViewRel<R>>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_AuthUpdate_U = { f0: t_U }
  
  type t_View_AuthViewRel_R
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function auth_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_Option_R
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function core_R (self: t_R) : t_Option_R
  
  function core_total_R (self: t_R) : t_R
  
  axiom core_total_R_spec: forall self: t_R. core_R self = Some (core_total_R self)
  
  constant unit_R : t_R
  
  axiom unit_R_spec: forall x: t_R [op_R x unit_R]. op_R x unit_R = Some x
  
  constant unit_core_R : ()
  
  axiom unit_core_R_spec: core_total_R unit_R = unit_R
  
  constant incl_refl_R : ()
  
  axiom incl_refl_R_spec: forall x: t_R. incl_R x x
  
  predicate rel_AuthViewRel_R (a: t_Option_R) (f: t_R) =
    match a with
      | Some a'0 -> incl_R f a'0
      | None -> true
      end
  
  function rel_unit_AuthViewRel_R (a: t_Option_R) : () = ()
  
  axiom rel_unit_AuthViewRel_R_spec: forall a: t_Option_R. rel_AuthViewRel_R a unit_R
  
  function rel_none_AuthViewRel_R (a: t_Option_R) (f: t_R) : () = ()
  
  axiom rel_none_AuthViewRel_R_spec: forall a: t_Option_R, f: t_R. rel_AuthViewRel_R (None) f
  
  function rel_mono_AuthViewRel_R (a: t_Option_R) (f1: t_R) (f2: t_R) : () = ()
  
  axiom rel_mono_AuthViewRel_R_spec: forall a: t_Option_R, f1: t_R, f2: t_R. rel_AuthViewRel_R a f1
      -> incl_R f2 f1 -> rel_AuthViewRel_R a f2
  
  function frag_AuthViewRel_R (self: t_View_AuthViewRel_R) : t_R
  
  axiom frag_AuthViewRel_R_spec:
    forall self: t_View_AuthViewRel_R. rel_AuthViewRel_R (auth_AuthViewRel_R self) (frag_AuthViewRel_R self)
  
  predicate premise_AuthUpdate_U [@inline:trivial] (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) =
    match auth_AuthViewRel_R from with
      | Some auth -> premise_U self.f0 auth (frag_AuthViewRel_R from)
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_AuthUpdate_U
  
  type t_Option_View_AuthViewRel_R = None'0 | Some'0 t_View_AuthViewRel_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function new_AuthViewRel_R (auth: t_Option_R) (frag: t_R) : t_View_AuthViewRel_R
  
  axiom new_AuthViewRel_R_spec: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> auth_AuthViewRel_R (new_AuthViewRel_R auth frag) = auth
  
  axiom new_AuthViewRel_R_spec'0: forall auth: t_Option_R, frag: t_R. rel_AuthViewRel_R auth frag
      -> frag_AuthViewRel_R (new_AuthViewRel_R auth frag) = frag
  
  function op_View_AuthViewRel_R (self: t_View_AuthViewRel_R) (other: t_View_AuthViewRel_R) : t_Option_View_AuthViewRel_R
   = match op_R (frag_AuthViewRel_R self) (frag_AuthViewRel_R other) with
      | Some f -> match { f0'0 = auth_AuthViewRel_R self; f1'0 = auth_AuthViewRel_R other } with
        | {f0'0 = None; f1'0 = a} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | {f0'0 = a; f1'0 = None} -> if rel_AuthViewRel_R a f then Some'0 (new_AuthViewRel_R a f) else None'0
        | _ -> None'0
        end
      | None -> None'0
      end
  
  function commutative_View_AuthViewRel_R (a: t_View_AuthViewRel_R) (b: t_View_AuthViewRel_R) : ()
  
  axiom commutative_View_AuthViewRel_R_spec:
    forall a: t_View_AuthViewRel_R, b: t_View_AuthViewRel_R. op_View_AuthViewRel_R a b = op_View_AuthViewRel_R b a
  
  type tup2_R_R = { f0'1: t_R; f1'1: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  predicate index_Mapping_R_bool [@inline:trivial] (self: Map.map t_R bool) (a: t_R) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_R_bool
  
  function such_that_R (p: Map.map t_R bool) : t_R
  
  axiom such_that_R_spec: forall p: Map.map t_R bool. (exists x: t_R. index_Mapping_R_bool p x)
      -> index_Mapping_R_bool p (such_that_R p)
  
  function unwrap_Option_R (self: t_Option_R) : t_R = match self with
      | Some x -> x
      | None -> such_that_R (fun (__0: t_R) -> true)
      end
  
  type t_Option_Option_R = None'1 | Some'1 t_Option_R
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'1
      | Some x -> Some'1 (Map.get f x)
      end
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'1 other
      | {f1'0 = None} -> Some'1 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function frame_preserving_U (self: t_U) (from_auth: t_R) (from_frag: t_R) (frame: t_Option_R) : ()
  
  axiom frame_preserving_U_spec:
    forall self: t_U, from_auth: t_R, from_frag: t_R, frame: t_Option_R. premise_U self from_auth from_frag
      -> op_Option_R (Some from_frag) frame = Some'1 (Some from_auth)
      -> (let {f0'1 = to_auth; f1'1 = to_frag} = update_U self from_auth from_frag in op_Option_R (Some to_frag) frame
      = Some'1 (Some to_auth))
  
  function update_AuthUpdate_U (self: t_AuthUpdate_U) (from: t_View_AuthViewRel_R) (_3: ()) : t_View_AuthViewRel_R =
    let from_auth = unwrap_Option_R (auth_AuthViewRel_R from) in let {f0'1 = auth; f1'1 = frag} = update_U self.f0 from_auth (frag_AuthViewRel_R from) in let _ = frame_preserving_U self.f0 from_auth (frag_AuthViewRel_R from) (factor_R from_auth (frag_AuthViewRel_R from)) in new_AuthViewRel_R (Some auth) frag
  
  axiom update_AuthUpdate_U_spec:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> auth_AuthViewRel_R (update_AuthUpdate_U self from _3)
      = Some ((update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f0'1)
  
  axiom update_AuthUpdate_U_spec'0:
    forall self: t_AuthUpdate_U, from: t_View_AuthViewRel_R, _3: (). premise_AuthUpdate_U self from
      -> frag_AuthViewRel_R (update_AuthUpdate_U self from _3)
      = (update_U self.f0 (unwrap_Option_R (auth_AuthViewRel_R from)) (frag_AuthViewRel_R from)).f1'1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_AuthUpdate_U. forall from: t_View_AuthViewRel_R. forall frame: t_View_AuthViewRel_R. premise_AuthUpdate_U self from
            /\ op_View_AuthViewRel_R from frame <> None'0
          -> premise_AuthUpdate_U self from
          /\ op_View_AuthViewRel_R from frame <> None'0
          /\ (forall result: (). op_View_AuthViewRel_R (update_AuthUpdate_U self from result) frame <> None'0
            -> op_View_AuthViewRel_R (update_AuthUpdate_U self from result) frame <> None'0)
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__update__refines (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate_T = { f0: t_T }
  
  type t_Excl_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T [@inline:trivial] (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  meta "rewrite_def" predicate premise_ExclUpdate_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ExclUpdate_T. forall from: t_Excl_T. forall ch: (). premise_ExclUpdate_T self from
          -> premise_ExclUpdate_T self from
end
module M_logic__ra__excl__impl_Update_for_ExclUpdate_T__frame_preserving__refines (* <logic::ra::excl::ExclUpdate<T> as logic::ra::update::Update<logic::ra::excl::Excl<T>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_ExclUpdate_T = { f0: t_T }
  
  type t_Excl_T = { f0'0: t_T }
  
  predicate premise_ExclUpdate_T [@inline:trivial] (self: t_ExclUpdate_T) (_2: t_Excl_T) = true
  
  meta "rewrite_def" predicate premise_ExclUpdate_T
  
  type t_Option_Excl_T = None | Some t_Excl_T
  
  function op_Excl_T (self: t_Excl_T) (_other: t_Excl_T) : t_Option_Excl_T = None
  
  function commutative_Excl_T (a: t_Excl_T) (b: t_Excl_T) : () = ()
  
  axiom commutative_Excl_T_spec: forall a: t_Excl_T, b: t_Excl_T. op_Excl_T a b = op_Excl_T b a
  
  function update_ExclUpdate_T [@inline:trivial] (self: t_ExclUpdate_T) (from: t_Excl_T) (_3: ()) : t_Excl_T =
    { f0'0 = self.f0 }
  
  meta "rewrite_def" function update_ExclUpdate_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ExclUpdate_T. forall from: t_Excl_T. forall frame: t_Excl_T. premise_ExclUpdate_T self from
            /\ op_Excl_T from frame <> None
          -> premise_ExclUpdate_T self from
          /\ op_Excl_T from frame <> None
          /\ (forall result: (). op_Excl_T (update_ExclUpdate_T self from result) frame <> None
            -> op_Excl_T (update_ExclUpdate_T self from result) frame <> None)
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__update__refines (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_OptionUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U [@inline:trivial] (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0 from'0
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_OptionUpdate_U
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_OptionUpdate_U. forall from: t_Option_R. forall ch: t_Choice. premise_OptionUpdate_U self from
          -> premise_OptionUpdate_U self from
end
module M_logic__ra__option__impl_Update_for_OptionUpdate_U__frame_preserving__refines (* <logic::ra::option::OptionUpdate<U> as logic::ra::update::Update<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_OptionUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_OptionUpdate_U [@inline:trivial] (self: t_OptionUpdate_U) (from: t_Option_R) =
    match from with
      | Some from'0 -> premise_U self.f0 from'0
      | None -> false
      end
  
  meta "rewrite_def" predicate premise_OptionUpdate_U
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : () = ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  type t_Choice
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_OptionUpdate_U [@inline:trivial] (self: t_OptionUpdate_U) (from: t_Option_R) (ch: t_Choice) : t_Option_R
   = match from with
      | Some from'0 -> Some (update_U self.f0 from'0 ch)
      | None -> None
      end
  
  meta "rewrite_def" function update_OptionUpdate_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_OptionUpdate_U. forall from: t_Option_R. forall frame: t_Option_R. premise_OptionUpdate_U self from
            /\ op_Option_R from frame <> None'0
          -> premise_OptionUpdate_U self from
          /\ op_Option_R from frame <> None'0
          /\ (forall result: t_Choice. op_Option_R (update_OptionUpdate_U self from result) frame <> None'0
            -> op_Option_R (update_OptionUpdate_U self from result) frame <> None'0)
end
module M_logic__ra__prod__impl_Update_for_tup2_U1_U2__update__refines (* <(U1, U2) as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type tup2_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0 from.f0'0 /\ premise_U2 self.f1 from.f1'0
  
  meta "rewrite_def" predicate premise_tup2_U1_U2
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'1: t_Choice; f1'1: t_Choice'0 }
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: tup2_U1_U2. forall from: tup2_R1_R2. forall ch: tup2_Choice_Choice. premise_tup2_U1_U2 self from
          -> premise_tup2_U1_U2 self from
end
module M_logic__ra__prod__impl_Update_for_tup2_U1_U2__frame_preserving__refines (* <(U1, U2) as logic::ra::update::Update<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U1
  
  type t_U2
  
  type tup2_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  predicate premise_U1 (self: t_U1) (from: t_R1)
  
  predicate premise_U2 (self: t_U2) (from: t_R2)
  
  predicate premise_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from: tup2_R1_R2) =
    premise_U1 self.f0 from.f0'0 /\ premise_U2 self.f1 from.f1'0
  
  meta "rewrite_def" predicate premise_tup2_U1_U2
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  type tup2_Option_R1_Option_R2 = { f0'1: t_Option_R1; f1'1: t_Option_R2 }
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match { f0'1 = op_R1 self.f0'0 other.f0'0; f1'1 = op_R2 self.f1'0 other.f1'0 } with
      | {f0'1 = Some'0 r1; f1'1 = Some'1 r2} -> Some { f0'0 = r1; f1'0 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  type t_Choice
  
  type t_Choice'0
  
  type tup2_Choice_Choice = { f0'2: t_Choice; f1'2: t_Choice'0 }
  
  function update_U1 (self: t_U1) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_U2 (self: t_U2) (from: t_R2) (ch: t_Choice'0) : t_R2
  
  function update_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from: tup2_R1_R2) (ch: tup2_Choice_Choice) : tup2_R1_R2
   = { f0'0 = update_U1 self.f0 from.f0'0 ch.f0'2; f1'0 = update_U2 self.f1 from.f1'0 ch.f1'2 }
  
  meta "rewrite_def" function update_tup2_U1_U2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_U1_U2. forall from: tup2_R1_R2. forall frame: tup2_R1_R2. premise_tup2_U1_U2 self from
            /\ op_tup2_R1_R2 from frame <> None
          -> premise_tup2_U1_U2 self from
          /\ op_tup2_R1_R2 from frame <> None
          /\ (forall result: tup2_Choice_Choice. op_tup2_R1_R2 (update_tup2_U1_U2 self from result) frame <> None
            -> op_tup2_R1_R2 (update_tup2_U1_U2 self from result) frame <> None)
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__update__refines (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U [@inline:trivial] (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0 from'0
      | Right _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateL_U
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumUpdateL_U. forall from: t_Sum_R1_R2. forall ch: t_Choice. premise_SumUpdateL_U self from
          -> premise_SumUpdateL_U self from
end
module M_logic__ra__sum__impl_Update_for_SumUpdateL_U__frame_preserving__refines (* <logic::ra::sum::SumUpdateL<U> as logic::ra::update::Update<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  predicate premise_U (self: t_U) (from: t_R1)
  
  predicate premise_SumUpdateL_U [@inline:trivial] (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) =
    match from with
      | Left from'0 -> premise_U self.f0 from'0
      | Right _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateL_U
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  type t_Option_R1 = None'0 | Some'0 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'0 c -> op_R1 factor c = Some'0 self
        | None'0 -> forall c: t_R1. op_R1 factor c <> Some'0 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'0
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'0 ab
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'0
      -> op_R1 b c = Some'0 bc -> op_R1 a bc = None'0
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'0 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'1 | Some'1 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'1 c -> op_R2 factor c = Some'1 self
        | None'1 -> forall c: t_R2. op_R2 factor c <> Some'1 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'1
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'1 ab
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'1
      -> op_R2 b c = Some'1 bc -> op_R2 a bc = None'1
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'1 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  type t_Choice
  
  function update_U (self: t_U) (from: t_R1) (ch: t_Choice) : t_R1
  
  function update_SumUpdateL_U [@inline:trivial] (self: t_SumUpdateL_U) (from: t_Sum_R1_R2) (ch: t_Choice) : t_Sum_R1_R2
   = match from with
      | Left from'0 -> Left (update_U self.f0 from'0 ch)
      | x -> x
      end
  
  meta "rewrite_def" function update_SumUpdateL_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumUpdateL_U. forall from: t_Sum_R1_R2. forall frame: t_Sum_R1_R2. premise_SumUpdateL_U self from
            /\ op_Sum_R1_R2 from frame <> None
          -> premise_SumUpdateL_U self from
          /\ op_Sum_R1_R2 from frame <> None
          /\ (forall result: t_Choice. op_Sum_R1_R2 (update_SumUpdateL_U self from result) frame <> None
            -> op_Sum_R1_R2 (update_SumUpdateL_U self from result) frame <> None)
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__frame_preserving__refines (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumUpdateR_U = { f0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U [@inline:trivial] (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0 from'0
      | Left _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateR_U
  
  type t_Option_Sum_V_R = None | Some t_Sum_V_R
  
  type tup2_Sum_V_R_Sum_V_R = { f0'0: t_Sum_V_R; f1'0: t_Sum_V_R }
  
  type t_Option_V = None'0 | Some'0 t_V
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'0 -> None
      | Some'0 x -> Some (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  type t_Option_R = None'1 | Some'1 t_R
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Sum_V_R) : t_Option_Sum_V_R = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some'1 c -> op_R factor c = Some'1 self
        | None'1 -> forall c: t_R. op_R factor c <> Some'1 self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None'1
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some'1 ab
      -> op_R b c = Some'1 bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None'1
      -> op_R b c = Some'1 bc -> op_R a bc = None'1
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some'1 comb -> incl_R self comb
  
  function op_Sum_V_R (self: t_Sum_V_R) (other: t_Sum_V_R) : t_Option_Sum_V_R = match { f0'0 = self; f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_V (op_V x y) (fun (l: t_V) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R (op_R x y) (fun (r: t_R) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_V_R (a: t_Sum_V_R) (b: t_Sum_V_R) : () = ()
  
  axiom commutative_Sum_V_R_spec: forall a: t_Sum_V_R, b: t_Sum_V_R. op_Sum_V_R a b = op_Sum_V_R b a
  
  type t_Choice
  
  function update_U (self: t_U) (from: t_R) (ch: t_Choice) : t_R
  
  function update_SumUpdateR_U [@inline:trivial] (self: t_SumUpdateR_U) (from: t_Sum_V_R) (ch: t_Choice) : t_Sum_V_R =
    match from with
      | Right from'0 -> Right (update_U self.f0 from'0 ch)
      | x -> x
      end
  
  meta "rewrite_def" function update_SumUpdateR_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumUpdateR_U. forall from: t_Sum_V_R. forall frame: t_Sum_V_R. premise_SumUpdateR_U self from
            /\ op_Sum_V_R from frame <> None
          -> premise_SumUpdateR_U self from
          /\ op_Sum_V_R from frame <> None
          /\ (forall result: t_Choice. op_Sum_V_R (update_SumUpdateR_U self from result) frame <> None
            -> op_Sum_V_R (update_SumUpdateR_U self from result) frame <> None)
end
module M_logic__ra__sum__impl_Update_for_SumUpdateR_U__update__refines (* <logic::ra::sum::SumUpdateR<U> as logic::ra::update::Update<logic::ra::sum::Sum<V, R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_U
  
  type t_SumUpdateR_U = { f0: t_U }
  
  type t_V
  
  type t_R
  
  type t_Sum_V_R = Left t_V | Right t_R
  
  predicate premise_U (self: t_U) (from: t_R)
  
  predicate premise_SumUpdateR_U [@inline:trivial] (self: t_SumUpdateR_U) (from: t_Sum_V_R) =
    match from with
      | Right from'0 -> premise_U self.f0 from'0
      | Left _ -> false
      end
  
  meta "rewrite_def" predicate premise_SumUpdateR_U
  
  type t_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_SumUpdateR_U. forall from: t_Sum_V_R. forall ch: t_Choice. premise_SumUpdateR_U self from
          -> premise_SumUpdateR_U self from
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__update__refines (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R [@inline:trivial] (self: t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  meta "rewrite_def" predicate premise_Snapshot_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_R. forall from: t_R. forall ch: (). premise_Snapshot_R self from
          -> premise_Snapshot_R self from
end
module M_logic__ra__update__impl_Update_for_Snapshot_R__frame_preserving__refines (* <snapshot::Snapshot<R> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  predicate premise_Snapshot_R [@inline:trivial] (self: t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> op_R self y <> None
  
  meta "rewrite_def" predicate premise_Snapshot_R
  
  function update_Snapshot_R [@inline:trivial] (self: t_R) (from: t_R) (_3: ()) : t_R = self
  
  meta "rewrite_def" function update_Snapshot_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_R. forall from: t_R. forall frame: t_R. premise_Snapshot_R self from
            /\ op_R from frame <> None
          -> premise_Snapshot_R self from
          /\ op_R from frame <> None
          /\ (forall result: (). op_R (update_Snapshot_R self from result) frame <> None
            -> op_R (update_Snapshot_R self from result) frame <> None)
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__frame_preserving__refines (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  meta "rewrite_def" predicate premise_Snapshot_Mapping_Choice_R
  
  function update_Snapshot_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (from: t_R) (ch: t_Choice) : t_R
   = index_Mapping_Choice_R self ch
  
  meta "rewrite_def" function update_Snapshot_Mapping_Choice_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Map.map t_Choice t_R. forall from: t_R. forall frame: t_R. premise_Snapshot_Mapping_Choice_R self from
            /\ op_R from frame <> None
          -> premise_Snapshot_Mapping_Choice_R self from
          /\ op_R from frame <> None
          /\ (forall result: t_Choice. op_R (update_Snapshot_Mapping_Choice_R self from result) frame <> None
            -> op_R (update_Snapshot_Mapping_Choice_R self from result) frame <> None)
end
module M_logic__ra__update__impl_Update_for_Snapshot_Mapping_Choice_R__update__refines (* <snapshot::Snapshot<logic::mapping::Mapping<Choice, R>> as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function index_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (a: t_Choice) : t_R = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_R
  
  predicate premise_Snapshot_Mapping_Choice_R [@inline:trivial] (self: Map.map t_Choice t_R) (from: t_R) =
    forall y: t_R. op_R from y <> None -> (exists ch: t_Choice. op_R (index_Mapping_Choice_R self ch) y <> None)
  
  meta "rewrite_def" predicate premise_Snapshot_Mapping_Choice_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Map.map t_Choice t_R. forall from: t_R. forall ch: t_Choice. premise_Snapshot_Mapping_Choice_R self from
          -> premise_Snapshot_Mapping_Choice_R self from
end
module M_logic__ra__update__impl_Update_for_unit__frame_preserving__refines (* <() as logic::ra::update::Update<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_R
  
  predicate premise_unit [@inline:trivial] (self: ()) (_2: t_R) = true
  
  meta "rewrite_def" predicate premise_unit
  
  type t_Option_R = None | Some t_R
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function update_unit [@inline:trivial] (self: ()) (from: t_R) (_3: ()) : t_R = from
  
  meta "rewrite_def" function update_unit
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: (). forall from: t_R. forall frame: t_R. premise_unit self from /\ op_R from frame <> None
          -> op_R from frame <> None
          /\ (forall result: (). op_R from frame <> None -> op_R (update_unit self from result) frame <> None)
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__frame_preserving__refines (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Auth_Frag = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'0: Map.map t_Choice tup2_Auth_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'1: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'1).auth
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'1).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdate_R_Choice [@inline:trivial] (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None
    /\ (forall ch: t_Choice. rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1 frame with
          | Some'0 ff -> rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) ff
          | None'0 -> false
          end))
  
  meta "rewrite_def" predicate premise_ViewUpdate_R_Choice
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  type tup2_Option_Auth_Option_Auth = { f0'2: t_Option_Auth; f1'2: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'1 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'2 = auth_R self; f1'2 = auth_R other } with
        | {f0'2 = None; f1'2 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'2 = a; f1'2 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function update_ViewUpdate_R_Choice [@inline:trivial] (self: t_ViewUpdate_R_Choice) (from: t_View_R) (ch: t_Choice) : t_View_R
   =
    new_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1
  
  meta "rewrite_def" function update_ViewUpdate_R_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdate_R_Choice. forall from: t_View_R. forall frame: t_View_R. premise_ViewUpdate_R_Choice self from
            /\ op_View_R from frame <> None'1
          -> premise_ViewUpdate_R_Choice self from
          /\ op_View_R from frame <> None'1
          /\ (forall result: t_Choice. op_View_R (update_ViewUpdate_R_Choice self from result) frame <> None'1
            -> op_View_R (update_ViewUpdate_R_Choice self from result) frame <> None'1)
end
module M_logic__ra__view__impl_Update_for_ViewUpdate_R_Choice__update__refines (* <logic::ra::view::ViewUpdate<R, Choice> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_Choice
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type tup2_Auth_Frag = { f0: t_Auth; f1: t_Frag }
  
  type t_ViewUpdate_R_Choice = { f0'0: Map.map t_Choice tup2_Auth_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'1: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'1).auth
  
  function index_Mapping_Choice_tup2_Auth_Frag [@inline:trivial] (self: Map.map t_Choice tup2_Auth_Frag) (a: t_Choice) : tup2_Auth_Frag
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Choice_tup2_Auth_Frag
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'1).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdate_R_Choice [@inline:trivial] (self: t_ViewUpdate_R_Choice) (from: t_View_R) =
    auth_R from <> None
    /\ (forall ch: t_Choice. rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1)
    /\ (forall frame: t_Frag. match op_Frag (frag_R from) frame with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end
      -> (exists ch: t_Choice. match op_Frag (index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f1 frame with
          | Some'0 ff -> rel_R (Some ((index_Mapping_Choice_tup2_Auth_Frag self.f0'0 ch).f0)) ff
          | None'0 -> false
          end))
  
  meta "rewrite_def" predicate premise_ViewUpdate_R_Choice
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdate_R_Choice. forall from: t_View_R. forall ch: t_Choice. premise_ViewUpdate_R_Choice self from
          -> premise_ViewUpdate_R_Choice self from
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__frame_preserving__refines (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateInsert_R = { f0: t_Auth; f1: t_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  predicate premise_ViewUpdateInsert_R [@inline:trivial] (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1 f with
        | Some'0 ff -> rel_R (Some (self.f0)) ff
        | None'0 -> false
        end)
  
  meta "rewrite_def" predicate premise_ViewUpdateInsert_R
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'1 = auth_R self; f1'1 = auth_R other } with
        | {f0'1 = None; f1'1 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'1 = a; f1'1 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function update_ViewUpdateInsert_R [@inline:trivial] (self: t_ViewUpdateInsert_R) (from: t_View_R) (_3: ()) : t_View_R
   = new_R (Some (self.f0)) self.f1
  
  meta "rewrite_def" function update_ViewUpdateInsert_R
  
  axiom update_ViewUpdateInsert_R_spec:
    forall self: t_ViewUpdateInsert_R, from: t_View_R, _3: (). premise_ViewUpdateInsert_R self from
      -> rel_R (Some (self.f0)) self.f1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdateInsert_R. forall from: t_View_R. forall frame: t_View_R. premise_ViewUpdateInsert_R self from
            /\ op_View_R from frame <> None'1
          -> premise_ViewUpdateInsert_R self from
          /\ op_View_R from frame <> None'1
          /\ (forall result: (). op_View_R (update_ViewUpdateInsert_R self from result) frame <> None'1
            -> op_View_R (update_ViewUpdateInsert_R self from result) frame <> None'1)
end
module M_logic__ra__view__impl_Update_for_ViewUpdateInsert_R__update__refines (* <logic::ra::view::ViewUpdateInsert<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateInsert_R = { f0: t_Auth; f1: t_Frag }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  predicate premise_ViewUpdateInsert_R [@inline:trivial] (self: t_ViewUpdateInsert_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. rel_R (auth_R from) f
      -> match op_Frag self.f1 f with
        | Some'0 ff -> rel_R (Some (self.f0)) ff
        | None'0 -> false
        end)
  
  meta "rewrite_def" predicate premise_ViewUpdateInsert_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdateInsert_R. forall from: t_View_R. forall ch: (). premise_ViewUpdateInsert_R self from
          -> premise_ViewUpdateInsert_R self from
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__update__refines (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateRemove_R = { f0: t_Auth }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdateRemove_R [@inline:trivial] (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some (self.f0)) f)
  
  meta "rewrite_def" predicate premise_ViewUpdateRemove_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdateRemove_R. forall from: t_View_R. forall ch: (). premise_ViewUpdateRemove_R self from
          -> premise_ViewUpdateRemove_R self from
end
module M_logic__ra__view__impl_Update_for_ViewUpdateRemove_R__frame_preserving__refines (* <logic::ra::view::ViewUpdateRemove<R> as logic::ra::update::Update<logic::ra::view::View<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Auth
  
  type t_Option_Auth = None | Some t_Auth
  
  type t_Frag
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewUpdateRemove_R = { f0: t_Auth }
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0'0: t_Subset_ViewInner_R }
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0'0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0'0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  predicate premise_ViewUpdateRemove_R [@inline:trivial] (self: t_ViewUpdateRemove_R) (from: t_View_R) =
    auth_R from <> None
    /\ (forall f: t_Frag. match op_Frag (frag_R from) f with
          | Some'0 ff -> rel_R (auth_R from) ff
          | None'0 -> false
          end -> rel_R (Some (self.f0)) f)
  
  meta "rewrite_def" predicate premise_ViewUpdateRemove_R
  
  type t_Option_View_R = None'1 | Some'1 t_View_R
  
  type tup2_Option_Auth_Option_Auth = { f0'1: t_Option_Auth; f1'1: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0'0 = new_ViewInner_R { auth = auth'0;
                                                                                                  frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'1 = auth_R self; f1'1 = auth_R other } with
        | {f0'1 = None; f1'1 = a} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | {f0'1 = a; f1'1 = None} -> if rel_R a f then Some'1 (new_R a f) else None'1
        | _ -> None'1
        end
      | None'0 -> None'1
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_auth_R [@inline:trivial] (auth'0: t_Auth) : t_View_R = new_R (Some auth'0) unit_Frag
  
  meta "rewrite_def" function new_auth_R
  
  function update_ViewUpdateRemove_R [@inline:trivial] (self: t_ViewUpdateRemove_R) (from: t_View_R) (_3: ()) : t_View_R
   = new_auth_R self.f0
  
  meta "rewrite_def" function update_ViewUpdateRemove_R
  
  axiom update_ViewUpdateRemove_R_spec:
    forall self: t_ViewUpdateRemove_R, from: t_View_R, _3: (). premise_ViewUpdateRemove_R self from
      -> rel_R (Some (self.f0)) unit_Frag
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_ViewUpdateRemove_R. forall from: t_View_R. forall frame: t_View_R. premise_ViewUpdateRemove_R self from
            /\ op_View_R from frame <> None'1
          -> premise_ViewUpdateRemove_R self from
          /\ op_View_R from frame <> None'1
          /\ (forall result: (). op_View_R (update_ViewUpdateRemove_R self from result) frame <> None'1
            -> op_View_R (update_ViewUpdateRemove_R self from result) frame <> None'1)
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__unit__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_FMap_K_V. (forall x: t_FMap_K_V [op_FMap_K_V x result]. op_FMap_K_V x result = Some x)
      -> (forall x: t_FMap_K_V [op_FMap_K_V x result]. op_FMap_K_V x result = Some x)
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_total__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_FMap_K_V. forall result: t_FMap_K_V. core_FMap_K_V self = Some result
        -> core_FMap_K_V self = Some result
end
module M_logic__ra__fmap__impl_UnitRA_for_FMap_K_V__core_total_idemp__refines (* <logic::fmap::FMap<K, V> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_FMap_K_V
  
  type t_Option_FMap_K_V = None | Some t_FMap_K_V
  
  type t_V
  
  type t_Option_V = None'0 | Some'0 t_V
  
  type t_Option_Option_V = None'1 | Some'1 t_Option_V
  
  type tup2_Option_V_Option_V = { f0: t_Option_V; f1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some'0 c -> op_V factor c = Some'0 self
        | None'0 -> forall c: t_V. op_V factor c <> Some'0 self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None'0
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some'0 ab
      -> op_V b c = Some'0 bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None'0
      -> op_V b c = Some'0 bc -> op_V a bc = None'0
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some'0 comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0 = self; f1 = other } with
      | {f0 = None'0} -> Some'1 other
      | {f1 = None'0} -> Some'1 self
      | {f0 = Some'0 x; f1 = Some'0 y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some'0 z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type t_K
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  type tup2_V_V = { f0'0: t_V; f1'0: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0 = get_K self k;
                                                                                                                         f1 = get_K m k } with
          | {f0 = None'0; f1 = y} -> get_K (merge_K self m f) k = y
          | {f0 = x; f1 = None'0} -> get_K (merge_K self m f) k = x
          | {f0 = Some'0 x; f1 = Some'0 y} -> get_K (merge_K self m f) k
          = Some'0 (index_Mapping_tup2_V_V_V f { f0'0 = x; f1'0 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'0 = x; f1'0 = y} = __0 in match op_V x y with
      | Some'0 r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1)
      -> (forall k: t_K. Some'1 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'1 then Some (total_op_K self other) else None
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  type tup2_K_V = { f0'1: t_K; f1'1: t_V }
  
  function index_Mapping_tup2_K_V_Option_V [@inline:trivial] (self: Map.map tup2_K_V t_Option_V) (a: tup2_K_V) : t_Option_V
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_K_V_Option_V
  
  function filter_map_K (self: t_FMap_K_V) (f: Map.map tup2_K_V t_Option_V) : t_FMap_K_V
  
  axiom filter_map_K_spec:
    forall self: t_FMap_K_V, f: Map.map tup2_K_V t_Option_V. forall k: t_K [get_K (filter_map_K self f) k]. get_K (filter_map_K self f) k
        = match get_K self k with
          | None'0 -> None'0
          | Some'0 v -> index_Mapping_tup2_K_V_Option_V f { f0'1 = k; f1'1 = v }
          end
  
  function core_V (self: t_V) : t_Option_V
  
  function core_FMap_K_V (self: t_FMap_K_V) : t_Option_FMap_K_V =
    Some (filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v))
  
  function core_total_FMap_K_V (self: t_FMap_K_V) : t_FMap_K_V =
    filter_map_K self (fun (__0: tup2_K_V) -> let {f1'1 = v} = __0 in core_V v)
  
  axiom core_total_FMap_K_V_spec: forall self: t_FMap_K_V. core_FMap_K_V self = Some (core_total_FMap_K_V self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FMap_K_V. forall result: (). op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self)
            = Some (core_total_FMap_K_V self)
          /\ op_FMap_K_V (core_total_FMap_K_V self) self = Some self
        -> op_FMap_K_V (core_total_FMap_K_V self) (core_total_FMap_K_V self) = Some (core_total_FMap_K_V self)
        /\ op_FMap_K_V (core_total_FMap_K_V self) self = Some self
end
module M_logic__ra__int__impl_UnitRA_for_Int__core_total_idemp__refines (* <logic::int::Int as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  function core_total_Int [@inline:trivial] (self: int) : int = 0
  
  meta "rewrite_def" function core_total_Int
  
  axiom core_total_Int_spec: forall self: int. core_Int self = Some (core_total_Int self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: int. forall result: (). op_Int (core_total_Int self) (core_total_Int self)
            = Some (core_total_Int self)
          /\ op_Int (core_total_Int self) self = Some self
        -> op_Int (core_total_Int self) (core_total_Int self) = Some (core_total_Int self)
        /\ op_Int (core_total_Int self) self = Some self
end
module M_logic__ra__int__impl_UnitRA_for_Int__unit__refines (* <logic::int::Int as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: int. (forall x: int [op_Int x result]. op_Int x result = Some x)
      -> (forall x: int [op_Int x result]. op_Int x result = Some x)
end
module M_logic__ra__int__impl_UnitRA_for_Int__core_total__refines (* <logic::int::Int as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Option_Int = None | Some int
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  function core_Int [@inline:trivial] (self: int) : t_Option_Int = Some 0
  
  meta "rewrite_def" function core_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: int. forall result: int. core_Int self = Some result -> core_Int self = Some result
end
module M_logic__ra__nat__impl_UnitRA_for_Nat__core_total_idemp__refines (* <logic::int::Nat as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function commutative_Nat (a: t_Nat) (b: t_Nat) : () = ()
  
  axiom commutative_Nat_spec: forall a: t_Nat, b: t_Nat. op_Nat a b = op_Nat b a
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  function core_total_Nat [@inline:trivial] (self: t_Nat) : t_Nat = new 0
  
  meta "rewrite_def" function core_total_Nat
  
  axiom core_total_Nat_spec: forall self: t_Nat. core_Nat self = Some (core_total_Nat self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Nat. forall result: (). op_Nat (core_total_Nat self) (core_total_Nat self)
            = Some (core_total_Nat self)
          /\ op_Nat (core_total_Nat self) self = Some self
        -> op_Nat (core_total_Nat self) (core_total_Nat self) = Some (core_total_Nat self)
        /\ op_Nat (core_total_Nat self) self = Some self
end
module M_logic__ra__nat__impl_UnitRA_for_Nat__unit__refines (* <logic::int::Nat as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function commutative_Nat (a: t_Nat) (b: t_Nat) : () = ()
  
  axiom commutative_Nat_spec: forall a: t_Nat, b: t_Nat. op_Nat a b = op_Nat b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_Nat. (forall x: t_Nat [op_Nat x result]. op_Nat x result = Some x)
      -> (forall x: t_Nat [op_Nat x result]. op_Nat x result = Some x)
end
module M_logic__ra__nat__impl_UnitRA_for_Nat__core_total__refines (* <logic::int::Nat as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use int.Int
  
  type t_Nat
  
  type t_Option_Nat = None | Some t_Nat
  
  function to_int (self: t_Nat) : int
  
  axiom to_int_spec: forall self: t_Nat. to_int self >= 0
  
  function add_Nat (self: t_Nat) (other: t_Nat) : t_Nat
  
  axiom add_Nat_spec: forall self: t_Nat, other: t_Nat. to_int (add_Nat self other) = to_int self + to_int other
  
  function op_Nat [@inline:trivial] (self: t_Nat) (other: t_Nat) : t_Option_Nat = Some (add_Nat self other)
  
  meta "rewrite_def" function op_Nat
  
  function commutative_Nat (a: t_Nat) (b: t_Nat) : () = ()
  
  axiom commutative_Nat_spec: forall a: t_Nat, b: t_Nat. op_Nat a b = op_Nat b a
  
  function new (n: int) : t_Nat
  
  axiom new_spec: forall n: int. n >= 0 -> to_int (new n) = n
  
  function core_Nat [@inline:trivial] (self: t_Nat) : t_Option_Nat = Some (new 0)
  
  meta "rewrite_def" function core_Nat
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Nat. forall result: t_Nat. core_Nat self = Some result -> core_Nat self = Some result
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_total__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_Option_T. forall result: t_Option_T. core_Option_T self = Some'0 result
        -> core_Option_T self = Some'0 result
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__unit__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_Option_T. (forall x: t_Option_T [op_Option_T x result]. op_Option_T x result
          = Some'0 x) -> (forall x: t_Option_T [op_Option_T x result]. op_Option_T x result = Some'0 x)
end
module M_logic__ra__option__impl_UnitRA_for_Option_T__core_total_idemp__refines (* <std::option::Option<T> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_T
  
  type t_Option_T = None | Some t_T
  
  type t_Option_Option_T = None'0 | Some'0 t_Option_T
  
  type tup2_Option_T_Option_T = { f0: t_Option_T; f1: t_Option_T }
  
  function map_Option_T (self: t_Option_T) (f: Map.map t_T t_Option_T) : t_Option_Option_T = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some c -> op_T factor c = Some self
        | None -> forall c: t_T. op_T factor c <> Some self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some ab
      -> op_T b c = Some bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None
      -> op_T b c = Some bc -> op_T a bc = None
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some comb -> incl_T self comb
  
  function op_Option_T (self: t_Option_T) (other: t_Option_T) : t_Option_Option_T = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_T (op_T x y) (fun (z: t_T) -> Some z)
      end
  
  function commutative_Option_T (a: t_Option_T) (b: t_Option_T) : () = ()
  
  axiom commutative_Option_T_spec: forall a: t_Option_T, b: t_Option_T. op_Option_T a b = op_Option_T b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_Option_T (self: t_Option_T) : t_Option_Option_T = match self with
      | None -> Some'0 (None)
      | Some x -> Some'0 (core_T x)
      end
  
  function core_total_Option_T (self: t_Option_T) : t_Option_T = match self with
      | None -> None
      | Some x -> core_T x
      end
  
  axiom core_total_Option_T_spec: forall self: t_Option_T. core_Option_T self = Some'0 (core_total_Option_T self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Option_T. forall result: (). op_Option_T (core_total_Option_T self) (core_total_Option_T self)
            = Some'0 (core_total_Option_T self)
          /\ op_Option_T (core_total_Option_T self) self = Some'0 self
        -> op_Option_T (core_total_Option_T self) (core_total_Option_T self) = Some'0 (core_total_Option_T self)
        /\ op_Option_T (core_total_Option_T self) self = Some'0 self
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__unit__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: tup2_T_U. (forall x: tup2_T_U [op_tup2_T_U x result]. op_tup2_T_U x result = Some x)
      -> (forall x: tup2_T_U [op_tup2_T_U x result]. op_tup2_T_U x result = Some x)
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_total_idemp__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  constant unit_T : t_T
  
  axiom unit_T_spec: forall x: t_T [op_T x unit_T]. op_T x unit_T = Some'0 x
  
  function core_total_T (self: t_T) : t_T
  
  axiom core_total_T_spec: forall self: t_T. core_T self = Some'0 (core_total_T self)
  
  constant unit_core_T : ()
  
  axiom unit_core_T_spec: core_total_T unit_T = unit_T
  
  constant incl_refl_T : ()
  
  axiom incl_refl_T_spec: forall x: t_T. incl_T x x
  
  constant unit_U : t_U
  
  axiom unit_U_spec: forall x: t_U [op_U x unit_U]. op_U x unit_U = Some'1 x
  
  function core_total_U (self: t_U) : t_U
  
  axiom core_total_U_spec: forall self: t_U. core_U self = Some'1 (core_total_U self)
  
  constant unit_core_U : ()
  
  axiom unit_core_U_spec: core_total_U unit_U = unit_U
  
  constant incl_refl_U : ()
  
  axiom incl_refl_U_spec: forall x: t_U. incl_U x x
  
  function core_total_tup2_T_U (self: tup2_T_U) : tup2_T_U = { f0 = core_total_T self.f0; f1 = core_total_U self.f1 }
  
  axiom core_total_tup2_T_U_spec: forall self: tup2_T_U. core_tup2_T_U self = Some (core_total_tup2_T_U self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: tup2_T_U. forall result: (). op_tup2_T_U (core_total_tup2_T_U self) (core_total_tup2_T_U self)
            = Some (core_total_tup2_T_U self)
          /\ op_tup2_T_U (core_total_tup2_T_U self) self = Some self
        -> op_tup2_T_U (core_total_tup2_T_U self) (core_total_tup2_T_U self) = Some (core_total_tup2_T_U self)
        /\ op_tup2_T_U (core_total_tup2_T_U self) self = Some self
end
module M_logic__ra__prod__impl_UnitRA_for_tup2_T_U__core_total__refines (* <(T, U) as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_T
  
  type t_U
  
  type tup2_T_U = { f0: t_T; f1: t_U }
  
  type t_Option_tup2_T_U = None | Some tup2_T_U
  
  type t_Option_T = None'0 | Some'0 t_T
  
  type t_Option_U = None'1 | Some'1 t_U
  
  type tup2_Option_T_Option_U = { f0'0: t_Option_T; f1'0: t_Option_U }
  
  function op_T (self: t_T) (other: t_T) : t_Option_T
  
  function factor_T (self: t_T) (factor: t_T) : t_Option_T
  
  axiom factor_T_spec: forall self: t_T, factor: t_T. match factor_T self factor with
        | Some'0 c -> op_T factor c = Some'0 self
        | None'0 -> forall c: t_T. op_T factor c <> Some'0 self
        end
  
  predicate incl_T (self: t_T) (other: t_T) = factor_T other self <> None'0
  
  function incl_transitive_T (a: t_T) (b: t_T) (c: t_T) : ()
  
  axiom incl_transitive_T_spec: forall a: t_T, b: t_T, c: t_T. incl_T a b -> incl_T b c -> incl_T a c
  
  function associative_some_T (a: t_T) (b: t_T) (c: t_T) (ab: t_T) (bc: t_T) : ()
  
  axiom associative_some_T_spec: forall a: t_T, b: t_T, c: t_T, ab: t_T, bc: t_T. op_T a b = Some'0 ab
      -> op_T b c = Some'0 bc -> op_T a bc = op_T ab c
  
  function associative_none_T (a: t_T) (b: t_T) (c: t_T) (bc: t_T) : ()
  
  axiom associative_none_T_spec: forall a: t_T, b: t_T, c: t_T, bc: t_T. op_T a b = None'0
      -> op_T b c = Some'0 bc -> op_T a bc = None'0
  
  function commutative_T (a: t_T) (b: t_T) : ()
  
  axiom commutative_T_spec: forall a: t_T, b: t_T. op_T a b = op_T b a
  
  function incl_op_T (self: t_T) (other: t_T) (comb: t_T) : ()
  
  axiom incl_op_T_spec: forall self: t_T, other: t_T, comb: t_T. op_T self other = Some'0 comb -> incl_T self comb
  
  function op_U (self: t_U) (other: t_U) : t_Option_U
  
  function factor_U (self: t_U) (factor: t_U) : t_Option_U
  
  axiom factor_U_spec: forall self: t_U, factor: t_U. match factor_U self factor with
        | Some'1 c -> op_U factor c = Some'1 self
        | None'1 -> forall c: t_U. op_U factor c <> Some'1 self
        end
  
  predicate incl_U (self: t_U) (other: t_U) = factor_U other self <> None'1
  
  function incl_transitive_U (a: t_U) (b: t_U) (c: t_U) : ()
  
  axiom incl_transitive_U_spec: forall a: t_U, b: t_U, c: t_U. incl_U a b -> incl_U b c -> incl_U a c
  
  function associative_some_U (a: t_U) (b: t_U) (c: t_U) (ab: t_U) (bc: t_U) : ()
  
  axiom associative_some_U_spec: forall a: t_U, b: t_U, c: t_U, ab: t_U, bc: t_U. op_U a b = Some'1 ab
      -> op_U b c = Some'1 bc -> op_U a bc = op_U ab c
  
  function associative_none_U (a: t_U) (b: t_U) (c: t_U) (bc: t_U) : ()
  
  axiom associative_none_U_spec: forall a: t_U, b: t_U, c: t_U, bc: t_U. op_U a b = None'1
      -> op_U b c = Some'1 bc -> op_U a bc = None'1
  
  function commutative_U (a: t_U) (b: t_U) : ()
  
  axiom commutative_U_spec: forall a: t_U, b: t_U. op_U a b = op_U b a
  
  function incl_op_U (self: t_U) (other: t_U) (comb: t_U) : ()
  
  axiom incl_op_U_spec: forall self: t_U, other: t_U, comb: t_U. op_U self other = Some'1 comb -> incl_U self comb
  
  function op_tup2_T_U (self: tup2_T_U) (other: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = op_T self.f0 other.f0;
                                                                                        f1'0 = op_U self.f1 other.f1 } with
      | {f0'0 = Some'0 r1; f1'0 = Some'1 r2} -> Some { f0 = r1; f1 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_T_U (a: tup2_T_U) (b: tup2_T_U) : () = ()
  
  axiom commutative_tup2_T_U_spec: forall a: tup2_T_U, b: tup2_T_U. op_tup2_T_U a b = op_tup2_T_U b a
  
  function core_T (self: t_T) : t_Option_T
  
  function core_U (self: t_U) : t_Option_U
  
  function core_tup2_T_U (self: tup2_T_U) : t_Option_tup2_T_U = match { f0'0 = core_T self.f0;
                                                                        f1'0 = core_U self.f1 } with
      | {f0'0 = Some'0 x; f1'0 = Some'1 y} -> Some { f0 = x; f1 = y }
      | _ -> None
      end
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: tup2_T_U. forall result: tup2_T_U. core_tup2_T_U self = Some result
        -> core_tup2_T_U self = Some result
end
module M_logic__ra__view__impl_UnitRA_for_View_R__unit__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall result: t_View_R. (forall x: t_View_R [op_View_R x result]. op_View_R x result = Some x)
      -> (forall x: t_View_R [op_View_R x result]. op_View_R x result = Some x)
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_total__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall result: t_View_R. core_View_R self = Some result
        -> core_View_R self = Some result
end
module M_logic__ra__view__impl_UnitRA_for_View_R__core_total_idemp__refines (* <logic::ra::view::View<R> as logic::ra::UnitRA> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_Subset_ViewInner_R
  
  type t_View_R = { f0: t_Subset_ViewInner_R }
  
  type t_Option_View_R = None | Some t_View_R
  
  type t_Frag
  
  type t_Option_Frag = None'0 | Some'0 t_Frag
  
  type t_Auth
  
  type t_Option_Auth = None'1 | Some'1 t_Auth
  
  predicate rel_R (a: t_Option_Auth) (f: t_Frag)
  
  function op_Frag (self: t_Frag) (other: t_Frag) : t_Option_Frag
  
  function factor_Frag (self: t_Frag) (factor: t_Frag) : t_Option_Frag
  
  axiom factor_Frag_spec: forall self: t_Frag, factor: t_Frag. match factor_Frag self factor with
        | Some'0 c -> op_Frag factor c = Some'0 self
        | None'0 -> forall c: t_Frag. op_Frag factor c <> Some'0 self
        end
  
  predicate incl_Frag (self: t_Frag) (other: t_Frag) = factor_Frag other self <> None'0
  
  function incl_transitive_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) : ()
  
  axiom incl_transitive_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag. incl_Frag a b
      -> incl_Frag b c -> incl_Frag a c
  
  function associative_some_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (ab: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_some_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, ab: t_Frag, bc: t_Frag. op_Frag a b
        = Some'0 ab -> op_Frag b c = Some'0 bc -> op_Frag a bc = op_Frag ab c
  
  function associative_none_Frag (a: t_Frag) (b: t_Frag) (c: t_Frag) (bc: t_Frag) : ()
  
  axiom associative_none_Frag_spec: forall a: t_Frag, b: t_Frag, c: t_Frag, bc: t_Frag. op_Frag a b = None'0
      -> op_Frag b c = Some'0 bc -> op_Frag a bc = None'0
  
  function commutative_Frag (a: t_Frag) (b: t_Frag) : ()
  
  axiom commutative_Frag_spec: forall a: t_Frag, b: t_Frag. op_Frag a b = op_Frag b a
  
  function incl_op_Frag (self: t_Frag) (other: t_Frag) (comb: t_Frag) : ()
  
  axiom incl_op_Frag_spec: forall self: t_Frag, other: t_Frag, comb: t_Frag. op_Frag self other = Some'0 comb
      -> incl_Frag self comb
  
  function core_Frag (self: t_Frag) : t_Option_Frag
  
  function core_total_Frag (self: t_Frag) : t_Frag
  
  axiom core_total_Frag_spec: forall self: t_Frag. core_Frag self = Some'0 (core_total_Frag self)
  
  constant unit_Frag : t_Frag
  
  axiom unit_Frag_spec: forall x: t_Frag [op_Frag x unit_Frag]. op_Frag x unit_Frag = Some'0 x
  
  constant unit_core_Frag : ()
  
  axiom unit_core_Frag_spec: core_total_Frag unit_Frag = unit_Frag
  
  constant incl_refl_Frag : ()
  
  axiom incl_refl_Frag_spec: forall x: t_Frag. incl_Frag x x
  
  function rel_unit_R (a: t_Option_Auth) : ()
  
  axiom rel_unit_R_spec: forall a: t_Option_Auth. rel_R a unit_Frag
  
  function rel_none_R (a: t_Option_Auth) (f: t_Frag) : ()
  
  axiom rel_none_R_spec: forall a: t_Option_Auth, f: t_Frag. rel_R a f -> rel_R (None'1) f
  
  function rel_mono_R (a: t_Option_Auth) (f1: t_Frag) (f2: t_Frag) : ()
  
  axiom rel_mono_R_spec: forall a: t_Option_Auth, f1: t_Frag, f2: t_Frag. rel_R a f1 -> incl_Frag f2 f1 -> rel_R a f2
  
  type t_ViewInner_R = { auth: t_Option_Auth; frag: t_Frag }
  
  predicate invariant_ViewInner_R (self: t_ViewInner_R) = rel_R self.auth self.frag
  
  function inner_ViewInner_R (self: t_Subset_ViewInner_R) : t_ViewInner_R
  
  axiom inner_ViewInner_R_spec: forall self: t_Subset_ViewInner_R. invariant_ViewInner_R (inner_ViewInner_R self)
  
  function auth_R (self: t_View_R) : t_Option_Auth = (inner_ViewInner_R self.f0).auth
  
  function frag_R (self: t_View_R) : t_Frag = (inner_ViewInner_R self.f0).frag
  
  axiom frag_R_spec: forall self: t_View_R. rel_R (auth_R self) (frag_R self)
  
  type tup2_Option_Auth_Option_Auth = { f0'0: t_Option_Auth; f1'0: t_Option_Auth }
  
  function new_ViewInner_R (x: t_ViewInner_R) : t_Subset_ViewInner_R
  
  axiom new_ViewInner_R_spec: forall x: t_ViewInner_R. invariant_ViewInner_R x
      -> inner_ViewInner_R (new_ViewInner_R x) = x
  
  function new_R (auth'0: t_Option_Auth) (frag'0: t_Frag) : t_View_R = { f0 = new_ViewInner_R { auth = auth'0;
                                                                                                frag = frag'0 } }
  
  axiom new_R_spec: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> auth_R (new_R auth'0 frag'0) = auth'0
  
  axiom new_R_spec'0: forall auth'0: t_Option_Auth, frag'0: t_Frag. rel_R auth'0 frag'0
      -> frag_R (new_R auth'0 frag'0) = frag'0
  
  function op_View_R (self: t_View_R) (other: t_View_R) : t_Option_View_R =
    match op_Frag (frag_R self) (frag_R other) with
      | Some'0 f -> match { f0'0 = auth_R self; f1'0 = auth_R other } with
        | {f0'0 = None'1; f1'0 = a} -> if rel_R a f then Some (new_R a f) else None
        | {f0'0 = a; f1'0 = None'1} -> if rel_R a f then Some (new_R a f) else None
        | _ -> None
        end
      | None'0 -> None
      end
  
  function commutative_View_R (a: t_View_R) (b: t_View_R) : () = ()
  
  axiom commutative_View_R_spec: forall a: t_View_R, b: t_View_R. op_View_R a b = op_View_R b a
  
  function new_frag_R [@inline:trivial] (frag'0: t_Frag) : t_View_R = new_R (None'1) frag'0
  
  meta "rewrite_def" function new_frag_R
  
  function core_View_R (self: t_View_R) : t_Option_View_R = Some (new_frag_R (core_total_Frag (frag_R self)))
  
  function core_total_idemp_Frag (self: t_Frag) : ()
  
  axiom core_total_idemp_Frag_spec: forall self: t_Frag. op_Frag (core_total_Frag self) (core_total_Frag self)
      = Some'0 (core_total_Frag self)
  
  axiom core_total_idemp_Frag_spec'0: forall self: t_Frag. op_Frag (core_total_Frag self) self = Some'0 self
  
  function core_total_View_R (self: t_View_R) : t_View_R =
    let _ = core_total_idemp_Frag (frag_R self) in new_frag_R (core_total_Frag (frag_R self))
  
  axiom core_total_View_R_spec: forall self: t_View_R. core_View_R self = Some (core_total_View_R self)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_View_R. forall result: (). op_View_R (core_total_View_R self) (core_total_View_R self)
            = Some (core_total_View_R self)
          /\ op_View_R (core_total_View_R self) self = Some self
        -> op_View_R (core_total_View_R self) (core_total_View_R self) = Some (core_total_View_R self)
        /\ op_View_R (core_total_View_R self) self = Some self
end
module M_logic__ra__fmap__impl_LocalUpdate_for_FMapInsertLocalUpdate_K_V__frame_preserving__refines (* <logic::ra::fmap::FMapInsertLocalUpdate<K, V> as logic::ra::update::LocalUpdate<logic::fmap::FMap<K, V>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_K
  
  type t_V
  
  type t_FMapInsertLocalUpdate_K_V = { f0: t_K; f1: t_V }
  
  type t_FMap_K_V
  
  type t_Option_V = None | Some t_V
  
  function to_mapping_K (self: t_FMap_K_V) : Map.map t_K t_Option_V
  
  function get_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) : t_Option_V = Map.get (to_mapping_K self) k
  
  meta "rewrite_def" function get_K
  
  predicate premise_FMapInsertLocalUpdate_K_V [@inline:trivial] (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (_3: t_FMap_K_V) =
    get_K from_auth self.f0 = None
  
  meta "rewrite_def" predicate premise_FMapInsertLocalUpdate_K_V
  
  type t_Option_FMap_K_V = None'0 | Some'0 t_FMap_K_V
  
  type t_Option_Option_FMap_K_V = None'1 | Some'1 t_Option_FMap_K_V
  
  type tup2_Option_FMap_K_V_Option_FMap_K_V = { f0'0: t_Option_FMap_K_V; f1'0: t_Option_FMap_K_V }
  
  function map_Option_FMap_K_V (self: t_Option_FMap_K_V) (f: Map.map t_FMap_K_V t_Option_FMap_K_V) : t_Option_Option_FMap_K_V
   = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  type t_Option_Option_V = None'2 | Some'2 t_Option_V
  
  type tup2_Option_V_Option_V = { f0'1: t_Option_V; f1'1: t_Option_V }
  
  function map_Option_V (self: t_Option_V) (f: Map.map t_V t_Option_V) : t_Option_Option_V = match self with
      | None -> None'2
      | Some x -> Some'2 (Map.get f x)
      end
  
  function op_V (self: t_V) (other: t_V) : t_Option_V
  
  function factor_V (self: t_V) (factor: t_V) : t_Option_V
  
  axiom factor_V_spec: forall self: t_V, factor: t_V. match factor_V self factor with
        | Some c -> op_V factor c = Some self
        | None -> forall c: t_V. op_V factor c <> Some self
        end
  
  predicate incl_V (self: t_V) (other: t_V) = factor_V other self <> None
  
  function incl_transitive_V (a: t_V) (b: t_V) (c: t_V) : ()
  
  axiom incl_transitive_V_spec: forall a: t_V, b: t_V, c: t_V. incl_V a b -> incl_V b c -> incl_V a c
  
  function associative_some_V (a: t_V) (b: t_V) (c: t_V) (ab: t_V) (bc: t_V) : ()
  
  axiom associative_some_V_spec: forall a: t_V, b: t_V, c: t_V, ab: t_V, bc: t_V. op_V a b = Some ab
      -> op_V b c = Some bc -> op_V a bc = op_V ab c
  
  function associative_none_V (a: t_V) (b: t_V) (c: t_V) (bc: t_V) : ()
  
  axiom associative_none_V_spec: forall a: t_V, b: t_V, c: t_V, bc: t_V. op_V a b = None
      -> op_V b c = Some bc -> op_V a bc = None
  
  function commutative_V (a: t_V) (b: t_V) : ()
  
  axiom commutative_V_spec: forall a: t_V, b: t_V. op_V a b = op_V b a
  
  function incl_op_V (self: t_V) (other: t_V) (comb: t_V) : ()
  
  axiom incl_op_V_spec: forall self: t_V, other: t_V, comb: t_V. op_V self other = Some comb -> incl_V self comb
  
  function op_Option_V (self: t_Option_V) (other: t_Option_V) : t_Option_Option_V = match { f0'1 = self;
                                                                                            f1'1 = other } with
      | {f0'1 = None} -> Some'2 other
      | {f1'1 = None} -> Some'2 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_V (op_V x y) (fun (z: t_V) -> Some z)
      end
  
  function commutative_Option_V (a: t_Option_V) (b: t_Option_V) : ()
  
  axiom commutative_Option_V_spec: forall a: t_Option_V, b: t_Option_V. op_Option_V a b = op_Option_V b a
  
  type tup2_V_V = { f0'2: t_V; f1'2: t_V }
  
  function index_Mapping_tup2_V_V_V [@inline:trivial] (self: Map.map tup2_V_V t_V) (a: tup2_V_V) : t_V = Map.get self a
  
  meta "rewrite_def" function index_Mapping_tup2_V_V_V
  
  function merge_K (self: t_FMap_K_V) (m: t_FMap_K_V) (f: Map.map tup2_V_V t_V) : t_FMap_K_V
  
  axiom merge_K_spec:
    forall self: t_FMap_K_V, m: t_FMap_K_V, f: Map.map tup2_V_V t_V. forall k: t_K [get_K (merge_K self m f) k]. match { f0'1 = get_K self k;
                                                                                                                         f1'1 = get_K m k } with
          | {f0'1 = None; f1'1 = y} -> get_K (merge_K self m f) k = y
          | {f0'1 = x; f1'1 = None} -> get_K (merge_K self m f) k = x
          | {f0'1 = Some x; f1'1 = Some y} -> get_K (merge_K self m f) k
          = Some (index_Mapping_tup2_V_V_V f { f0'2 = x; f1'2 = y })
          end
  
  predicate index_Mapping_V_bool [@inline:trivial] (self: Map.map t_V bool) (a: t_V) = Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_V_bool
  
  function such_that_V (p: Map.map t_V bool) : t_V
  
  axiom such_that_V_spec: forall p: Map.map t_V bool. (exists x: t_V. index_Mapping_V_bool p x)
      -> index_Mapping_V_bool p (such_that_V p)
  
  function total_op_K (self: t_FMap_K_V) (other: t_FMap_K_V) : t_FMap_K_V =
    merge_K self other (fun (__0: tup2_V_V) -> let {f0'2 = x; f1'2 = y} = __0 in match op_V x y with
      | Some r -> r
      | _ -> such_that_V (fun (__0'0: t_V) -> true)
      end)
  
  axiom total_op_K_spec:
    forall self: t_FMap_K_V, other: t_FMap_K_V. (forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2)
      -> (forall k: t_K. Some'2 (get_K (total_op_K self other) k) = op_Option_V (get_K self k) (get_K other k))
  
  function op_FMap_K_V (self: t_FMap_K_V) (other: t_FMap_K_V) : t_Option_FMap_K_V =
    if forall k: t_K. op_Option_V (get_K self k) (get_K other k) <> None'2 then
      Some'0 (total_op_K self other)
    else
      None'0
  
  
  function commutative_FMap_K_V (a: t_FMap_K_V) (b: t_FMap_K_V) : () = ()
  
  axiom commutative_FMap_K_V_spec: forall a: t_FMap_K_V, b: t_FMap_K_V. op_FMap_K_V a b = op_FMap_K_V b a
  
  function op_Option_FMap_K_V (self: t_Option_FMap_K_V) (other: t_Option_FMap_K_V) : t_Option_Option_FMap_K_V =
    match { f0'0 = self; f1'0 = other } with
      | {f0'0 = None'0} -> Some'1 other
      | {f1'0 = None'0} -> Some'1 self
      | {f0'0 = Some'0 x; f1'0 = Some'0 y} -> map_Option_FMap_K_V (op_FMap_K_V x y) (fun (z: t_FMap_K_V) -> Some'0 z)
      end
  
  function commutative_Option_FMap_K_V (a: t_Option_FMap_K_V) (b: t_Option_FMap_K_V) : ()
  
  axiom commutative_Option_FMap_K_V_spec: forall a: t_Option_FMap_K_V, b: t_Option_FMap_K_V. op_Option_FMap_K_V a b
      = op_Option_FMap_K_V b a
  
  type tup2_FMap_K_V_FMap_K_V = { f0'3: t_FMap_K_V; f1'3: t_FMap_K_V }
  
  function len_K (self: t_FMap_K_V) : int
  
  axiom len_K_spec: forall self: t_FMap_K_V. len_K self >= 0
  
  predicate contains_K [@inline:trivial] (self: t_FMap_K_V) (k: t_K) = get_K self k <> None
  
  meta "rewrite_def" predicate contains_K
  
  function insert_K (self: t_FMap_K_V) (k: t_K) (v: t_V) : t_FMap_K_V
  
  axiom insert_K_spec: forall self: t_FMap_K_V, k: t_K, v: t_V. to_mapping_K (insert_K self k v)
      = Map.set (to_mapping_K self) k (Some v)
  
  axiom insert_K_spec'0: forall self: t_FMap_K_V, k: t_K, v: t_V. len_K (insert_K self k v)
      = (if contains_K self k then len_K self else len_K self + 1)
  
  function update_FMapInsertLocalUpdate_K_V [@inline:trivial] (self: t_FMapInsertLocalUpdate_K_V) (from_auth: t_FMap_K_V) (from_frag: t_FMap_K_V) : tup2_FMap_K_V_FMap_K_V
   = { f0'3 = insert_K from_auth self.f0 self.f1; f1'3 = insert_K from_frag self.f0 self.f1 }
  
  meta "rewrite_def" function update_FMapInsertLocalUpdate_K_V
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_FMapInsertLocalUpdate_K_V. forall from_auth: t_FMap_K_V. forall from_frag: t_FMap_K_V. forall frame: t_Option_FMap_K_V. premise_FMapInsertLocalUpdate_K_V self from_auth from_frag
              /\ op_Option_FMap_K_V (Some'0 from_frag) frame = Some'1 (Some'0 from_auth)
            -> premise_FMapInsertLocalUpdate_K_V self from_auth from_frag
            /\ op_Option_FMap_K_V (Some'0 from_frag) frame = Some'1 (Some'0 from_auth)
            /\ (forall result: (). (let {f0'3 = to_auth; f1'3 = to_frag} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some'0 to_frag) frame
                = Some'1 (Some'0 to_auth))
              -> (let {f0'3 = to_auth; f1'3 = to_frag} = update_FMapInsertLocalUpdate_K_V self from_auth from_frag in op_Option_FMap_K_V (Some'0 to_frag) frame
              = Some'1 (Some'0 to_auth)))
end
module M_logic__ra__int__impl_LocalUpdate_for_Int__frame_preserving__refines (* <logic::int::Int as logic::ra::update::LocalUpdate<logic::int::Int>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  predicate premise_Int [@inline:trivial] (self: int) (_2: int) (_3: int) = true
  
  meta "rewrite_def" predicate premise_Int
  
  type t_Option_Int = None | Some int
  
  type t_Option_Option_Int = None'0 | Some'0 t_Option_Int
  
  type tup2_Option_Int_Option_Int = { f0: t_Option_Int; f1: t_Option_Int }
  
  function map_Option_Int (self: t_Option_Int) (f: Map.map int t_Option_Int) : t_Option_Option_Int = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_Int [@inline:trivial] (self: int) (other: int) : t_Option_Int = Some (self + other)
  
  meta "rewrite_def" function op_Int
  
  function commutative_Int (a: int) (b: int) : () = ()
  
  axiom commutative_Int_spec: forall a: int, b: int. op_Int a b = op_Int b a
  
  function op_Option_Int (self: t_Option_Int) (other: t_Option_Int) : t_Option_Option_Int = match { f0 = self;
                                                                                                    f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_Int (op_Int x y) (fun (z: int) -> Some z)
      end
  
  function commutative_Option_Int (a: t_Option_Int) (b: t_Option_Int) : ()
  
  axiom commutative_Option_Int_spec: forall a: t_Option_Int, b: t_Option_Int. op_Option_Int a b = op_Option_Int b a
  
  type tup2_Int_Int = { f0'0: int; f1'0: int }
  
  function update_Int [@inline:trivial] (self: int) (from_auth: int) (from_frag: int) : tup2_Int_Int =
    { f0'0 = from_auth + self; f1'0 = from_frag + self }
  
  meta "rewrite_def" function update_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: int. forall from_auth: int. forall from_frag: int. forall frame: t_Option_Int. premise_Int self from_auth from_frag
              /\ op_Option_Int (Some from_frag) frame = Some'0 (Some from_auth)
            -> premise_Int self from_auth from_frag
            /\ op_Option_Int (Some from_frag) frame = Some'0 (Some from_auth)
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update_Int self from_auth from_frag in op_Option_Int (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_Int self from_auth from_frag in op_Option_Int (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__option__impl_LocalUpdate_for_OptionLocalUpdate_U__frame_preserving__refines (* <logic::ra::option::OptionLocalUpdate<U> as logic::ra::update::LocalUpdate<std::option::Option<R>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_OptionLocalUpdate_U = { f0: t_U }
  
  type t_R
  
  type t_Option_R = None | Some t_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  predicate premise_U (self: t_U) (from_auth: t_R) (from_frag: t_R)
  
  predicate premise_OptionLocalUpdate_U [@inline:trivial] (self: t_OptionLocalUpdate_U) (from_auth: t_Option_R) (from_frag: t_Option_R) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Some from_auth'0; f1'0 = Some from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | _ -> false
      end
  
  meta "rewrite_def" predicate premise_OptionLocalUpdate_U
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type t_Option_Option_Option_R = None'1 | Some'1 t_Option_Option_R
  
  type tup2_Option_Option_R_Option_Option_R = { f0'1: t_Option_Option_R; f1'1: t_Option_Option_R }
  
  function map_Option_Option_R (self: t_Option_Option_R) (f: Map.map t_Option_R t_Option_Option_R) : t_Option_Option_Option_R
   = match self with
      | None'0 -> None'1
      | Some'0 x -> Some'1 (Map.get f x)
      end
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : () = ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  function op_Option_Option_R (self: t_Option_Option_R) (other: t_Option_Option_R) : t_Option_Option_Option_R =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None'0} -> Some'1 other
      | {f1'1 = None'0} -> Some'1 self
      | {f0'1 = Some'0 x; f1'1 = Some'0 y} -> map_Option_Option_R (op_Option_R x y) (fun (z: t_Option_R) -> Some'0 z)
      end
  
  function commutative_Option_Option_R (a: t_Option_Option_R) (b: t_Option_Option_R) : () = ()
  
  axiom commutative_Option_Option_R_spec: forall a: t_Option_Option_R, b: t_Option_Option_R. op_Option_Option_R a b
      = op_Option_Option_R b a
  
  type tup2_R_R = { f0'2: t_R; f1'2: t_R }
  
  function update_U (self: t_U) (from_auth: t_R) (from_frag: t_R) : tup2_R_R
  
  function update_OptionLocalUpdate_U [@inline:trivial] (self: t_OptionLocalUpdate_U) (from_auth: t_Option_R) (from_frag: t_Option_R) : tup2_Option_R_Option_R
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Some from_auth'0; f1'0 = Some from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Some to_auth;
                                                                                                                                                   f1'0 = Some to_frag }
      | _ -> { f0'0 = None; f1'0 = None }
      end
  
  meta "rewrite_def" function update_OptionLocalUpdate_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_OptionLocalUpdate_U. forall from_auth: t_Option_R. forall from_frag: t_Option_R. forall frame: t_Option_Option_R. premise_OptionLocalUpdate_U self from_auth from_frag
              /\ op_Option_Option_R (Some'0 from_frag) frame = Some'1 (Some'0 from_auth)
            -> premise_OptionLocalUpdate_U self from_auth from_frag
            /\ op_Option_Option_R (Some'0 from_frag) frame = Some'1 (Some'0 from_auth)
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update_OptionLocalUpdate_U self from_auth from_frag in op_Option_Option_R (Some'0 to_frag) frame
                = Some'1 (Some'0 to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_OptionLocalUpdate_U self from_auth from_frag in op_Option_Option_R (Some'0 to_frag) frame
              = Some'1 (Some'0 to_auth)))
end
module M_logic__ra__prod__impl_LocalUpdate_for_tup2_U1_U2__frame_preserving__refines (* <(U1, U2) as logic::ra::update::LocalUpdate<(R1, R2)>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U1
  
  type t_U2
  
  type tup2_U1_U2 = { f0: t_U1; f1: t_U2 }
  
  type t_R1
  
  type t_R2
  
  type tup2_R1_R2 = { f0'0: t_R1; f1'0: t_R2 }
  
  predicate premise_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) =
    premise_U1 self.f0 from_auth.f0'0 from_frag.f0'0 /\ premise_U2 self.f1 from_auth.f1'0 from_frag.f1'0
  
  meta "rewrite_def" predicate premise_tup2_U1_U2
  
  type t_Option_tup2_R1_R2 = None | Some tup2_R1_R2
  
  type t_Option_Option_tup2_R1_R2 = None'0 | Some'0 t_Option_tup2_R1_R2
  
  type tup2_Option_tup2_R1_R2_Option_tup2_R1_R2 = { f0'1: t_Option_tup2_R1_R2; f1'1: t_Option_tup2_R1_R2 }
  
  function map_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (f: Map.map tup2_R1_R2 t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  type tup2_Option_R1_Option_R2 = { f0'2: t_Option_R1; f1'2: t_Option_R2 }
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'1 ab
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'1
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = None'1
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'2 ab
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'2
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = None'2
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_tup2_R1_R2 (self: tup2_R1_R2) (other: tup2_R1_R2) : t_Option_tup2_R1_R2 =
    match { f0'2 = op_R1 self.f0'0 other.f0'0; f1'2 = op_R2 self.f1'0 other.f1'0 } with
      | {f0'2 = Some'1 r1; f1'2 = Some'2 r2} -> Some { f0'0 = r1; f1'0 = r2 }
      | _ -> None
      end
  
  function commutative_tup2_R1_R2 (a: tup2_R1_R2) (b: tup2_R1_R2) : () = ()
  
  axiom commutative_tup2_R1_R2_spec: forall a: tup2_R1_R2, b: tup2_R1_R2. op_tup2_R1_R2 a b = op_tup2_R1_R2 b a
  
  function op_Option_tup2_R1_R2 (self: t_Option_tup2_R1_R2) (other: t_Option_tup2_R1_R2) : t_Option_Option_tup2_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_tup2_R1_R2 (op_tup2_R1_R2 x y) (fun (z: tup2_R1_R2) -> Some z)
      end
  
  function commutative_Option_tup2_R1_R2 (a: t_Option_tup2_R1_R2) (b: t_Option_tup2_R1_R2) : ()
  
  axiom commutative_Option_tup2_R1_R2_spec:
    forall a: t_Option_tup2_R1_R2, b: t_Option_tup2_R1_R2. op_Option_tup2_R1_R2 a b = op_Option_tup2_R1_R2 b a
  
  type tup2_tup2_R1_R2_tup2_R1_R2 = { f0'3: tup2_R1_R2; f1'3: tup2_R1_R2 }
  
  type tup2_R1_R1 = { f0'4: t_R1; f1'4: t_R1 }
  
  function update_U1 (self: t_U1) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  type tup2_R2_R2 = { f0'5: t_R2; f1'5: t_R2 }
  
  function update_U2 (self: t_U2) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  function update_tup2_U1_U2 [@inline:trivial] (self: tup2_U1_U2) (from_auth: tup2_R1_R2) (from_frag: tup2_R1_R2) : tup2_tup2_R1_R2_tup2_R1_R2
   =
    let {f0'4 = to_auth0; f1'4 = to_frag0} = update_U1 self.f0 from_auth.f0'0 from_frag.f0'0 in let {f0'5 = to_auth1; f1'5 = to_frag1} = update_U2 self.f1 from_auth.f1'0 from_frag.f1'0 in { f0'3 = { f0'0 = to_auth0;
                                                                                                                                                                                                       f1'0 = to_auth1 };
                                                                                                                                                                                              f1'3 = { f0'0 = to_frag0;
                                                                                                                                                                                                       f1'0 = to_frag1 } }
  
  meta "rewrite_def" function update_tup2_U1_U2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: tup2_U1_U2. forall from_auth: tup2_R1_R2. forall from_frag: tup2_R1_R2. forall frame: t_Option_tup2_R1_R2. premise_tup2_U1_U2 self from_auth from_frag
              /\ op_Option_tup2_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            -> premise_tup2_U1_U2 self from_auth from_frag
            /\ op_Option_tup2_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            /\ (forall result: (). (let {f0'3 = to_auth; f1'3 = to_frag} = update_tup2_U1_U2 self from_auth from_frag in op_Option_tup2_R1_R2 (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'3 = to_auth; f1'3 = to_frag} = update_tup2_U1_U2 self from_auth from_frag in op_Option_tup2_R1_R2 (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateL_U__frame_preserving__refines (* <logic::ra::sum::SumLocalUpdateL<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateL_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  predicate premise_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1)
  
  predicate premise_SumLocalUpdateL_U [@inline:trivial] (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | {f0'0 = Right _; f1'0 = Right _} -> false
      | _ -> true
      end
  
  meta "rewrite_def" predicate premise_SumLocalUpdateL_U
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0'1: t_Option_Sum_R1_R2; f1'1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'1 ab
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'1
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = None'1
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'2 ab
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'2
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = None'2
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type tup2_R1_R1 = { f0'2: t_R1; f1'2: t_R1 }
  
  function update_U (self: t_U) (from_auth: t_R1) (from_frag: t_R1) : tup2_R1_R1
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateL_U [@inline:trivial] (self: t_SumLocalUpdateL_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Left from_auth'0; f1'0 = Left from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Left to_auth;
                                                                                                                                                   f1'0 = Left to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  meta "rewrite_def" function update_SumLocalUpdateL_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumLocalUpdateL_U. forall from_auth: t_Sum_R1_R2. forall from_frag: t_Sum_R1_R2. forall frame: t_Option_Sum_R1_R2. premise_SumLocalUpdateL_U self from_auth from_frag
              /\ op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            -> premise_SumLocalUpdateL_U self from_auth from_frag
            /\ op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateL_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__sum__impl_LocalUpdate_for_SumLocalUpdateR_U__frame_preserving__refines (* <logic::ra::sum::SumLocalUpdateR<U> as logic::ra::update::LocalUpdate<logic::ra::sum::Sum<R1, R2>>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_U
  
  type t_SumLocalUpdateR_U = { f0: t_U }
  
  type t_R1
  
  type t_R2
  
  type t_Sum_R1_R2 = Left t_R1 | Right t_R2
  
  type tup2_Sum_R1_R2_Sum_R1_R2 = { f0'0: t_Sum_R1_R2; f1'0: t_Sum_R1_R2 }
  
  predicate premise_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2)
  
  predicate premise_SumLocalUpdateR_U [@inline:trivial] (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) =
    match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> premise_U self.f0 from_auth'0 from_frag'0
      | {f0'0 = Left _; f1'0 = Left _} -> false
      | _ -> true
      end
  
  meta "rewrite_def" predicate premise_SumLocalUpdateR_U
  
  type t_Option_Sum_R1_R2 = None | Some t_Sum_R1_R2
  
  type t_Option_Option_Sum_R1_R2 = None'0 | Some'0 t_Option_Sum_R1_R2
  
  type tup2_Option_Sum_R1_R2_Option_Sum_R1_R2 = { f0'1: t_Option_Sum_R1_R2; f1'1: t_Option_Sum_R1_R2 }
  
  function map_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (f: Map.map t_Sum_R1_R2 t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2
   = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  type t_Option_R1 = None'1 | Some'1 t_R1
  
  function map_Option_R1 (self: t_Option_R1) (f: Map.map t_R1 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'1 -> None
      | Some'1 x -> Some (Map.get f x)
      end
  
  function op_R1 (self: t_R1) (other: t_R1) : t_Option_R1
  
  function factor_R1 (self: t_R1) (factor: t_R1) : t_Option_R1
  
  axiom factor_R1_spec: forall self: t_R1, factor: t_R1. match factor_R1 self factor with
        | Some'1 c -> op_R1 factor c = Some'1 self
        | None'1 -> forall c: t_R1. op_R1 factor c <> Some'1 self
        end
  
  predicate incl_R1 (self: t_R1) (other: t_R1) = factor_R1 other self <> None'1
  
  function incl_transitive_R1 (a: t_R1) (b: t_R1) (c: t_R1) : ()
  
  axiom incl_transitive_R1_spec: forall a: t_R1, b: t_R1, c: t_R1. incl_R1 a b -> incl_R1 b c -> incl_R1 a c
  
  function associative_some_R1 (a: t_R1) (b: t_R1) (c: t_R1) (ab: t_R1) (bc: t_R1) : ()
  
  axiom associative_some_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, ab: t_R1, bc: t_R1. op_R1 a b = Some'1 ab
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = op_R1 ab c
  
  function associative_none_R1 (a: t_R1) (b: t_R1) (c: t_R1) (bc: t_R1) : ()
  
  axiom associative_none_R1_spec: forall a: t_R1, b: t_R1, c: t_R1, bc: t_R1. op_R1 a b = None'1
      -> op_R1 b c = Some'1 bc -> op_R1 a bc = None'1
  
  function commutative_R1 (a: t_R1) (b: t_R1) : ()
  
  axiom commutative_R1_spec: forall a: t_R1, b: t_R1. op_R1 a b = op_R1 b a
  
  function incl_op_R1 (self: t_R1) (other: t_R1) (comb: t_R1) : ()
  
  axiom incl_op_R1_spec: forall self: t_R1, other: t_R1, comb: t_R1. op_R1 self other = Some'1 comb -> incl_R1 self comb
  
  type t_Option_R2 = None'2 | Some'2 t_R2
  
  function map_Option_R2 (self: t_Option_R2) (f: Map.map t_R2 t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match self with
      | None'2 -> None
      | Some'2 x -> Some (Map.get f x)
      end
  
  function op_R2 (self: t_R2) (other: t_R2) : t_Option_R2
  
  function factor_R2 (self: t_R2) (factor: t_R2) : t_Option_R2
  
  axiom factor_R2_spec: forall self: t_R2, factor: t_R2. match factor_R2 self factor with
        | Some'2 c -> op_R2 factor c = Some'2 self
        | None'2 -> forall c: t_R2. op_R2 factor c <> Some'2 self
        end
  
  predicate incl_R2 (self: t_R2) (other: t_R2) = factor_R2 other self <> None'2
  
  function incl_transitive_R2 (a: t_R2) (b: t_R2) (c: t_R2) : ()
  
  axiom incl_transitive_R2_spec: forall a: t_R2, b: t_R2, c: t_R2. incl_R2 a b -> incl_R2 b c -> incl_R2 a c
  
  function associative_some_R2 (a: t_R2) (b: t_R2) (c: t_R2) (ab: t_R2) (bc: t_R2) : ()
  
  axiom associative_some_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, ab: t_R2, bc: t_R2. op_R2 a b = Some'2 ab
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = op_R2 ab c
  
  function associative_none_R2 (a: t_R2) (b: t_R2) (c: t_R2) (bc: t_R2) : ()
  
  axiom associative_none_R2_spec: forall a: t_R2, b: t_R2, c: t_R2, bc: t_R2. op_R2 a b = None'2
      -> op_R2 b c = Some'2 bc -> op_R2 a bc = None'2
  
  function commutative_R2 (a: t_R2) (b: t_R2) : ()
  
  axiom commutative_R2_spec: forall a: t_R2, b: t_R2. op_R2 a b = op_R2 b a
  
  function incl_op_R2 (self: t_R2) (other: t_R2) (comb: t_R2) : ()
  
  axiom incl_op_R2_spec: forall self: t_R2, other: t_R2, comb: t_R2. op_R2 self other = Some'2 comb -> incl_R2 self comb
  
  function op_Sum_R1_R2 (self: t_Sum_R1_R2) (other: t_Sum_R1_R2) : t_Option_Sum_R1_R2 = match { f0'0 = self;
                                                                                                f1'0 = other } with
      | {f0'0 = Left x; f1'0 = Left y} -> map_Option_R1 (op_R1 x y) (fun (l: t_R1) -> Left l)
      | {f0'0 = Right x; f1'0 = Right y} -> map_Option_R2 (op_R2 x y) (fun (r: t_R2) -> Right r)
      | _ -> None
      end
  
  function commutative_Sum_R1_R2 (a: t_Sum_R1_R2) (b: t_Sum_R1_R2) : () = ()
  
  axiom commutative_Sum_R1_R2_spec: forall a: t_Sum_R1_R2, b: t_Sum_R1_R2. op_Sum_R1_R2 a b = op_Sum_R1_R2 b a
  
  function op_Option_Sum_R1_R2 (self: t_Option_Sum_R1_R2) (other: t_Option_Sum_R1_R2) : t_Option_Option_Sum_R1_R2 =
    match { f0'1 = self; f1'1 = other } with
      | {f0'1 = None} -> Some'0 other
      | {f1'1 = None} -> Some'0 self
      | {f0'1 = Some x; f1'1 = Some y} -> map_Option_Sum_R1_R2 (op_Sum_R1_R2 x y) (fun (z: t_Sum_R1_R2) -> Some z)
      end
  
  function commutative_Option_Sum_R1_R2 (a: t_Option_Sum_R1_R2) (b: t_Option_Sum_R1_R2) : ()
  
  axiom commutative_Option_Sum_R1_R2_spec: forall a: t_Option_Sum_R1_R2, b: t_Option_Sum_R1_R2. op_Option_Sum_R1_R2 a b
      = op_Option_Sum_R1_R2 b a
  
  type tup2_R2_R2 = { f0'2: t_R2; f1'2: t_R2 }
  
  function update_U (self: t_U) (from_auth: t_R2) (from_frag: t_R2) : tup2_R2_R2
  
  predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool [@inline:trivial] (self: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) (a: tup2_Sum_R1_R2_Sum_R1_R2) =
    Map.get self a
  
  meta "rewrite_def" predicate index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool
  
  function such_that_tup2_Sum_R1_R2_Sum_R1_R2 (p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool) : tup2_Sum_R1_R2_Sum_R1_R2
  
  axiom such_that_tup2_Sum_R1_R2_Sum_R1_R2_spec:
    forall p: Map.map tup2_Sum_R1_R2_Sum_R1_R2 bool. (exists x: tup2_Sum_R1_R2_Sum_R1_R2. index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p x)
      -> index_Mapping_tup2_Sum_R1_R2_Sum_R1_R2_bool p (such_that_tup2_Sum_R1_R2_Sum_R1_R2 p)
  
  function update_SumLocalUpdateR_U [@inline:trivial] (self: t_SumLocalUpdateR_U) (from_auth: t_Sum_R1_R2) (from_frag: t_Sum_R1_R2) : tup2_Sum_R1_R2_Sum_R1_R2
   = match { f0'0 = from_auth; f1'0 = from_frag } with
      | {f0'0 = Right from_auth'0; f1'0 = Right from_frag'0} -> let {f0'2 = to_auth; f1'2 = to_frag} = update_U self.f0 from_auth'0 from_frag'0 in { f0'0 = Right to_auth;
                                                                                                                                                     f1'0 = Right to_frag }
      | _ -> such_that_tup2_Sum_R1_R2_Sum_R1_R2 (fun (__0: tup2_Sum_R1_R2_Sum_R1_R2) -> true)
      end
  
  meta "rewrite_def" function update_SumLocalUpdateR_U
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_SumLocalUpdateR_U. forall from_auth: t_Sum_R1_R2. forall from_frag: t_Sum_R1_R2. forall frame: t_Option_Sum_R1_R2. premise_SumLocalUpdateR_U self from_auth from_frag
              /\ op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            -> premise_SumLocalUpdateR_U self from_auth from_frag
            /\ op_Option_Sum_R1_R2 (Some from_frag) frame = Some'0 (Some from_auth)
            /\ (forall result: (). (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_SumLocalUpdateR_U self from_auth from_frag in op_Option_Sum_R1_R2 (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__update__impl_LocalUpdate_for_Snapshot_tup2_R_R__frame_preserving__refines (* <snapshot::Snapshot<(R, R)> as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  type tup2_R_R = { f0: t_R; f1: t_R }
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0'0: t_Option_R; f1'0: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0'0 = self;
                                                                                            f1'0 = other } with
      | {f0'0 = None} -> Some'0 other
      | {f1'0 = None} -> Some'0 self
      | {f0'0 = Some x; f1'0 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  predicate premise_Snapshot_tup2_R_R [@inline:trivial] (self: tup2_R_R) (from_auth: t_R) (from_frag: t_R) =
    forall f: t_Option_R. op_Option_R (Some from_frag) f = Some'0 (Some from_auth)
      -> op_Option_R (Some (self.f1)) f = Some'0 (Some (self.f0))
  
  meta "rewrite_def" predicate premise_Snapshot_tup2_R_R
  
  function update_Snapshot_tup2_R_R [@inline:trivial] (self: tup2_R_R) (_2: t_R) (_3: t_R) : tup2_R_R = self
  
  meta "rewrite_def" function update_Snapshot_tup2_R_R
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: tup2_R_R. forall from_auth: t_R. forall from_frag: t_R. forall frame: t_Option_R. premise_Snapshot_tup2_R_R self from_auth from_frag
              /\ op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
            -> premise_Snapshot_tup2_R_R self from_auth from_frag
            /\ op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
            /\ (forall result: (). (let {f0 = to_auth; f1 = to_frag} = update_Snapshot_tup2_R_R self from_auth from_frag in op_Option_R (Some to_frag) frame
                = Some'0 (Some to_auth))
              -> (let {f0 = to_auth; f1 = to_frag} = update_Snapshot_tup2_R_R self from_auth from_frag in op_Option_R (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__ra__update__impl_LocalUpdate_for_unit__frame_preserving__refines (* <() as logic::ra::update::LocalUpdate<R>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  
  type t_R
  
  predicate premise_unit [@inline:trivial] (self: ()) (_2: t_R) (_3: t_R) = true
  
  meta "rewrite_def" predicate premise_unit
  
  type t_Option_R = None | Some t_R
  
  type t_Option_Option_R = None'0 | Some'0 t_Option_R
  
  type tup2_Option_R_Option_R = { f0: t_Option_R; f1: t_Option_R }
  
  function map_Option_R (self: t_Option_R) (f: Map.map t_R t_Option_R) : t_Option_Option_R = match self with
      | None -> None'0
      | Some x -> Some'0 (Map.get f x)
      end
  
  function op_R (self: t_R) (other: t_R) : t_Option_R
  
  function factor_R (self: t_R) (factor: t_R) : t_Option_R
  
  axiom factor_R_spec: forall self: t_R, factor: t_R. match factor_R self factor with
        | Some c -> op_R factor c = Some self
        | None -> forall c: t_R. op_R factor c <> Some self
        end
  
  predicate incl_R (self: t_R) (other: t_R) = factor_R other self <> None
  
  function incl_transitive_R (a: t_R) (b: t_R) (c: t_R) : ()
  
  axiom incl_transitive_R_spec: forall a: t_R, b: t_R, c: t_R. incl_R a b -> incl_R b c -> incl_R a c
  
  function associative_some_R (a: t_R) (b: t_R) (c: t_R) (ab: t_R) (bc: t_R) : ()
  
  axiom associative_some_R_spec: forall a: t_R, b: t_R, c: t_R, ab: t_R, bc: t_R. op_R a b = Some ab
      -> op_R b c = Some bc -> op_R a bc = op_R ab c
  
  function associative_none_R (a: t_R) (b: t_R) (c: t_R) (bc: t_R) : ()
  
  axiom associative_none_R_spec: forall a: t_R, b: t_R, c: t_R, bc: t_R. op_R a b = None
      -> op_R b c = Some bc -> op_R a bc = None
  
  function commutative_R (a: t_R) (b: t_R) : ()
  
  axiom commutative_R_spec: forall a: t_R, b: t_R. op_R a b = op_R b a
  
  function incl_op_R (self: t_R) (other: t_R) (comb: t_R) : ()
  
  axiom incl_op_R_spec: forall self: t_R, other: t_R, comb: t_R. op_R self other = Some comb -> incl_R self comb
  
  function op_Option_R (self: t_Option_R) (other: t_Option_R) : t_Option_Option_R = match { f0 = self; f1 = other } with
      | {f0 = None} -> Some'0 other
      | {f1 = None} -> Some'0 self
      | {f0 = Some x; f1 = Some y} -> map_Option_R (op_R x y) (fun (z: t_R) -> Some z)
      end
  
  function commutative_Option_R (a: t_Option_R) (b: t_Option_R) : ()
  
  axiom commutative_Option_R_spec: forall a: t_Option_R, b: t_Option_R. op_Option_R a b = op_Option_R b a
  
  type tup2_R_R = { f0'0: t_R; f1'0: t_R }
  
  function update_unit [@inline:trivial] (self: ()) (from_auth: t_R) (from_frag: t_R) : tup2_R_R = { f0'0 = from_auth;
                                                                                                     f1'0 = from_frag }
  
  meta "rewrite_def" function update_unit
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: (). forall from_auth: t_R. forall from_frag: t_R. forall frame: t_Option_R. premise_unit self from_auth from_frag
              /\ op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
            -> op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
            /\ (forall result: (). op_Option_R (Some from_frag) frame = Some'0 (Some from_auth)
              -> (let {f0'0 = to_auth; f1'0 = to_frag} = update_unit self from_auth from_frag in op_Option_R (Some to_frag) frame
              = Some'0 (Some to_auth)))
end
module M_logic__well_founded__impl_WellFounded_for_Int__no_infinite_decreasing_sequence__refines (* <logic::int::Int as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  predicate well_founded_relation_Int [@inline:trivial] (self: int) (other: int) = self >= 0 /\ self > other
  
  meta "rewrite_def" predicate well_founded_relation_Int
  
  function index_Mapping_Int_Int [@inline:trivial] (self: Map.map int int) (a: int) : int = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int int. forall result: int. result >= 0
          /\ not well_founded_relation_Int (index_Mapping_Int_Int s result) (index_Mapping_Int_Int s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_Int (index_Mapping_Int_Int s result) (index_Mapping_Int_Int s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_u8__no_infinite_decreasing_sequence__refines (* <u8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt8
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u8 (self: UInt8.t) (o: UInt8.t) : t_Ordering = if UInt8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom eq_cmp_u8_spec: forall x: UInt8.t, y: UInt8.t. (x = y) = (cmp_log_u8 x y = Equal)
  
  function antisym2_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym2_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Greater -> cmp_log_u8 y x = Less
  
  function antisym1_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom antisym1_u8_spec: forall x: UInt8.t, y: UInt8.t. cmp_log_u8 x y = Less -> cmp_log_u8 y x = Greater
  
  function trans_u8 (x: UInt8.t) (y: UInt8.t) (z: UInt8.t) (o: t_Ordering) : ()
  
  axiom trans_u8_spec: forall x: UInt8.t, y: UInt8.t, z: UInt8.t, o: t_Ordering. cmp_log_u8 x y = o
      -> cmp_log_u8 y z = o -> cmp_log_u8 x z = o
  
  function refl_u8 (x: UInt8.t) : ()
  
  axiom refl_u8_spec: forall x: UInt8.t. cmp_log_u8 x x = Equal
  
  function cmp_gt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_gt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.gt x y = (cmp_log_u8 x y = Greater)
  
  function cmp_ge_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_ge_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.ge x y = (cmp_log_u8 x y <> Less)
  
  function cmp_lt_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_lt_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.lt x y = (cmp_log_u8 x y = Less)
  
  function cmp_le_log_u8 (x: UInt8.t) (y: UInt8.t) : ()
  
  axiom cmp_le_log_u8_spec: forall x: UInt8.t, y: UInt8.t. UInt8.le x y = (cmp_log_u8 x y <> Greater)
  
  predicate well_founded_relation_u8 [@inline:trivial] (self: UInt8.t) (other: UInt8.t) = UInt8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u8
  
  function index_Mapping_Int_u8 [@inline:trivial] (self: Map.map int UInt8.t) (a: int) : UInt8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int UInt8.t. forall result: int. result >= 0
          /\ not well_founded_relation_u8 (index_Mapping_Int_u8 s result) (index_Mapping_Int_u8 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_u8 (index_Mapping_Int_u8 s result) (index_Mapping_Int_u8 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_u16__no_infinite_decreasing_sequence__refines (* <u16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt16
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u16 (self: UInt16.t) (o: UInt16.t) : t_Ordering = if UInt16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom eq_cmp_u16_spec: forall x: UInt16.t, y: UInt16.t. (x = y) = (cmp_log_u16 x y = Equal)
  
  function antisym2_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym2_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Greater -> cmp_log_u16 y x = Less
  
  function antisym1_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom antisym1_u16_spec: forall x: UInt16.t, y: UInt16.t. cmp_log_u16 x y = Less -> cmp_log_u16 y x = Greater
  
  function trans_u16 (x: UInt16.t) (y: UInt16.t) (z: UInt16.t) (o: t_Ordering) : ()
  
  axiom trans_u16_spec: forall x: UInt16.t, y: UInt16.t, z: UInt16.t, o: t_Ordering. cmp_log_u16 x y = o
      -> cmp_log_u16 y z = o -> cmp_log_u16 x z = o
  
  function refl_u16 (x: UInt16.t) : ()
  
  axiom refl_u16_spec: forall x: UInt16.t. cmp_log_u16 x x = Equal
  
  function cmp_gt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_gt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.gt x y = (cmp_log_u16 x y = Greater)
  
  function cmp_ge_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_ge_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.ge x y = (cmp_log_u16 x y <> Less)
  
  function cmp_lt_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_lt_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.lt x y = (cmp_log_u16 x y = Less)
  
  function cmp_le_log_u16 (x: UInt16.t) (y: UInt16.t) : ()
  
  axiom cmp_le_log_u16_spec: forall x: UInt16.t, y: UInt16.t. UInt16.le x y = (cmp_log_u16 x y <> Greater)
  
  predicate well_founded_relation_u16 [@inline:trivial] (self: UInt16.t) (other: UInt16.t) = UInt16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u16
  
  function index_Mapping_Int_u16 [@inline:trivial] (self: Map.map int UInt16.t) (a: int) : UInt16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int UInt16.t. forall result: int. result >= 0
          /\ not well_founded_relation_u16 (index_Mapping_Int_u16 s result) (index_Mapping_Int_u16 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_u16 (index_Mapping_Int_u16 s result) (index_Mapping_Int_u16 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_u32__no_infinite_decreasing_sequence__refines (* <u32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt32
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u32 (self: UInt32.t) (o: UInt32.t) : t_Ordering = if UInt32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom eq_cmp_u32_spec: forall x: UInt32.t, y: UInt32.t. (x = y) = (cmp_log_u32 x y = Equal)
  
  function antisym2_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym2_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Greater -> cmp_log_u32 y x = Less
  
  function antisym1_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom antisym1_u32_spec: forall x: UInt32.t, y: UInt32.t. cmp_log_u32 x y = Less -> cmp_log_u32 y x = Greater
  
  function trans_u32 (x: UInt32.t) (y: UInt32.t) (z: UInt32.t) (o: t_Ordering) : ()
  
  axiom trans_u32_spec: forall x: UInt32.t, y: UInt32.t, z: UInt32.t, o: t_Ordering. cmp_log_u32 x y = o
      -> cmp_log_u32 y z = o -> cmp_log_u32 x z = o
  
  function refl_u32 (x: UInt32.t) : ()
  
  axiom refl_u32_spec: forall x: UInt32.t. cmp_log_u32 x x = Equal
  
  function cmp_gt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_gt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.gt x y = (cmp_log_u32 x y = Greater)
  
  function cmp_ge_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_ge_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.ge x y = (cmp_log_u32 x y <> Less)
  
  function cmp_lt_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_lt_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.lt x y = (cmp_log_u32 x y = Less)
  
  function cmp_le_log_u32 (x: UInt32.t) (y: UInt32.t) : ()
  
  axiom cmp_le_log_u32_spec: forall x: UInt32.t, y: UInt32.t. UInt32.le x y = (cmp_log_u32 x y <> Greater)
  
  predicate well_founded_relation_u32 [@inline:trivial] (self: UInt32.t) (other: UInt32.t) = UInt32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u32
  
  function index_Mapping_Int_u32 [@inline:trivial] (self: Map.map int UInt32.t) (a: int) : UInt32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int UInt32.t. forall result: int. result >= 0
          /\ not well_founded_relation_u32 (index_Mapping_Int_u32 s result) (index_Mapping_Int_u32 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_u32 (index_Mapping_Int_u32 s result) (index_Mapping_Int_u32 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_u64__no_infinite_decreasing_sequence__refines (* <u64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  predicate well_founded_relation_u64 [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u64
  
  function index_Mapping_Int_u64 [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int UInt64.t. forall result: int. result >= 0
          /\ not well_founded_relation_u64 (index_Mapping_Int_u64 s result) (index_Mapping_Int_u64 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_u64 (index_Mapping_Int_u64 s result) (index_Mapping_Int_u64 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_u128__no_infinite_decreasing_sequence__refines (* <u128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt128
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u128 (self: UInt128.t) (o: UInt128.t) : t_Ordering = if UInt128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom eq_cmp_u128_spec: forall x: UInt128.t, y: UInt128.t. (x = y) = (cmp_log_u128 x y = Equal)
  
  function antisym2_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym2_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Greater -> cmp_log_u128 y x = Less
  
  function antisym1_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom antisym1_u128_spec: forall x: UInt128.t, y: UInt128.t. cmp_log_u128 x y = Less -> cmp_log_u128 y x = Greater
  
  function trans_u128 (x: UInt128.t) (y: UInt128.t) (z: UInt128.t) (o: t_Ordering) : ()
  
  axiom trans_u128_spec: forall x: UInt128.t, y: UInt128.t, z: UInt128.t, o: t_Ordering. cmp_log_u128 x y = o
      -> cmp_log_u128 y z = o -> cmp_log_u128 x z = o
  
  function refl_u128 (x: UInt128.t) : ()
  
  axiom refl_u128_spec: forall x: UInt128.t. cmp_log_u128 x x = Equal
  
  function cmp_gt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_gt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.gt x y = (cmp_log_u128 x y = Greater)
  
  function cmp_ge_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_ge_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.ge x y = (cmp_log_u128 x y <> Less)
  
  function cmp_lt_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_lt_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.lt x y = (cmp_log_u128 x y = Less)
  
  function cmp_le_log_u128 (x: UInt128.t) (y: UInt128.t) : ()
  
  axiom cmp_le_log_u128_spec: forall x: UInt128.t, y: UInt128.t. UInt128.le x y = (cmp_log_u128 x y <> Greater)
  
  predicate well_founded_relation_u128 [@inline:trivial] (self: UInt128.t) (other: UInt128.t) = UInt128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_u128
  
  function index_Mapping_Int_u128 [@inline:trivial] (self: Map.map int UInt128.t) (a: int) : UInt128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_u128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int UInt128.t. forall result: int. result >= 0
          /\ not well_founded_relation_u128 (index_Mapping_Int_u128 s result) (index_Mapping_Int_u128 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_u128 (index_Mapping_Int_u128 s result) (index_Mapping_Int_u128 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_usize__no_infinite_decreasing_sequence__refines (* <usize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_usize (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_usize_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_usize x y = Equal)
  
  function antisym2_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Greater -> cmp_log_usize y x = Less
  
  function antisym1_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_usize_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_usize x y = Less -> cmp_log_usize y x = Greater
  
  function trans_usize (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_usize_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_usize x y = o
      -> cmp_log_usize y z = o -> cmp_log_usize x z = o
  
  function refl_usize (x: UInt64.t) : ()
  
  axiom refl_usize_spec: forall x: UInt64.t. cmp_log_usize x x = Equal
  
  function cmp_gt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_usize x y = Greater)
  
  function cmp_ge_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_usize x y <> Less)
  
  function cmp_lt_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_usize x y = Less)
  
  function cmp_le_log_usize (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_usize_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_usize x y <> Greater)
  
  predicate well_founded_relation_usize [@inline:trivial] (self: UInt64.t) (other: UInt64.t) = UInt64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_usize
  
  function index_Mapping_Int_usize [@inline:trivial] (self: Map.map int UInt64.t) (a: int) : UInt64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_usize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int UInt64.t. forall result: int. result >= 0
          /\ not well_founded_relation_usize (index_Mapping_Int_usize s result) (index_Mapping_Int_usize s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_usize (index_Mapping_Int_usize s result) (index_Mapping_Int_usize s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_i8__no_infinite_decreasing_sequence__refines (* <i8 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int8
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i8 (self: Int8.t) (o: Int8.t) : t_Ordering = if Int8.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom eq_cmp_i8_spec: forall x: Int8.t, y: Int8.t. (x = y) = (cmp_log_i8 x y = Equal)
  
  function antisym2_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym2_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Greater -> cmp_log_i8 y x = Less
  
  function antisym1_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom antisym1_i8_spec: forall x: Int8.t, y: Int8.t. cmp_log_i8 x y = Less -> cmp_log_i8 y x = Greater
  
  function trans_i8 (x: Int8.t) (y: Int8.t) (z: Int8.t) (o: t_Ordering) : ()
  
  axiom trans_i8_spec: forall x: Int8.t, y: Int8.t, z: Int8.t, o: t_Ordering. cmp_log_i8 x y = o
      -> cmp_log_i8 y z = o -> cmp_log_i8 x z = o
  
  function refl_i8 (x: Int8.t) : ()
  
  axiom refl_i8_spec: forall x: Int8.t. cmp_log_i8 x x = Equal
  
  function cmp_gt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_gt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.gt x y = (cmp_log_i8 x y = Greater)
  
  function cmp_ge_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_ge_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.ge x y = (cmp_log_i8 x y <> Less)
  
  function cmp_lt_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_lt_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.lt x y = (cmp_log_i8 x y = Less)
  
  function cmp_le_log_i8 (x: Int8.t) (y: Int8.t) : ()
  
  axiom cmp_le_log_i8_spec: forall x: Int8.t, y: Int8.t. Int8.le x y = (cmp_log_i8 x y <> Greater)
  
  predicate well_founded_relation_i8 [@inline:trivial] (self: Int8.t) (other: Int8.t) = Int8.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i8
  
  function index_Mapping_Int_i8 [@inline:trivial] (self: Map.map int Int8.t) (a: int) : Int8.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i8
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int Int8.t. forall result: int. result >= 0
          /\ not well_founded_relation_i8 (index_Mapping_Int_i8 s result) (index_Mapping_Int_i8 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_i8 (index_Mapping_Int_i8 s result) (index_Mapping_Int_i8 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_i16__no_infinite_decreasing_sequence__refines (* <i16 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int16
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i16 (self: Int16.t) (o: Int16.t) : t_Ordering = if Int16.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom eq_cmp_i16_spec: forall x: Int16.t, y: Int16.t. (x = y) = (cmp_log_i16 x y = Equal)
  
  function antisym2_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym2_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Greater -> cmp_log_i16 y x = Less
  
  function antisym1_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom antisym1_i16_spec: forall x: Int16.t, y: Int16.t. cmp_log_i16 x y = Less -> cmp_log_i16 y x = Greater
  
  function trans_i16 (x: Int16.t) (y: Int16.t) (z: Int16.t) (o: t_Ordering) : ()
  
  axiom trans_i16_spec: forall x: Int16.t, y: Int16.t, z: Int16.t, o: t_Ordering. cmp_log_i16 x y = o
      -> cmp_log_i16 y z = o -> cmp_log_i16 x z = o
  
  function refl_i16 (x: Int16.t) : ()
  
  axiom refl_i16_spec: forall x: Int16.t. cmp_log_i16 x x = Equal
  
  function cmp_gt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_gt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.gt x y = (cmp_log_i16 x y = Greater)
  
  function cmp_ge_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_ge_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.ge x y = (cmp_log_i16 x y <> Less)
  
  function cmp_lt_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_lt_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.lt x y = (cmp_log_i16 x y = Less)
  
  function cmp_le_log_i16 (x: Int16.t) (y: Int16.t) : ()
  
  axiom cmp_le_log_i16_spec: forall x: Int16.t, y: Int16.t. Int16.le x y = (cmp_log_i16 x y <> Greater)
  
  predicate well_founded_relation_i16 [@inline:trivial] (self: Int16.t) (other: Int16.t) = Int16.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i16
  
  function index_Mapping_Int_i16 [@inline:trivial] (self: Map.map int Int16.t) (a: int) : Int16.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i16
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int Int16.t. forall result: int. result >= 0
          /\ not well_founded_relation_i16 (index_Mapping_Int_i16 s result) (index_Mapping_Int_i16 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_i16 (index_Mapping_Int_i16 s result) (index_Mapping_Int_i16 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_i32__no_infinite_decreasing_sequence__refines (* <i32 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int32
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i32 (self: Int32.t) (o: Int32.t) : t_Ordering = if Int32.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom eq_cmp_i32_spec: forall x: Int32.t, y: Int32.t. (x = y) = (cmp_log_i32 x y = Equal)
  
  function antisym2_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym2_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Greater -> cmp_log_i32 y x = Less
  
  function antisym1_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom antisym1_i32_spec: forall x: Int32.t, y: Int32.t. cmp_log_i32 x y = Less -> cmp_log_i32 y x = Greater
  
  function trans_i32 (x: Int32.t) (y: Int32.t) (z: Int32.t) (o: t_Ordering) : ()
  
  axiom trans_i32_spec: forall x: Int32.t, y: Int32.t, z: Int32.t, o: t_Ordering. cmp_log_i32 x y = o
      -> cmp_log_i32 y z = o -> cmp_log_i32 x z = o
  
  function refl_i32 (x: Int32.t) : ()
  
  axiom refl_i32_spec: forall x: Int32.t. cmp_log_i32 x x = Equal
  
  function cmp_gt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_gt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.gt x y = (cmp_log_i32 x y = Greater)
  
  function cmp_ge_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_ge_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.ge x y = (cmp_log_i32 x y <> Less)
  
  function cmp_lt_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_lt_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.lt x y = (cmp_log_i32 x y = Less)
  
  function cmp_le_log_i32 (x: Int32.t) (y: Int32.t) : ()
  
  axiom cmp_le_log_i32_spec: forall x: Int32.t, y: Int32.t. Int32.le x y = (cmp_log_i32 x y <> Greater)
  
  predicate well_founded_relation_i32 [@inline:trivial] (self: Int32.t) (other: Int32.t) = Int32.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i32
  
  function index_Mapping_Int_i32 [@inline:trivial] (self: Map.map int Int32.t) (a: int) : Int32.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i32
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int Int32.t. forall result: int. result >= 0
          /\ not well_founded_relation_i32 (index_Mapping_Int_i32 s result) (index_Mapping_Int_i32 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_i32 (index_Mapping_Int_i32 s result) (index_Mapping_Int_i32 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_i64__no_infinite_decreasing_sequence__refines (* <i64 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i64 (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_i64_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_i64 x y = Equal)
  
  function antisym2_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Greater -> cmp_log_i64 y x = Less
  
  function antisym1_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_i64_spec: forall x: Int64.t, y: Int64.t. cmp_log_i64 x y = Less -> cmp_log_i64 y x = Greater
  
  function trans_i64 (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_i64_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_i64 x y = o
      -> cmp_log_i64 y z = o -> cmp_log_i64 x z = o
  
  function refl_i64 (x: Int64.t) : ()
  
  axiom refl_i64_spec: forall x: Int64.t. cmp_log_i64 x x = Equal
  
  function cmp_gt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_i64 x y = Greater)
  
  function cmp_ge_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_i64 x y <> Less)
  
  function cmp_lt_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_i64 x y = Less)
  
  function cmp_le_log_i64 (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_i64_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_i64 x y <> Greater)
  
  predicate well_founded_relation_i64 [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i64
  
  function index_Mapping_Int_i64 [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i64
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int Int64.t. forall result: int. result >= 0
          /\ not well_founded_relation_i64 (index_Mapping_Int_i64 s result) (index_Mapping_Int_i64 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_i64 (index_Mapping_Int_i64 s result) (index_Mapping_Int_i64 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_i128__no_infinite_decreasing_sequence__refines (* <i128 as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int128
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_i128 (self: Int128.t) (o: Int128.t) : t_Ordering = if Int128.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom eq_cmp_i128_spec: forall x: Int128.t, y: Int128.t. (x = y) = (cmp_log_i128 x y = Equal)
  
  function antisym2_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym2_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Greater -> cmp_log_i128 y x = Less
  
  function antisym1_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom antisym1_i128_spec: forall x: Int128.t, y: Int128.t. cmp_log_i128 x y = Less -> cmp_log_i128 y x = Greater
  
  function trans_i128 (x: Int128.t) (y: Int128.t) (z: Int128.t) (o: t_Ordering) : ()
  
  axiom trans_i128_spec: forall x: Int128.t, y: Int128.t, z: Int128.t, o: t_Ordering. cmp_log_i128 x y = o
      -> cmp_log_i128 y z = o -> cmp_log_i128 x z = o
  
  function refl_i128 (x: Int128.t) : ()
  
  axiom refl_i128_spec: forall x: Int128.t. cmp_log_i128 x x = Equal
  
  function cmp_gt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_gt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.gt x y = (cmp_log_i128 x y = Greater)
  
  function cmp_ge_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_ge_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.ge x y = (cmp_log_i128 x y <> Less)
  
  function cmp_lt_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_lt_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.lt x y = (cmp_log_i128 x y = Less)
  
  function cmp_le_log_i128 (x: Int128.t) (y: Int128.t) : ()
  
  axiom cmp_le_log_i128_spec: forall x: Int128.t, y: Int128.t. Int128.le x y = (cmp_log_i128 x y <> Greater)
  
  predicate well_founded_relation_i128 [@inline:trivial] (self: Int128.t) (other: Int128.t) = Int128.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_i128
  
  function index_Mapping_Int_i128 [@inline:trivial] (self: Map.map int Int128.t) (a: int) : Int128.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_i128
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int Int128.t. forall result: int. result >= 0
          /\ not well_founded_relation_i128 (index_Mapping_Int_i128 s result) (index_Mapping_Int_i128 s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_i128 (index_Mapping_Int_i128 s result) (index_Mapping_Int_i128 s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_isize__no_infinite_decreasing_sequence__refines (* <isize as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.Int64
  use map.Map
  use int.Int
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_isize (self: Int64.t) (o: Int64.t) : t_Ordering = if Int64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom eq_cmp_isize_spec: forall x: Int64.t, y: Int64.t. (x = y) = (cmp_log_isize x y = Equal)
  
  function antisym2_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym2_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Greater -> cmp_log_isize y x = Less
  
  function antisym1_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom antisym1_isize_spec: forall x: Int64.t, y: Int64.t. cmp_log_isize x y = Less -> cmp_log_isize y x = Greater
  
  function trans_isize (x: Int64.t) (y: Int64.t) (z: Int64.t) (o: t_Ordering) : ()
  
  axiom trans_isize_spec: forall x: Int64.t, y: Int64.t, z: Int64.t, o: t_Ordering. cmp_log_isize x y = o
      -> cmp_log_isize y z = o -> cmp_log_isize x z = o
  
  function refl_isize (x: Int64.t) : ()
  
  axiom refl_isize_spec: forall x: Int64.t. cmp_log_isize x x = Equal
  
  function cmp_gt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_gt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.gt x y = (cmp_log_isize x y = Greater)
  
  function cmp_ge_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_ge_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.ge x y = (cmp_log_isize x y <> Less)
  
  function cmp_lt_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_lt_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.lt x y = (cmp_log_isize x y = Less)
  
  function cmp_le_log_isize (x: Int64.t) (y: Int64.t) : ()
  
  axiom cmp_le_log_isize_spec: forall x: Int64.t, y: Int64.t. Int64.le x y = (cmp_log_isize x y <> Greater)
  
  predicate well_founded_relation_isize [@inline:trivial] (self: Int64.t) (other: Int64.t) = Int64.gt self other
  
  meta "rewrite_def" predicate well_founded_relation_isize
  
  function index_Mapping_Int_isize [@inline:trivial] (self: Map.map int Int64.t) (a: int) : Int64.t = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_isize
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int Int64.t. forall result: int. result >= 0
          /\ not well_founded_relation_isize (index_Mapping_Int_isize s result) (index_Mapping_Int_isize s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_isize (index_Mapping_Int_isize s result) (index_Mapping_Int_isize s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_ref_T__no_infinite_decreasing_sequence__refines (* <&T as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_ref_T [@inline:trivial] (self: t_T) (other: t_T) = well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_ref_T
  
  function index_Mapping_Int_ref_T [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_ref_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int t_T. forall result: int. result >= 0
          /\ not well_founded_relation_ref_T (index_Mapping_Int_ref_T s result) (index_Mapping_Int_ref_T s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_ref_T (index_Mapping_Int_ref_T s result) (index_Mapping_Int_ref_T s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_Box_T_Global__no_infinite_decreasing_sequence__refines (* <std::boxed::Box<T> as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T
  
  predicate well_founded_relation_T (self: t_T) (other: t_T)
  
  predicate well_founded_relation_Box_T_Global [@inline:trivial] (self: t_T) (other: t_T) =
    well_founded_relation_T self other
  
  meta "rewrite_def" predicate well_founded_relation_Box_T_Global
  
  function index_Mapping_Int_Box_T_Global [@inline:trivial] (self: Map.map int t_T) (a: int) : t_T = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_Box_T_Global
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int t_T. forall result: int. result >= 0
          /\ not well_founded_relation_Box_T_Global (index_Mapping_Int_Box_T_Global s result) (index_Mapping_Int_Box_T_Global s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_Box_T_Global (index_Mapping_Int_Box_T_Global s result) (index_Mapping_Int_Box_T_Global s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_unit__no_infinite_decreasing_sequence__refines (* <() as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  predicate well_founded_relation_unit [@inline:trivial] (self: ()) (_2: ()) = false
  
  meta "rewrite_def" predicate well_founded_relation_unit
  
  function index_Mapping_Int_unit [@inline:trivial] (self: Map.map int ()) (a: int) : () = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_unit
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int (). forall result: int. result >= 0
          /\ not well_founded_relation_unit (index_Mapping_Int_unit s result) (index_Mapping_Int_unit s (result + 1))
        -> result >= 0
        /\ not well_founded_relation_unit (index_Mapping_Int_unit s result) (index_Mapping_Int_unit s (result + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup8_T0_T1_T2_T3_T4_T5_T6_T7__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5, T6, T7) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type t_T7
  
  type tup8_T0_T1_T2_T3_T4_T5_T6_T7 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6; f7: t_T7 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_T7 (self: t_T7) (other: t_T7)
  
  predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: tup8_T0_T1_T2_T3_T4_T5_T6_T7) (other: tup8_T0_T1_T2_T3_T4_T5_T6_T7) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2
      /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3
    /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ self.f6 = other.f6 /\ well_founded_relation_T7 self.f7 other.f7
  
  meta "rewrite_def" predicate well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 [@inline:trivial] (self: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7) (a: int) : tup8_T0_T1_T2_T3_T4_T5_T6_T7
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int tup8_T0_T1_T2_T3_T4_T5_T6_T7. forall result: int. result >= 0
          /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup8_T0_T1_T2_T3_T4_T5_T6_T7 (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s result) (index_Mapping_Int_tup8_T0_T1_T2_T3_T4_T5_T6_T7 s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup7_T0_T1_T2_T3_T4_T5_T6__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5, T6) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type t_T6
  
  type tup7_T0_T1_T2_T3_T4_T5_T6 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5; f6: t_T6 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_T6 (self: t_T6) (other: t_T6)
  
  predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: tup7_T0_T1_T2_T3_T4_T5_T6) (other: tup7_T0_T1_T2_T3_T4_T5_T6) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1
      /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2
    /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ self.f5 = other.f5 /\ well_founded_relation_T6 self.f6 other.f6
  
  meta "rewrite_def" predicate well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6
  
  function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 [@inline:trivial] (self: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6) (a: int) : tup7_T0_T1_T2_T3_T4_T5_T6
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int tup7_T0_T1_T2_T3_T4_T5_T6. forall result: int. result >= 0
          /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup7_T0_T1_T2_T3_T4_T5_T6 (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s result) (index_Mapping_Int_tup7_T0_T1_T2_T3_T4_T5_T6 s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup6_T0_T1_T2_T3_T4_T5__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4, T5) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type t_T5
  
  type tup6_T0_T1_T2_T3_T4_T5 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4; f5: t_T5 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_T5 (self: t_T5) (other: t_T5)
  
  predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: tup6_T0_T1_T2_T3_T4_T5) (other: tup6_T0_T1_T2_T3_T4_T5) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
      /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1
    /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ self.f4 = other.f4 /\ well_founded_relation_T5 self.f5 other.f5
  
  meta "rewrite_def" predicate well_founded_relation_tup6_T0_T1_T2_T3_T4_T5
  
  function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 [@inline:trivial] (self: Map.map int tup6_T0_T1_T2_T3_T4_T5) (a: int) : tup6_T0_T1_T2_T3_T4_T5
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int tup6_T0_T1_T2_T3_T4_T5. forall result: int. result >= 0
          /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup6_T0_T1_T2_T3_T4_T5 (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s result) (index_Mapping_Int_tup6_T0_T1_T2_T3_T4_T5 s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup5_T0_T1_T2_T3_T4__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3, T4) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type t_T4
  
  type tup5_T0_T1_T2_T3_T4 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3; f4: t_T4 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_T4 (self: t_T4) (other: t_T4)
  
  predicate well_founded_relation_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: tup5_T0_T1_T2_T3_T4) (other: tup5_T0_T1_T2_T3_T4) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
    \/ self.f0 = other.f0
    /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ self.f3 = other.f3 /\ well_founded_relation_T4 self.f4 other.f4
  
  meta "rewrite_def" predicate well_founded_relation_tup5_T0_T1_T2_T3_T4
  
  function index_Mapping_Int_tup5_T0_T1_T2_T3_T4 [@inline:trivial] (self: Map.map int tup5_T0_T1_T2_T3_T4) (a: int) : tup5_T0_T1_T2_T3_T4
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup5_T0_T1_T2_T3_T4
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int tup5_T0_T1_T2_T3_T4. forall result: int. result >= 0
          /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup5_T0_T1_T2_T3_T4 (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s result) (index_Mapping_Int_tup5_T0_T1_T2_T3_T4 s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup4_T0_T1_T2_T3__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2, T3) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type t_T3
  
  type tup4_T0_T1_T2_T3 = { f0: t_T0; f1: t_T1; f2: t_T2; f3: t_T3 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_T3 (self: t_T3) (other: t_T3)
  
  predicate well_founded_relation_tup4_T0_T1_T2_T3 [@inline:trivial] (self: tup4_T0_T1_T2_T3) (other: tup4_T0_T1_T2_T3) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ self.f2 = other.f2 /\ well_founded_relation_T3 self.f3 other.f3
  
  meta "rewrite_def" predicate well_founded_relation_tup4_T0_T1_T2_T3
  
  function index_Mapping_Int_tup4_T0_T1_T2_T3 [@inline:trivial] (self: Map.map int tup4_T0_T1_T2_T3) (a: int) : tup4_T0_T1_T2_T3
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup4_T0_T1_T2_T3
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int tup4_T0_T1_T2_T3. forall result: int. result >= 0
          /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup4_T0_T1_T2_T3 (index_Mapping_Int_tup4_T0_T1_T2_T3 s result) (index_Mapping_Int_tup4_T0_T1_T2_T3 s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup3_T0_T1_T2__no_infinite_decreasing_sequence__refines (* <(T0, T1, T2) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type t_T2
  
  type tup3_T0_T1_T2 = { f0: t_T0; f1: t_T1; f2: t_T2 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_T2 (self: t_T2) (other: t_T2)
  
  predicate well_founded_relation_tup3_T0_T1_T2 [@inline:trivial] (self: tup3_T0_T1_T2) (other: tup3_T0_T1_T2) =
    well_founded_relation_T0 self.f0 other.f0
    \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
    \/ self.f0 = other.f0 /\ self.f1 = other.f1 /\ well_founded_relation_T2 self.f2 other.f2
  
  meta "rewrite_def" predicate well_founded_relation_tup3_T0_T1_T2
  
  function index_Mapping_Int_tup3_T0_T1_T2 [@inline:trivial] (self: Map.map int tup3_T0_T1_T2) (a: int) : tup3_T0_T1_T2
   = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup3_T0_T1_T2
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int tup3_T0_T1_T2. forall result: int. result >= 0
          /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup3_T0_T1_T2 (index_Mapping_Int_tup3_T0_T1_T2 s result) (index_Mapping_Int_tup3_T0_T1_T2 s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup2_T0_T1__no_infinite_decreasing_sequence__refines (* <(T0, T1) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  type t_T1
  
  type tup2_T0_T1 = { f0: t_T0; f1: t_T1 }
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_T1 (self: t_T1) (other: t_T1)
  
  predicate well_founded_relation_tup2_T0_T1 [@inline:trivial] (self: tup2_T0_T1) (other: tup2_T0_T1) =
    well_founded_relation_T0 self.f0 other.f0 \/ self.f0 = other.f0 /\ well_founded_relation_T1 self.f1 other.f1
  
  meta "rewrite_def" predicate well_founded_relation_tup2_T0_T1
  
  function index_Mapping_Int_tup2_T0_T1 [@inline:trivial] (self: Map.map int tup2_T0_T1) (a: int) : tup2_T0_T1 =
    Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup2_T0_T1
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int tup2_T0_T1. forall result: int. result >= 0
          /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup2_T0_T1 (index_Mapping_Int_tup2_T0_T1 s result) (index_Mapping_Int_tup2_T0_T1 s (result
        + 1))
end
module M_logic__well_founded__impl_WellFounded_for_tup1_T0__no_infinite_decreasing_sequence__refines (* <(T0,) as logic::well_founded::WellFounded> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use map.Map
  use int.Int
  
  type t_T0
  
  predicate well_founded_relation_T0 (self: t_T0) (other: t_T0)
  
  predicate well_founded_relation_tup1_T0 [@inline:trivial] (self: t_T0) (other: t_T0) =
    well_founded_relation_T0 self other
  
  meta "rewrite_def" predicate well_founded_relation_tup1_T0
  
  function index_Mapping_Int_tup1_T0 [@inline:trivial] (self: Map.map int t_T0) (a: int) : t_T0 = Map.get self a
  
  meta "rewrite_def" function index_Mapping_Int_tup1_T0
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall s: Map.map int t_T0. forall result: int. result >= 0
          /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
          + 1))
        -> result >= 0
        /\ not well_founded_relation_tup1_T0 (index_Mapping_Int_tup1_T0 s result) (index_Mapping_Int_tup1_T0 s (result
        + 1))
end
module M_peano__impl_Ord_for_PeanoInt__cmp__refines (* <peano::PeanoInt as std::cmp::Ord> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  
  type t_PeanoInt = { f0: UInt64.t }
  
  type t_Ordering = Less | Equal | Greater
  
  function cmp_log_u64 (self: UInt64.t) (o: UInt64.t) : t_Ordering = if UInt64.lt self o then
      Less
    else
      if self = o then Equal else Greater
  
  
  function eq_cmp_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom eq_cmp_u64_spec: forall x: UInt64.t, y: UInt64.t. (x = y) = (cmp_log_u64 x y = Equal)
  
  function antisym2_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym2_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Greater -> cmp_log_u64 y x = Less
  
  function antisym1_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom antisym1_u64_spec: forall x: UInt64.t, y: UInt64.t. cmp_log_u64 x y = Less -> cmp_log_u64 y x = Greater
  
  function trans_u64 (x: UInt64.t) (y: UInt64.t) (z: UInt64.t) (o: t_Ordering) : ()
  
  axiom trans_u64_spec: forall x: UInt64.t, y: UInt64.t, z: UInt64.t, o: t_Ordering. cmp_log_u64 x y = o
      -> cmp_log_u64 y z = o -> cmp_log_u64 x z = o
  
  function refl_u64 (x: UInt64.t) : ()
  
  axiom refl_u64_spec: forall x: UInt64.t. cmp_log_u64 x x = Equal
  
  function cmp_gt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_gt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.gt x y = (cmp_log_u64 x y = Greater)
  
  function cmp_ge_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_ge_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.ge x y = (cmp_log_u64 x y <> Less)
  
  function cmp_lt_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_lt_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.lt x y = (cmp_log_u64 x y = Less)
  
  function cmp_le_log_u64 (x: UInt64.t) (y: UInt64.t) : ()
  
  axiom cmp_le_log_u64_spec: forall x: UInt64.t, y: UInt64.t. UInt64.le x y = (cmp_log_u64 x y <> Greater)
  
  function cmp_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) : t_Ordering = cmp_log_u64 self.f0 o.f0
  
  meta "rewrite_def" function cmp_log_PeanoInt
  
  function eq_cmp_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom eq_cmp_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. (x = y) = (cmp_log_PeanoInt x y = Equal)
  
  function antisym2_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym2_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Greater
      -> cmp_log_PeanoInt y x = Less
  
  function antisym1_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom antisym1_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. cmp_log_PeanoInt x y = Less
      -> cmp_log_PeanoInt y x = Greater
  
  function trans_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) (z: t_PeanoInt) (o: t_Ordering) : () = ()
  
  axiom trans_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt, z: t_PeanoInt, o: t_Ordering. cmp_log_PeanoInt x y = o
      -> cmp_log_PeanoInt y z = o -> cmp_log_PeanoInt x z = o
  
  function refl_PeanoInt (x: t_PeanoInt) : () = ()
  
  axiom refl_PeanoInt_spec: forall x: t_PeanoInt. cmp_log_PeanoInt x x = Equal
  
  predicate gt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.gt self.f0 o.f0
  
  meta "rewrite_def" predicate gt_log_PeanoInt
  
  function cmp_gt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_gt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. gt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Greater)
  
  predicate ge_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.ge self.f0 o.f0
  
  meta "rewrite_def" predicate ge_log_PeanoInt
  
  function cmp_ge_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_ge_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. ge_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Less)
  
  predicate lt_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.lt self.f0 o.f0
  
  meta "rewrite_def" predicate lt_log_PeanoInt
  
  function cmp_lt_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_lt_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. lt_log_PeanoInt x y
      = (cmp_log_PeanoInt x y = Less)
  
  predicate le_log_PeanoInt [@inline:trivial] (self: t_PeanoInt) (o: t_PeanoInt) = UInt64.le self.f0 o.f0
  
  meta "rewrite_def" predicate le_log_PeanoInt
  
  function cmp_le_log_PeanoInt (x: t_PeanoInt) (y: t_PeanoInt) : () = ()
  
  axiom cmp_le_log_PeanoInt_spec: forall x: t_PeanoInt, y: t_PeanoInt. le_log_PeanoInt x y
      = (cmp_log_PeanoInt x y <> Greater)
  
  function deep_model_PeanoInt [@inline:trivial] (self: t_PeanoInt) : UInt64.t = self.f0
  
  meta "rewrite_def" function deep_model_PeanoInt
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self_: t_PeanoInt. forall rhs: t_PeanoInt. forall result: t_Ordering. result
            = cmp_log_PeanoInt self_ rhs -> result = cmp_log_u64 (deep_model_PeanoInt self_) (deep_model_PeanoInt rhs)
end
module M_std__iter__fuse__impl_FusedIterator_for_Fuse_I__is_fused__refines (* <std::iter::Fuse<I> as std::iter::fuse::FusedIterator> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use creusot.prelude.MutBorrow
  
  type t_Fuse_I
  
  type t_Item
  
  type t_I
  
  type t_Option_I = None | Some t_I
  
  function view_Fuse_I (self: t_Fuse_I) : t_Option_I
  
  predicate produces_I (self: t_I) (visited: Seq.seq t_Item) (o: t_I)
  
  function produces_trans_I (a: t_I) (ab: Seq.seq t_Item) (b: t_I) (bc: Seq.seq t_Item) (c: t_I) : ()
  
  axiom produces_trans_I_spec: forall a: t_I, ab: Seq.seq t_Item, b: t_I, bc: Seq.seq t_Item, c: t_I. produces_I a ab b
      -> produces_I b bc c -> produces_I a (Seq.(++) ab bc) c
  
  function produces_refl_I (self: t_I) : ()
  
  axiom produces_refl_I_spec: forall self: t_I. produces_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate produces_Fuse_I (self: t_Fuse_I) (prod: Seq.seq t_Item) (other: t_Fuse_I) =
    match view_Fuse_I self with
      | None -> prod = (Seq.empty: Seq.seq t_Item) /\ view_Fuse_I other = view_Fuse_I self
      | Some i -> match view_Fuse_I other with
        | Some i2 -> produces_I i prod i2
        | None -> false
        end
      end
  
  function produces_trans_Fuse_I (a: t_Fuse_I) (ab: Seq.seq t_Item) (b: t_Fuse_I) (bc: Seq.seq t_Item) (c: t_Fuse_I) : ()
   = ()
  
  axiom produces_trans_Fuse_I_spec:
    forall a: t_Fuse_I, ab: Seq.seq t_Item, b: t_Fuse_I, bc: Seq.seq t_Item, c: t_Fuse_I. produces_Fuse_I a ab b
      -> produces_Fuse_I b bc c -> produces_Fuse_I a (Seq.(++) ab bc) c
  
  function produces_refl_Fuse_I (self: t_Fuse_I) : () = ()
  
  axiom produces_refl_Fuse_I_spec: forall self: t_Fuse_I. produces_Fuse_I self (Seq.empty: Seq.seq t_Item) self
  
  predicate completed_I (self: MutBorrow.t t_I)
  
  predicate completed_Fuse_I (self: MutBorrow.t t_Fuse_I) =
    (view_Fuse_I self.current = None
      \/ (exists it: MutBorrow.t t_I. completed_I it /\ view_Fuse_I self.current = Some (it.current)))
    /\ view_Fuse_I self.final = None
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: MutBorrow.t t_Fuse_I. forall steps: Seq.seq t_Item. forall next: t_Fuse_I. completed_Fuse_I self
            /\ produces_Fuse_I self.final steps next
          -> completed_Fuse_I self
          /\ produces_Fuse_I self.final steps next
          /\ (forall result: (). steps = (Seq.empty: Seq.seq t_Item) -> steps = (Seq.empty: Seq.seq t_Item))
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_refl__refines (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_Range_Idx. forall result: (). produces_back_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_back_Range_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_Range_Idx__produces_back_trans__refines (* <std::ops::Range<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_Idx
  
  type t_Range_Idx = { start: t_Idx; end': t_Idx }
  
  function deep_model_Idx (self: t_Idx) : int
  
  predicate produces_back_Range_Idx (self: t_Range_Idx) (visited: Seq.seq t_Idx) (o: t_Range_Idx) =
    self.start = o.start
    /\ deep_model_Idx self.end' >= deep_model_Idx o.end'
    /\ (Seq.length visited > 0 -> deep_model_Idx o.end' >= deep_model_Idx o.start)
    /\ Seq.length visited = deep_model_Idx o.end' - deep_model_Idx self.end'
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx self.end' - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_Range_Idx. forall ab: Seq.seq t_Idx. forall b: t_Range_Idx. forall bc: Seq.seq t_Idx. forall c: t_Range_Idx. produces_back_Range_Idx a ab b
                /\ produces_back_Range_Idx b bc c
              -> produces_back_Range_Idx a ab b
              /\ produces_back_Range_Idx b bc c
              /\ (forall result: (). produces_back_Range_Idx a (Seq.(++) ab bc) c
                -> produces_back_Range_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_trans__refines (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall a: t_RangeInclusive_Idx. forall ab: Seq.seq t_Idx. forall b: t_RangeInclusive_Idx. forall bc: Seq.seq t_Idx. forall c: t_RangeInclusive_Idx. produces_back_RangeInclusive_Idx a ab b
                /\ produces_back_RangeInclusive_Idx b bc c
              -> produces_back_RangeInclusive_Idx a ab b
              /\ produces_back_RangeInclusive_Idx b bc c
              /\ (forall result: (). produces_back_RangeInclusive_Idx a (Seq.(++) ab bc) c
                -> produces_back_RangeInclusive_Idx a (Seq.(++) ab bc) c)
end
module M_std__iter__range__impl_DoubleEndedIteratorSpec_for_RangeInclusive_Idx__produces_back_refl__refines (* <std::ops::RangeInclusive<Idx> as std::iter::DoubleEndedIteratorSpec> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use seq.Seq
  use int.Int
  
  type t_RangeInclusive_Idx
  
  type t_Idx
  
  function deep_model_Idx (self: t_Idx) : int
  
  function start_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  function end_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx) : t_Idx
  
  predicate is_empty_log_RangeInclusive_Idx (self: t_RangeInclusive_Idx)
  
  axiom is_empty_log_RangeInclusive_Idx_spec:
    forall self: t_RangeInclusive_Idx. not is_empty_log_RangeInclusive_Idx self
      -> deep_model_Idx (start_log_RangeInclusive_Idx self) <= deep_model_Idx (end_log_RangeInclusive_Idx self)
  
  function range_inclusive_len_Idx (r: t_RangeInclusive_Idx) : int = if is_empty_log_RangeInclusive_Idx r then
      0
    else
      deep_model_Idx (end_log_RangeInclusive_Idx r) - deep_model_Idx (start_log_RangeInclusive_Idx r) + 1
  
  
  axiom range_inclusive_len_Idx_spec: forall r: t_RangeInclusive_Idx. is_empty_log_RangeInclusive_Idx r
      = (range_inclusive_len_Idx r = 0)
  
  predicate produces_back_RangeInclusive_Idx (self: t_RangeInclusive_Idx) (visited: Seq.seq t_Idx) (o: t_RangeInclusive_Idx) =
    Seq.length visited = range_inclusive_len_Idx self - range_inclusive_len_Idx o
    /\ (is_empty_log_RangeInclusive_Idx self -> is_empty_log_RangeInclusive_Idx o)
    /\ (is_empty_log_RangeInclusive_Idx o \/ start_log_RangeInclusive_Idx self = start_log_RangeInclusive_Idx o)
    /\ (forall i: int. 0 <= i /\ i < Seq.length visited
      -> deep_model_Idx (Seq.get visited i) = deep_model_Idx (end_log_RangeInclusive_Idx self) - i)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_RangeInclusive_Idx. forall result: (). produces_back_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
        -> produces_back_RangeInclusive_Idx self (Seq.empty: Seq.seq t_Idx) self
end
module M_std__ops__impl_FnMutExt_for_F__fn_mut_once__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once_F (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate postcondition_mut_F (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate resolve_F (_1: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once_F self args res
              = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
            -> postcondition_once_F self args res
            = (exists res_state: t_F. postcondition_mut_F self args res_state res /\ resolve_F res_state)
end
module M_std__ops__impl_FnMutExt_for_F__hist_inv_trans__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall b: t_F. forall c: t_F. hist_inv_F self b /\ hist_inv_F b c
          -> hist_inv_F self b /\ hist_inv_F b c /\ (forall result: (). hist_inv_F self c -> hist_inv_F self c)
end
module M_std__ops__impl_FnMutExt_for_F__hist_inv_refl__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall result: (). hist_inv_F self self -> hist_inv_F self self
end
module M_std__ops__impl_FnMutExt_for_F__postcondition_mut_hist_inv__refines (* <F as std::ops::FnMutExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut_F (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. postcondition_mut_F self args res_state res
            -> postcondition_mut_F self args res_state res
            /\ (forall result: (). hist_inv_F self res_state -> hist_inv_F self res_state)
end
module M_std__ops__impl_FnExt_for_F__fn_once__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_once_F (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate postcondition_F (self: t_F) (args: t_Args) (result: t_Output)
  
  predicate resolve_F (_1: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res: t_Output. forall result: (). postcondition_once_F self args res
              = (postcondition_F self args res /\ resolve_F self)
            -> postcondition_once_F self args res = (postcondition_F self args res /\ resolve_F self)
end
module M_std__ops__impl_FnExt_for_F__fn_hist_inv__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  predicate hist_inv_F (self: t_F) (result_state: t_F)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_F. forall res_state: t_F. forall result: (). hist_inv_F self res_state
            = (self = res_state) -> hist_inv_F self res_state = (self = res_state)
end
module M_std__ops__impl_FnExt_for_F__fn_mut__refines (* <F as std::ops::FnExt<Args>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_F
  
  type t_Args
  
  type t_Output
  
  predicate postcondition_mut_F (self: t_F) (args: t_Args) (result_state: t_F) (result: t_Output)
  
  predicate postcondition_F (self: t_F) (args: t_Args) (result: t_Output)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: t_F. forall args: t_Args. forall res_state: t_F. forall res: t_Output. forall result: (). postcondition_mut_F self args res_state res
                = (postcondition_F self args res /\ self = res_state)
              -> postcondition_mut_F self args res_state res = (postcondition_F self args res /\ self = res_state)
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__offset_logic_assoc__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_ptr_T (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_ptr_T_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_ptr_T self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Opaque.ptr. forall offset1: int. forall offset2: int. forall result: (). offset_ptr_T (offset_ptr_T self offset1) offset2
              = offset_ptr_T self (offset1 + offset2)
            -> offset_ptr_T (offset_ptr_T self offset1) offset2 = offset_ptr_T self (offset1 + offset2)
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__sub_logic_refl__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  
  function sub_ptr_T (self: Opaque.ptr) (rhs: Opaque.ptr) : int
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall result: (). sub_ptr_T self self = 0 -> sub_ptr_T self self = 0
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__offset_logic__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use creusot.prelude.Opaque
  use int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall offset: int. UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
          < UInt64.t'int const_MAX
        -> UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T < UInt64.t'int const_MAX
        /\ (forall result: Opaque.ptr. UInt64.t'int (Ptr.addr_logic_u64 result)
            = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
          -> UInt64.t'int (Ptr.addr_logic_u64 result) = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T)
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__sub_offset_logic__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use int.Int
  
  function sub_ptr_T (self: Opaque.ptr) (rhs: Opaque.ptr) : int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_ptr_T (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_ptr_T_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_ptr_T self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines:
    forall self: Opaque.ptr. forall offset: int. forall result: (). sub_ptr_T (offset_ptr_T self offset) self = offset
          -> sub_ptr_T (offset_ptr_T self offset) self = offset
end
module M_std__ptr__impl_SizedPointerExt_for_ptr_T__offset_logic_zero__refines (* <*const T as std::ptr::SizedPointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  use creusot.prelude.Ptr
  use int.Int
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  constant const_MAX: UInt64.t = (18446744073709551615: UInt64.t)
  
  function offset_ptr_T (self: Opaque.ptr) (offset: int) : Opaque.ptr
  
  axiom offset_ptr_T_spec: forall self: Opaque.ptr, offset: int. UInt64.t'int (Ptr.addr_logic_u64 self)
          + offset * size_of_T
        < UInt64.t'int const_MAX
      -> UInt64.t'int (Ptr.addr_logic_u64 (offset_ptr_T self offset))
      = UInt64.t'int (Ptr.addr_logic_u64 self) + offset * size_of_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall result: (). offset_ptr_T self 0 = self -> offset_ptr_T self 0 = self
end
module M_std__ptr__impl_SlicePointerExt_for_ptr_slice_T__slice_ptr_ext__refines (* <*const [T] as std::ptr::SlicePointerExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.Opaque
  use creusot.int.UInt64
  
  function thin_ptr_slice_T [@inline:trivial] (self: Opaque.ptr) : Opaque.ptr = Opaque.thin self
  
  meta "rewrite_def" function thin_ptr_slice_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  function len_ptr_slice_T [@inline:trivial] (self: Opaque.ptr) : UInt64.t = metadata_slice_T self
  
  meta "rewrite_def" function len_ptr_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Opaque.ptr. forall other: Opaque.ptr. forall result: (). thin_ptr_slice_T self
                = thin_ptr_slice_T other
              /\ len_ptr_slice_T self = len_ptr_slice_T other -> self = other
          -> thin_ptr_slice_T self = thin_ptr_slice_T other /\ len_ptr_slice_T self = len_ptr_slice_T other
          -> self = other
end
module M_std__slice__impl_SliceExt_for_slice_T__as_ptr_perm__refines (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  type t_Perm_ptr_slice_T
  
  type tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T = { f0: Opaque.ptr; f1: t_Perm_ptr_slice_T }
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ward_ptr_slice_T (self: t_Perm_ptr_slice_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_Perm_ptr_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function val_ptr_slice_T (self: t_Perm_ptr_slice_T) : Slice64.slice t_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_Perm_ptr_slice_T (self: t_Perm_ptr_slice_T) =
    not is_null_ptr_slice_T (ward_ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_ptr_slice_T self) (metadata_slice_T (ward_ptr_slice_T self))
    /\ size_of_val_slice_T (val_ptr_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ward_ptr_slice_T self)) + size_of_val_slice_T (val_ptr_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T (val_ptr_slice_T self)
  
  predicate inv_Perm_ptr_slice_T (_1: t_Perm_ptr_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Perm_ptr_slice_T [inv_Perm_ptr_slice_T x]. inv_Perm_ptr_slice_T x
      = invariant_Perm_ptr_slice_T x
  
  predicate invariant_ref_Perm_ptr_slice_T [@inline:trivial] (self: t_Perm_ptr_slice_T) = inv_Perm_ptr_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_Perm_ptr_slice_T
  
  predicate inv_ref_Perm_ptr_slice_T [@inline:trivial] (_1: t_Perm_ptr_slice_T) = invariant_ref_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_Perm_ptr_slice_T
  
  predicate invariant_Ghost_ref_Perm_ptr_slice_T [@inline:trivial] (self: t_Perm_ptr_slice_T) =
    inv_ref_Perm_ptr_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_ref_Perm_ptr_slice_T
  
  predicate inv_Ghost_ref_Perm_ptr_slice_T [@inline:trivial] (_1: t_Perm_ptr_slice_T) =
    invariant_Ghost_ref_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_ref_Perm_ptr_slice_T
  
  predicate inv_tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T) =
    inv_Ghost_ref_Perm_ptr_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: Slice64.slice t_T. inv_ref_slice_T self
      -> inv_ref_slice_T self
      /\ (forall result: tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T. inv_tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T result
          /\ result.f0 = Opaque.thin (ward_ptr_slice_T result.f1) /\ self = val_ptr_slice_T result.f1
        -> inv_tup2_ptr_T_Ghost_ref_Perm_ptr_slice_T result)
end
module M_std__slice__impl_SliceExt_for_slice_T__as_mut_ptr_perm__refines (* <[T] as std::slice::SliceExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  use creusot.prelude.MutBorrow
  use creusot.slice.Slice64
  use seq.Seq
  use creusot.prelude.Opaque
  use creusot.prelude.Ptr
  use creusot.int.UInt64
  use creusot.int.Int64
  use int.Int
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate invariant_ref_T [@inline:trivial] (self: t_T) = inv_T self
  
  meta "rewrite_def" predicate invariant_ref_T
  
  predicate inv_ref_T [@inline:trivial] (_1: t_T) = invariant_ref_T _1
  
  meta "rewrite_def" predicate inv_ref_T
  
  predicate invariant_Seq_T [@inline:trivial] (self: Seq.seq t_T) =
    forall i: int. 0 <= i /\ i < Seq.length self -> inv_ref_T (Seq.get self i)
  
  meta "rewrite_def" predicate invariant_Seq_T
  
  predicate inv_Seq_T [@inline:trivial] (_1: Seq.seq t_T) = invariant_Seq_T _1
  
  meta "rewrite_def" predicate inv_Seq_T
  
  predicate invariant_slice_T (self: Slice64.slice t_T) = inv_Seq_T (Slice64.view self)
  
  predicate inv_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_slice_T _1
  
  meta "rewrite_def" predicate inv_slice_T
  
  predicate invariant_refmut_slice_T [@inline:trivial] (self: MutBorrow.t (Slice64.slice t_T)) =
    inv_slice_T self.current /\ inv_slice_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_slice_T
  
  predicate inv_refmut_slice_T [@inline:trivial] (_1: MutBorrow.t (Slice64.slice t_T)) = invariant_refmut_slice_T _1
  
  meta "rewrite_def" predicate inv_refmut_slice_T
  
  type t_Perm_ptr_slice_T
  
  type tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T = { f0: Opaque.ptr; f1: MutBorrow.t t_Perm_ptr_slice_T }
  
  predicate is_null_ptr_slice_T (self: Opaque.ptr) = Ptr.addr_logic_u64 self = (0: UInt64.t)
  
  function ward_ptr_slice_T (self: t_Perm_ptr_slice_T) : Opaque.ptr
  
  predicate ptr_is_aligned_opaque_slice_T (self: t_Perm_ptr_slice_T)
  
  predicate metadata_matches_slice_T [@inline:trivial] (_value: Slice64.slice t_T) (_metadata: UInt64.t) =
    Seq.length (Slice64.view _value) = UInt64.t'int _metadata
  
  meta "rewrite_def" predicate metadata_matches_slice_T
  
  function val_ptr_slice_T (self: t_Perm_ptr_slice_T) : Slice64.slice t_T
  
  function metadata_slice_T (_1: Opaque.ptr) : UInt64.t
  
  constant size_of_T : int
  
  axiom size_of_T_spec: 0 <= size_of_T
  
  function size_of_val_slice_T [@inline:trivial] (val': Slice64.slice t_T) : int = size_of_T
    * Seq.length (Slice64.view val')
  
  meta "rewrite_def" function size_of_val_slice_T
  
  axiom size_of_val_slice_T_spec: forall val': Slice64.slice t_T. 0 <= size_of_val_slice_T val'
  
  constant const_MAX: Int64.t = (9223372036854775807: Int64.t)
  
  constant const_MAX'0: UInt64.t = (18446744073709551615: UInt64.t)
  
  predicate invariant_ref_slice_T [@inline:trivial] (self: Slice64.slice t_T) = inv_slice_T self
  
  meta "rewrite_def" predicate invariant_ref_slice_T
  
  predicate inv_ref_slice_T [@inline:trivial] (_1: Slice64.slice t_T) = invariant_ref_slice_T _1
  
  meta "rewrite_def" predicate inv_ref_slice_T
  
  predicate invariant_Perm_ptr_slice_T (self: t_Perm_ptr_slice_T) =
    not is_null_ptr_slice_T (ward_ptr_slice_T self)
    /\ ptr_is_aligned_opaque_slice_T self
    /\ metadata_matches_slice_T (val_ptr_slice_T self) (metadata_slice_T (ward_ptr_slice_T self))
    /\ size_of_val_slice_T (val_ptr_slice_T self) <= Int64.to_int const_MAX
    /\ UInt64.t'int (Ptr.addr_logic_u64 (ward_ptr_slice_T self)) + size_of_val_slice_T (val_ptr_slice_T self)
      <= UInt64.t'int const_MAX'0
    /\ inv_ref_slice_T (val_ptr_slice_T self)
  
  predicate inv_Perm_ptr_slice_T (_1: t_Perm_ptr_slice_T)
  
  axiom inv_axiom [@rewrite]: forall x: t_Perm_ptr_slice_T [inv_Perm_ptr_slice_T x]. inv_Perm_ptr_slice_T x
      = invariant_Perm_ptr_slice_T x
  
  predicate invariant_refmut_Perm_ptr_slice_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_slice_T) =
    inv_Perm_ptr_slice_T self.current /\ inv_Perm_ptr_slice_T self.final
  
  meta "rewrite_def" predicate invariant_refmut_Perm_ptr_slice_T
  
  predicate inv_refmut_Perm_ptr_slice_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_slice_T) =
    invariant_refmut_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_refmut_Perm_ptr_slice_T
  
  predicate invariant_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_slice_T) =
    inv_refmut_Perm_ptr_slice_T self
  
  meta "rewrite_def" predicate invariant_Ghost_refmut_Perm_ptr_slice_T
  
  predicate inv_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (_1: MutBorrow.t t_Perm_ptr_slice_T) =
    invariant_Ghost_refmut_Perm_ptr_slice_T _1
  
  meta "rewrite_def" predicate inv_Ghost_refmut_Perm_ptr_slice_T
  
  predicate inv_tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (_1: tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T) =
    inv_Ghost_refmut_Perm_ptr_slice_T _1.f1
  
  meta "rewrite_def" predicate inv_tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T
  
  function fin_Ghost_refmut_Perm_ptr_slice_T [@inline:trivial] (self: MutBorrow.t t_Perm_ptr_slice_T) : t_Perm_ptr_slice_T
   = self.final
  
  meta "rewrite_def" function fin_Ghost_refmut_Perm_ptr_slice_T
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: MutBorrow.t (Slice64.slice t_T). inv_refmut_slice_T self
      -> inv_refmut_slice_T self
      /\ (forall result: tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T. inv_tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T result
          /\ result.f0 = Opaque.thin (ward_ptr_slice_T result.f1.current)
          /\ self.current = val_ptr_slice_T result.f1.current
          /\ self.final = val_ptr_slice_T (fin_Ghost_refmut_Perm_ptr_slice_T result.f1)
        -> inv_tup2_ptr_T_Ghost_refmut_Perm_ptr_slice_T result)
end
module M_std__thread__impl_JoinHandleExt_for_JoinHandle_T__join_unwrap__refines (* <std::thread::JoinHandle<T> as std::thread::JoinHandleExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_JoinHandle_T
  
  predicate inv_JoinHandle_T (_1: t_JoinHandle_T)
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate valid_result_JoinHandle_T (self: t_JoinHandle_T) (_x: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_JoinHandle_T. inv_JoinHandle_T self
      -> inv_JoinHandle_T self
      /\ (forall result: t_T. inv_T result /\ valid_result_JoinHandle_T self result
        -> inv_T result /\ valid_result_JoinHandle_T self result)
end
module M_std__thread__impl_JoinHandleExt_for_ScopedJoinHandle_T__join_unwrap__refines (* <std::thread::ScopedJoinHandle<'_, T> as std::thread::JoinHandleExt<T>> *)
  type namespace_other
  
  type t_Namespace = Other namespace_other
  
  type t_ScopedJoinHandle_T
  
  predicate inv_ScopedJoinHandle_T (_1: t_ScopedJoinHandle_T)
  
  type t_T
  
  predicate inv_T (_1: t_T)
  
  predicate valid_result_ScopedJoinHandle_T (self: t_ScopedJoinHandle_T) (_x: t_T)
  
  meta "compute_max_steps" 1000000
  
  meta "select_lsinst" "all"
  
  goal refines: forall self: t_ScopedJoinHandle_T. inv_ScopedJoinHandle_T self
      -> inv_ScopedJoinHandle_T self
      /\ (forall result: t_T. inv_T result /\ valid_result_ScopedJoinHandle_T self result
        -> inv_T result /\ valid_result_ScopedJoinHandle_T self result)
end
